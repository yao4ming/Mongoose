/**
 *  IDS Enterprise Components - v4.12.0
 *  Date: 08/11/2018, 6:12:15 pm
 *  Revision: 8d74e9ab184bd6fe13d16f290c84f5c6349b189a
 *
 *
 *  Apache License
 *  Version 2.0, January 2004
 *  http://www.apache.org/licenses/
 *
 *  TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *  1. Definitions.
 *
 *  "License" shall mean the terms and conditions for use, reproduction,
 *  and distribution as defined by Sections 1 through 9 of this document.
 *
 *  "Licensor" shall mean the copyright owner or entity authorized by
 *  the copyright owner that is granting the License.
 *
 *  "Legal Entity" shall mean the union of the acting entity and all
 *  other entities that control, are controlled by, or are under common
 *  control with that entity. For the purposes of this definition,
 *  "control" means (i) the power, direct or indirect, to cause the
 *  direction or management of such entity, whether by contract or
 *  otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *  outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *  "You" (or "Your") shall mean an individual or Legal Entity
 *  exercising permissions granted by this License.
 *
 *  "Source" form shall mean the preferred form for making modifications,
 *  including but not limited to software source code, documentation
 *  source, and configuration files.
 *
 *  "Object" form shall mean any form resulting from mechanical
 *  transformation or translation of a Source form, including but
 *  not limited to compiled object code, generated documentation,
 *  and conversions to other media types.
 *
 *  "Work" shall mean the work of authorship, whether in Source or
 *  Object form, made available under the License, as indicated by a
 *  copyright notice that is included in or attached to the work
 *  (an example is provided in the Appendix below).
 *
 *  "Derivative Works" shall mean any work, whether in Source or Object
 *  form, that is based on (or derived from) the Work and for which the
 *  editorial revisions, annotations, elaborations, or other modifications
 *  represent, as a whole, an original work of authorship. For the purposes
 *  of this License, Derivative Works shall not include works that remain
 *  separable from, or merely link (or bind by name) to the interfaces of,
 *  the Work and Derivative Works thereof.
 *
 *  "Contribution" shall mean any work of authorship, including
 *  the original version of the Work and any modifications or additions
 *  to that Work or Derivative Works thereof, that is intentionally
 *  submitted to Licensor for inclusion in the Work by the copyright owner
 *  or by an individual or Legal Entity authorized to submit on behalf of
 *  the copyright owner. For the purposes of this definition, "submitted"
 *  means any form of electronic, verbal, or written communication sent
 *  to the Licensor or its representatives, including but not limited to
 *  communication on electronic mailing lists, source code control systems,
 *  and issue tracking systems that are managed by, or on behalf of, the
 *  Licensor for the purpose of discussing and improving the Work, but
 *  excluding communication that is conspicuously marked or otherwise
 *  designated in writing by the copyright owner as "Not a Contribution."
 *
 *  "Contributor" shall mean Licensor and any individual or Legal Entity
 *  on behalf of whom a Contribution has been received by Licensor and
 *  subsequently incorporated within the Work.
 *
 *  2. Grant of Copyright License. Subject to the terms and conditions of
 *  this License, each Contributor hereby grants to You a perpetual,
 *  worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *  copyright license to reproduce, prepare Derivative Works of,
 *  publicly display, publicly perform, sublicense, and distribute the
 *  Work and such Derivative Works in Source or Object form.
 *
 *  3. Grant of Patent License. Subject to the terms and conditions of
 *  this License, each Contributor hereby grants to You a perpetual,
 *  worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *  (except as stated in this section) patent license to make, have made,
 *  use, offer to sell, sell, import, and otherwise transfer the Work,
 *  where such license applies only to those patent claims licensable
 *  by such Contributor that are necessarily infringed by their
 *  Contribution(s) alone or by combination of their Contribution(s)
 *  with the Work to which such Contribution(s) was submitted. If You
 *  institute patent litigation against any entity (including a
 *  cross-claim or counterclaim in a lawsuit) alleging that the Work
 *  or a Contribution incorporated within the Work constitutes direct
 *  or contributory patent infringement, then any patent licenses
 *  granted to You under this License for that Work shall terminate
 *  as of the date such litigation is filed.
 *
 *  4. Redistribution. You may reproduce and distribute copies of the
 *  Work or Derivative Works thereof in any medium, with or without
 *  modifications, and in Source or Object form, provided that You
 *  meet the following conditions:
 *
 *  (a) You must give any other recipients of the Work or
 *  Derivative Works a copy of this License; and
 *
 *  (b) You must cause any modified files to carry prominent notices
 *  stating that You changed the files; and
 *
 *  (c) You must retain, in the Source form of any Derivative Works
 *  that You distribute, all copyright, patent, trademark, and
 *  attribution notices from the Source form of the Work,
 *  excluding those notices that do not pertain to any part of
 *  the Derivative Works; and
 *
 *  (d) If the Work includes a "NOTICE" text file as part of its
 *  distribution, then any Derivative Works that You distribute must
 *  include a readable copy of the attribution notices contained
 *  within such NOTICE file, excluding those notices that do not
 *  pertain to any part of the Derivative Works, in at least one
 *  of the following places: within a NOTICE text file distributed
 *  as part of the Derivative Works; within the Source form or
 *  documentation, if provided along with the Derivative Works; or,
 *  within a display generated by the Derivative Works, if and
 *  wherever such third-party notices normally appear. The contents
 *  of the NOTICE file are for informational purposes only and
 *  do not modify the License. You may add Your own attribution
 *  notices within Derivative Works that You distribute, alongside
 *  or as an addendum to the NOTICE text from the Work, provided
 *  that such additional attribution notices cannot be construed
 *  as modifying the License.
 *
 *  You may add Your own copyright statement to Your modifications and
 *  may provide additional or different license terms and conditions
 *  for use, reproduction, or distribution of Your modifications, or
 *  for any such Derivative Works as a whole, provided Your use,
 *  reproduction, and distribution of the Work otherwise complies with
 *  the conditions stated in this License.
 *
 *  5. Submission of Contributions. Unless You explicitly state otherwise,
 *  any Contribution intentionally submitted for inclusion in the Work
 *  by You to the Licensor shall be under the terms and conditions of
 *  this License, without any additional terms or conditions.
 *  Notwithstanding the above, nothing herein shall supersede or modify
 *  the terms of any separate license agreement you may have executed
 *  with Licensor regarding such Contributions.
 *
 *  6. Trademarks. This License does not grant permission to use the trade
 *  names, trademarks, service marks, or product names of the Licensor,
 *  except as required for reasonable and customary use in describing the
 *  origin of the Work and reproducing the content of the NOTICE file.
 *
 *  7. Disclaimer of Warranty. Unless required by applicable law or
 *  agreed to in writing, Licensor provides the Work (and each
 *  Contributor provides its Contributions) on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *  implied, including, without limitation, any warranties or conditions
 *  of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *  PARTICULAR PURPOSE. You are solely responsible for determining the
 *  appropriateness of using or redistributing the Work and assume any
 *  risks associated with Your exercise of permissions under this License.
 *
 *  8. Limitation of Liability. In no event and under no legal theory,
 *  whether in tort (including negligence), contract, or otherwise,
 *  unless required by applicable law (such as deliberate and grossly
 *  negligent acts) or agreed to in writing, shall any Contributor be
 *  liable to You for damages, including any direct, indirect, special,
 *  incidental, or consequential damages of any character arising as a
 *  result of this License or out of the use or inability to use the
 *  Work (including but not limited to damages for loss of goodwill,
 *  work stoppage, computer failure or malfunction, or any and all
 *  other commercial damages or losses), even if such Contributor
 *  has been advised of the possibility of such damages.
 *
 *  9. Accepting Warranty or Additional Liability. While redistributing
 *  the Work or Derivative Works thereof, You may choose to offer,
 *  and charge a fee for, acceptance of support, warranty, indemnity,
 *  or other liability obligations and/or rights consistent with this
 *  License. However, in accepting such obligations, You may act only
 *  on Your own behalf and on Your sole responsibility, not on behalf
 *  of any other Contributor, and only if You agree to indemnify,
 *  defend, and hold each Contributor harmless for any liability
 *  incurred by, or claims asserted against, such Contributor by reason
 *  of your accepting any such warranty or additional liability.
 *
 *  END OF TERMS AND CONDITIONS
 *
 *  APPENDIX: How to apply the Apache License to your work.
 *
 *  To apply the Apache License to your work, attach the following
 *  boilerplate notice, with the fields enclosed by brackets "[]"
 *  replaced with your own identifying information. (Don't include
 *  the brackets!)  The text should be enclosed in the appropriate
 *  comment syntax for the file format. We also recommend that a
 *  file or class name and description of purpose be included on the
 *  same "printed page" as the copyright notice for easier
 *  identification within third-party archives.
 *
 *  Copyright 2018  Infor, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
var Soho = (function (exports) {
  'use strict';

  /* eslint-disable no-console */

  // Easy flag for determining whether or not time will be logged to the console.
  var enableTimeLogging = false;

  /**
   * Start the logging timer
   * @param  {string} label Provide a way to match a timing operation.
   * @returns {void}
   */
  function logTimeStart(label) {
  }

  /**
   * End the logging timer and print the result
   * @param  {string} label End this matching timing operation
   * @returns {void}
   */
  function logTimeEnd(label) {
  }

  // Easy flag for allowing console debugging
  var enableConsoleLogging = false;

  /**
   * Simple wrapper for `console.[whatever]` to abstract out console access.
   * @param {string} type console display type
   * @param {string} message message type
   * @returns {void}
   */
  function log(type, message) {
    {
      return;
    }

    if (!console) {
      // eslint-disable-line
      return;
    }

    if (!message && typeof type === 'string') {
      message = type;
      type = 'log';
    }

    if (typeof !console[type] !== 'function') {
      // eslint-disable-line
      type = 'log';
    }

    console[type]('' + message); // eslint-disable-line
  }

  var debug = /*#__PURE__*/Object.freeze({
    enableTimeLogging: enableTimeLogging,
    logTimeStart: logTimeStart,
    logTimeEnd: logTimeEnd,
    enableConsoleLogging: enableConsoleLogging,
    log: log
  });

  var version = "4.12.0";

  var xssUtils = {};

  /**
   * Takes a string and removes all html tags
   * @param {string} str The string to parse
   * @returns {string} The string minus html tags.
   */
  xssUtils.stripHTML = function stripHTML(str) {
    var newStr = str;

    if (!newStr) {
      return '';
    }

    newStr = newStr.replace(/<\/?[^>]+(>|$)/g, '');
    return newStr;
  };

  /**
   * Remove all html tags except for the ones specified. I.E. White list to a specific set of accepted tags.
   * @private
   * @param {string} html HTML in string form
   * @param {string} allowed Comma seperated string of allowed tags e.g. '<b><i><p>''
   * @returns {string} the modified value
   */
  xssUtils.stripTags = function (html, allowed) {
    if (!html) {
      return '';
    }

    if (typeof html === 'number') {
      return html;
    }

    var whitelist = (('' + (allowed || '')).toLowerCase().match(/<[a-z][a-z0-9]*>/g) || []).join(''); // making sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)

    var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi;
    var commentsAndPhpTags = /<!--[\s\S]*?-->|<\?(?:php)?[\s\S]*?\?>/gi;

    return html.replace(commentsAndPhpTags, '').replace(tags, function ($0, $1) {
      return whitelist.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';
    }); //eslint-disable-line
  };

  /**
   * Remove Script tags and all onXXX functions
   * @private
   * @param {string} html HTML in string form
   * @returns {string} the modified value
   */
  xssUtils.sanitizeHTML = function (html) {
    var santizedHtml = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/g, '');
    santizedHtml = santizedHtml.replace(/<[^>]+/g, function (match) {
      return match.replace(/(\/|\s)on\w+=(\'|")?[^"]*(\'|")?/g, '');
    }); // eslint-disable-line

    // Remove console.logs
    santizedHtml = santizedHtml.replace(/console.log(\b[^<]*(?:(?!\);)<[^<]*)*);/g, '');
    santizedHtml = santizedHtml.replace(/console.log(\b[^<]*(?:(?!\))<[^<]*)*)/g, '');

    // Remove nested script tags
    santizedHtml = santizedHtml.replace(/<\/script>/g, '');

    return santizedHtml;
  };

  /**
   * Make sure a string is only alphanumeric (with dashes allowed.)
   * @private
   * @param {string} string HTML in string form
   * @returns {string} the modified value
   */
  xssUtils.ensureAlphaNumeric = function (string) {
    if (typeof string === 'number') {
      return string;
    }
    return this.stripTags(string).replace(/[^a-z0-9-]/gi, '', '');
  };

  /**
   * Escapes HTML, replacing special characters with encoded symbols.
   * Symbols taken from https://bit.ly/1iVkGlc
   * @private
   * @param {string} value HTML in string form
   * @returns {string} the modified value
   */
  xssUtils.escapeHTML = function (value) {
    var newValue = value;
    if (typeof newValue === 'string') {
      var map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;'
      };
      var reg = /[&<>"']/ig;
      return newValue.replace(reg, function (match) {
        return map[match];
      });
    }
    return newValue;
  };

  /**
   * Un-escapes HTML, replacing encoded symbols with special characters.
   * Symbols taken from https://bit.ly/1iVkGlc
   * @private
   * @param {string} value HTML in string form
   * @returns {string} the modified value
   */
  xssUtils.unescapeHTML = function (value) {
    var newValue = value;
    if (typeof value === 'string') {
      newValue = newValue.replace(/&amp;/g, '&');
      newValue = newValue.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
      newValue = newValue.replace(/&quot;/g, '"');
      newValue = newValue.replace(/&#x27;/g, "'");
      newValue = newValue.replace(/&#x2F;/g, '/');
    }
    return newValue;
  };

  /**
   * htmlentities() is a PHP function which converts special characters (like <)
   * into their escaped/encoded values (like &lt;). This is a JS verson of it.
   * This allows you to show to display the string without the browser reading it as HTML.
   * This is useful for encoding hrefs.
   * @private
   * @param {string} string string to process
   * @returns {string} the processed value
   */
  xssUtils.htmlEntities = function (string) {
    return String(string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  };

  /**
   * Ensure that a link is a local link (relative to the current page)
   * @private
   * @param {string} url string to process
   * @returns {boolean} If it is local or not
   */
  xssUtils.isUrlLocal = function (url) {
    var isEmpty = url === '';
    return !isEmpty && (url[0] === '/' && (url.length === 1 || url[1] !== '/' && url[1] !== '\\') || // "/" or "/foo" but not "//" or "/\"
    url.length > 1 && url[0] === '~' && url[1] === '/') || // "~/" or "~/foo"
    url.length >= 1 && url[0] === '#'; // "#" or "#foo"
  };

  var DOM = {};

  /**
   * Returns an array containing an element's attributes.
   * @param {HTMLElement|SVGElement} element the element whose attributes are being accessed
   * @returns {object} list of attributes in name/value pairs.
   */
  DOM.getAttributes = function getAttributes(element) {
    if (!element || !(element instanceof HTMLElement) && !(element instanceof SVGElement)) {
      return {};
    }

    return element.attributes;
  };

  /**
   * Adding, removing, and testing for classes
   * @param {HTMLElement} element the element to test
   * @returns {boolean} whether or not a className exists
   */
  DOM.classNameExists = function classNameExists(element) {
    var cn = element.className;
    return cn && cn.length > 0;
  };

  /**
   * Checks the contents of a string for the existence of a particular substring.
   * @param {string} classNameString a string to test
   * @param {string} targetContents the contents that need to exist inside the `classNameString`
   * @returns {boolean} whether or not a className exists
   */
  DOM.hasClassName = function has(classNameString, targetContents) {
    return classNameString.indexOf(targetContents) > -1;
  };

  /**
   * @param {HTMLElement} el a element being checked.
   * @param {string} className a string representing a class name to check for.
   * @returns {boolean} whether or not the element's class attribute contains the string.
   */
  DOM.hasClass = function hasClass(el, className) {
    return el.classList ? el.classList.contains(className) : new RegExp('\\b' + className + '\\b').test(el.className);
  };

  /**
   * @param {HTMLElement} el a element being checked.
   * @param {string} className a string representing a class name.
   */
  DOM.addClass = function addClass(el, className) {
    if (el.classList) {
      el.classList.add(className);
    } else if (!DOM.hasClass(el, className)) {
      el.className += ' ' + className;
    }
  };

  /**
   * Checks if an element is valid
   * @param {HTMLElement|SVGElement|jQuery[]} el The element being checked
   * @returns {boolean} represents all values normally contained by a DOMRect or ClientRect
   */
  DOM.isElement = function isElement(el) {
    if (el instanceof HTMLElement || el instanceof SVGElement || el instanceof $ && el.length) {
      return true;
    }
    return false;
  };

  /**
   * Runs the generic _getBoundingClientRect()_ method on an element, but returns its results
   * as a plain object instead of a ClientRect
   * @param {HTMLElement|SVGElement|jQuery[]} el The element being manipulated
   * @returns {object} represents all values normally contained by a DOMRect or ClientRect
   */
  DOM.getDimensions = function getDimensions(el) {
    if (!DOM.isElement(el)) {
      return {};
    }

    if (el instanceof $) {
      if (!el.length) {
        return {};
      }

      el = el[0];
    }

    var rect = el.getBoundingClientRect();
    var rectObj = {};

    for (var prop in rect) {
      // eslint-disable-line
      if (!isNaN(rect[prop])) {
        rectObj[prop] = rect[prop];
      }
    }

    return rectObj;
  };

  /**
   * Append content to a DOM element (like jQuery.append)
   * @param {HTMLElement|SVGElement|jQuery[]} el The element to append to
   * @param {string|jQuery} contents The html string or jQuery object.
   * @param {string} stripTags A list of tags to strip to prevent xss, or * for sanitizing and allowing all tags.
   */
  DOM.append = function append(el, contents, stripTags) {
    var domEl = el;

    if (el instanceof $ && el.length) {
      domEl = domEl[0];
    }

    if (domEl instanceof HTMLElement || domEl instanceof SVGElement) {
      domEl.insertAdjacentHTML('beforeend', this.xssClean(contents, stripTags));
    }
  };

  /**
   * Set an attribute with an extra check that the object exists.
   * @param {HTMLElement|SVGElement|jQuery[]} el The element to set the attribute on
   * @param {string} attribute The attribute name.
   * @param {string} value The attribute value.
   */
  DOM.setAttribute = function append(el, attribute, value) {
    var domEl = el;

    if (el instanceof $ && el.length) {
      domEl = domEl[0];
    }

    if (domEl instanceof HTMLElement || domEl instanceof SVGElement) {
      domEl.setAttribute('attribute', value);
    }
  };

  /**
   * Clean the markup before insertion.
   * @param {string|jQuery} contents The html string or jQuery object.
   * @param {string} stripTags A list of tags to strip to prevent xss, or * for sanitizing and allowing all tags.
   * @returns {string} the cleaned up markup
   */
  DOM.xssClean = function xssClean(contents, stripTags) {
    var markup = contents;

    if (stripTags && stripTags !== '*') {
      markup = xssUtils.stripTags(contents, stripTags);
    }

    if (stripTags === '*') {
      markup = xssUtils.sanitizeHTML(contents);
    }

    return markup;
  };

  /**
   * Append content to a DOM element (like jQuery.append)
   * @param {HTMLElement|SVGElement|jQuery[]} el The element to append to
   * @param {string|jQuery} contents The html string or jQuery object.
   * @param {string} stripTags A list of tags to strip to prevent xss, or * for sanitizing and allowing all tags.
   */
  DOM.html = function html(el, contents, stripTags) {
    var domEl = el;

    if (el instanceof $ && el.length) {
      domEl = domEl[0];
    }

    if (domEl instanceof HTMLElement || domEl instanceof SVGElement) {
      domEl.innerHTML = this.xssClean(contents, stripTags);
    }
  };

  /**
   * HideFocus Behavior
   * Only shows the focus state on key entry (tabs or arrows).
   * @param {HTMLElement|SVGElement} element the base element
   * @returns {HideFocus} component instance
   */
  function HideFocus(element) {
    return this.init(element);
  }

  HideFocus.prototype = {
    init: function init(element) {
      if (!this.element && (element instanceof HTMLElement || element instanceof SVGElement)) {
        this.element = element;
      }

      var $el = $(element);
      var isClick = false;
      var isFocused = false;
      var labelClicked = false;

      // Checkbox, Radio buttons or Switch
      if ($el.is('.checkbox, .radio, .switch')) {
        var label = $el.next();
        if (label.is('[type="hidden"]')) {
          label = label.next();
        }
        this.label = label[0];

        $el.addClass('hide-focus').on('focusin.hide-focus', function (e) {
          if (!isClick && !isFocused && !labelClicked) {
            $el.removeClass('hide-focus');
            $el.triggerHandler('hidefocusremove', [e]);
          }
          isClick = false;
          isFocused = true;
          labelClicked = false;
        }).on('focusout.hide-focus', function (e) {
          $el.addClass('hide-focus');
          labelClicked = label.is(labelClicked);
          isClick = false;
          isFocused = false;
          $el.triggerHandler('hidefocusadd', [e]);
        });

        label.on('mousedown.hide-focus', function (e) {
          labelClicked = this;
          isClick = true;
          $el.addClass('hide-focus');
          $el.triggerHandler('hidefocusadd', [e]);
        });
      } else {
        // All other elements (ie. Hyperlinks)
        var handleMousedown = function handleMousedown(e) {
          isClick = true;
          $el.addClass('hide-focus');
          $el.triggerHandler('hidefocusadd', [e]);
        };
        var isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        if (isTouch) {
          $el.on('touchstart.hide-focus', function (e) {
            handleMousedown(e);
          });
        }

        $el.addClass('hide-focus').on('mousedown.hide-focus', function (e) {
          handleMousedown(e);
        }).on('focusin.hide-focus', function (e) {
          if (!isClick && !isFocused) {
            $el.removeClass('hide-focus');
            $el.triggerHandler('hidefocusremove', [e]);
          }
          isClick = false;
          isFocused = true;
        }).on('focusout.hide-focus', function (e) {
          $el.addClass('hide-focus');
          isClick = false;
          isFocused = false;
          $el.triggerHandler('hidefocusadd', [e]);
        });
      }

      return this;
    },
    updated: function updated() {
      return this.teardown().init();
    },
    teardown: function teardown() {
      if (this.label) {
        $(this.label).off('mousedown.hide-focus');
      }

      var elemEvents = ['focusin.hide-focus', 'focusout.hide-focus', 'mousedown.hide-focus', 'touchstart.hide-focus'];
      $(this.element).off(elemEvents.join(' '));

      return this;
    }
  };

  /**
   * jQuery component wrapper for the HideFocus behavior
   * @returns {jQuery[]} components being acted on
   */
  $.fn.hideFocus = function () {
    return this.each(function () {
      var instance = $.data(this, 'hidefocus');
      if (instance) {
        instance.updated();
      } else {
        instance = $.data(this, 'hidefocus', new HideFocus(this));
        instance.destroy = function destroy() {
          this.teardown();
          $.removeData(this, 'hidefocus');
        };
      }
    });
  };

  /**
   * Allows for the smooth scrolling of an element's content area.
   * @param {HTMLElement|SVGElement|jQuery[]} el The element being manipulated.
   * @param {number} target target distance.
   * @param {number} duration the time that will be needed for the scrolling to complete.
   * @returns {$.Deferred} promise that resolved when scrolling completes.
   */
  function smoothScrollTo(el, target, duration) {
    var dfd = $.Deferred();

    if (!DOM.isElement(el)) {
      // Not a workable element
      return dfd.reject();
    }

    // Strip the jQuery
    if (el instanceof $ && el.length) {
      el = el[0];
    }

    // undefined (not zero) target should instantly resolve
    if (target === undefined || target === null) {
      return dfd.resolve();
    }

    if (isNaN(duration)) {
      duration = 0;
    }

    target = Math.round(target);
    duration = Math.round(duration);

    if (duration < 0) {
      // bad duration
      return dfd.fail();
    }

    if (duration === 0) {
      el.scrollLeft += target;
      return dfd.resolve();
    }

    var startTime = Date.now();
    var endTime = startTime + duration;
    var startLeft = el.scrollLeft;
    var distance = target;

    // based on http://en.wikipedia.org/wiki/Smoothstep
    function smoothStep(start, end, point) {
      if (point <= start) {
        return 0;
      }
      if (point >= end) {
        return 1;
      }
      var x = (point - start) / (end - start); // interpolation
      return x * x * (3 - 2 * x);
    }

    // This is to keep track of where the element's scrollLeft is
    // supposed to be, based on what we're doing
    var previousLeft = el.scrollLeft;

    // This is like a think function from a game loop
    function scrollFrame() {
      if (el.scrollLeft !== previousLeft) {
        // interrupted
        dfd.reject();
        return;
      }

      // set the scrollLeft for this frame
      var now = Date.now();
      var point = smoothStep(startTime, endTime, now);
      var frameLeft = Math.round(startLeft + distance * point);
      el.scrollLeft = frameLeft;

      // check if we're done!
      if (now >= endTime) {
        dfd.resolve();
        return;
      }

      // If we were supposed to scroll but didn't, then we
      // probably hit the limit, so consider it done; not
      // interrupted.
      if (el.scrollLeft === previousLeft && el.scrollLeft !== frameLeft) {
        dfd.resolve();
        return;
      }
      previousLeft = el.scrollLeft;

      // schedule next frame for execution
      setTimeout(scrollFrame, 0);
    }

    // boostrap the animation process
    setTimeout(scrollFrame, 0);

    return dfd;
  }

  /**
   * Binds the Soho Behavior _smoothScrollTo()_ to a jQuery selector
   * @param {number} target target distance to scroll the element
   * @param {number} duration the time that will be needed for the scrolling to complete.
   * @returns {$.Deferred} promise that resolved when scrolling completes.
   */
  $.fn.smoothScroll = function (target, duration) {
    return smoothScrollTo(this, target, duration);
  };

  /**
   * Uses 'requestAnimationFrame' or 'setTimeout' to defer a function.
   * @param {function} callback the callback that runs on a deferment.
   * @param {number} timer how long to delay before running the callback.
   * @returns {function} either `requestAnimationFrame` or `setTimeout`
   */
  function defer(callback, timer) {
    var deferMethod = typeof window.requestAnimationFrame !== 'undefined' ? window.requestAnimationFrame : setTimeout;
    return deferMethod(callback, timer);
  }

  // =================================================================
  // Soho JS-level Breakpoint Access
  // NOTE: these should match whatever the breakpoints are in "/sass/_config.scss"
  // =================================================================
  var breakpoints = {
    phone: 320,
    slim: 400,
    phablet: 610,
    'phone-to-tablet': 767,
    'wide-tablet': 968,
    'tablet-to-desktop': 1280,
    desktop: 1024,
    'desktop-to-extralarge': 1600
  };

  /**
   * Get the name of the current CSS breakpoint by checking the popuplated 'content' value of the
   * <body> tag's `::after` pseudo-element.  These names should be reflected in the breakpoints object
   * above.
   * @returns {string} name of the current breakpoint
   */
  breakpoints.current = function () {
    var afterElement = window.getComputedStyle ? window.getComputedStyle(document.body, ':after') : false;
    if (!afterElement) {
      return '';
    }
    return (afterElement.getPropertyValue('content') || '').replace(/"/g, '');
  };

  /**
   * @param {string} breakpoint matches one of the entries in the "Soho.breakpoints" object.
   * @returns {boolean} whether or not the window is currently wider than the breakpoint provided.
   */
  breakpoints.isAbove = function isAbove(breakpoint) {
    var bp = breakpoints[breakpoint];
    if (!bp) {
      return false;
    }

    var windowWidth = $(window).width();
    return windowWidth > bp - 1;
  };

  /**
   * @param {string} breakpoint matches one of the entries in the "Soho.breakpoints" object.
   * @returns {boolean} whether or not the window is currently more narrow
   *  than the breakpoint provided.
   */
  breakpoints.isBelow = function isBelow(breakpoint) {
    var bp = breakpoints[breakpoint];
    if (!bp) {
      return false;
    }

    var windowWidth = $(window).width();
    return windowWidth < bp;
  };

  /**
   * Compares the last-stored breakpoint with a check on the "current" breakpoint to see if the
   * breakpoint has changed.
   * @returns {void}
   */
  breakpoints.compare = function compare() {
    if (!this.last) {
      this.last = '';
    }

    var cur = this.current();
    if (this.last !== cur) {
      $('body').triggerHandler('breakpoint-change', [{
        previous: this.last,
        current: cur
      }]);
      this.last = cur;
    }
  };

  /**
   * Checks an element for Soho visibility classes and determines whether or not
   * should be hidden based on those values at the current breakpoint.
   * NOTE: this method does NOT determine if the element is ACTUALLY hidden with a
   * `display: none;` or `visibility: hidden;` rule.  It determines whether or not a CSS
   * visibility rule alone would hide the element.
   * @param {HTMLElement} element the element being checked.
   * @returns {boolean} whether or not the element is hidden at this breakpoint.
   */
  breakpoints.isHidden = function (element) {
    if (!element || !DOM.isElement(element)) {
      return false;
    }

    // If there are no CSS classes on the element, return false.
    var cl = element.classList;
    if (!cl.length) {
      return false;
    }

    // If it's always hidden, always return true.
    if (cl.contains('hidden')) {
      return true;
    }

    var bp = this.current();
    var map = {
      phonedown: 'xs',
      phone: 'sm',
      tablet: 'md',
      desktop: 'lg',
      extralarge: 'xl'
    };
    var size = map[bp];
    var hiddenClassName = 'hidden-' + size;
    var visibleClassName = 'visible-' + size + '-';

    // Should be hidden on this breakpoint
    if (cl.contains(hiddenClassName)) {
      return true;
    }

    // If explicitly visible, return
    if (cl.toString().indexOf(visibleClassName) > -1) {
      return false;
    }

    // Simply return false if none of these thing are found
    return false;
  };

  /**
   * jQuery wrapper for `Soho.breakpoints.isHidden()`
   * NOTE: if a jQuery selector with multiple elements is passed to this function,
   * it will only operate on the first one.
   * This method is NOT chainable.
   * @returns {boolean} whether or not the element is hidden at this breakpoint.
   */
  $.fn.isHiddenAtBreakpoint = function () {
    if (!this.length) {
      return false;
    }
    return breakpoints.isHidden($(this).first()[0]);
  };

  /**
   * Debounce method
   * @param {function} func the callback function to be run on a stagger.
   * @param {number} [threshold] the amount of time in CPU ticks to delay.
   * @param {boolean} [execAsap] if true, executes the callback immediately
   *  instead of waiting for the threshold to complete.
   * @returns {void}
   */
  function debounce(func, threshold, execAsap) {
    var timeout = void 0;

    return function debounced() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var obj = this;
      function delayed() {
        if (!execAsap) {
          func.apply(obj, args);
        }
        timeout = null;
      }

      if (timeout) {
        clearTimeout(timeout);
      } else if (execAsap) {
        func.apply(obj, args);
      }

      timeout = setTimeout(delayed, threshold || 250);
    };
  }

  var debouncedResizeName = 'debouncedResize';

  /**
   * Bind the smartResize method to $.fn()
   * @param {function} fn the callback function to be bound on debounced resize
   * @returns {void}
   */
  $.fn[debouncedResizeName] = function (fn) {
    if (fn) {
      return this.bind('resize', debounce(fn));
    }
    return this.trigger(debouncedResizeName);
  };

  // Utility Name
  var UTIL_NAME = 'environment';

  /**
   * @class {Environment}
   */
  var Environment = {

    browser: {},

    features: {
      touch: 'ontouchstart' in window || navigator.MaxTouchPoints > 0 || navigator.msMaxTouchPoints > 0
    },

    os: {},
    devicespecs: {},

    rtl: $('html').attr('dir') === 'rtl',

    /**
     * Builds run-time environment settings
     */
    set: function set() {
      $('html').attr('data-sohoxi-version', version);
      this.addBrowserClasses();
      this.addGlobalResize();
      this.addGlobalEvents();
      this.addDeviceSpecs();
    },


    /**
     * Global Classes for browser, version and device as needed.
     */
    addBrowserClasses: function addBrowserClasses() {
      var ua = navigator.userAgent || navigator.vendor || window.opera;
      var platform = navigator.platform;
      var html = $('html');
      var cssClasses = ''; // User-agent string

      if (ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Android') === -1) {
        cssClasses += 'is-safari ';
        this.browser.name = 'safari';
      }

      if (ua.indexOf('Chrome') !== -1) {
        cssClasses += 'is-chrome ';
        this.browser.name = 'chrome';
      }

      var macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'];
      if (macosPlatforms.indexOf(platform) > -1 && !/Linux/.test(platform)) {
        cssClasses += 'is-mac ';
        this.os.name = 'Mac OS X';
      }

      if (ua.indexOf('Firefox') > 0) {
        cssClasses += 'is-firefox ';
        this.browser.name = 'firefox';
      }

      // Class-based detection for IE
      if (ua.match(/Edge\//)) {
        cssClasses += 'ie ie-edge ';
        this.browser.name = 'edge';
      }
      if (ua.match(/Trident/)) {
        cssClasses += 'ie ';
        this.browser.name = 'ie';
      }
      if (navigator.appVersion.indexOf('MSIE 8.0') > -1 || ua.indexOf('MSIE 8.0') > -1 || document.documentMode === 8) {
        cssClasses += 'ie8 ';
        this.browser.version = '8';
      }
      if (navigator.appVersion.indexOf('MSIE 9.0') > -1) {
        cssClasses += 'ie9 ';
        this.browser.version = '9';
      }
      if (navigator.appVersion.indexOf('MSIE 10.0') > -1) {
        cssClasses += 'ie10 ';
        this.browser.version = '10';
      } else if (ua.match(/Trident\/7\./)) {
        cssClasses += 'ie11 ';
        this.browser.version = '11';
      }

      // Class-based detection for iOS
      // /iPhone|iPod|iPad|Silk|Android|BlackBerry|Opera Mini|IEMobile/
      if (/iPhone|iPod|iPad/.test(ua)) {
        cssClasses += 'ios ';
        this.os.name = 'ios';

        var iDevices = ['iPod', 'iPad', 'iPhone'];
        for (var i = 0; i < iDevices.length; i++) {
          if (new RegExp(iDevices[i]).test(ua)) {
            cssClasses += iDevices[i].toLowerCase() + ' ';
            this.device = iDevices[i];
          }
        }
      }

      if (/Android/.test(ua)) {
        cssClasses += 'android ';
        this.os.name = 'android';
      }

      if (!this.os.name && /Linux/.test(platform)) {
        this.os.name = 'linux';
      }

      html.addClass(cssClasses);
    },
    addDeviceSpecs: function addDeviceSpecs() {
      var unknown = '-';
      var nAppVer = navigator.appVersion;
      var nUAgent = navigator.userAgent;
      var browser = navigator.appName;
      var version$$1 = ' ' + parseFloat(navigator.appVersion);
      var majorVersion = parseInt(navigator.appVersion, 10);
      var nameOffset = void 0;
      var verOffset = void 0;
      var ix = void 0;

      if ((verOffset = nUAgent.indexOf('Opera')) !== -1) {
        //eslint-disable-line
        browser = 'Opera';
        version$$1 = nUAgent.substring(verOffset + 6);
        if ((verOffset = nUAgent.indexOf('Version')) !== -1) {
          //eslint-disable-line
          version$$1 = nUAgent.substring(verOffset + 8);
        }
      }
      if ((verOffset = nUAgent.indexOf('OPR')) !== -1) {
        //eslint-disable-line
        browser = 'Opera';
        version$$1 = nUAgent.substring(verOffset + 4);
      } else if ((verOffset = nUAgent.indexOf('Edge')) !== -1) {
        //eslint-disable-line
        browser = 'Microsoft Edge';
        version$$1 = nUAgent.substring(verOffset + 5);
      } else if ((verOffset = nUAgent.indexOf('MSIE')) !== -1) {
        //eslint-disable-line
        browser = 'Microsoft Internet Explorer';
        version$$1 = nUAgent.substring(verOffset + 5);
      } else if ((verOffset = nUAgent.indexOf('Chrome')) !== -1) {
        //eslint-disable-line
        browser = 'Chrome';
        version$$1 = nUAgent.substring(verOffset + 7);
      } else if ((verOffset = nUAgent.indexOf('Safari')) !== -1) {
        //eslint-disable-line
        browser = 'Safari';
        version$$1 = nUAgent.substring(verOffset + 7);
        if ((verOffset = nUAgent.indexOf('Version')) !== -1) {
          //eslint-disable-line
          version$$1 = nUAgent.substring(verOffset + 8);
        }
      } else if ((verOffset = nUAgent.indexOf('Firefox')) !== -1) {
        //eslint-disable-line
        browser = 'Firefox';
        version$$1 = nUAgent.substring(verOffset + 8);
      } else if (nUAgent.indexOf('Trident/') !== -1) {
        //eslint-disable-line
        browser = 'Microsoft Internet Explorer';
        version$$1 = nUAgent.substring(nUAgent.indexOf('rv:') + 3);
      } else if ((nameOffset = nUAgent.lastIndexOf(' ') + 1) < (verOffset = nUAgent.lastIndexOf('/'))) {
        //eslint-disable-line
        browser = nUAgent.substring(nameOffset, verOffset);
        version$$1 = nUAgent.substring(verOffset + 1);
        if (browser.toLowerCase() === browser.toUpperCase()) {
          browser = navigator.appName;
        }
      }
      // Trim the version string
      if ((ix = version$$1.indexOf(';')) !== -1) version$$1 = version$$1.substring(0, ix); //eslint-disable-line
      if ((ix = version$$1.indexOf(' ')) !== -1) version$$1 = version$$1.substring(0, ix); //eslint-disable-line
      if ((ix = version$$1.indexOf(')')) !== -1) version$$1 = version$$1.substring(0, ix); //eslint-disable-line

      majorVersion = ' ' + parseInt(version$$1, 10);
      if (isNaN(majorVersion)) {
        version$$1 = ' ' + parseFloat(navigator.appVersion);
        majorVersion = parseInt(navigator.appVersion, 10);
      }

      // mobile version
      var mobile = /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(nAppVer);

      var os = unknown;

      var clientStrings = [{ s: 'Windows 10', r: /(Windows 10.0|Windows NT 10.0)/ }, { s: 'Windows 8.1', r: /(Windows 8.1|Windows NT 6.3)/ }, { s: 'Windows 8', r: /(Windows 8|Windows NT 6.2)/ }, { s: 'Windows 7', r: /(Windows 7|Windows NT 6.1)/ }, { s: 'Android', r: /Android/ }, { s: 'Open BSD', r: /OpenBSD/ }, { s: 'Sun OS', r: /SunOS/ }, { s: 'Linux', r: /(Linux|X11)/ }, { s: 'iOS', r: /(iPhone|iPad|iPod)/ }, { s: 'Mac OS X', r: /Mac OS X/ }, { s: 'Mac OS', r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/ }, { s: 'UNIX', r: /UNIX/ }];

      for (var id in clientStrings) {
        //eslint-disable-line
        var cs = clientStrings[id];
        if (cs.r.test(nUAgent)) {
          os = cs.s;
          break;
        }
      }

      var osVersion = unknown;

      if (/Windows/.test(os)) {
        osVersion = /Windows (.*)/.exec(os)[1];
      }

      switch (os) {//eslint-disable-line
        case 'Mac OS X':
          osVersion = /Mac OS X (10[\.\_\d]+)/.exec(nUAgent)[1].replace(/\_/g, '.'); //eslint-disable-line
          break;

        case 'Android':
          osVersion = /Android ([\.\_\d]+)/.exec(nUAgent)[1]; //eslint-disable-line
          break;

        case 'iOS':
          osVersion = /OS (\d+)_?(\d+)?/.exec(nUAgent); //eslint-disable-line
          osVersion = osVersion[1] + '.' + osVersion[2] + '.' + (osVersion[3] | 0); //eslint-disable-line
          break;
      }

      this.devicespecs = {
        currentBrowser: browser,
        browserVersion: version$$1,
        browserMajorVersion: majorVersion,
        isMobile: mobile,
        os: os,
        currentOSVersion: osVersion
      };
    },


    /**
     * Setup a global resize event trigger for controls to listen to
     */
    addGlobalResize: function addGlobalResize() {
      // Global resize event
      $(window).debouncedResize(function () {
        $('body').triggerHandler('resize', [window]);
        breakpoints.compare();
      });

      // Also detect whenenver a load or orientation change occurs
      $(window).on('orientationchange load', function () {
        return breakpoints.compare();
      });
    },


    /**
     * Sets up global UI-specific event handlers
     * @returns {void}
     */
    addGlobalEvents: function addGlobalEvents() {
      var _this = this;

      var self = this;

      this.globalMouseActive = 0;
      this.globalTouchActive = 0;

      // Detect mouse/touch events on the body to help scrolling detection along
      $('body').on('mousedown.' + UTIL_NAME, function () {
        ++_this.globalMouseActive;
      }).on('mouseup.' + UTIL_NAME, function () {
        --_this.globalMouseActive;
      }).on('touchstart.' + UTIL_NAME, function () {
        ++_this.globalTouchActive;
      }).on('touchend.' + UTIL_NAME, function () {
        --_this.globalTouchActive;
      });

      // On iOS, it's possible to scroll the body tag even if there's a `no-scroll` class attached
      // This listener persists and will prevent scrolling on the body tag in the event of a `no-scroll`
      // class, only in iOS environments
      $(window).on('scroll.' + UTIL_NAME, function (e) {
        if (self.os.name !== 'ios' || document.body.className.indexOf('no-scroll') === -1) {
          return true;
        }

        // If a mouse button or touch is still active, continue as normal
        if (_this.globalTouchActive || _this.globalMouseActive) {
          return true;
        }

        e.preventDefault();
        if (document.body.scrollTop > 0) {
          document.body.scrollTop = 0;
        }
        return false;
      });

      // Prevent zooming on inputs/textareas' `focusin`/`focusout` events.
      // Some components like Dropdown have this feature built in on their specified elements.
      // This particular setup prevents zooming on input fields not tied to a component wrapper.
      $('body').on('focusin.' + UTIL_NAME, 'input, textarea', function (e) {
        var target = e.target;
        if (target.className.indexOf('dropdown-search') > -1) {
          return;
        }

        if (self.os.name === 'ios') {
          $('head').triggerHandler('disable-zoom');
        }
      }).on('focusout.' + UTIL_NAME, 'input, textarea', function (e) {
        var target = e.target;
        if (target.className.indexOf('dropdown-search') > -1) {
          return;
        }

        if (self.os.name === 'ios') {
          $('head').triggerHandler('enable-zoom');
        }
      });
    },


    /**
     * Tears down global UI-specific event handlers
     * @returns {void}
     */
    removeGlobalEvents: function removeGlobalEvents() {
      $(window).off('scroll.' + UTIL_NAME);

      $('body').off(['focusin.' + UTIL_NAME, 'focusout.' + UTIL_NAME].join(' '));
    }
  };

  /**
   * @returns {boolean} whether or not the current browser is IE11
   */
  Environment.browser.isIE11 = function () {
    return Environment.browser.name === 'ie' && Environment.browser.version === '11';
  };

  /**
   * @returns {boolean} whether or not the current browser is IE10
   */
  Environment.browser.isIE10 = function () {
    return Environment.browser.name === 'ie' && Environment.browser.version === '10';
  };

  /**
   * Automatically set up the environment by virtue of including this script
   */
  Environment.set();

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  /**
   * Used for changing the stacking order of jQuery events.  This is needed to override certain
   * Events invoked by other plugins http://stackoverflow.com/questions/2360655
   * @private
   * @param {string} name the event name
   * @param {function} fn callback function that will be called during the supplied event name
   * @returns {void}
   */
  $.fn.bindFirst = function (name, fn) {
    this.on(name, fn);
    this.each(function () {
      var handlers = $._data(this, 'events')[name.split('.')[0]]; // eslint-disable-line
      // take out the handler we just inserted from the end
      var handler = handlers.pop();
      // move it at the beginning
      handlers.splice(0, 0, handler);
    });
  };

  /**
   * @private
   * uniqueIdCount is a baseline unique number that will be used when generating
   * uniqueIds for elements and components.
   */
  exports.uniqueIdCount = 0; // eslint-disable-line

  /**
   * Detect whether or not a text string represents a valid CSS property.  This check
   * includes an attempt at checking for vendor-prefixed versions of the CSS property
   * provided.
   * @private
   * @param {string} prop a possible CSS property
   * @returns {string|null} If the property exists, it will be returned in string format.
   *  If the property doesn't exist, a null result is returned.
   */
  $.fn.cssPropSupport = function (prop) {
    if (!prop) {
      return null;
    }

    var el = $('<div></div>')[0];
    var propStr = prop.toString();
    var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
    var capitalizedProp = propStr.charAt(0).toUpperCase() + propStr.substr(1);

    if (prop in el.style) {
      $(el).remove();
      return prop;
    }

    for (var i = 0; i < prefixes.length; i++) {
      var vendorProp = prefixes[i] + capitalizedProp;
      if (vendorProp in el.style) {
        $(el).remove();
        return vendorProp;
      }
    }

    $(el).remove();
    return null;
  };

  /**
   * Returns the name of the TransitionEnd event.
   * @private
   * @returns {string} a (possibly) vendor-adjusted CSS transition property name.
   */
  $.fn.transitionEndName = function () {
    var prop = $.fn.cssPropSupport('transition');
    var eventNames = {
      WebkitTransition: 'webkitTransitionEnd',
      MozTransition: 'transitionend',
      MSTransition: 'msTransitionEnd',
      OTransition: 'oTransitionEnd',
      transition: 'transitionend'
    };

    return eventNames[prop] || null;
  };

  /**
   * Checks to see if a provided element is visible based on its CSS `visibility` property.
   * @private
   * @param {HTMLElement} element the element being checked.
   * @returns {boolean} whether or not the element is visible.
   */
  function visible(element) {
    return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {
      return $.css(this, 'visibility') === 'hidden';
    }).length;
  }

  /**
   * From jQueryUI Core: https://github.com/jquery/jquery-ui/blob/24756a978a977d7abbef5e5bce403837a01d964f/ui/jquery.ui.core.js#L93
   * Adapted from:  http://stackoverflow.com/questions/7668525/is-there-a-jquery-selector-to-get-all-elements-that-can-get-focus
   * Adds the ':focusable' selector to Sizzle to allow for the selection of elements
   * that can currently be focused.
   * @private
   * @param {HTMLElement} element the element being checked
   * @returns {boolean} whether or not the element is focusable.
   */
  function _focusable(element) {
    var map = void 0;
    var mapName = void 0;
    var img = void 0;
    var nodeName = element.nodeName.toLowerCase();
    var isTabIndexNotNaN = !isNaN($.attr(element, 'tabindex'));

    if (nodeName === 'area') {
      map = element.parentNode;
      mapName = map.name;
      if (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
        return false;
      }
      img = $('img[usemap=#' + mapName + ']')[0];
      return !!img && visible(img);
    }

    // The element and all of its ancestors must be visible.
    // Return out fast if this isn't the case.
    if (!visible(element)) {
      return false;
    }

    var match = /input|select|textarea|button|object/.test(nodeName);
    if (match) {
      return !element.disabled;
    }
    if (nodeName === 'a') {
      return element.href !== undefined || isTabIndexNotNaN;
    }
    return isTabIndexNotNaN;
  }

  // Adds a `:focusable` selector to jQuery's selector library.
  $.extend($.expr[':'], {
    focusable: function focusable(element) {
      return _focusable(element, !isNaN($.attr(element, 'tabindex')));
    }
  });

  /**
   * Returns a key/value list of currently attached event listeners
   * @private
   * @returns {object} containing list of event names as keys, and event listener functions as values.
   */
  $.fn.listEvents = function () {
    var data = {};

    this.each(function () {
      data = $._data(this, 'events'); // eslint-disable-line
    });

    return data;
  };

  var utils = {};

  /**
   * Generates a unique ID for an element based on the element's configuration, any
   * Soho components that are generated against it, and provided prefixes/suffixes.
   * @private
   * @param {HTMLElement} element the element being used for uniqueId capture
   * @param {string} [className] CSS classname (will be interpreted automatically
   *  if it's not provided)
   * @param {string} [prefix] optional prefix
   * @param {string} [suffix] optional suffix
   * @returns {string} the compiled uniqueID
   */
  utils.uniqueId = function (element, className, prefix, suffix) {
    var predefinedId = element.id;

    if (predefinedId && $('#' + predefinedId).length < 2) {
      return predefinedId;
    }

    prefix = !prefix ? '' : prefix + '-';
    suffix = !suffix ? '' : '-' + suffix;
    className = !className ? Array.from(element.classList).join('-') : className;

    var str = '' + prefix + className + '-' + exports.uniqueIdCount + suffix;
    exports.uniqueIdCount += 1;
    return str;
  };

  /**
   * Grabs an attribute from an HTMLElement containing stringified JSON syntax,
   * and interprets it into options.
   * @private
   * @param {HTMLElement} element the element whose settings are being interpreted
   * @param {string} [attr] optional different attribute to parse for settings
   * @returns {object} a list of interpreted settings for this element
   */
  utils.parseSettings = function parseSettings(element, attr) {
    var options = {};
    if (!element || !(element instanceof HTMLElement) && !(element instanceof $) || element instanceof $ && !element.length) {
      return options;
    }

    if (element instanceof $) {
      element = element[0];
    }

    // Use `data-options` as a default.
    attr = attr || 'data-options';

    var str = element.getAttribute(attr);
    if (!str || typeof str !== 'string' || str.indexOf('{') === -1) {
      return options;
    }

    // replace single to double quotes, since single-quotes may be necessary
    // due to entry in markup.
    function replaceDoubleQuotes(changedStr) {
      return changedStr.replace(/'/g, '"');
    }

    // Manually parse a string more in-depth
    function manualParse(changedStr) {
      // get keys
      var regex = /({|,)(?:\s*)(?:')?([A-Za-z_$\.][A-Za-z0-9_ \-\.$]*)(?:')?(?:\s*):/g; // eslint-disable-line

      // add double quotes to keys
      changedStr = changedStr.replace(regex, '$1\"$2\":'); // eslint-disable-line

      // get strings in values
      regex = /:(?:\s*)(?!(true|false|null|undefined))([A-Za-z_$\.#][A-Za-z0-9_ \-\.$]*)/g; // eslint-disable-line

      // add double quotes to strings in values
      changedStr = changedStr.replace(regex, ':\"$2\"'); // eslint-disable-line
      changedStr = replaceDoubleQuotes(changedStr);
      return changedStr;
    }

    try {
      options = JSON.parse(replaceDoubleQuotes(str));
    } catch (err) {
      options = JSON.parse(manualParse(str));
    }

    return options;
  };

  /**
   * Deprecate `utils.parseOptions` in favor of `utils.parseSettings`
   * @private
   * @deprecated
   * TODO: Remove in 4.4.1 ?
   */
  utils.parseOptions = utils.parseSettings;

  /**
  * jQuery Behavior Wrapper for `utils.parseOptions`.
  * @deprecated
  * @private
  * @param {HTMLElement|jQuery[]} element the element whose options are being parsed
  * @param {string} [attr] an optional alternate attribute name to use when obtaining settings
  * @returns {Object|Object[]} an object representation of parsed settings.
  */
  $.fn.parseOptions = function (element, attr) {
    var results = [];
    var isCalledDirectly = element instanceof HTMLElement || element instanceof SVGElement || element instanceof $;
    var targets = this;

    if (isCalledDirectly) {
      targets = $(element);
    } else {
      attr = element;
      element = undefined;
    }

    targets.each(function (i, item) {
      results.push({
        element: this,
        options: utils.parseOptions(item, attr)
      });
    });

    if (results.length === 1) {
      return results[0].options;
    }
    return results;
  };

  /**
   * Performs the usual Boolean coercion with the exception of the strings "false"
   * (case insensitive) and "0"
   * @private
   * @param {boolean|string|number} b the value to be checked
   * @returns {boolean} whether or not the value passed coerces to true.
   */
  utils.coerceToBoolean = function (b) {
    return !/^(false|0)$/i.test(b) && !!b;
  };

  /**
   * Coerces all properties inside of a settings object to a boolean.
   * @param {Object} settings incoming settings
   * @param {String[]} [targetPropsArr=undefined] optional array of specific settings keys to target.
   *  If no keys are provided, all keys will be targeted.
   * @returns {Object} modified settings.
   */
  utils.coerceSettingsToBoolean = function (settings, targetPropsArr) {
    if (!targetPropsArr || !Array.isArray(targetPropsArr)) {
      Object.keys(settings).forEach(function (key) {
        targetPropsArr.push(key);
      });
    }

    var i = void 0;
    var l = void 0;
    for (i = 0, l = targetPropsArr.length; i < l; i++) {
      settings[targetPropsArr[i]] = utils.coerceToBoolean(settings[targetPropsArr[i]]);
    }

    return settings;
  };

  /**
   * Timer - can be used for play/pause or stop for given time.
   * Use as new instance [ var timer = new $.fn.timer(function() {}, 6000); ]
   * then can be listen events as:
   * [ $(timer.event).on('update', function(e, data){console.log(data.counter)}); ]
   * or can access as [ timer.cancel(); -or- timer.pause(); -or- timer.resume(); ]
   * @private
   * @param {function} [callback] method that will run on each timer update
   * @param {number} delay amount of time between timer ticks
   * @returns {object} containing methods that can be run on the timer
   */
  $.fn.timer = function (callback, delay) {
    var self = $(this);
    var speed = 10;
    var interval = void 0;
    var counter = 0;

    function cancel() {
      self.triggerHandler('cancel');
      clearInterval(interval);
      counter = 0;
    }

    function pause() {
      self.triggerHandler('pause');
      clearInterval(interval);
    }

    function update() {
      interval = setInterval(function () {
        counter += speed;
        self.triggerHandler('update', [{ counter: counter }]);
        if (counter > delay) {
          self.triggerHandler('timeout');
          callback.apply(arguments); // eslint-disable-line
          clearInterval(interval);
          counter = 0;
        }
      }, speed);
    }

    function resume() {
      self.triggerHandler('resume');
      update();
    }

    update();

    return {
      event: this,
      cancel: cancel,
      pause: pause,
      resume: resume
    };
  };

  /**
   * Copies a string to the clipboard. Must be called from within an event handler such as click.
   * May return false if it failed, but this is not always
   * possible. Browser support for Chrome 43+, Firefox 42+, Edge and IE 10+.
   * No Safari support, as of (Nov. 2015). Returns false.
   * IE: The clipboard feature may be disabled by an adminstrator. By default a prompt is
   * shown the first time the clipboard is used (per session).
   * @private
   * @param {string} text incoming text content
   * @returns {string|boolean} copied text, or a false result if there was an error
   */
  $.copyToClipboard = function (text) {
    // eslint-disable-line
    if (window.clipboardData && window.clipboardData.setData) {
      // IE specific code path to prevent textarea being shown while dialog is visible.
      return window.clipboardData.setData('Text', text);
    } else if (document.queryCommandSupported && document.queryCommandSupported('copy')) {
      var textarea = document.createElement('textarea');
      textarea.textContent = text;
      textarea.style.position = 'fixed'; // Prevent scrolling to bottom of page in MS Edge.
      document.body.appendChild(textarea);
      textarea.select();
      try {
        return document.execCommand('copy'); // Security exception may be thrown by some browsers.
      } catch (ex) {
        // console.warn('Copy to clipboard failed.', ex);
        return false;
      } finally {
        document.body.removeChild(textarea);
      }
    }
  };

  /**
   * Clearable (Shows an X to clear)
   * @private
   */
  $.fn.clearable = function () {
    var self = this;
    this.element = $(this);

    var COMPONENT_NAME = 'clearable';

    // Create an X icon button styles in icons.scss
    this.xButton = this.element.find('.icon.close').first();
    if (!this.xButton || !this.xButton.length) {
      this.xButton = $.createIconElement({ classes: 'close is-empty', icon: 'close' }).icon();
    }

    // Clears the contents of the base element
    this.clear = function () {
      self.element.val('').trigger('change').focus().trigger('cleared');
      self.checkContents();
    };

    // Event listener for the xButton's `keydown` event
    this.handleKeydown = function (e) {
      var key = e.key;

      if (key === 'Enter' || e.altKey && (key === 'Delete' || key === 'Backspace')) {
        e.preventDefault();
        self.clear();
      }
    };

    // Checks the contents of the base element (presumably an input field) for empty
    this.checkContents = function () {
      var text = self.element.val();
      if (!text || !text.length) {
        this.xButton.addClass('is-empty');
      } else {
        this.xButton.removeClass('is-empty');
      }

      this.element.trigger('contents-checked');
    };

    // Add the button to field parent
    this.xButton.insertAfter(self.element);
    this.xButton[0].tabIndex = 0;
    this.xButton[0].setAttribute('focusable', true);

    // Handle Events
    this.xButton.off(['click.' + COMPONENT_NAME, 'keydown.' + COMPONENT_NAME].join(' ')).on('click.clearable', this.clear).on('keydown.clearable', this.handleKeydown);

    var elemEvents = ['blur.' + COMPONENT_NAME, 'change.' + COMPONENT_NAME, 'keyup.' + COMPONENT_NAME].join(' ');

    this.element.off(elemEvents).on(elemEvents, function () {
      self.checkContents();
    });

    // Set initial state
    this.checkContents();
  };

  /**
   * Replacement for String.fromCharCode() that takes meta keys into account when determining which
   * @private
   * character key was pressed.
   * @param {jQuery.Event} e jQuery-wrapped `keypress` event
   * @returns {string} text tcharacter
   */
  utils.actualChar = function (e) {
    var key = e.which;
    var character = '';
    var toAscii = {
      188: '44',
      // '109': '45', // changes "m" to "-" when using keypress
      190: '46',
      191: '47',
      192: '96',
      220: '92',
      222: '39',
      221: '93',
      219: '91',
      173: '45',
      187: '61', // IE Key codes
      186: '59', // IE Key codes
      189: '45' // IE Key codes
    };
    var shiftUps = {
      96: '~',
      49: '!',
      50: '@',
      51: '#',
      52: '$',
      53: '%',
      54: '^',
      55: '&',
      56: '*',
      57: '(',
      48: ')',
      45: '_',
      61: '+',
      91: '{',
      93: '}',
      92: '|',
      59: ':',
      37: '%',
      38: '&',
      39: '"',
      44: '<',
      46: '>',
      47: '?'
    };

    // Normalize weird keycodes
    if (Object.prototype.hasOwnProperty.call(toAscii, key)) {
      key = toAscii[key];
    }

    // Handle Numpad keys
    if (key >= 96 && key <= 105) {
      key -= 48;
    }

    // Convert Keycode to Character String
    if (!e.shiftKey && key >= 65 && key <= 90) {
      character = String.fromCharCode(key + 32);
    } else if (e.shiftKey && Object.prototype.hasOwnProperty.call(shiftUps, key)) {
      // User was pressing Shift + any key
      character = shiftUps[key];
    } else {
      character = String.fromCharCode(key);
    }

    return character;
  };

  /**
   * Get the actualy typed key from the event.
   * @private
   * @param  {object} e The event to check for the key.
   * @returns {string} The actual key typed.
   */
  $.actualChar = function (e) {
    return utils.actualChar(e);
  };

  /**
   * Equate two values quickly in a truthy fashion
   * @private
   * @param {any} a first value
   * @param {any} b second value
   * @returns {boolean} whether the two items compare in a truthy fashion.
   */
  utils.equals = function equals(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
  };

  /**
   * Converts an element wrapped in a jQuery collection down to its original HTMLElement reference.
   * If an HTMLElement is passed in, simply returns it.
   * If anything besides HTMLElements or jQuery[] is passed in, returns undefined;
   * @private
   * @param {any} item the item being evaluated
   * @returns {HTMLElement|undefined} the unwrapped item, or nothing.
   */
  DOM.convertToHTMLElement = function convertToHTMLElement(item) {
    if (item instanceof HTMLElement) {
      return item;
    }

    if (item instanceof $) {
      if (item.length) {
        item = item[0];
      } else {
        item = undefined;
      }
      return item;
    }

    return undefined;
  };

  /**
   * Object deep copy.
   * For now, alias jQuery.extend
   * Eventually we'll replace this with a non-jQuery extend method.
   * @private
   */
  utils.extend = $.extend;

  /**
   * Hack for IE11 and SVGs that get moved around/appended at inconvenient times.
   * The action of changing the xlink:href attribute to something else and back will fix the problem.
   * @private
   * @param {HTMLElement} rootElement the base element
   * @returns {void}
   */
  utils.fixSVGIcons = function fixSVGIcons(rootElement) {
    if (Environment.browser.name !== 'ie' && Environment.browser.version !== '11') {
      return;
    }

    if (rootElement === undefined) {
      return;
    }

    var xlinkNS = 'http://www.w3.org/1999/xlink';

    // Handle jQuery
    if (rootElement instanceof $) {
      if (!rootElement.length) {
        return;
      }

      if (rootElement.length === 1) {
        rootElement = rootElement[0];
      } else {
        rootElement.each(function (i, elem) {
          fixSVGIcons(elem);
        });
        return;
      }
    }

    // Handle NodeList in an IE-friendly way
    // https://developer.mozilla.org/en-US/docs/Web/API/NodeList#Example
    if (rootElement instanceof NodeList) {
      Array.prototype.forEach.call(rootElement, function (elem) {
        fixSVGIcons(elem);
      });
      return;
    }

    setTimeout(function () {
      var uses = rootElement.getElementsByTagName('use');
      for (var i = 0; i < uses.length; i++) {
        var attr = uses[i].getAttributeNS(xlinkNS, 'href');
        uses[i].setAttributeNS(xlinkNS, 'href', 'x');
        uses[i].setAttributeNS(xlinkNS, 'href', attr);
      }
    }, 1);
  };

  /**
   * Gets the current size of the viewport
   * @private
   * @returns {object} width/height of the viewport
   */
  utils.getViewportSize = function getViewportSize() {
    return {
      width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
      height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
    };
  };

  /**
   * Gets the various scrollable containers that an element is nested inside of, and returns
   *  their scrollHeight and scrollLeft values.
   * @private
   * @param {HTMLElement} element the base element to check for containment
   * @returns {object} containing references to the container element and its top/left
   */
  utils.getContainerScrollDistance = function getContainerScrollDistance(element) {
    if (!DOM.isElement(element)) {
      return [];
    }

    var containers = [];
    var scrollableElements = ['.scrollable', '.scrollable-x', '.scrollable-y', '.modal', '.card-content', '.widget-content', '.tab-panel', '.datagrid-content'];

    $(element).parents(scrollableElements.join(', ')).each(function () {
      var el = this;

      containers.push({
        element: el,
        left: el.scrollLeft,
        top: el.scrollTop
      });
    });

    // Push the body's scroll area if it's not a "no-scroll" area
    if (!document.body.classList.contains('no-scroll')) {
      containers.push({
        element: document.body,
        left: document.body.scrollLeft,
        top: document.body.scrollTop
      });
    }

    return containers;
  };

  /**
   * Takes an element that is currently hidden by some means (FX: "display: none;")
   *  and gets its potential dimensions by checking a clone of the element that is NOT hidden.
   * @private
   * @param {HTMLElement|SVGElement|jQuery[]} el The element being manipulated.
   * @param {object} options incoming options.
   * @param {jQuery[]} [parentElement] the parent element where a clone of this
   *  hidden element will be attached.
   * @returns {object} containing various width/height properties of the element provided.
   */
  utils.getHiddenSize = function getHiddenSize(el, options) {
    var defaults$$1 = {
      dims: { width: 0, height: 0, innerWidth: 0, innerHeight: 0, outerWidth: 0, outerHeight: 0 },
      parentElement: undefined,
      includeMargin: false
    };

    if (!DOM.isElement(el)) {
      return defaults$$1.dims;
    }

    el = $(el);
    options = $.extend({}, defaults$$1, options);

    // element becomes clone and appended to a parentElement, if defined
    var hasDefinedParentElement = DOM.isElement(options.parentElement);
    if (hasDefinedParentElement) {
      el = el.clone().appendTo(options.parentElement);
    }

    var dims = options.dims;
    var hiddenParents = el.parents().add(el);
    var props = {
      transition: 'none',
      webkitTransition: 'none',
      mozTransition: 'none',
      msTransition: 'none',
      visibility: 'hidden',
      display: 'block'
    };
    var oldProps = [];

    hiddenParents.each(function () {
      var _this = this;

      var old = {};
      var propTypes = Object.keys(props);
      propTypes.forEach(function (name) {
        if (_this.style[name]) {
          old[name] = _this.style[name];
          _this.style[name] = props[name];
        }
      });

      oldProps.push(old);
    });

    dims.padding = {
      bottom: el.css('padding-bottom'),
      left: el.css('padding-left'),
      right: el.css('padding-right'),
      top: el.css('padding-top')
    };
    dims.width = el.width();
    dims.outerWidth = el.outerWidth(options.includeMargin);
    dims.innerWidth = el.innerWidth();
    dims.scrollWidth = el[0].scrollWidth;
    dims.height = el.height();
    dims.innerHeight = el.innerHeight();
    dims.outerHeight = el.outerHeight(options.includeMargin);
    dims.scrollHeight = el[0].scrollHeight;

    hiddenParents.each(function (i) {
      var _this2 = this;

      var old = oldProps[i];
      var propTypes = Object.keys(props);
      propTypes.forEach(function (name) {
        if (old[name]) {
          _this2.style[name] = old[name];
        }
      });
    });

    // element is ONLY removed when a parentElement is defined because it was cloned.
    if (hasDefinedParentElement) {
      el.remove();
    }

    return dims;
  };

  /**
   * Binds the Soho Util _getHiddenSize()_ to a jQuery selector
   * @private
   * @param {object} options - incoming options
   * @returns {object} hidden size
   */
  $.fn.getHiddenSize = function (options) {
    return utils.getHiddenSize(this, options);
  };

  /**
   * Checks if a specific input is a String
   * @private
   * @param {any} value an object of unknown type to check
   * @returns {boolean} whether or not a specific input is a String
   */
  utils.isString = function isString(value) {
    return typeof value === 'string' || value instanceof String;
  };

  /**
   * Checks if a specific input is a Number
   * @private
   * @param {any} value an object of unknown type to check
   * @returns {boolean} whether or not a specific input is a Number
   */
  utils.isNumber = function isNumber(value) {
    return typeof value === 'number' && value.length === undefined && !isNaN(value);
  };

  /**
   * Safely changes the position of a text caret inside of an editable element.
   * In most cases, will call "setSelectionRange" on an editable element immediately, but in some
   * cases, will be deferred with `requestAnimationFrame` or `setTimeout`.
   * @private
   * @param {HTMLElement} element the element to get selection
   * @param {number} startPos starting position of the text caret
   * @param {number} endPos ending position of the text caret
   */
  utils.safeSetSelection = function safeSetSelection(element, startPos, endPos) {
    if (startPos && endPos === undefined) {
      endPos = startPos;
    }

    if (document.activeElement === element) {
      if (Environment.os.name === 'android') {
        defer(function () {
          element.setSelectionRange(startPos, endPos, 'none');
        }, 0);
      } else {
        element.setSelectionRange(startPos, endPos, 'none');
      }
    }
  };

  /**
   * Checks to see if a variable is valid for containing Soho component options.
   * @private
   * @param {object|function} o an object or function
   * @returns {boolean} whether or not the object type is valid
   */
  function isValidOptions(o) {
    return (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' || typeof o === 'function';
  }

  /**
   * In some cases, functions are passed to component constructors as the settings argument.
   * This method runs the settings function if it's present and returns the resulting object.
   * @private
   * @param {object|function} o represents settings
   * @returns {object} processed settings
   */
  function resolveFunctionBasedSettings(o) {
    if (typeof o === 'function') {
      return o();
    }
    return o;
  }

  /**
   * Merges various sets of options into a single object,
   * whose intention is to be set as options on a Soho component.
   * @private
   * @param {HTMLElement|SVGElement|jQuery[]} [element] the element to process for inline-settings
   * @param {Object|function} incomingOptions desired settings
   * @param {Object|function} [defaultOptions] optional base settings
   * @returns {object} processed settings
   */
  utils.mergeSettings = function mergeSettings(element, incomingOptions, defaultOptions) {
    if (!incomingOptions || !isValidOptions(incomingOptions)) {
      if (isValidOptions(defaultOptions)) {
        incomingOptions = defaultOptions;
      } else {
        incomingOptions = {};
      }
    }

    // Actually get ready to merge incoming options if we get to this point.
    return utils.extend(true, {}, resolveFunctionBasedSettings(defaultOptions || {}), resolveFunctionBasedSettings(incomingOptions), element !== undefined ? utils.parseSettings(element) : {}); // possible to run this without an element present -- will simply skip this part
  };

  /**
   * Test if a string is Html or not
   * @private
   * @param  {string} string The string to test.
   * @returns {boolean} True if it is html.
   */
  utils.isHTML = function (string) {
    return (/(<([^>]+)>)/i.test(string)
    );
  };

  var math = {};

  /**
   * Convert `setTimeout/Interval` delay values (CPU ticks) into frames-per-second
   * (FPS) numeric values.
   * @private
   * @param {number} delay CPU Ticks
   * @returns {number} Frames Per Second
   */
  math.convertDelayToFPS = function convertDelayToFPS(delay) {
    if (isNaN(delay)) {
      throw new Error('provided delay value is not a number');
    }
    return delay / 16.7;
  };

  /**
   * Convert `setTimeout/Interval` delay values (CPU ticks) into frames-per-second
   * (FPS) numeric values.
   * @private
   * @param {number} fps (Frames Per Second)
   * @returns {number} delay in CPU ticks
   */
  math.convertFPSToDelay = function convertFPSToDelay(fps) {
    if (isNaN(fps)) {
      throw new Error('provided delay value is not a number');
    }
    return fps * 16.7;
  };

  /**
   *  Determines whether the passed value is a finite number.
   * @private
   * @param {number} value The number
   * @returns {boolean} If it is finite or not.
   */
  math.isFinite = function isFinite(value) {
    // 1. If Type(number) is not Number, return false.
    if (typeof value !== 'number') {
      return false;
    }
    // 2. If number is NaN, +∞, or −∞, return false.
    if (value !== value || value === Infinity || value === -Infinity) {
      //eslint-disable-line
      return false;
    }
    // 3. Otherwise, return true.
    return true;
  };

  /**
   * `Array.ForEach()`-style method that is also friendly to `NodeList` types.
   * @param {Array|NodeList} array incoming items
   * @param {function} callback the method to run
   * @param {object} scope the context in which to run the method
   */
  utils.forEach = function forEach(array, callback, scope) {
    for (var i = 0; i < array.length; i++) {
      callback.call(scope, array[i], i, array); // passes back stuff we need
    }
  };

  /**
   * Returns the sign of a number, indicating whether the number is positive, negative or zero
   * @param {number} x A number.
   * @returns {number} A number representing the sign of the given argument. If the argument is a positive number, negative number, positive zero or negative zero, the function will return 1, -1, 0 or -0 respectively. Otherwise, NaN is returned.
   */
  math.sign = function (x) {
    if (Math.sign) {
      return Math.sign(x);
    }

    x = +x;
    if (x === 0 || isNaN(x)) {
      return x;
    }
    return x > 0 ? 1 : -1;
  };

  var stringUtils = {};

  /**
   * Re-usable Empty String that can be referenced everywhere to save small amounts of space.
   */
  stringUtils.EMPTY = '';

  /**
  * The splice() method changes the content of a string by removing a range of
  * characters and/or adding new characters.
  *
  * @param {string} str The string that will be manipulated.
  * @param {number} start Index at which to start changing the string.
  * @param {number} delCount An integer indicating the number of old chars to remove.
  * @param {string} newSubStr The String that is spliced in.
  * @returns {string} A new string with the spliced substring.
  */
  stringUtils.splice = function splice(str, start, delCount, newSubStr) {
    return str.slice(0, start) + newSubStr + str.slice(start + Math.abs(delCount));
  };

  /**
   * Takes a string with possible duplicate characters and returns a string
   * containing ALL unique characters.  Useful for construction of REGEX objects
   * with characters from an input field, etc.
   * @param {string} str The string to process
   * @returns {string} The processed string
   */
  stringUtils.removeDuplicates = function removeDuplicates(str) {
    return str.split('').filter(function (item, pos, self) {
      //eslint-disable-line
      return self.indexOf(item) === pos;
    }).join('');
  };

  /**
   * Takes a string and uses a regex test to detect the presence of HTML elements.
   * @param {string} str The string to search
   * @returns {boolean} True if the string is contained.
   */
  stringUtils.containsHTML = function containsHTML(str) {
    return (/<[a-z][\s\S]*>/i.test(str)
    );
  };

  /**
   * Takes a string containing HTML and strips it of extraneous white space.
   * @param {string} str The string to parse
   * @returns {string} The string minus extraneous white space.
   */
  stringUtils.stripWhitespace = function stripWhitespace(str) {
    return str.replace(/\n/g, '').replace(/[\t ]+</g, '<').replace(/>[\t ]+</g, '><').replace(/>[\t ]+$/g, '>');
  };

  /**
   * Capitalizes the first letter of a string
   * @param {string} str the incoming text
   * @returns {string} the modified text
   */
  stringUtils.capitalize = function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };

  /**
   * [capitalize description]
   * @param  {string} val A text string ("true" or "false") that can be converted to a boolean.
   * @returns {boolean} true or false
   */
  stringUtils.toBoolean = function capitalize(val) {
    var num = +val;
    return !isNaN(num) ? !!num : !!String(val).toLowerCase().replace(!!0, '');
  };

  /**
   * Return the width in pixels, assuming fontsize 14 as a default
   * @param  {string} text A text string to measure.
   * @param  {string} fontsize The elements font size (defaults to 14)
   * @returns {number} The text width.
   */
  stringUtils.textWidth = function capitalize(text) {
    var fontsize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 14;

    this.canvas = this.canvas || (this.canvas = document.createElement('canvas'));
    var context = this.canvas.getContext('2d');
    context.font = fontsize + 'px arial';

    var metrics = context.measureText(text);
    return Math.round(metrics.width);
  };

  /**
   * Pad a date into a string with zeros added.
   * @private
   * @param {number} year The year to use.
   * @param {number} month The month to use.
   * @param {number} day The day to use.
   * @returns {void}
   */
  stringUtils.padDate = function padDate(year, month, day) {
    return year + ('0' + (month + 1)).slice(-2) + ('0' + day).slice(-2);
  };

  /**
   * Calculate the width for given text string.
   * @private
   * @param {string} text string to process
   * @param {number} padding value for left + right
   * @param {string} font size and family used with the given text string
   * @returns {number} calculated width
   */
  stringUtils.textWidth = function textWidth(text, padding, font) {
    this.canvasTW = this.canvasTW || (this.canvasTW = document.createElement('canvas'));
    var context = this.canvasTW.getContext('2d');
    context.font = font || '14px arial';

    var metrics = context.measureText(text);
    return Math.round(metrics.width + (padding || 0));
  };

  /**
   * Escape  user input to be treated as literal string with regular expressions
   * @private
   * @param {string} s string to process.
   * @returns {string} string after escaping.
   */
  stringUtils.escapeRegExp = function escapeRegExp(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& whole matched string
  };
   //eslint-disable-line

  /* eslint-disable no-nested-ternary, no-useless-escape */

  // If `SohoConfig` exists with a `culturesPath` property, use that path for retrieving
  // culture files. This allows manually setting the directory for the culture files.
  var existingCulturePath = '';
  if (_typeof(window.SohoConfig) === 'object' && typeof window.SohoConfig.culturesPath === 'string') {
    existingCulturePath = window.SohoConfig.culturesPath;
  }

  /**
  * The Locale component handles i18n
  * Data From: http://www.unicode.org/repos/cldr-aux/json/22.1/main/
  * For Docs See: http://ibm.co/1nXyNxp
  * @class Locale
  * @constructor
  *
  * @param {string} currentLocale  The Currently Set Locale
  * @param {object} cultures  Contains all currently-stored cultures.
  * @param {string} culturesPath  the web-server's path to culture files.
  */
  var Locale = { // eslint-disable-line

    currentLocale: { name: '', data: {} }, // default
    cultures: {},
    culturesPath: existingCulturePath,

    /**
     * Sets the current language in the Html Header
     * @private
     * @returns {void}
     */
    updateLang: function updateLang() {
      var html = $('html');

      html.attr('lang', this.currentLocale.name);
      if (this.isRTL()) {
        html.attr('dir', 'rtl');
      } else {
        html.removeAttr('dir');
      }

      // ICONS: Right to Left Direction
      if (this.isRTL()) {
        Locale.flipIconsHorizontally();
      }
      $('body').removeClass('busy-loading-locale');
    },


    /**
     * Get the path to the directory with the cultures
     * @private
     * @returns {string} path containing culture files.
     */
    getCulturesPath: function getCulturesPath() {
      if (!this.culturesPath) {
        var scripts = document.getElementsByTagName('script');
        var partialPathMin = 'sohoxi.min.js';
        var partialPath = 'sohoxi.js';

        for (var i = 0; i < scripts.length; i++) {
          var src = scripts[i].src;

          // remove from ? to end
          var idx = src.indexOf('?');
          if (src !== '' && idx > -1) {
            src = src.substr(0, idx);
          }

          if (scripts[i].id === 'sohoxi-script') {
            return src.substring(0, src.lastIndexOf('/')) + '/';
          }

          if (src.indexOf(partialPathMin) > -1) {
            this.culturesPath = src.replace(partialPathMin, '') + 'cultures/';
          }
          if (src.indexOf(partialPath) > -1) {
            this.culturesPath = src.replace(partialPath, '') + 'cultures/';
          }
        }
      }
      return this.culturesPath;
    },


    /**
     * Checks if the culture is set as an inline script in the head tag.
     * @private
     * @returns {boolean} whether or not a culture file exists in the document header.
     */
    cultureInHead: function cultureInHead() {
      var isThere = false;
      var scripts = document.getElementsByTagName('script');
      var partialPath = 'cultures';

      for (var i = 0; i < scripts.length; i++) {
        var src = scripts[i].src;

        if (src.indexOf(partialPath) > -1) {
          isThere = true;
        }
      }

      return isThere;
    },


    /**
     * Internally stores a new culture file for future use.
     * @private
     * @param {string} locale The locale to check.
     * @returns {string} The actual locale to use.
     */
    defaultLocale: function defaultLocale(locale) {
      var lang = locale.split('-')[0];
      var defaults$$1 = [{ lang: 'af', default: 'af-ZA' }, { lang: 'ar', default: 'af-EG' }, { lang: 'bg', default: 'bg-BG' }, { lang: 'cs', default: 'cs-CZ' }, { lang: 'de', default: 'de-DE' }, { lang: 'el', default: 'el-GR' }, { lang: 'en', default: 'en-US' }, { lang: 'es', default: 'es-ES' }, { lang: 'et', default: 'et-ET' }, { lang: 'fi', default: 'fi-FI' }, { lang: 'fr', default: 'fr-FR' }, { lang: 'he', default: 'he-IL' }, { lang: 'hi', default: 'hi-IN' }, { lang: 'hr', default: 'hr-HR' }, { lang: 'hu', default: 'hu-HU' }, { lang: 'id', default: 'id-ID' }, { lang: 'it', default: 'it-IT' }, { lang: 'iw', default: 'he-IL' }, { lang: 'ja', default: 'ja-JP' }, { lang: 'ko', default: 'ko-KR' }, { lang: 'lt', default: 'lt-LT' }, { lang: 'ms', default: 'ms-bn' }, { lang: 'nb', default: 'nb-NO' }, { lang: 'nl', default: 'nl-NL' }, { lang: 'no', default: 'no-NO' }, { lang: 'pl', default: 'pl-PL' }, { lang: 'pt', default: 'pt-PT' }, { lang: 'ro', default: 'ro-RO' }, { lang: 'ru', default: 'ru-RU' }, { lang: 'sl', default: 'sl-SI' }, { lang: 'sv', default: 'sv-SE' }, { lang: 'th', default: 'th-TH' }, { lang: 'tr', default: 'tr-TR' }, { lang: 'uk', default: 'uk-UA' }, { lang: 'vi', default: 'vi-VN' }, { lang: 'zh', default: 'zh-CN' }];
      var allLocales = ['af-ZA', 'ar-EG', 'ar-SA', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-AU', 'en-GB', 'en-IN', 'en-NZ', 'en-US', 'en-ZA', 'es-AR', 'es-ES', 'es-MX', 'es-US', 'et-EE', 'fi-FI', 'fr-CA', 'fr-FR', 'he-IL', 'hi-IN', 'hr-HR', 'hu-HU', 'id-ID', 'it-IT', 'ja-JP', 'ko-KR', 'lt-LT', 'lv-LV', 'ms-bn', 'ms-my', 'nb-NO', 'nl-NL', 'no-NO', 'pl-PL', 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN', 'zh-Hans', 'zh-Hant', 'zh-TW'];

      if (allLocales.indexOf(locale) === -1) {
        locale = defaults$$1.filter(function (a) {
          return a.lang === lang;
        });

        if (locale && locale[0]) {
          return locale[0].default;
        }
        return '';
      }
      return locale;
    },


    /**
     * Internally stores a new culture file for future use.
     * @param {string} locale the 4-character Locale ID
     * @param {object} data translation data and locale-specific functions, such as calendars.
     * @returns {void}
     */
    addCulture: function addCulture(locale, data) {
      this.cultures[locale] = data;
    },


    /**
     * Append the local script to the page.
     * @private
     * @param {string} locale The locale name to append.
     * @param {boolean} isCurrent If we should set this as the current locale
     * @returns {void}
     */
    appendLocaleScript: function appendLocaleScript(locale, isCurrent) {
      var _this = this;

      var script = document.createElement('script');
      script.src = this.getCulturesPath() + locale + '.js';

      script.onload = function () {
        if (isCurrent) {
          _this.setCurrentLocale(locale, _this.cultures[locale]);
        }
        _this.addCulture(locale, _this.currentLocale.data);

        if (isCurrent) {
          _this.dff.resolve(_this.currentLocale.name);
        }
      };

      script.onerror = function () {
        _this.dff.reject();
      };

      if (_typeof(window.SohoConfig) === 'object' && typeof window.SohoConfig.nonce === 'string') {
        script.setAttribute('nonce', window.SohoConfig.nonce);
      }

      document.head.appendChild(script);
    },


    /**
     * Sets the current locale.
     * @param {string} locale The locale to fetch and set.
     * @returns {jquery.deferred} which is resolved once the locale culture is retrieved and set
     */
    set: function set$$1(locale) {
      var self = this;
      this.dff = $.Deferred();

      // Map incorrect java locale to correct locale
      if (locale === 'in-ID') {
        locale = 'id-ID';
      }

      if (locale.substr(0, 2) === 'iw') {
        locale = 'he-IL';
      }

      locale = this.defaultLocale(locale);

      if (locale === '') {
        self.dff.resolve();
        return this.dff.promise();
      }

      if (locale && locale !== 'en-US' && !this.cultures['en-US']) {
        this.appendLocaleScript('en-US', false);
      }

      if (locale && !this.cultures[locale] && this.currentLocale.name !== locale) {
        this.setCurrentLocale(locale);
        // Fetch the local and cache it
        this.appendLocaleScript(locale, true);
      }

      if (locale && self.currentLocale.data && self.currentLocale.dataName === locale) {
        self.dff.resolve(self.currentLocale.name);
      }

      self.setCurrentLocale(locale, self.cultures[locale]);

      if (self.cultures[locale] && this.cultureInHead()) {
        self.dff.resolve(self.currentLocale.name);
      }

      return this.dff.promise();
    },


    /**
     * Chooses a stored locale dataset and sets it as "current"
     * @private
     * @param {string} name the 4-character Locale ID
     * @param {object} data translation data and locale-specific functions, such as calendars.
     * @returns {void}
     */
    setCurrentLocale: function setCurrentLocale(name, data) {
      this.currentLocale.name = name;

      if (data) {
        this.currentLocale.data = data;
        this.currentLocale.dataName = name;
        this.updateLang();
      }
    },


    /**
    * Formats a date object and returns it parsed back using the current locale or settings.
    * @param {date} value The date to show in the current locale.
    * @param {object} attribs additional formatting settings.
    * @returns {string} the formatted date.
    */
    formatDate: function formatDate(value, attribs) {
      // We will use http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
      if (!attribs) {
        attribs = { date: 'short' }; // can be date, time, datetime or pattern
      }

      if (!value) {
        return undefined;
      }

      // Convert if a timezone string.
      if (!(value instanceof Date) && typeof value === 'string' && value.indexOf('Z') > -1) {
        var tDate1 = new Date(value);
        value = tDate1;
      }

      if (!(value instanceof Date) && typeof value === 'string' && value.indexOf('T') > -1) {
        var _tDate = new Date(value);
        value = _tDate;
      }

      // Convert if a string..
      if (!(value instanceof Date) && typeof value === 'string') {
        var tDate2 = Locale.parseDate(value, attribs);
        if (isNaN(tDate2) && attribs.date === 'datetime' && value.substr(4, 1) === '-' && value.substr(7, 1) === '-') {
          tDate2 = new Date(value.substr(0, 4), value.substr(5, 2) - 1, value.substr(8, 2), value.substr(11, 2), value.substr(14, 2), value.substr(17, 2));
        }
        value = tDate2;
      }

      if (!(value instanceof Date) && typeof value === 'number') {
        var tDate3 = new Date(value);
        value = tDate3;
      }

      if (!value) {
        return undefined;
      }

      // TODO: Can we handle this if (this.dff.state()==='pending')
      var data = this.currentLocale.data;
      var pattern = void 0;
      var ret = '';
      var cal = data.calendars ? data.calendars[0] : null;

      if (attribs.pattern) {
        pattern = attribs.pattern;
      }

      if (attribs.date) {
        pattern = cal.dateFormat[attribs.date];
      }

      var day = value.getDate();
      var month = value.getMonth();
      var year = value.getFullYear();
      var mins = value.getMinutes();
      var hours = value.getHours();
      var seconds = value.getSeconds();

      if (cal && cal.conversions) {
        if (attribs.fromGregorian) {
          var islamicParts = cal.conversions.fromGregorian(value);
          day = islamicParts[2];
          month = islamicParts[1];
          year = islamicParts[0];
        } else if (attribs.toGregorian) {
          var gregorianDate = cal.conversions.toGregorian(year, month, day);
          day = gregorianDate.getDate();
          month = gregorianDate.getMonth();
          year = gregorianDate.getFullYear();
        }
      }

      // Special
      pattern = pattern.replace('ngày', 'nnnn');
      pattern = pattern.replace('tháng', 't1áng');
      pattern = pattern.replace('den', 'nnn');

      // Day of Month
      ret = pattern.replace('dd', this.pad(day, 2));
      ret = ret.replace('d', day);

      // years
      ret = ret.replace('yyyy', year);
      ret = ret.replace('yy', year.toString().substr(2));
      ret = ret.replace('y', year);

      // Time
      var showDayPeriods = ret.indexOf(' a') > -1;

      if (showDayPeriods && hours === 0) {
        ret = ret.replace('hh', 12);
        ret = ret.replace('h', 12);
      }

      ret = ret.replace('hh', hours > 12 ? this.pad(hours - 12, 2) : this.pad(hours, 2));
      ret = ret.replace('h', hours > 12 ? hours - 12 : hours);
      ret = ret.replace('HH', this.pad(hours, 2));
      ret = ret.replace('H', hours);
      ret = ret.replace('mm', this.pad(mins, 2));
      ret = ret.replace('ss', this.pad(seconds, 2));
      ret = ret.replace('SSS', this.pad(value.getMilliseconds(), 0));

      // months
      ret = ret.replace('MMMM', cal ? cal.months.wide[month] : null); // full
      ret = ret.replace('MMM', cal ? cal.months.abbreviated[month] : null); // abreviation
      if (pattern.indexOf('MMM') === -1) {
        ret = ret.replace('MM', this.pad(month + 1, 2)); // number padded
        ret = ret.replace('M', month + 1); // number unpadded
      }

      // PM
      if (cal) {
        ret = ret.replace(' a', ' ' + (hours >= 12 ? cal.dayPeriods[1] : cal.dayPeriods[0]));
        ret = ret.replace('EEEE', cal.days.wide[value.getDay()]); // Day of Week
      }

      // Day of Week
      if (cal) {
        ret = ret.replace('EEEE', cal.days.wide[value.getDay()]); // Day of Week
      }
      ret = ret.replace('nnnn', 'ngày');
      ret = ret.replace('t1áng', 'tháng');
      ret = ret.replace('nnn', 'den');

      return ret.trim();
    },


    /**
    * Formats a Date Object and return it in UTC format
    * @param {date} date The date to show in the current locale.
    * @returns {date} the utc date
    */
    dateToUTC: function dateToUTC(date) {
      return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
    },


    /**
     * Check if the date is valid using the current locale to do so.
     * @param {date} date  The date to show in the current locale.
     * @returns {boolean} whether or not the date is valid.
     */
    isValidDate: function isValidDate(date) {
      if (Object.prototype.toString.call(date) === '[object Date]') {
        // it is a date
        if (isNaN(date.getTime())) {
          // d.valueOf() could also work
          return false;
        }
        return true;
      }
      return false;
    },


    /**
     * Takes a formatted date string and parses back it into a date object
     * @param {string} dateString  The string to parse in the current format
     * @param {string} dateFormat  The source format fx yyyy-MM-dd
     * @param {boolean} isStrict  If true missing date parts will be considered
     *  invalid. If false the current month/day.
     * @returns {date|undefined} updated date object, or nothing
     */
    parseDate: function parseDate(dateString, dateFormat, isStrict) {
      var thisLocaleCalendar = this.calendar();
      var orgDatestring = dateString;

      if (!dateString) {
        return undefined;
      }

      if (!dateFormat) {
        dateFormat = this.calendar().dateFormat.short;
      }

      if (dateFormat.pattern) {
        dateFormat = dateFormat.pattern;
      }

      if ((typeof dateFormat === 'undefined' ? 'undefined' : _typeof(dateFormat)) === 'object' && dateFormat.date) {
        dateFormat = this.calendar().dateFormat[dateFormat.date];
      }

      var formatParts = void 0;
      var dateStringParts = void 0;
      var dateObj = {};
      var isDateTime = dateFormat.toLowerCase().indexOf('h') > -1;
      var isUTC = dateString.toLowerCase().indexOf('z') > -1;
      var i = void 0;
      var l = void 0;

      if (isDateTime) {
        // replace [space & colon & dot] with "/"
        dateFormat = dateFormat.replace(/[T\s:.-]/g, '/').replace(/z/i, '');
        dateString = dateString.replace(/[T\s:.-]/g, '/').replace(/z/i, '');
      }

      if (dateFormat === 'Mdyyyy' || dateFormat === 'dMyyyy') {
        dateString = dateString.substr(0, dateString.length - 4) + '/' + dateString.substr(dateString.length - 4, dateString.length);
        dateString = dateString.substr(0, dateString.indexOf('/') / 2) + '/' + dateString.substr(dateString.indexOf('/') / 2);
      }

      if (dateFormat === 'Mdyyyy') {
        dateFormat = 'M/d/yyyy';
      }

      if (dateFormat === 'dMyyyy') {
        dateFormat = 'd/M/yyyy';
      }

      if (dateFormat.indexOf(' ') !== -1) {
        dateFormat = dateFormat.replace(/[\s:.]/g, '/');
        dateString = dateString.replace(/[\s:.]/g, '/');
      }

      // Extra Check incase month has spaces
      if (dateFormat.indexOf('MMMM') > -1 && Locale.isRTL() && dateFormat) {
        var lastIdx = dateString.lastIndexOf('/');
        dateString = dateString.substr(0, lastIdx - 1).replace('/', ' ') + dateString.substr(lastIdx);
      }

      if (dateFormat.indexOf(' ') === -1 && dateFormat.indexOf('.') === -1 && dateFormat.indexOf('/') === -1 && dateFormat.indexOf('-') === -1) {
        // Remove delimeter for the data string.
        if (dateString.indexOf(' ') !== -1) {
          dateString = dateString.split(' ').join('');
        } else if (dateString.indexOf('.') !== -1) {
          dateString = dateString.split('.').join('');
        } else if (dateString.indexOf('/') !== -1) {
          dateString = dateString.split('/').join('');
        } else if (dateString.indexOf('-') !== -1) {
          dateString = dateString.split('-').join('');
        }

        var lastChar = dateFormat[0];
        var newFormat = '';
        var newDateString = '';

        for (i = 0, l = dateFormat.length; i < l; i++) {
          newDateString += dateFormat[i] !== lastChar ? '/' + dateString[i] : dateString[i];
          newFormat += dateFormat[i] !== lastChar ? '/' + dateFormat[i] : dateFormat[i];

          if (i > 1) {
            lastChar = dateFormat[i];
          }
        }

        dateString = newDateString;
        dateFormat = newFormat;
      }

      formatParts = dateFormat.split('/');
      dateStringParts = dateString.split('/');

      if (formatParts.length === 1) {
        formatParts = dateFormat.split('.');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split('.');
      }

      if (formatParts.length === 1) {
        formatParts = dateFormat.split('-');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split('-');
      }

      if (formatParts.length === 1) {
        formatParts = dateFormat.split(' ');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split(' ');
      }

      // Check the incoming date string's parts to make sure the values are
      // valid against the localized Date pattern.
      var month = this.getDatePart(formatParts, dateStringParts, 'M', 'MM', 'MMM');
      var year = this.getDatePart(formatParts, dateStringParts, 'yy', 'yyyy');
      var hasDays = false;

      for (i = 0, l = dateStringParts.length; i < l; i++) {
        var pattern = '' + formatParts[i];
        var value = dateStringParts[i];
        var numberValue = parseInt(value, 10);

        if (!hasDays) {
          hasDays = pattern.toLowerCase().indexOf('d') > -1;
        }

        var lastDay = void 0;
        var abrMonth = void 0;
        var textMonths = void 0;

        switch (pattern) {
          case 'd':
            lastDay = new Date(year, month, 0).getDate();

            if (numberValue < 1 || numberValue > 31 || numberValue > lastDay) {
              return undefined;
            }
            dateObj.day = value;
            break;
          case 'dd':
            if (numberValue < 1 || numberValue > 31 || numberValue < 10 && value.substr(0, 1) !== '0') {
              return undefined;
            }
            dateObj.day = value;
            break;
          case 'M':
            if (numberValue < 1 || numberValue > 12) {
              return undefined;
            }
            dateObj.month = value - 1;
            break;
          case 'MM':
            if (numberValue < 1 || numberValue > 12 || numberValue < 10 && value.substr(0, 1) !== '0') {
              return undefined;
            }
            dateObj.month = value - 1;
            break;
          case 'MMM':
            abrMonth = this.calendar().months.abbreviated;

            for (var len = 0; len < abrMonth.length; len++) {
              if (orgDatestring.indexOf(abrMonth[len]) > -1) {
                dateObj.month = len;
              }
            }

            break;
          case 'MMMM':
            textMonths = this.calendar().months.wide;

            for (var k = 0; k < textMonths.length; k++) {
              if (orgDatestring.indexOf(textMonths[k]) > -1) {
                dateObj.month = k;
              }
            }

            break;
          case 'yy':
            dateObj.year = this.twoToFourDigitYear(value);
            break;
          case 'yyyy':
            dateObj.year = value.length === 2 ? this.twoToFourDigitYear(value) : value;
            break;
          case 'h':
            if (numberValue < 0 || numberValue > 12) {
              return undefined;
            }
            dateObj.h = value;
            break;
          case 'hh':
            if (numberValue < 0 || numberValue > 12) {
              return undefined;
            }
            dateObj.h = value.length === 1 ? '0' + value : value;
            break;
          case 'H':
            if (numberValue < 0 || numberValue > 24) {
              return undefined;
            }
            dateObj.h = value;
            break;
          case 'HH':
            if (numberValue < 0 || numberValue > 24) {
              return undefined;
            }
            dateObj.h = value.length === 1 ? '0' + value : value;
            break;

          case 'ss':
            if (numberValue < 0 || numberValue > 60) {
              dateObj.ss = 0;
              break;
            }
            dateObj.ss = value;
            break;

          case 'SSS':
            dateObj.ms = value;
            break;

          case 'mm':
            if (numberValue < 0 || numberValue > 60) {
              dateObj.mm = 0;
              break;
            }
            dateObj.mm = value;
            break;

          case 'a':
            if (value.toLowerCase() === thisLocaleCalendar.dayPeriods[0] || value.toUpperCase() === thisLocaleCalendar.dayPeriods[0]) {
              dateObj.a = 'AM';

              if (dateObj.h) {
                if (dateObj.h === 12 || dateObj.h === '12') {
                  dateObj.h = 0;
                }
              }
            }

            if (value.toLowerCase() === thisLocaleCalendar.dayPeriods[1] || value.toUpperCase() === thisLocaleCalendar.dayPeriods[1]) {
              dateObj.a = 'PM';

              if (dateObj.h) {
                if (dateObj.h < 12) {
                  dateObj.h = parseInt(dateObj.h, 10) + 12;
                }
              }
            }
            break;
          default:
            break;
        }
      }

      dateObj.return = undefined;
      dateObj.leapYear = dateObj.year % 4 === 0 && dateObj.year % 100 !== 0 || dateObj.year % 400 === 0;

      if (isDateTime && !dateObj.h && !dateObj.mm) {
        return undefined;
      }

      if (!dateObj.year && dateObj.year !== 0 && !isStrict) {
        dateObj.isUndefindedYear = true;
        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('y') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedYear = false;
            break;
          }
        }
        if (dateObj.isUndefindedYear) {
          dateObj.year = new Date().getFullYear();
        } else {
          delete dateObj.year;
        }
      }

      // Fix incomelete 2 and 3 digit years
      if (dateObj.year && dateObj.year.length === 2) {
        dateObj.year = '20' + dateObj.year;
      }

      // TODO: Need to find solution for three digit year
      // http://jira/browse/SOHO-4691
      // if (dateObj.year && dateObj.year.length === 3) {
      //   dateObj.year = '2' + dateObj.year;
      // }

      dateObj.year = $.trim(dateObj.year);
      dateObj.day = $.trim(dateObj.day);

      if (dateObj.year === '' || dateObj.year && !(('' + dateObj.year).length === 2 || ('' + dateObj.year).length === 4)) {
        delete dateObj.year;
      }

      if (!dateObj.month && dateObj.month !== 0 && !isStrict) {
        dateObj.isUndefindedMonth = true;
        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('M') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedMonth = false;
            break;
          }
        }
        if (dateObj.isUndefindedMonth) {
          dateObj.month = new Date().getMonth();
        }
      }

      if (!dateObj.day && dateObj.day !== 0 && (!isStrict || !hasDays)) {
        dateObj.isUndefindedDay = true;
        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('d') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedDay = false;
            break;
          }
        }
        if (dateObj.isUndefindedDay) {
          dateObj.day = 1;
        } else {
          delete dateObj.day;
        }
      }

      if (isDateTime) {
        if (isUTC) {
          if (dateObj.h !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm)); //eslint-disable-line
          }
          if (dateObj.ss !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss)); //eslint-disable-line
          }
          if (dateObj.ms !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss, dateObj.ms)); //eslint-disable-line
          }
        } else {
          if (dateObj.h !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm); //eslint-disable-line
          }
          if (dateObj.ss !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss); //eslint-disable-line
          }
          if (dateObj.ms !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss, dateObj.ms); //eslint-disable-line
          }
        }
      } else {
        dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day);
      }

      return this.isValidDate(dateObj.return) ? dateObj.return : undefined;
    },
    twoToFourDigitYear: function twoToFourDigitYear(twoDigitYear) {
      return parseInt((twoDigitYear > 39 ? '19' : '20') + twoDigitYear, 10);
    },
    getDatePart: function getDatePart(formatParts, dateStringParts, filter1, filter2, filter3) {
      var ret = 0;

      $.each(dateStringParts, function (i) {
        if (filter1 === formatParts[i] || filter2 === formatParts[i] || filter3 === formatParts[i]) {
          ret = dateStringParts[i];
        }
      });

      return ret;
    },


    /**
    * Formats a decimal with thousands and padding in the current locale or settings.
    * @param {number} number The source number.
    * @param {object} options additional options (see Number Format Patterns)
    * @returns {string} the formatted number.
    */
    formatNumber: function formatNumber(number, options) {
      // Lookup , decimals, decimalSep, thousandsSep
      var formattedNum = void 0;
      var curFormat = void 0;
      var percentFormat = void 0;
      var decimal = options && options.decimal ? options.decimal : this.numbers().decimal;
      var group = options && options.group !== undefined ? options.group : this.numbers().group;
      var minimumFractionDigits = options && options.minimumFractionDigits !== undefined ? options.minimumFractionDigits : options && options.style && options.style === 'currency' ? 2 : options && options.style && options.style === 'percent' ? 0 : 2;
      var maximumFractionDigits = options && options.maximumFractionDigits !== undefined ? options.maximumFractionDigits : options && options.style && (options.style === 'currency' || options.style === 'percent') ? 2 : options && options.minimumFractionDigits ? options.minimumFractionDigits : 3;

      if (number === undefined || number === null || number === '') {
        return undefined;
      }

      if (options && options.style === 'integer') {
        maximumFractionDigits = 0;
        minimumFractionDigits = 0;
      }

      if (options && options.style === 'currency') {
        var sign = options && options.currencySign ? options.currencySign : this.currentLocale.data.currencySign;
        var format = options && options.currencyFormat ? options.currencyFormat : this.currentLocale.data.currencyFormat;

        if (!format) {
          format = '¤#,##0.00'; // default to en-us
        }
        curFormat = format.replace('¤', sign);
      }

      if (options && options.style === 'percent') {
        var percentSign = !this.currentLocale.data.numbers ? '%' : this.currentLocale.data.numbers.percentSign;

        percentFormat = !this.currentLocale.data.numbers ? '#,##0 %' : this.currentLocale.data.numbers.percentFormat;
        percentFormat = percentFormat.replace('¤', percentSign);
      }

      if (typeof number === 'string') {
        if (decimal !== '.') {
          number = number.replace(decimal, '.');
        }
        number = Locale.parseNumber(number);
      }

      if (options && options.style === 'percent') {
        // the toFixed for maximumFractionDigits + 1 means we won't loose any precision
        number = (number * 100).toFixed(minimumFractionDigits);
      }

      var parts = this.truncateDecimals(number, minimumFractionDigits, maximumFractionDigits, options && options.round).split('.');
      parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, group);
      formattedNum = parts.join(decimal);

      // Position the negative at the front - There is no CLDR info for this.
      var minusSign = this.currentLocale.data && this.currentLocale.data.numbers && this.currentLocale.data.numbers.minusSign ? this.currentLocale.data.numbers.minusSign : '-';
      var isNegative = formattedNum.indexOf(minusSign) > -1;
      formattedNum = formattedNum.replace(minusSign, '');

      if (minimumFractionDigits === 0) {
        // Not default
        formattedNum = formattedNum.replace(/(\.[0-9]*?)0+$/, '$1'); // remove trailing zeros
        formattedNum = formattedNum.replace(/\.$/, ''); // remove trailing dot
      }

      if (minimumFractionDigits === 0 && decimal !== '.') {
        // Not default
        formattedNum = formattedNum.replace(/(\,[0-9]*?)0+$/, '$1'); // remove trailing zeros
        formattedNum = formattedNum.replace(/\,$/, ''); // remove trailing dot
      }

      if (minimumFractionDigits > 0) {
        var expr = new RegExp('(\\..{' + minimumFractionDigits + '}[0-9]*?)0+$');
        formattedNum = formattedNum.replace(expr, '$1'); // remove trailing zeros
        formattedNum = formattedNum.replace(/\.$/, ''); // remove trailing dot
      }

      // Confirm Logic After All Locales are added.
      if (options && options.style === 'currency') {
        formattedNum = curFormat.replace('#,##0.00', formattedNum);
        formattedNum = formattedNum.replace('#,##0.00', formattedNum);
      }

      if (options && options.style === 'percent') {
        formattedNum = percentFormat.replace('#,##0', formattedNum);
        formattedNum = formattedNum.replace('#.##0', formattedNum);
      }

      if (isNegative) {
        formattedNum = minusSign + formattedNum;
      }
      return formattedNum;
    },
    decimalPlaces: function decimalPlaces(number) {
      if (Math.floor(number) === number) {
        return 0;
      }

      if (number.toString().indexOf('.') === -1) {
        return 0;
      }
      return number.toString().split('.')[1].length || 0;
    },
    truncateDecimals: function truncateDecimals(number, minDigits, maxDigits, round) {
      var multiplier = Math.pow(10, maxDigits);
      var adjustedNum = number * multiplier;
      var truncatedNum = void 0;

      // Round Decimals
      var decimals = this.decimalPlaces(number);

      // Handle larger numbers
      if (number.toString().length - decimals - 1 >= 10 || decimals === minDigits && decimals === maxDigits || decimals < maxDigits) {
        multiplier = Math.pow(100, maxDigits);
        adjustedNum = number * multiplier;
      }

      truncatedNum = Math[adjustedNum < 0 ? 'ceil' : 'floor'](adjustedNum);

      if (round && decimals >= maxDigits && adjustedNum > 0) {
        truncatedNum = Math.round(adjustedNum);
      }

      if (round && decimals <= maxDigits && decimals > 0) {
        truncatedNum = Math.round(adjustedNum);
      }

      if (decimals < maxDigits && decimals > 0) {
        truncatedNum = Math.floor(adjustedNum);
        maxDigits = Math.max(decimals, minDigits);
      }

      return (truncatedNum / multiplier).toFixed(maxDigits);
    },


    /**
     * Takes a formatted number string and returns back real number object.
     * @param {string} input  The source number (as a string).
     * @returns {number} the number as an actual Number type.
     */
    parseNumber: function parseNumber(input) {
      var numSettings = this.currentLocale.data.numbers;
      var numString = void 0;

      numString = input;

      if (!numString) {
        return NaN;
      }

      if (typeof input === 'number') {
        numString = numString.toString();
      }

      var group = numSettings ? numSettings.group : ',';
      var decimal = numSettings ? numSettings.decimal : '.';
      var percentSign = numSettings ? numSettings.percentSign : '%';
      var currencySign = this.currentLocale.data.currencySign || '$';

      numString = numString.replace(new RegExp('\\' + group, 'g'), '');
      numString = numString.replace(decimal, '.');
      numString = numString.replace(percentSign, '');
      numString = numString.replace(currencySign, '');
      numString = numString.replace(' ', '');

      return parseFloat(numString);
    },


    /**
     * Takes a translation key and returns the translation in the current locale.
     * @param {string} key  The key to search for on the string.
     * @param {boolean} [showAsUndefined] causes a translated phrase to be
      instead of defaulting to the default locale's version of the string.
     * @returns {string|undefined} a translated string, or nothing, depending on configuration
     */
    translate: function translate(key, showAsUndefined) {
      if (this.currentLocale.data === undefined || this.currentLocale.data.messages === undefined) {
        return showAsUndefined ? undefined : '[' + key + ']';
      }

      if (this.currentLocale.data.messages[key] === undefined) {
        // Substitue English Expression if missing
        if (!this.cultures || !this.cultures['en-US'] || !this.cultures['en-US'].messages || this.cultures['en-US'].messages[key] === undefined) {
          return showAsUndefined ? undefined : '[' + key + ']';
        }
        return this.cultures['en-US'].messages[key].value;
      }

      return this.currentLocale.data.messages[key].value;
    },


    /**
     * Translate Day Period
     * @private
     * @param {string} period should be "am", "pm", "AM", "PM", or "i"
     * @returns {string} the translated day period.
     */
    translateDayPeriod: function translateDayPeriod(period) {
      if (/am|pm|AM|PM/i.test(period)) {
        var periods = this.calendar().dayPeriods || ['AM', 'PM'];
        return periods[/AM|am/i.test(period) ? 0 : 1];
      }
      return period;
    },


    /**
     * Shortcut function to get 'first' calendar
     * @private
     * @returns {object} containing calendar data.
     */
    calendar: function calendar() {
      if (this.currentLocale.data.calendars) {
        return this.currentLocale.data.calendars[0];
      }

      // Defaults to ISO 8601
      return {
        dateFormat: {
          separator: '/',
          timeSeparator: ':',
          short: 'M/d/yyyy',
          medium: 'MMM d, yyyy',
          long: 'MMMM d, yyyy',
          full: 'EEEE, MMMM d, y',
          month: 'MMMM d',
          year: 'MMMM yyyy',
          timestamp: 'h:mm:ss a',
          datetime: 'M/d/yyyy h:mm a'
        },
        timeFormat: 'HH:mm:ss',
        dayPeriods: ['AM', 'PM']
      };
    },


    /**
     * Access the calendar array
     * @private
     * @param {string} name the name of the calendar (fx: "gregorian", "islamic-umalqura")
     * @returns {object} containing calendar data
     */
    getCalendar: function getCalendar(name) {
      if (this.currentLocale.data.calendars) {
        for (var i = 0; i < this.currentLocale.data.calendars.length; i++) {
          var calendar = this.currentLocale.data.calendars[i];
          if (calendar.name === name) {
            return calendar;
          }
        }
      }

      // Defaults to ISO 8601
      return [{ dateFormat: 'yyyy-MM-dd', timeFormat: 'HH:mm:ss' }];
    },


    /**
     * Shortcut function to get numbers
     * @private
     * @returns {object} containing information for formatting numbers
     */
    numbers: function numbers() {
      return this.currentLocale.data.numbers ? this.currentLocale.data.numbers : {
        percentSign: '%',
        percentFormat: '#,##0 %',
        minusSign: '-',
        decimal: '.',
        group: ','
      };
    },


    /**
     * Padd a number to the given width and decimals
     * @private
     * @param {string} n the number
     * @param {number} width the decimal with
     * @param {string} z the padding character
     * @returns {string} the padded string
     */
    pad: function pad(n, width, z) {
      z = z || '0';
      n += '';
      return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
    },


    /**
     * Describes whether or not this locale is one that is read in "right-to-left" fashion.
     * @returns {boolean} whether or not this locale is "right-to-left".
     */
    isRTL: function isRTL() {
      return this.currentLocale.data.direction === 'right-to-left';
    },


    /**
     * Takes a string and converts its contents to upper case, taking into account
     * Locale-specific character conversions.  In most cases this method will simply
     * pipe the string to `String.prototype.toUpperCase()`.
     * @private
     * @param {string} str the incoming string
     * @returns {string} modified string
     */
    toUpperCase: function toUpperCase(str) {
      if (typeof this.currentLocale.data.toUpperCase === 'function') {
        return this.currentLocale.data.toUpperCase(str);
      }

      return str.toLocaleUpperCase();
    },


    /**
     * Takes a string and converts its contents to lower case, taking into account
     * Locale-specific character conversions. In most cases this method will simply
     * pipe the string to `String.prototype.toLowerCase()`
     * @private
     * @param {string} str - the incoming string
     * @returns {string} The localized string
     */
    toLowerCase: function toLowerCase(str) {
      if (typeof this.currentLocale.data.toLowerCase === 'function') {
        return this.currentLocale.data.toLowerCase(str);
      }

      return str.toString().toLocaleLowerCase();
    },


    /**
     * Takes a string and capitalizes the first letter, taking into account Locale-specific
     * character conversions. In most cases this method will simply use a simple algorithm
     * for captializing the first letter of the string.
     * @private
     * @param {string} str the incoming string
     * @returns {string} the modified string
     */
    capitalize: function capitalize(str) {
      return this.toUpperCase(str.charAt(0)) + str.slice(1);
    },


    /**
     * Takes a string and capitalizes the first letter of each word in a string, taking
     * into account Locale-specific character conversions. In most cases this method
     * will simply use a simple algorithm for captializing the first letter of the string.
     * @private
     * @param {string} str the incoming string
     * @returns {string} the modified string
     */
    capitalizeWords: function capitalizeWords(str) {
      var words = str.split(' ');

      for (var i = 0; i < words.length; i++) {
        words[i] = this.capitalize(words[i]);
      }

      return words.join(' ');
    },


    /**
     * Modifies a specified list of icons by flipping them horizontally to make them
     * compatible for RTL-based locales.
     * @private
     * @returns {void}
     */
    flipIconsHorizontally: function flipIconsHorizontally() {
      var icons = ['attach', 'bottom-aligned', 'bullet-list', 'cancel', 'cart', 'collapse-app-tray', 'cut', 'document', 'drilldown', 'duplicate', 'expand-app-tray', 'export', 'first-page', 'folder', 'import', 'last-page', 'launch', 'left-align', 'left-text-align', 'left-arrow', 'new-document', 'next-page', 'number-list', 'paste', 'previous-page', 'quote', 'redo', 'refresh', 'right-align', 'right-arrow', 'right-text-align', 'save', 'search-folder', 'search-list', 'search', 'send', 'tack', 'tree-collapse', 'tree-expand', 'undo', 'unlocked', 'add-grid-record', 'add-grid-row', 'additional-help', 'bubble', 'cascade', 'change-font', 'clear-screen', 'script', 'clockwise-90', 'close-cancel', 'close-save', 'contacts', 'copy-from', 'copy-mail', 'copy-url', 'counter-clockwise-90', 'create-report', 'delete-grid-record', 'delete-grid-row', 'display', 'employee-directory', 'export-2', 'export-to-pdf', 'generate-key', 'get-more-rows', 'group-selection', 'headphones', 'help', 'helper-list-select', 'history', 'invoice-released', 'language', 'logout', 'key', 'lasso', 'line-bar-chart', 'line-chart', 'new-expense-report', 'new-payment-request', 'new-time-sheet', 'new-travel-plan', 'no-attachment', 'no-comment', 'no-filter', 'overlay-line', 'pdf-file', 'phone', 'payment-request', 'pie-chart', 'queries', 'quick-access', 'refresh-current', 'restore-user', 'run-quick-access', 'save-close', 'save-new', 'search-results-history', 'select', 'send-submit', 'show-last-x-days', 'special-item', 'stacked', 'timesheet', 'unsubscribe', 'update-preview', 'zoom-100', 'zoom-in', 'zoom-out', 'caret-left', 'caret-right'];

      $('svg').each(function () {
        var iconName = $(this).getIconName();

        if (iconName && $.inArray(iconName, icons) !== -1 && $(this).closest('.monthview').length === 0) {
          $(this).addClass('icon-rtl-rotate');
        }
      });
    }
  };

  // Has to delay in order to check if no culture in head since scripts load async
  $(function () {
    setTimeout(function () {
      if (Locale && !Locale.cultureInHead() && !Locale.currentLocale.name) {
        Locale.set('en-US');
      }
    }, 50);
  });

  /**
   * Provides a global object that detects the existence of a Base Tag,
   * and provides some methods that can be used to get an accurate relative
   * URL using the base tag.
   * @class Base
   * @constructor
   * @param {HTMLElement} element the Base Tag Element
   * @returns {Base} component instance
   */
  function Base(element) {
    this.element = $(element);
    return this;
  }

  Base.prototype = {

    /**
     * @private
     * @returns {string} current page URL
     */
    get url() {
      return window.location.href.replace(window.location.hash, '');
    },

    /**
     * @private
     * @returns {string} the base tag's `href` attribute
     */
    get href() {
      return this.element[0].getAttribute('href');
    },

    /**
     * @private
     * @deprecated as of v4.12.x, use `this.url` instead
     * @returns {string} current page URL
     */
    getCurrentURL: function getCurrentURL() {
      return this.url;
    },


    /**
     * Gets a copy of a URL prepended with the contents of the Base Tag's hash.
     * If there's no base tag present, this simply returns the hash provided.
     * @param {string} hash the URL to be checked.
     * @returns {string} the current URL prepended with the Base Tag's ref, if necessary
     */
    getBaseURL: function getBaseURL(hash) {
      // If no valid base tag exists, just return the hash provided.
      if (!this.element.length || !this.href || this.href === '/') {
        if (!hash) {
          return '';
        }
        return hash;
      }

      if (hash) {
        if (hash.indexOf('/') === 0) {
          return hash;
        }

        hash = (hash.indexOf('#') === -1 ? '#' : '') + hash;
        return this.url + hash;
      }

      return this.url;
    }
  };

  // Setup a Base Tag Component instance
  var base = new Base($('base[href]'));

  /**
   * Setup a default function that just returns the contents of the hash,
   * if no base tag is present.
   * @param {string} hash the URL to be checked.
   * @returns {string} the current URL prepended with the Base Tag's ref, if necessary
   */
  $.getBaseURL = function (hash) {
    return base.getBaseURL(hash);
  };

  /**
   * Detect the Base tag and install a global object, if necessary.
   * Does nothing right now.
   * @deprecated as of v4.4.0
   */
  $.detectBaseTag = function () {};

  /**
   * Gets an accurate timestamp from
   * @private
   * @returns {number} a current timestamp
   */
  function timestamp() {
    return window.performance && window.performance.now ? window.performance.now() : new Date().getTime();
  }

  /**
   * RenderLoop Queue items
   * @param {object} opts options
   * @returns {this} RenderLoopItem
   */
  function RenderLoopItem(opts) {
    // Either ID or a duration is required
    this.id = opts.id;
    this.duration = opts.duration || -1;
    if (this.duration < 1 && (typeof this.id !== 'string' || !this.id.length)) {
      throw new Error('cannot build a RenderLoopItem with no duration and no namespace');
    }
    this.updateDuration = opts.updateDuration || 1;

    // functions
    this.setFuncs(opts);

    // internal state
    this.paused = false;
    this.elapsedTime = 0;
    this.startTime = timestamp();

    return this;
  }

  RenderLoopItem.prototype = {

    /**
     * @private
     * @param {object} opts incoming settings
     */
    setFuncs: function setFuncs(opts) {
      if (typeof opts.updateCallback !== 'function' && typeof opts.timeoutCallback !== 'function') {
        throw new Error('cannot register callback to RenderLoop because callback is not a function');
      }

      if (typeof opts.updateCallback === 'function') {
        this.updateCallback = opts.updateCallback;
      }

      if (typeof opts.timeoutCallback === 'function') {
        this.timeoutCallback = opts.timeoutCallback;
      }
    },
    pause: function pause() {
      this.paused = true;
    },
    resume: function resume() {
      this.paused = false;
    },


    /**
     * @param {boolean} noTimeout causes the item to be destroyed without triggering the `timeoutCallback` function
     */
    destroy: function destroy(noTimeout) {
      if (noTimeout) {
        this.noTimeout = true;
      }
      this.doRemoveOnNextTick = true;
    }
  };

  /**
   * Sets up a timed rendering loop that can be used for controlling animations
   * globally in an application that implements Soho.
   * @constructor
   */
  function RenderLoop() {
    this.items = [];
    this.element = $('body');

    return this;
  }

  RenderLoop.prototype = {

    /**
     * Start the entire render loop
     * @returns {void}
     */
    start: function start() {
      this.doLoop = true;
      this.startTime = timestamp();

      var self = this;
      var last = timestamp();
      var now = void 0;
      var deltaTime = void 0;

      function tick() {
        // Don't continue if the loop is stopped externally
        if (!self.doLoop) {
          return;
        }

        now = timestamp();
        deltaTime = (now - last) / 1000;

        // Iterate through each item stored in the queue and "update" each one.
        // In some cases, items will be removed from the queue automatically.
        // In some cases, `update` events will be triggered on loop items, if they are
        // ready to be externally updated.
        self.items.forEach(function (loopItem) {
          // Remove if we've set the `doRemoveOnNextTick` flag.
          if (loopItem.doRemoveOnNextTick) {
            self.remove(loopItem);
            return;
          }

          // Add to elapsedTime
          if (!loopItem.paused) {
            loopItem.elapsedTime++;
          }

          // Check duration
          if (typeof loopItem.duration === 'number' && loopItem.duration > -1) {
            if (!loopItem.startTime) {
              loopItem.startTime = now;
            }

            if (loopItem.elapsedTime >= loopItem.duration) {
              loopItem.destroy();
              return;
            }
          }

          // Call the updateCallback, if applicable.
          var modifiedArgs = void 0;
          if (typeof loopItem.updateCallback === 'function') {
            // If this item doesn't update on each tick, simply count down.
            // Otherwise, call the update function
            if (loopItem.updateDuration && loopItem.updateDuration > 1) {
              if (isNaN(loopItem.timeUntilNextUpdate)) {
                loopItem.timeUntilNextUpdate = loopItem.updateDuration;
              }

              if (loopItem.timeUntilNextUpdate > 0) {
                --loopItem.timeUntilNextUpdate;
                return;
              }
            }

            // Arguments produced for the updateCallback contain:
            // [0] the current RenderLoopItem
            // [1] overall timing values for the RenderLoop
            modifiedArgs = [loopItem, {
              last: last,
              delta: deltaTime,
              now: now
            }];

            loopItem.updateCallback.apply(null, modifiedArgs);
          }
        });

        // Continue the loop
        last = now;
        requestAnimationFrame(tick);
      }

      tick();
    },


    /**
     * Stops the entire render loop
     * @returns {void}
     */
    stop: function stop() {
      this.doLoop = false;
    },


    /**
     * @returns {number} amount of time that has passed since the RenderLoop was started.
     */
    totalDuration: function totalDuration() {
      return timestamp() - this.startTime;
    },


    /**
     * External method for getting the callback queue contents
     * @returns {array} list of internal RenderLoopItems
     */
    queue: function queue() {
      return this.items;
    },


    /**
     * @private
     * @param {function} updateCallback - (can also be the "updateCallback" function)
     * @param {function} [timeoutCallback] callback function that gets fired at
     *  the end of this item's lifecycle
     * @param {number} [duration] the amount of time in frames that this item should exist
     * @param {string} [namespace] the namespace for this item
     * @returns {RenderLoopItem} the item that was registered
     */
    buildRenderLoopItem: function buildRenderLoopItem(updateCallback, timeoutCallback, duration, namespace) {
      var noNamespace = typeof namespace !== 'string' || !namespace.length;

      // valid for a callback not to have a duration, as long as it's
      // namespaced for future manual removal
      if (typeof duration === 'string') {
        if (noNamespace) {
          namespace = duration;
          duration = -1;
          noNamespace = false;
        } else {
          var numberDuration = Number(duration);
          if (!isNaN(numberDuration)) {
            duration = numberDuration;
          }
        }
      } else if (typeof duration !== 'number') {
        duration = -1;
      }

      if (typeof namespace !== 'string' || !namespace.length) {
        namespace = ''; // TODO: make unique
      }

      var loopItem = new RenderLoopItem({
        id: namespace,
        updateCallback: updateCallback,
        timeoutCallback: timeoutCallback,
        duration: duration
      });

      return loopItem;
    },


    /**
     * @param {RenderLoopItem|function} loopItem - (can also be the "updateCallback" function)
     * @param {function} [timeoutCallback] callback function that gets fired at
     *  the end of this item's lifecycle
     * @param {number} [duration] the amount of time in frames that this item should exist
     * @param {string} [namespace] the namespace for this item
     * @returns {RenderLoopItem} the item that was registered
     */
    register: function register(loopItem, timeoutCallback, duration, namespace) {
      // If we're not working with a RenderLoopItem off the bat, take arguments
      // and convert to a RenderLoopItem.  Consider the first argument
      // to be the "updateCallback" function
      if (!(loopItem instanceof RenderLoopItem)) {
        loopItem = this.buildRenderLoopItem(loopItem, timeoutCallback, duration, namespace);
      }

      this.items.push(loopItem);

      return loopItem;
    },


    /**
     * @param {function} callback callback function to be unregistered
     * @param {string} [namespace] namespace to be unregistered
     * @returns {RenderLoopItem} the item that was unregistered
     */
    unregister: function unregister(callback, namespace) {
      if (typeof callback !== 'function' && typeof callback !== 'string' && typeof namespace !== 'string') {
        throw new Error('must provide either a callback function or a namespace string to remove an entry from the RenderLoop queue.');
      }

      // If callback is defined as a string, simply swap it for the namespace.
      if (typeof callback === 'string') {
        namespace = callback;
        callback = undefined;
      }

      return this.remove({
        cb: callback,
        id: namespace
      });
    },


    /**
     * @private
     * Uses a callback function, or a defined namespace, to grab a RenderLoop item from the queue.
     * @param {function} updateCallback callback function to be retrieved
     * @param {string} [namespace] namespace to be retrieved
     * @returns {RenderLoopItem} the RenderLoopItem that represents the item that was paused.
     */
    getFromQueue: function getFromQueue(updateCallback, namespace) {
      // If callback is defined as a string, simply swap it for the namespace.
      if (typeof callback === 'string') {
        namespace = updateCallback;
        updateCallback = undefined;
      }

      var retreivedItem = void 0;

      if (typeof callback === 'function') {
        // Remove by callback method
        this.items.forEach(function (item) {
          if ('' + item.updateCallback !== '' + updateCallback) {
            return true;
          }
          retreivedItem = item;
          return false;
        });
      } else if (typeof namespace === 'string') {
        // Remove by namespace
        this.items.forEach(function (item) {
          if (item.id !== namespace) {
            return true;
          }
          retreivedItem = item;
          return false;
        });
      }

      return retreivedItem;
    },


    /**
     * @private
     * Actually does the removal of a registered callback from the queue
     * Pulled out into its own function because it can be automatically called by
     * the tick, or manually triggered from an external API call.
     * @param {renderLoopItem|Object} obj the renderLoopItem
     * @returns {RenderLoopItem} reference to the removed renderLoopItem
     */
    remove: function remove(obj) {
      var removedItem = void 0;

      if (obj instanceof RenderLoopItem) {
        removedItem = obj;
        this.items = this.items.filter(function (item) {
          return item !== obj;
        });
      } else if (typeof obj.updateCallback === 'function') {
        // Remove by callback method
        this.items = this.items.filter(function (item) {
          if ('' + item.updateCallback !== '' + obj.updateCallback) {
            return true;
          }
          removedItem = item;
          return false;
        });
      } else if (typeof obj.id === 'string') {
        // Remove by namespace
        this.items = this.items.filter(function (item) {
          if (item.id !== obj.id) {
            return true;
          }
          removedItem = item;
          return false;
        });
      }

      if (typeof removedItem.timeoutCallback === 'function' && !removedItem.noTimeout) {
        removedItem.timeoutCallback.apply(null, removedItem);
      }

      this.element.triggerHandler('remove.renderLoop', [removedItem]);

      // If this is undefined, an item was NOT removed from the queue successfully.
      return removedItem;
    },


    /**
     * @param {function} callback callback function to be paused
     * @param {string} [namespace] namespace to be paused
     * @returns {RenderLoopItem} the RenderLoopItem that represents the item that was paused.
     */
    pause: function pause(callback, namespace) {
      if (typeof callback !== 'function' && typeof callback !== 'string' && typeof namespace !== 'string') {
        throw new Error('must provide either a callback function or a namespace string to pause an entry in the RenderLoop queue.');
      }

      var pausedItem = this.getFromQueue(callback, namespace);

      pausedItem.pause();

      return pausedItem;
    },


    /**
     * @param {function} callback callback function to be resumed
     * @param {string} [namespace] namespace to be resumed
     * @returns {RenderLoopItem} the RenderLoopItem that represents the item that was resumed.
     */
    resume: function resume(callback, namespace) {
      if (typeof callback !== 'function' && typeof callback !== 'string' && typeof namespace !== 'string') {
        throw new Error('must provide either a callback function or a namespace string to pause an entry in the RenderLoop queue.');
      }

      var resumableItem = this.getFromQueue(callback, namespace);

      resumableItem.resume();

      return resumableItem;
    }
  };

  // Setup a single instance of RenderLoop for export.
  var renderLoop = new RenderLoop();
  renderLoop.start();

  // Current "theme" string
  exports.theme = 'light'; //eslint-disable-line

  // Component name as referenced by jQuery/event namespace/etc
  var COMPONENT_NAME = 'personalize';

  // Component Defaults
  var PERSONALIZE_DEFAULTS = {
    colors: '',
    theme: exports.theme,
    font: ''
  };

  /**
   * The personalization routines for setting custom company colors.
   *
   * @class Personalize
   * @param {HTMLElement|jQuery[]} element the base element
   * @param {object} [settings] incoming settings
   * @param {string} [settings.colors]  The list of colors
   * @param {string} [settings.theme='light'] The theme name (light, dark or high-contrast)
   * @param {string} [settings.font='Helvetica'] Use the newer source sans font
  */
  function Personalize(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, PERSONALIZE_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Personalize.prototype = {

    /**
     * Runs on each initialization
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      this.availableThemes = ['light', 'dark', 'high-contrast'];

      // Set the default theme, or grab the theme from an external CSS stylesheet.
      var cssTheme = this.getThemeFromStylesheet();
      this.currentTheme = cssTheme || this.settings.theme;
      this.setTheme(this.currentTheme);

      if (this.settings.colors) {
        this.setColors(this.settings.colors);
      }

      if (this.settings.font) {
        $('html').addClass('font-' + this.settings.font);
      }

      this.handleEvents();

      return this;
    },


    /**
     * Sets up event handlers for this control and its sub-elements
     * @private
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.on('updated.' + COMPONENT_NAME, function () {
        self.updated();
      }).on('changecolors.' + COMPONENT_NAME, function (e, newColor, noAnimate) {
        self.setColors(newColor, noAnimate);
      }).on('changetheme.' + COMPONENT_NAME, function (e, thisTheme) {
        self.setTheme(thisTheme);
      });

      return this;
    },


    /**
     * Validates a string containing a hexadecimal number
     * @private
     * @param {string} hex A hex color.
     * @returns {string} a validated hexadecimal string.
     */
    validateHex: function validateHex(hex) {
      hex = String(hex).replace(/[^0-9a-f]/gi, '');

      if (hex.length < 6) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
      }

      return '#' + hex;
    },


    /**
     * Validates a string containing a hexadecimal number
     * @private
     * @param {object} cssRules The rules to append.
     */
    appendStyleSheet: function appendStyleSheet(cssRules) {
      var sheet = document.getElementById('soho-personalization');
      if (sheet) {
        sheet.parentNode.removeChild(sheet);
      }

      // Create the <style> tag
      sheet = document.createElement('style');
      sheet.setAttribute('id', 'soho-personalization');
      sheet.appendChild(document.createTextNode(cssRules));

      // Add the <style> element to the page
      document.head.appendChild(sheet);
    },


    /**
     * Generate a style sheet to append in the page.
     * @private
     * @param {array} colors The rules to append.
     * @returns {string} The string of css to append.
     */
    getColorStyleSheet: function getColorStyleSheet(colors) {
      if (!colors) {
        colors = {};
      }

      // Use an incoming `colors` param defined as a string, as the desired
      // "header" color (backwards compatibility)
      if (typeof colors === 'string') {
        colors = {
          header: colors
        };
      }

      if (!colors || colors === '') {
        return this;
      }

      // Default Colors...
      // (Color)07 for the main color (fx headers)
      // (Color)06 for the secondary color (fx sub-headers)
      // Light or Dark (fff or 000) for the contrast color

      // (Color)06 for the vertical borders between module tabs - 133C59
      // (Color)07 for the page header and active module tab - 2578A9 DEFAULT
      // (Color)08 for the inactive module tab - 1d5f8a
      // (Color)09 for the horizontal border - 134D71
      // (Color)10 for the hover state on module tab - 133C59
      var defaultColors = {
        header: '2578A9',
        subheader: '1d5f8a',
        text: 'ffffff',
        verticalBorder: '133C59',
        horizontalBorder: '134D71',
        inactive: '1d5f8a',
        hover: '133C59',
        btnColorHeader: '368AC0',
        btnColorSubheader: '54a1d3'
      };

      // If an event sends a blank string through instead of a hex,
      // reset any color values back to the theme defaults.  Otherwise, get a valid hex value.
      colors.header = this.validateHex(colors.header || defaultColors.header);
      colors.text = this.validateHex(colors.text || defaultColors.text);
      colors.subheader = this.validateHex(colors.subheader || this.getLuminousColorShade(colors.header, 0.2));
      colors.inactive = this.validateHex(colors.inactive || this.getLuminousColorShade(colors.header, -0.22));
      colors.verticalBorder = this.validateHex(colors.verticalBorder || this.getLuminousColorShade(colors.header, 0.1));
      colors.horizontalBorder = this.validateHex(colors.horizontalBorder || this.getLuminousColorShade(colors.header, -0.4));
      colors.hover = this.validateHex(colors.hover || this.getLuminousColorShade(colors.header, -0.5));
      colors.btnColorHeader = this.validateHex(colors.btnColorHeader || this.getLuminousColorShade(colors.subheader, -0.025));
      colors.btnColorSubheader = this.validateHex(colors.btnColorSubheader || this.getLuminousColorShade(colors.header, -0.025));

      // not that the sheet is appended in backwards
      var cssRules = '.tab-container.module-tabs.is-personalizable { border-top: 1px solid ' + colors.horizontalBorder + ' !important; border-bottom: 1px solid ' + colors.horizontalBorder + ' !important}' + (' .module-tabs.is-personalizable .tab:not(:first-child) { border-left: 1px solid ' + colors.verticalBorder + ' !important}') + (' .module-tabs.is-personalizable { background-color: ' + colors.inactive + ' !important}') + (' .module-tabs.is-personalizable .tab.is-selected { background-color: ' + colors.header + ' !important}') + (' .accordion.panel .accordion-header.is-selected { background-color: ' + colors.subheader + ' !important; color: ' + colors.text + ' !important}') + (' .builder-header.is-personalizable{ background-color: ' + colors.subheader + '}') + (' .header.is-personalizable { background-color: ' + colors.header + '}') + (' .header.is-personalizable .title { color: ' + colors.text + '}') + (' .header.is-personalizable h1 { color: ' + colors.text + '}') + (' .header.is-personalizable .go-button.is-personalizable { background-color: ' + colors.btnColorHeader + '; border-color:' + colors.btnColorHeader + ';color: ' + colors.text + '}') + (' .subheader.is-personalizable .go-button.is-personalizable { background-color: ' + colors.btnColorSubheader + '; border-color:' + colors.btnColorSubheader + ';color: ' + colors.text + '}') + (' .module-tabs.is-personalizable .tab-more { border-left: ' + colors.verticalBorder + ' !important}') + (' .module-tabs.is-personalizable .tab-more:hover { background-color: ' + colors.hover + ' !important}') + (' .module-tabs.is-personalizable .tab-more.is-open { background-color: ' + colors.hover + ' !important}') + (' .module-tabs.is-personalizable .tab-more.is-selected { background-color: ' + colors.header + ' !important}') + (' .header .toolbar > .toolbar-searchfield-wrapper.active .searchfield { background-color: ' + colors.hover + ' !important; border-bottom-color: ' + colors.hover + ' !important}') + (' .header .toolbar > .toolbar-searchfield-wrapper.active .searchfield-category-button { background-color: ' + colors.hover + ' !important; border-bottom-color: ' + colors.hover + ' !important}') + (' .subheader.is-personalizable { background-color: ' + colors.subheader + ' !important}') + (' .builder .sidebar .header {border-right: 1px solid ' + colors.hover + ' !important}') + (' .module-tabs.is-personalizable .tab:hover { background-color: ' + colors.hover + ' !important}') + (' .module-tabs.has-toolbar.is-personalizable .tab-list-container + .toolbar { border-left: ' + colors.verticalBorder + ' !important}') + (' .module-tabs.is-personalizable [class^="btn"] { background-color: ' + colors.inactive + ' !important; color: ' + colors.text + ' !important}') + (' .module-tabs.is-personalizable .tab.is-disabled { background-color: ' + colors.inactive + ' !important; color: ' + colors.text + ' !important}') + (' .module-tabs.is-personalizable .tab.is-disabled > svg { fill: ' + colors.text + ' !important}') + (' .module-tabs.is-personalizable .add-tab-button { border-left: ' + colors.verticalBorder + ' !important}') + (' .module-tabs.is-personalizable .add-tab-button:hover { background-color: ' + colors.inactive + ' !important}') + (' .module-tabs.is-personalizable .toolbar-searchfield-wrapper > .searchfield { color: ' + colors.text + ' !important}') + (' .module-tabs.is-personalizable .toolbar-searchfield-wrapper > svg { fill: ' + colors.text + ' !important}') + (' .hero-widget.is-personalizable { background-color: ' + colors.subheader + ' }') + (' .hero-widget.is-personalizable .hero-bottom { background-color: ' + colors.header + ' }') + (' .hero-widget.is-personalizable .hero-footer .hero-footer-nav li::before { color: ' + colors.verticalBorder + ' }') + (' .hero-widget.is-personalizable .chart-container .arc { stroke: ' + colors.subheader + ' }') + (' .hero-widget.is-personalizable .chart-container .bar { stroke: ' + colors.subheader + ' }') + (' .hero-widget.is-personalizable .chart-container.line-chart .dot { stroke: ' + colors.subheader + ' }') + '';

      return cssRules;
    },


    /**
    * Sets the personalization color(s)
    * @param {array} colors The original hex color as a string or an object with all the Colors
    * @returns {this} component instance
    */
    setColors: function setColors(colors) {
      if (!colors) {
        return this;
      }

      this.appendStyleSheet(this.getColorStyleSheet(colors));
      return this;
    },


    /**
    * Takes a color and performs a change in luminosity of that color programatically.
    * @private
    * @param {string} hex  The original Hexadecimal base color.
    * @param {string} lum  A percentage used to set luminosity
    * change on the base color:  -0.1 would be 10% darker, 0.2 would be 20% brighter
    * @returns {string} hexadecimal color.
    */
    getLuminousColorShade: function getLuminousColorShade(hex, lum) {
      // validate hex string
      hex = this.validateHex(hex).substr(1);
      lum = lum || 0;

      // convert to decimal and change luminosity
      var rgb = '#';
      var c = void 0;
      var i = void 0;

      for (i = 0; i < 3; i++) {
        c = parseInt(hex.substr(i * 2, 2), 16);
        c = Math.round(Math.min(Math.max(0, c + c * lum), 255)).toString(16);
        rgb += ('00' + c).substr(c.length);
      }

      return rgb;
    },


    /**
     * Detect the current theme based on the style sheet.
     * @private
     * @returns {string} The current theme.
     */
    getThemeFromStylesheet: function getThemeFromStylesheet() {
      var css = $('#stylesheet, #sohoxi-stylesheet');
      var thisTheme = '';

      if (css.length > 0) {
        var path = css.attr('href');
        thisTheme = path.substring(path.lastIndexOf('/') + 1);
        // trim query string off the end if it exists
        // something like ?v=123 may be used for cache busting or build identifiers
        var queryParamIndex = thisTheme.lastIndexOf('?');
        if (queryParamIndex > -1) {
          thisTheme = thisTheme.slice(0, queryParamIndex);
        }
        // trim the file extensions off the end and drop the -theme portion
        thisTheme = thisTheme.replace('.min.css', '').replace('.css', '').replace('-theme', '');
      }
      return thisTheme;
    },


    /**
    * Sets the current theme, blocking the ui during the change.
    * @param {string} incomingTheme  Represents the file name of a color
    * scheme (can be dark, light or high-contrast)
    */
    setTheme: function setTheme(incomingTheme) {
      if (exports.theme === incomingTheme) {
        if (!$('html').hasClass(exports.theme + '-theme')) {
          $('html').addClass(exports.theme + '-theme');
        }
        return;
      }

      exports.theme = incomingTheme;

      // validate theme
      if (this.availableThemes.indexOf(exports.theme) === -1) {
        return;
      }

      $('html').removeClass('light-theme dark-theme high-contrast-theme').addClass(exports.theme + '-theme');

      this.blockUi();

      var self = this;
      var originalCss = $('#stylesheet, #sohoxi-stylesheet');
      var newCss = $('<link rel="stylesheet">');
      var path = originalCss.attr('href');

      newCss.on('load', function () {
        originalCss.remove();
        self.unBlockUi();
      });

      var themePath = path ? path.substring(0, path.lastIndexOf('/')) : '';
      var isMin = path ? path.indexOf('.min') > -1 : false;

      newCss.attr({
        id: originalCss.attr('id'),
        href: xssUtils.stripTags(themePath + '/' + exports.theme + '-theme' + (isMin ? '.min' : '') + '.css')
      });
      originalCss.removeAttr('id');
      originalCss.after(newCss);
    },


    /**
     * Builds a temporary page overlay that prevents end users from experiencing FOUC
     * @private
     * @returns {void}
     */
    blockUi: function blockUi() {
      var backgroundColor = '#bdbdbd';
      if (exports.theme === 'light') {
        backgroundColor = '#f0f0f0';
      }
      if (exports.theme === 'dark') {
        backgroundColor = '#313236';
      }

      this.pageOverlay = this.pageOverlay || $('<div class="personalize-overlay"></div>');

      this.pageOverlay.css('background', backgroundColor);
      $('body').append(this.pageOverlay);
    },


    /**
     * Removes a temporary page overlay built by `blockUi()`
     * @private
     * @returns {void}
     */
    unBlockUi: function unBlockUi() {
      var self = this;

      self.pageOverlay.fadeOut(300, function () {
        self.pageOverlay.remove();
        self.pageOverlay = undefined;
      });
    },


    /**
     * Handle Updating Settings
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * Ideally this will do non-destructive things that make it possible to easily rebuild
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME);
      return this;
    },


    /**
     * Teardown - Remove added markup and events
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME);
    }
  };

  /**
   * Setup a single instance of the Personalization system on the HTML tag.
   * Personalization is top-level.
   */
  var personalization = new Personalize(document.documentElement, {
    theme: exports.theme
  });

  /**
   * Hooks that match up to methods in the Personalization system,
   * that need to exist on the Soho object for backwards-compatibility reasons.
   * These exported functions end up on the Soho object during the bootstrapping process.
   * TODO: make this not the preferred way of accessing these methods, and instead
   * prefer access to the global `Personalize`
   */

  function setTheme(theme) {
    return personalization.setTheme(theme);
  }

  function setColors(colors) {
    return personalization.setColors(colors);
  }

  function getColorStyleSheet(colors) {
    return personalization.getColorStyleSheet(colors);
  }

  /**
   * jQuery Component Wrapper for Personalize
   * NOTE: One instance of the Personalzation system can exist at any time, and is applied
   * to the <body> tag. When an app developer calls this directly, it's assumed that the
   * personalization system has already been established (during bootstrapping) and simply
   * needs to be updated with current settings.
   * @param {object} [settings] incoming Settings
   * @returns {jQuery[]} elements to be acted on
   */
  $.fn.personalize = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME);
      if (!instance) {
        instance = $.data(this, COMPONENT_NAME, personalization);
      }
      instance.updated(settings);
    });
  };

  // ====================================================
  // Soho Form/Element Utilities
  // ====================================================

  // Note marked these private so the doc generator doesnt work on them.
  // These should be refactored into an ES6 FormUtils component.

  /*
   * Make elements in the jQuery selector disabled if they support the prop disabled.
   * Or has a disable method.
   * @private
   * @returns {jQuery[]} processed, jQuery-wrapped elements
   */
  $.fn.disable = function () {
    $.each(this.data(), function (index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value && value.disable) {
        value.disable();
      }
    });
    this.prop('disabled', true);
    return this;
  };

  /*
   * Make elements in the jQuery selector enabled if they support the prop disabled.
   * Or has a enable method.
   * @private
   * @returns {jQuery[]} processed, jQuery-wrapped elements
   */
  $.fn.enable = function () {
    $.each(this.data(), function (index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value && value.enable) {
        value.enable();
      }
    });
    this.prop({ disabled: false, readonly: false });
    return this;
  };

  /*
   * Make elements in the jQuery selector readonly if they support the prop readonly.
   * Or has a readonly method.
   * @private
   * @returns {jQuery[]} processed, jQuery-wrapped elements
   */
  $.fn.readonly = function () {
    $.each(this.data(), function (index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value && value.readonly) {
        value.readonly();
      }
    });
    this.prop('readonly', true);
    return this;
  };

  // Fix: Labels without the "for" attribute
  $(function () {
    var str = void 0;
    var control = void 0;
    var labelText = $('.label-text');
    var labels = labelText.closest('label, .label');

    labels.each(function () {
      control = $('input, textarea, select', this);
      str = control.attr('class');

      $(this).addClass(function () {
        return (
          // Add "inline" and "inline-{control}" class to label
          // assuming control class is first thing in class string
          'inline' + (str ? ' inline-' + (str.indexOf(' ') === -1 ? str : str.substr(0, str.indexOf(' '))) : '')
        );
      });
    });
  });

  // Fix: Radio buttons was not selecting when click and than use arrow keys on Firefox
  $(function () {
    $('input:radio').on('click.radios', function () {
      this.focus();
    });
  });

  // Add css classes to parent for apply special rules
  $(function () {
    var addCssClassToParent = function addCssClassToParent(elemArray, cssClass) {
      for (var i = 0, l = elemArray.length; i < l; i++) {
        $(elemArray[i]).parent().addClass(cssClass);
      }
    };
    addCssClassToParent($('.field > input:checkbox, .field > .inline-checkbox'), 'field-checkbox');
    addCssClassToParent($('.field > input:radio, .field > .inline-radio'), 'field-radio');
  });

  // Text Highlight/Unhighlight Control
  // Originally called "highlight v5" by Johann Burkard
  // http://johannburkard.de/blog/programming/javascript/highlight-javascript-text-higlighting-jquery-plugin.html
  //
  // Modified for SoHo Xi (TODO: bit.ly link to docs)

  function innerHighlight(node, pat) {
    var skip = 0;
    var pos = void 0;
    var spannode = void 0;
    var middlebit = void 0;
    var middleclone = void 0;

    if (node.nodeType === 3) {
      pos = node.data.toUpperCase().indexOf(pat);
      pos -= node.data.substr(0, pos).toUpperCase().length - node.data.substr(0, pos).length;

      if (pos >= 0) {
        spannode = document.createElement('mark');
        spannode.className = 'highlight';
        middlebit = node.splitText(pos);
        middlebit.splitText(pat.length);
        middleclone = middlebit.cloneNode(true);
        spannode.appendChild(middleclone);
        middlebit.parentNode.replaceChild(spannode, middlebit);
        skip = 1;
      }
    } else if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName)) {
      for (var i = 0; i < node.childNodes.length; ++i) {
        i += innerHighlight(node.childNodes[i], pat);
      }
    }

    return skip;
  }

  /**
   * Highlight a portion of text inside an element
   * @param {string} pat portion of text that's being highlighted
   * @returns {this} this
   */
  $.fn.highlight = function (pat) {
    if (this.length && pat && pat.length) {
      return this.each(function () {
        innerHighlight(this, pat.toUpperCase());
      });
    }
    return this;
  };

  /**
   * Removes highlighting from portions of text inside an element
   * @returns {this} this
   */
  $.fn.unhighlight = function () {
    return this.find('mark.highlight').each(function () {
      var node = this.parentNode;
      node.replaceChild(this.firstChild, this);
      node.normalize();
    }).end();
  };

  // Component Name
  var COMPONENT_NAME$1 = 'arrange';

  /**
  * The Arrange Component allows touch and drag support to sort UI items.
  * @class Arrange
  * @constructor
  *
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [settings.handle] The CSS class name of the handle element to connect
  * @param {string} [settings.itemsSelector] The CSS selector to match all the sortable elements.
  * @param {string} [settings.connectWith] Optional CSS Selector to connect with when using two lists
  * @param {boolean} [settings.isVisualItems] Use only index of visual items to trigger
  * @param {string} [settings.placeholder] The html for the element that appears while dragging
  * @param {string} [settings.placeholderCssClass='arrange-placeholder'] The class to add to the ghost element that is being dragged.
  */
  var ARRANGE_DEFAULTS = {
    handle: null, // The Class of the handle element
    itemsSelector: null,
    connectWith: false,
    isVisualItems: false,
    placeholder: null,
    placeholderCssClass: 'arrange-placeholder'
  };

  function Arrange(element, settings) {
    this.settings = utils.mergeSettings(element, settings, ARRANGE_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Arrange Methods
  Arrange.prototype = {

    // example from: https://github.com/farhadi/html5arrangeable/blob/master/jquery.arrangeable.js
    init: function init() {
      this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      this.handleEvents();
    },


    /**
     * Get Element By Touch In List
     * @private
     * @param {object} list element.
     * @param {number} x value.
     * @param {number} y value.
     * @returns {object} item found in list
     */
    getElementByTouchInList: function getElementByTouchInList(list, x, y) {
      var returns = false;
      var listJq = $(list);

      for (var i = 0, l = listJq.length; i < l; i++) {
        var item = $(listJq[i]);
        var offset = item.offset();

        if (!(x <= offset.left || x >= offset.left + item.outerWidth() || y <= offset.top || y >= offset.top + item.outerHeight())) {
          returns = item;
        }
      }
      return returns;
    },


    /**
     * Dragg touch element
     * @private
     * @param {object} e as event.
     * @param {object} elm as element.
     * @returns {void}
     */
    dragTouchElement: function dragTouchElement(e, elm) {
      var orig = e.originalEvent.changedTouches[0];
      elm[0].style.top = orig.pageY - this.offset.y + 'px';
      elm[0].style.left = orig.pageX - this.offset.x + 'px';
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.items.removeClass('draggable').removeAttr('draggable').off('selectstart.arrange ' + this.dragStart + ' ' + this.dragEnd + ' ' + this.dragWhileDragging);

      $(this.handle, this.items).removeClass('draggable').off('mousedown.arrange mouseup.arrange touchstart.arrange touchend.arrange');

      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, ARRANGE_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
    * Teardown process for this plugin
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$1);
    },


    /**
     * Find out the visual index to trigger
     * @private
     * @param {object} elem to get index number.
     * @returns {number} the index
     */
    getVisualIndex: function getVisualIndex(elem) {
      var s = this.settings;
      var idx = null;

      if (s.isVisualItems) {
        var items = this.element.children().not('[data-arrange-exclude="true"]');
        if (s.itemsSelector) {
          items = $(s.itemsSelector, this.element).not('[data-arrange-exclude="true"]');
        }
        idx = items.index(elem);
      }

      return idx;
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var self = this;
      var s = this.settings;

      var index = void 0;
      var isHandle = void 0;
      var status = {};
      var items = this.element.children().not('[data-arrange-exclude="true"]');
      var placeholder = $('<' + (/^(ul|ol)$/i.test(this.element[0].tagName) ? 'li' : 'div') + '>');

      if (s.itemsSelector) {
        items = $(s.itemsSelector, this.element).not('[data-arrange-exclude="true"]');
        placeholder = $('<' + items.first()[0].tagName + ' />');
      }

      if (s.placeholder) {
        placeholder = $(s.placeholder);
      }

      this.dragStart = 'dragstart.arrange touchstart.arrange gesturestart.arrange';
      this.dragEnd = 'dragend.arrange touchend.arrange touchcancel.arrange gestureend.arrange';
      this.dragWhileDragging = 'dragover.arrange dragenter.arrange drop.arrange touchmove.arrange gesturechange.arrange';

      this.handle = s.handle || this.element.attr('data-arrange-handle');
      this.connectWith = this.element.attr('data-arrange-connectWith');
      this.placeholders = placeholder;

      if (!this.isTouch) {
        this.placeholders.addClass(s.placeholderCssClass + ' draggable');
      }

      // Use Handle if available
      $(this.handle, items).addClass('draggable').on('mousedown.arrange touchstart.arrange', function () {
        isHandle = true;
      }).on('mouseup.arrange touchend.arrange', function () {
        isHandle = false;
      });

      // Add connect with
      if (this.connectWith) {
        items = items.add($(this.connectWith).children().not('[data-arrange-exclude="true"]')).data('connectWith', this.connectWith);
      }

      this.items = items;

      // Draggable Items
      this.items.attr('draggable', true).addClass(this.handle ? '' : 'draggable').add([this, placeholder]).not('a[href], img').on('selectstart.arrange', function () {
        if (this.dragDrop) {
          this.dragDrop(); // ie9
        }
        return false;
      }).end().each(function () {
        $(this)
        // Drag start --------------------------------------------------------------------------
        .on(self.dragStart, function (e) {
          if (self.handle && !isHandle) {
            if (self.isTouch) {
              return;
            }
            return false; // eslint-disable-line
          }
          isHandle = false;
          self.dragging = $(this);

          index = self.dragging.addClass('arrange-dragging').index();
          var idx = s.isVisualItems ? self.getVisualIndex(self.dragging) : index;

          $.extend(status, { start: self.dragging, startIndex: idx });

          /**
          * Fires before moving an element allowing you to access the ui to
           customize the draggable item.
          *
          * @event beforearrange
          * @memberof Arrange
          * @property {object} event - The jquery event object
          * @property {object} status - Status for this item
          */
          var result = self.element.triggerHandler('beforearrange', status);
          if (typeof result === 'boolean' && !result || typeof result === 'string' && result.toLowerCase() === 'false') {
            self.dragging = null;
            return;
          }

          if (self.isTouch) {
            var rect = self.dragging[0].getBoundingClientRect();
            var touch = e.originalEvent.changedTouches[0];

            // Save offset
            self.offset = {
              x: touch.pageX - rect.left,
              y: touch.pageY - rect.top
            };
            self.placeholderTouch = self.dragging.clone().addClass('is-touch').attr('id', 'arrange-placeholder-touch').insertBefore(self.dragging);

            self.dragTouchElement(e, self.placeholderTouch);
          } else {
            var dt = e.originalEvent.dataTransfer;
            dt.effectAllowed = 'move';
            dt.setData('Text', 'dummy');
          }
        })

        // Drag end ----------------------------------------------------------
        .on(self.dragEnd, function () {
          if (!self.dragging) {
            return;
          }

          if (self.isTouch) {
            self.dragging.css('opacity', 1);
            self.placeholderTouch.remove();
          }

          self.placeholders.filter(':visible').after(self.dragging);
          self.dragging.removeClass('arrange-dragging').show();
          self.placeholders.detach();

          if (index !== self.dragging.index()) {
            var idx = s.isVisualItems ? self.getVisualIndex(self.dragging) : self.dragging.index();
            $.extend(status, { end: self.dragging, endIndex: idx });

            /**
            * Fires after moving an element allowing you do any follow up updating.
            *
            * @event arrangeupdate
            * @memberof Arrange
            * @property {object} event - The jquery event object
            * @property {object} status - Status for this item
            */
            self.element.triggerHandler('arrangeupdate', status);
          }
          self.dragging = null;
          self.placeholderTouch = null;
        })

        // While dragging ----------------------------------------------------
        .on(self.dragWhileDragging, function (e) {
          if (!self.dragging) {
            return;
          }
          var overItem = this;
          var overIndex = void 0;
          e.preventDefault();

          /**
          * Fires after finishing an arrange action.
          *
          * @event dragend
          * @memberof ApplicationMenu
          * @param {object} event - The jquery event object
          */
          if (e.type === 'drop') {
            e.stopPropagation();
            self.dragging.trigger('dragend.arrange');
            return false; // eslint-disable-line
          }

          if (self.isTouch) {
            var touch = e.originalEvent.touches[0];
            overItem = self.getElementByTouchInList(items, touch.pageX, touch.pageY) || overItem;
          }
          overItem = $(overItem);

          if (!self.isTouch) {
            e.originalEvent.dataTransfer.dropEffect = 'move';
          }

          if (items.is(overItem) && placeholder.index() !== overItem.index()) {
            if (self.isTouch) {
              self.dragging.css('opacity', 0);
            } else {
              self.dragging.hide();
            }

            var idx = void 0;
            if (placeholder.index() < overItem.index()) {
              placeholder.insertAfter(overItem);
              overIndex = overItem.index();
              idx = s.isVisualItems ? self.getVisualIndex(overItem) : overIndex;
            } else {
              placeholder.insertBefore(overItem);
              overIndex = placeholder.index();
              idx = s.isVisualItems ? self.getVisualIndex(placeholder) : overIndex;
            }

            $.extend(status, { over: overItem, overIndex: idx });
            self.element.triggerHandler('draggingarrange', status);

            // Fix: IE-11 on windows-10 svg was disappering
            utils.fixSVGIcons(overItem);

            self.placeholders.not(placeholder).detach();
          } else if (!self.placeholders.is(this)) {
            self.placeholders.detach();
            self.element.append(placeholder);
          }

          if (self.isTouch) {
            self.dragTouchElement(e, self.placeholderTouch);
            return;
          }
          return false; // eslint-disable-line
        }); //-----------------------------------------------------------------
      }); // end each items
    }
  };

  /**
   * jQuery component wrapper for Arrange
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */
  $.fn.arrange = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1, new Arrange(this, settings));
      }
    });
  };

  /* eslint-disable no-cond-assign */

  // TODO: Resize: http://stackoverflow.com/questions/8258232/resize-an-html-element-using-touches
  // Similar: https://github.com/desandro/draggabilly

  // The name of this plugin
  var COMPONENT_NAME$2 = 'drag';

  /**
   * Drag/Drop functions with touch support.
   * @class Drag
   * @constructor
   *
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.axis]  Constrains dragging to either axis. Possible values: null, 'x', 'y'
   * @param {boolean} [settings.clone=false] Set to true to clone the object to drag. In many situations this is
   *  needed to break out of layout.
   * @param {string} [settings.cloneCssClass='is-clone'] Css class added to clone element (defaults is 'is-clone')
   * @param {boolean} [settings.clonePosIsFixed=false] If true cloned object will use css style "position: fixed"
   * @param {string} [settings.cloneAppendTo] Selector to append to for the clone
   * ['body'|'parent'|'jquery object'] default:'body'
   * @param {boolean} [settings.containment=false] Constrains dragging to within the bounds of the specified element
   *  or region. Possible values: "parent", "document", "window".
   * @param {string} [settings.obstacle] jQuery Selector of object(s) that you cannot drag into,
   * @param {boolean} [settings.underElements=false] If set to true will return list of elements that are
   * underneath the drag element
   * @param {object} [settings.containmentOffset={left: 0, top: 0}] How close to the containment object should we be allowed
   * to drag in position form. `{left: 0, top: 0}`
  */
  var DRAG_DEFAULTS = {
    axis: null,
    clone: false,
    cloneCssClass: 'is-clone',
    clonePosIsFixed: false,
    cloneAppendTo: null,
    containment: false,
    obstacle: false,
    underElements: false,
    containmentOffset: { left: 0, top: 0 }
  };

  function Drag(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, DRAG_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Drag.prototype = {
    init: function init() {
      this.handleEvents();
    },


    /**
    * Trigger events and remove clone
    * @private
    * @param {number} left Current left position
    * @param {number} top Current top position
    */
    finish: function finish(left, top) {
      var pos = { top: top, left: left };

      this.element.off('mouseup.draggable');
      $(document).off('mousemove.draggable mouseup.draggable');
      if (this.settings.underElements) {
        pos.underElements = this.getElementsFromPoint(pos.left, pos.top);
      }

      /**
      * Fires after the drag is completed. Use this to remove / set drag feedback off.
      * @event dragend
      * @memberof Drag
      * @property {object} event - The jquery event object.
      * @property {object} ui - The dialog object
      */
      this.element.trigger('dragend', pos);
      this.element.removeClass('is-dragging');

      if (this.clone) {
        if (this.settings.axis === 'x') {
          delete pos.top;
        }

        if (this.settings.axis === 'y') {
          delete pos.left;
        }
        // this.element.css(pos);
        this.clone.remove();
        this.clone = null;
      }

      // Clear Cached Sizes
      if (this.obstacle) {
        this.obstacle = null;
      }
      if (this.upperYLimit) {
        this.upperYLimit = null;
      }
      if (this.upperXLimit) {
        this.upperXLimit = null;
      }
      $('body').removeClass('disable-select');
    },


    // Move the object from the event coords
    move: function move(left, top) {
      var self = this;

      var css = {
        left: left,
        top: top
      };

      // X-Y Axis
      if (this.settings.axis === 'x') {
        delete css.top;
      }

      if (this.settings.axis === 'y') {
        delete css.left;
      }

      if (this.settings.containment) {
        if (this.settings.containment === 'parent') {
          this.container = this.element.parent();
        } else if (this.settings.containment === 'window') {
          this.container = $(window);
        } else if (this.settings.containment === 'container') {
          this.container = this.element.closest('.page-container');
        } else {
          this.container = $(document);
        }

        if (!this.upperXLimit) {
          this.upperXLimit = this.container.width() - this.element.outerWidth() + this.settings.containmentOffset.left;
        }
        if (!this.upperYLimit) {
          this.upperYLimit = this.container.height() - this.element.outerHeight() + this.settings.containmentOffset.top;
        }
        if (css.top > this.upperYLimit) {
          css.top = this.upperYLimit;
        }

        if (css.left > this.upperXLimit) {
          css.left = this.upperXLimit;
        }

        if (css.top < 0) {
          css.top = 0;
        }

        if (css.left < 0) {
          css.left = 0;
        }

        if (this.settings.containment === 'container' && css.left <= 1) {
          css.left = 1;
        }
      }

      if (this.settings.obstacle) {
        var elemOffset = this.clone ? this.clone.offset() : this.element.offset();
        var elemWidth = this.clone ? this.clone.outerWidth() : this.element.outerWidth();
        var movingRight = css.left > elemOffset.left;

        // Caching this so drag is not jaggie
        if (!this.obstacle) {
          this.obstacle = $(this.settings.obstacle).not(this.element);
          var obstacleOffset = $(this.obstacle).offset();

          this.constraints = {
            top: obstacleOffset.top,
            left: obstacleOffset.left,
            bottom: obstacleOffset.top + this.obstacle.outerHeight(),
            right: obstacleOffset.left + this.obstacle.outerWidth()
          };
        }

        if (!movingRight && self.originalPos.left > this.constraints.left && css.left <= this.constraints.right) {
          css.left = this.constraints.right;
        }

        if (movingRight && self.originalPos.left + elemWidth <= this.constraints.left && css.left + elemWidth >= this.constraints.left) {
          css.left = this.constraints.left - this.obstacle.outerWidth();
        }

        // TODO: Moving Down
      }

      var applyCssStyle = function applyCssStyle(el, applyCss, prop) {
        if (typeof applyCss[prop] !== 'undefined') {
          el[0].style[prop] = applyCss[prop] + 'px';
        }
      };

      applyCssStyle(this.clone || this.element, css, 'top');
      applyCssStyle(this.clone || this.element, css, 'left');

      if (this.settings.underElements) {
        css.underElements = this.getElementsFromPoint(css.left, css.top);
      }

      /**
      * Fires (many times) while dragging is occuring. Use this for DOM feedback but
      * be careful about what you do in here for performance.
      * @event drag
      * @memberof Drag
      * @property {object} event - The jquery event object.
      * @property {object} ui - The dialog object
      */
      this.element.trigger('drag', css);
    },


    /**
    * Get elements from given point.
    * @param {number} x The x-coordinate of the Point.
    * @param {number} y The y-coordinate of the Point.
    * @Returns {array} List of all elements at the given point.
    */
    getElementsFromPoint: function getElementsFromPoint(x, y) {
      var elements = [];

      if (document.elementsFromPoint) {
        elements = document.elementsFromPoint(x, y);
      } else if (document.msElementsFromPoint) {
        elements = document.msElementsFromPoint(x, y);
      } else {
        var i = void 0;
        var l = void 0;
        var d = void 0;
        var current = void 0;
        var max = 999;
        var pointerEvents = [];

        while ((current = document.elementFromPoint(x, y)) && elements.indexOf(current) === -1 && current !== null && max > -1) {
          max--;

          // push the element and its current style
          elements.push(current);
          pointerEvents.push({
            value: current.style.getPropertyValue('pointer-events') || '',
            priority: current.style.getPropertyPriority('pointer-events')
          });
          // add "pointer-events: none", to get to the underlying element
          current.style.setProperty('pointer-events', 'none', 'important');
        }
        // restore the previous pointer-events values
        for (i = 0, l = elements.length; i < l; i++) {
          d = pointerEvents[i];
          elements[i].style.setProperty('pointer-events', d.value, d.priority);
        }
      }
      return elements;
    },


    /**
     * Update the component and optionally apply new settings.
     * @param  {object} settings the settings to update to.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }
    },


    /**
     * Detach all functionality and events.
     */
    destroy: function destroy() {
      $.removeData(this.element[0], COMPONENT_NAME$2);
      this.element.off('touchstart.draggable MSPointerDown.draggable pointerdown.draggable touchmove.draggable touchend.draggable touchcancel.draggable mousedown.draggable');
    },
    handleEvents: function handleEvents() {
      var self = this;
      self.offset = null;

      // Touch and Drag Support
      self.element.attr('draggable', false);

      if ('onpointerdown' in window || 'onmspointerdown' in window) ; else {
        // Touch-only Drag Support
        self.element.on('touchstart.draggable gesturestart.draggable', function (e) {
          var pos = $(this).position();
          var orig = e.originalEvent;

          self.offset = {
            x: orig.changedTouches[0].pageX - pos.left,
            y: orig.changedTouches[0].pageY - pos.top
          };

          self.originalPos = pos;
          self.element.addClass('is-dragging');

          /**
          * When the dragging is initiated. Use this to customize/style
          * the drag/drop objects in the DOM.
          * @event dragstart
          * @memberof Drag
          * @property {object} event - The jquery event object.
          * @property {object} ui - The dialog object
          */
          self.element.trigger('dragstart', pos);
        })
        // Move
        .on('touchmove.draggable gesturechange.draggable', function (e) {
          e.preventDefault();
          var orig = e.originalEvent;

          // do now allow two touch points to drag the same element
          if (orig.targetTouches.length > 1) {
            return;
          }

          var xpos = orig.changedTouches[0].pageX - self.offset.x;
          var ypos = orig.changedTouches[0].pageY - self.offset.y;
          self.move(xpos, ypos);
        })
        // Finish Touch Dragging
        .on('touchend.draggable gestureend.draggable touchcancel.draggable', function (e) {
          e.preventDefault();
          var touch = e.originalEvent.changedTouches[0];
          self.finish(touch.pageX - self.offset.x, touch.pageY - self.offset.y);
        });
      }

      // Always bind mousedown in either scenario, in the event that a mouse is used
      self.element.on('mousedown.draggable', function (e) {
        e.preventDefault();

        var pos = self.settings.clonePosIsFixed ? self.element[0].getBoundingClientRect() : self.element.position();

        // Save offset
        self.offset = {
          x: e.pageX - pos.left,
          y: e.pageY - pos.top
        };

        self.originalPos = pos;

        // Prevent Text Selection
        $('body').addClass('disable-select');

        // Handle Mouse Press over draggable element
        $(document).on('mousemove.draggable', function (mouseMoveEvent) {
          mouseMoveEvent.preventDefault();
          self.move(mouseMoveEvent.pageX - self.offset.x, mouseMoveEvent.pageY - self.offset.y);
        });

        // Handle Mouse release over draggable element close out events and trigger
        $(document).on('mouseup.draggable', function (docMouseUpEvent) {
          docMouseUpEvent.preventDefault();
          self.finish(e.pageX - self.offset.x, docMouseUpEvent.pageY - self.offset.y);
        });

        self.element.on('mouseup.draggable', function (mouseUpEvent) {
          mouseUpEvent.preventDefault();
          self.finish(mouseUpEvent.pageX - self.offset.x, mouseUpEvent.pageY - self.offset.y);
        });

        // Trigger dragging
        // Clone
        if (!self.clone && self.settings.clone) {
          self.clone = self.element.clone(true);
          if (self.settings.cloneAppendTo === 'parent') {
            self.settings.cloneAppendTo = self.element.parent();
          }
          self.clone.addClass(self.settings.cloneCssClass).appendTo(self.settings.cloneAppendTo || 'body');
        }

        self.element.addClass('is-dragging');
        self.element.trigger('dragstart', [pos, self.clone]);
      });
    }
  };

  /**
   * jQuery Component Wrapper for Drag
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.drag = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$2);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$2, new Drag(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$3 = 'place';

  // Default Component Options
  var DEFAULT_PLACE_SETTINGS = {
    bleedFromContainer: false,
    callback: null,
    container: null,
    parent: null,
    parentXAlignment: 'center',
    parentYAlignment: 'center',
    placement: 'bottom',
    strategies: ['nudge']
  };

  // Constants used throughout
  var PLACE_STRATEGIES = ['nudge', 'clockwise', 'flip', 'shrink', 'shrink-x', 'shrink-y'];
  var PLACE_POSITIONS = ['top', 'left', 'right', 'bottom', 'center'];
  var PLACE_X_ALIGNMENTS = ['left', 'center', 'right'];
  var PLACE_Y_ALIGNMENTS = ['top', 'center', 'bottom'];
  var PLACEMENT_OBJECT_SETTING_KEYS = ['x', 'y', 'container', 'containerOffsetX', 'containerOffsetY', 'callback', 'parent', 'parentXAlignment', 'parentYAlignment', 'useParentWidth', 'useParentHeight', 'placement', 'strategies'];

  /**
   * Object that contains coordinates along with temporary, changeable properties.
   * This object gets passed around the Place Behavior and modified during each phase of positioning.
   * This object is also passed to all callbacks and event listeners for further modification.
   * @private
   * @param {object} [placementOptions] object containing settings for placement
   * @returns {void}
   */
  function PlacementObject(placementOptions) {
    var self = this;

    PLACEMENT_OBJECT_SETTING_KEYS.forEach(function (val) {
      if (placementOptions[val] === null) {
        return;
      }

      if (val === 'x' || val === 'y') {
        self.setCoordinate(val, placementOptions[val]);
        self['original' + val] = placementOptions[val];
        return;
      }

      self[val] = placementOptions[val];
    });

    this.modified = false;

    return this.sanitize();
  }

  PlacementObject.prototype = {
    isReasonableDefault: function isReasonableDefault(setting, limits) {
      return $.inArray(setting, limits) > -1;
    },
    sanitize: function sanitize() {
      var self = this;

      this.bleedFromContainer = this.bleedFromContainer === true;
      this.callback = typeof this.callback === 'function' ? this.callback : DEFAULT_PLACE_SETTINGS.callback;
      this.container = this.container instanceof $ && this.container.length ? this.container : DEFAULT_PLACE_SETTINGS.container;
      this.containerOffsetX = !isNaN(parseInt(this.containerOffsetX, 10)) ? this.containerOffsetX : 0;
      this.containerOffsetY = !isNaN(parseInt(this.containerOffsetY, 10)) ? this.containerOffsetY : 0;
      this.parent = this.parent instanceof $ && this.parent.length ? this.parent : DEFAULT_PLACE_SETTINGS.parent;
      this.parentXAlignment = this.isReasonableDefault(this.parentXAlignment, PLACE_X_ALIGNMENTS) ? this.parentXAlignment : DEFAULT_PLACE_SETTINGS.parentXAlignment;
      this.parentYAlignment = this.isReasonableDefault(this.parentYAlignment, PLACE_Y_ALIGNMENTS) ? this.parentYAlignment : DEFAULT_PLACE_SETTINGS.parentYAlignment;
      this.placement = this.isReasonableDefault(this.placement, PLACE_POSITIONS) ? this.placement : DEFAULT_PLACE_SETTINGS.placement;
      this.useParentHeight = this.useParentHeight === true;
      this.useParentWidth = this.useParentWidth === true;

      if (!$.isArray(this.strategies) || !this.strategies.length) {
        this.strategies = ['nudge'];
      }
      this.strategies.forEach(function (strat, i) {
        self.strategies[i] = self.isReasonableDefault(strat, PLACE_STRATEGIES) ? strat : self.strategies[i];
      });
    },
    setCoordinate: function setCoordinate(coordinate, value) {
      var coordinates = ['x', 'y'];
      if (!this.isReasonableDefault(coordinate, coordinates)) {
        return;
      }

      if (isNaN(value)) {
        value = 0;
      }

      this[coordinate] = Math.round(value);
    }
  };

  /**
   * The Place API which handles internal placement of popups, menus ect.
   * @class Place
   * @param {HTMLElement|jQuery[]} element the base element being placed
   * @param {object} [settings] incoming settings
   * @param {boolean} [settings.bleedFromContainer = false] If true, allows positioned content to bleed
   *  outside of a defined container.
   * @param {function} [settings.callback] If defined, provides extra placement adjustments
   *  after the main calculation is performed.
   * @param {HTMLElement} [settings.container] If defined, contains the placement of the
   *  element to the boundaries of a specific container element.
   * @param {HTMLElement} [settings.parent] If defined, will be used as the reference
   *  element for placement this element.
   * @param {string} [settings.parentXAlignment = 'center'] Only used for parent-based placement.
   *  Determines the X-coordinate alignment of the placed element against its parent.
   * @param {string} [settings.parentYAlignment = 'center'] Only used for parent-based placement.
   *  Determines the Y-coordinate alignment of the placed element against its parent.
   * @param {string} [settings.placement = 'bottom'] If defined, changes the direction in which
   *  placement of the element happens
   * @param {string[]} [settings.strategies = ['nudge']] Determines the "strategy" for alternatively
   *  placing the element if it doesn't fit in the defined boundaries.  Only matters
   *  when "parent" is a defined setting.  It's possible to define multiple strategies
   *  and execute them in order.
   */
  function Place(element, settings) {
    this.settings = utils.mergeSettings(element, settings, DEFAULT_PLACE_SETTINGS);
    this.element = $(element);
    this.init();
  }

  Place.prototype = {

    /**
     * Do other init (change/normalize settings, load externals, etc)
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      return this.build().handleEvents();
    },


    /**
     * Add markup to the control
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      if (!this.element.hasClass('placeable')) {
        this.element.addClass('placeable');
      }

      // Setup a hash of original styles that will retain width/height whenever
      // the placement for this element is recalculated.
      this.originalStyles = {};
      var h = this.element[0].style.height;
      var w = this.element[0].style.width;

      if (h) {
        this.originalStyles.height = h;
      }
      if (w) {
        this.originalStyles.width = w;
      }

      return this;
    },


    /**
     * Sets up event handlers for this control and its sub-elements
     * @private
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.on('place.' + COMPONENT_NAME$3, function (e, x, y) {
        self.place(new PlacementObject({ x: x, y: y }));
      }).on('updated.' + COMPONENT_NAME$3, function () {
        self.updated();
      });

      return this;
    },


    /**
     * Actually renders an element with coordinates inside the DOM
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {void}
     */
    render: function render(placementObj) {
      var unitRegex = /(px|%)/i;

      this.element.offset({
        left: placementObj.x,
        top: placementObj.y
      });

      if (placementObj.height) {
        this.element[0].style.height = placementObj.height + (unitRegex.test('' + placementObj.height) ? '' : 'px');
      }
      if (placementObj.width) {
        this.element[0].style.width = placementObj.width + (unitRegex.test('' + placementObj.width) ? '' : 'px');
      }
    },


    /**
     * Main placement API Method (external)
     * Can either take a PlacementObject as a single argument, or can take 2 coordinates (x, y) and
     * will use the pre-defined settings.
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {void}
     */
    place: function place(placementObj) {
      var curr = [this.element[0].style.left, this.element[0].style.top];

      // Cancel placement with return:false; from a "beforeplace" event
      var canBePlaced = this.element.trigger('beforeplace', [curr]);
      if (!canBePlaced) {
        return curr;
      }

      if (!(placementObj instanceof PlacementObject)) {
        placementObj = new PlacementObject(placementObj);
      }

      // If no values are defined, simply return the current coordinates with a warning.
      if (placementObj.x == null && placementObj.y == null) {
        // TODO: Log a warning about not positioning stuff?
        return curr;
      }

      // Remove any previous placement styles
      this.clearOldStyles();

      // Use different methods if placement against a parent, versus straight-up coordinate placement
      if (placementObj.parent) {
        return this.placeWithParent(placementObj);
      }

      return this.placeWithCoords(placementObj);
    },


    /**
     * Placement Routine that expects a parent to be used as a base placement marking.
     * In this case, "x" and "y" integers are "relative" adjustments to the original
     * numbers generated by the parent. Can be modified by using a callback in the settings.
     * @private
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {PlacementObject} modified placementObject with updated settings
     */
    placeWithParent: function placeWithParent(placementObj) {
      if (!placementObj.parent || !placementObj.parent.length) {
        // can't simply return x and y here because if there is no parent element,
        // these numbers are not coordinates, they are offsets.
        return [undefined, undefined];
      }

      var self = this;
      var parentRect = DOM.getDimensions(placementObj.parent[0]);
      var elRect = DOM.getDimensions(this.element[0]);
      var container = this.getContainer(placementObj);
      var containerIsBody = container.length && container[0] === document.body;
      // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
      // Firefox $('body').scrollTop() will always return zero.
      var scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft();
      var scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop();

      if (placementObj.useParentWidth) {
        placementObj.width = parentRect.width;
      }
      if (placementObj.useParentHeight) {
        placementObj.height = parentRect.height;
      }

      function getCoordsFromPlacement(incomingPlacementObj) {
        var p = incomingPlacementObj.placement;
        var aX = incomingPlacementObj.parentXAlignment;
        var aY = incomingPlacementObj.parentYAlignment;
        var cX = void 0;
        var cY = void 0;

        // Set initial placements
        switch (p) {
          case 'top':
            cY = parentRect.top - elRect.height - incomingPlacementObj.y + (containerIsBody ? scrollY : 0);
            break;
          case 'left':
            cX = parentRect.left - elRect.width - incomingPlacementObj.x + (containerIsBody ? scrollX : 0);
            break;
          case 'right':
            cX = parentRect.right + incomingPlacementObj.x + (containerIsBody ? scrollX : 0);
            break;
          default:
            // Bottom
            cY = parentRect.bottom + incomingPlacementObj.y + (containerIsBody ? scrollY : 0);
            break;
        }

        // Set X alignments on bottom/top placements
        if (p === 'top' || p === 'bottom') {
          switch (aX) {
            case 'left':
              cX = parentRect.left - incomingPlacementObj.x + (containerIsBody ? scrollX : 0);
              break;
            case 'right':
              cX = parentRect.right - elRect.width + incomingPlacementObj.x + (containerIsBody ? scrollX : 0);
              break;
            default:
              // center
              cX = parentRect.left + (parentRect.width - elRect.width) / 2 + incomingPlacementObj.x + (containerIsBody ? scrollX : 0);
              break;
          }
        }

        // Set Y alignments on left/right placements
        if (p === 'right' || p === 'left') {
          switch (aY) {
            case 'top':
              cY = parentRect.top - incomingPlacementObj.y + (containerIsBody ? scrollY : 0);
              break;
            case 'bottom':
              cY = parentRect.bottom - elRect.height + incomingPlacementObj.y + (containerIsBody ? scrollY : 0);
              break;
            default:
              // center
              cY = parentRect.top + (parentRect.height - elRect.height) / 2 + incomingPlacementObj.y + (containerIsBody ? scrollY : 0);
              break;
          }
        }

        return [cX, cY];
      }

      function doPlacementAgainstParent(incomingPlacementObj) {
        var coords = getCoordsFromPlacement(incomingPlacementObj);
        incomingPlacementObj.setCoordinate('x', coords[0]);
        incomingPlacementObj.setCoordinate('y', coords[1]);
        self.render(incomingPlacementObj);
        incomingPlacementObj = self.handlePlacementCallback(incomingPlacementObj);
        return incomingPlacementObj;
      }

      // Simple placement logic
      placementObj = doPlacementAgainstParent(placementObj);

      // Adjusts the placement coordinates based on a defined strategy
      // Will only adjust the current strategy if bleeding outside the
      // viewport/container are detected.
      placementObj.strategies.forEach(function (strat) {
        placementObj = self.checkBleeds(placementObj);

        if (placementObj.bleeds) {
          placementObj = function () {
            switch (strat) {
              case 'nudge':
                return self.nudge(placementObj);
              case 'clockwise':
                return self.clockwise(placementObj);
              case 'flip':
                placementObj = self.flip(placementObj);
                placementObj.setCoordinate('x', placementObj.originalx);
                placementObj.setCoordinate('y', placementObj.originaly);
                placementObj = doPlacementAgainstParent(placementObj);
                return placementObj;
              case 'shrink':
                return self.shrink(placementObj);
              case 'shrink-x':
                return self.shrink(placementObj, 'x');
              case 'shrink-y':
                return self.shrink(placementObj, 'y');
              default:
                return placementObj;
            }
          }(self);

          self.render(placementObj);
        }
      });

      // Trigger an event to notify placement has ended
      this.element.trigger('afterplace', [placementObj]);

      return placementObj;
    },


    /**
     * Basic Placement Routine that simply accepts X and Y coordinates.
     * In this case, "x" and "y" integers are "absolute" and will be the base point for placement.
     * Can be modified by using a callback in the settings.
     * @private
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {PlacementObject} modified placementObject with updated settings
     */
    placeWithCoords: function placeWithCoords(placementObj) {
      this.render(placementObj);

      placementObj = this.handlePlacementCallback(placementObj);

      this.render(placementObj);

      // Coordinate placement can only be "nudged" (strategy is not used in this style of placement).
      placementObj = this.checkBleeds(placementObj);
      if (placementObj.bleeds) {
        placementObj = this.nudge(placementObj);
      }

      // Place again
      this.render(placementObj);

      placementObj = this.checkBleeds(placementObj);
      if (placementObj.bleeds) {
        placementObj = this.shrink(placementObj);
      }

      this.render(placementObj);

      this.element.trigger('afterplace', [placementObj]);

      return placementObj;
    },


    /**
     * Perform callback, if it exists.
     * Callback should return an array containing the modified coordinate values: [x, y];
     * NOTE: These are actual coordinates in all cases.
     * NOTE: They are not relative values - they are absolute.
     * @private
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {PlacementObject} modified placementObject with updated settings
     */
    handlePlacementCallback: function handlePlacementCallback(placementObj) {
      var cb = placementObj.callback || this.settings.callback;

      if (cb && typeof cb === 'function') {
        placementObj = cb(placementObj);
      }

      this.render(placementObj);
      return placementObj;
    },


    /**
     * Detects for elements with fixed positioning, or an absolutely-positioned containment.
     * If either condition is true, this placement should not account for container scrolling.
     * @private
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {boolean} whether or not the values calculated should account for scrolling.
     */
    accountForScrolling: function accountForScrolling(placementObj) {
      var container = placementObj.container;
      var pos = window.getComputedStyle(this.element[0]).position;

      // fixed-positoned, placed elements don't account for scrolling
      if (pos === 'fixed') {
        return false;
      }

      // Check the container element.
      // If we can't find a valid container element, do account for scrolling.
      if (!container || !container.length) {
        container = this.element.parents().filter(function () {
          var containerPos = window.getComputedStyle(this).position;
          return containerPos === 'absolute' || pos === 'fixed';
        });
      }
      if (!container || !container.length) {
        return true;
      }

      if (container[0] === document.body) {
        return false;
      }

      var containerStyle = window.getComputedStyle(container[0]);
      pos = containerStyle.position;
      if (pos === 'fixed') {
        return false;
      }
      if (pos === 'absolute' && containerStyle.overflow === 'hidden') {
        return false;
      }
      return true;
    },


    /**
     * Gets a parent container element.
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {HTMLElement|jQuery[]} container element
     */
    getContainer: function getContainer(placementObj) {
      if (placementObj.container instanceof $ && placementObj.container.length) {
        return placementObj.container;
      }

      var modalParent = this.element.parents('.modal');
      if (modalParent.length) {
        return modalParent;
      }

      return $(document.body);
    },


    /**
     * Re-adjust a previously-placed element to account for bleeding off the edges.
     * Element must fit within the boundaries of the page or it's current scrollable pane.
     * @param {PlacementObject} placementObj settings for the placement routine.
     * @returns {PlacementObject} modified placementObject with updated settings.
     */
    checkBleeds: function checkBleeds(placementObj) {
      var containerBleed = this.settings.bleedFromContainer;
      var container = this.getContainer(placementObj);
      var containerIsBody = container.length && container[0] === document.body;
      var BoundingRect = this.element[0].getBoundingClientRect();
      var rect = {};
      var containerRect = container ? container[0].getBoundingClientRect() : {};
      // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
      // Firefox $('body').scrollTop() will always return zero.
      var scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft();
      var scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop();
      var windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      var windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      var d = void 0;

      rect.width = BoundingRect.width;
      rect.height = BoundingRect.height;
      rect.top = BoundingRect.top;
      rect.right = BoundingRect.right;
      rect.bottom = BoundingRect.bottom;
      rect.left = BoundingRect.left;

      function getBoundary(edge) {
        switch (edge) {
          case 'top':
            return (containerBleed ? 0 : containerRect.top) - (!containerIsBody ? 0 : scrollY * -1); // 0 === top edge of viewport
          case 'left':
            return (containerBleed ? 0 : containerRect.left) - (!containerIsBody ? 0 : scrollX * -1); // 0 === left edge of viewport
          case 'right':
            return (containerBleed ? windowW : containerRect.right) - (!containerIsBody ? 0 : scrollX * -1);
          default:
            // bottom
            return (containerBleed ? windowH : containerRect.bottom) - (!containerIsBody ? 0 : scrollY * -1);
        }
      }

      // If element width is greater than window width, shrink to fit
      var rightViewportEdge = getBoundary('right');
      if (rect.width >= rightViewportEdge) {
        d = rect.width - rightViewportEdge;
        var newWidth = rect.width - d;
        placementObj.width = newWidth;

        this.element[0].style.width = newWidth + 'px';
        rect.width = newWidth; // reset the rect because the size changed
      }

      // If element height is greater than window height, shrink to fit
      var bottomViewportEdge = getBoundary('bottom');
      if (rect.height >= bottomViewportEdge) {
        d = rect.height - bottomViewportEdge;
        var newHeight = rect.height - d;
        placementObj.height = newHeight;

        this.element[0].style.height = newHeight + 'px';
        rect.height = newHeight; // reset the rect because the size changed
      }

      // build conditions
      var offRightEdge = rect.right > getBoundary('right');
      var offLeftEdge = rect.left < getBoundary('left');
      var offTopEdge = rect.top < getBoundary('top');
      var offBottomEdge = rect.bottom > getBoundary('bottom');

      // Return if no bleeding is detected (no need to fix anything!)
      if (!offRightEdge && !offLeftEdge && !offTopEdge && !offBottomEdge) {
        placementObj.bleeds = undefined;
        return placementObj;
      }

      // Keep a record of bleeds that need to be adjusted, and by what values
      placementObj.bleeds = {};
      placementObj.bleeds.right = offRightEdge ? rect.right - getBoundary('right') : null;
      placementObj.bleeds.left = offLeftEdge ? -(rect.left - getBoundary('left')) : null;
      placementObj.bleeds.top = offTopEdge ? -(rect.top - getBoundary('top')) : null;
      placementObj.bleeds.bottom = offBottomEdge ? rect.bottom - getBoundary('bottom') : null;

      return placementObj;
    },


    // Bumps the element around in each direction
    nudge: function nudge(placementObj) {
      if (!placementObj.nudges) {
        placementObj.nudges = { x: 0, y: 0 };
      }

      var d = 0;
      if (placementObj.bleeds.right) {
        d = Math.abs(placementObj.bleeds.right) + Math.abs(placementObj.containerOffsetX);
        placementObj.setCoordinate('x', placementObj.x - d);
        placementObj.nudges.x -= d;
      }
      if (placementObj.bleeds.left) {
        d = Math.abs(placementObj.bleeds.left) + Math.abs(placementObj.containerOffsetX);
        placementObj.setCoordinate('x', placementObj.x + d);
        placementObj.nudges.x += d;
      }
      if (placementObj.bleeds.top) {
        d = Math.abs(placementObj.bleeds.top) + Math.abs(placementObj.containerOffsetY);
        placementObj.setCoordinate('y', placementObj.y + d);
        placementObj.nudges.y += d;
      }
      if (placementObj.bleeds.bottom) {
        d = Math.abs(placementObj.bleeds.bottom) + Math.abs(placementObj.containerOffsetY);
        placementObj.setCoordinate('y', placementObj.y - d);
        placementObj.nudges.y -= d;
      }

      placementObj.wasNudged = true;
      placementObj.bleeds = undefined;

      return placementObj;
    },
    flip: function flip(placementObj) {
      // Don't attempt to flip if there was no bleeding on the edge we're attempting to leave from.
      if (!placementObj.bleeds[placementObj.placement]) {
        return placementObj;
      }

      if (!placementObj.attemptedFlips) {
        placementObj.attemptedFlips = [];
      }
      placementObj.attemptedFlips.push(placementObj.placement);

      // If we've tried flipping in all directions, give up and use the default placement.
      if (placementObj.attemptedFlips.length > 3) {
        placementObj = this.giveup(placementObj);
        return placementObj;
      }

      var accountForScrolling = this.accountForScrolling(placementObj);
      var isXCoord = ['left', 'right'].indexOf(placementObj.placement) > -1;
      var containerBleed = this.settings.bleedFromContainer;
      var container = this.getContainer(placementObj);
      var containerIsBody = container.length && container[0] === document.body;
      var containerRect = container ? container[0].getBoundingClientRect() : {};
      var parentRect = placementObj.parent[0].getBoundingClientRect();
      // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
      // Firefox $('body').scrollTop() will always return zero.
      var scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft();
      var scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop();
      var windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      var windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);

      function getOppositeDir(dir) {
        switch (dir) {
          case 'left':
            return 'right';
          case 'right':
            return 'left';
          case 'top':
            return 'bottom';
          default:
            // bottom
            return 'top';
        }
      }

      // Gets the distance between an edge on the target element, and its opposing viewport border
      function getDistance(dir) {
        var d = 0;

        switch (dir) {
          case 'left':
            d = (containerBleed ? 0 : containerRect.left) - (accountForScrolling ? scrollX : 0) - parentRect.left + placementObj.containerOffsetX;
            break;
          case 'right':
            d = (containerBleed ? windowW : containerRect.right) - (accountForScrolling ? scrollX : 0) - parentRect.right - placementObj.containerOffsetX;
            break;
          case 'top':
            d = (containerBleed ? 0 : containerRect.top) - (accountForScrolling ? scrollY : 0) - parentRect.top + placementObj.containerOffsetY;
            break;
          default:
            // bottom
            d = (containerBleed ? windowH : containerRect.bottom) - (accountForScrolling ? scrollY : 0) - parentRect.bottom - placementObj.containerOffsetY;
            break;
        }

        return Math.abs(d);
      }

      function tried(placement) {
        return $.inArray(placement, placementObj.attemptedFlips) > -1;
      }

      function performFlip(originalDir) {
        var newDir = getOppositeDir(originalDir);
        var perpendicularDir = isXCoord ? 'top' : 'left';
        var oppPerpendicularDir = getOppositeDir(perpendicularDir);
        var originalDistance = getDistance(originalDir);
        var targetDistance = getDistance(newDir);

        if (!tried(newDir)) {
          if (originalDistance >= targetDistance) {
            return originalDir;
          }

          placementObj.wasFlipped = true;
          return newDir;
        }

        // switch the coordinate definitions
        // since the axis for placement is flipped, our coordinate offsets should also flip
        var tmp = placementObj.originalx;
        placementObj.originalx = placementObj.originaly;
        placementObj.originaly = tmp;

        var perpendicularDistance = getDistance(perpendicularDir);
        var oppPerpendicularDistance = getDistance(oppPerpendicularDir);

        if (!tried(perpendicularDir)) {
          if (perpendicularDistance >= oppPerpendicularDistance) {
            return perpendicularDir;
          }

          if (!tried(oppPerpendicularDir)) {
            return oppPerpendicularDir;
          }
        }

        return originalDir;
      }

      placementObj.placement = performFlip(placementObj.placement);

      return placementObj;
    },


    // TODO: Move Clockwise
    clockwise: function clockwise(placementObj) {
      return placementObj;
    },


    // If element height/width is greater than window height/width, shrink to fit
    shrink: function shrink(placementObj, dimension) {
      var accountForScrolling = this.accountForScrolling(placementObj);
      var containerBleed = this.settings.bleedFromContainer;
      var container = this.getContainer(placementObj);
      var containerRect = container ? container[0].getBoundingClientRect() : {};
      var containerIsBody = container.length && container[0] === document.body;
      var rect = this.element[0].getBoundingClientRect();
      var useX = dimension === undefined || dimension === null || dimension === 'x';
      var useY = dimension === undefined || dimension === null || dimension === 'y';
      // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
      // Firefox $('body').scrollTop() will always return zero.
      var scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft();
      var scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop();
      var windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      var windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      var leftViewportEdge = (accountForScrolling ? scrollX : 0) + (containerBleed ? 0 : containerRect.left) + placementObj.containerOffsetX;
      var topViewportEdge = (accountForScrolling ? scrollY : 0) + (containerBleed ? 0 : containerRect.top) + placementObj.containerOffsetY;
      var rightViewportEdge = (accountForScrolling ? scrollX : 0) + (containerBleed ? windowW : containerRect.right) - placementObj.containerOffsetX;
      var bottomViewportEdge = (accountForScrolling ? scrollY : 0) + (containerBleed ? windowH : containerRect.bottom) - placementObj.containerOffsetY;
      var d = void 0;

      // Shrink in each direction.
      // The value of the "containerOffsets" is "factored out" of each calculation,
      // if for some reason the element is larger than the viewport/container space allowed.
      placementObj.nudges = placementObj.nudges || {};

      if (useX) {
        // Left
        if (rect.left < leftViewportEdge) {
          d = Math.abs(leftViewportEdge - rect.left);
          if (rect.right >= rightViewportEdge) {
            d -= placementObj.containerOffsetX;
          }
          placementObj.width = rect.width - d;
          placementObj.setCoordinate('x', placementObj.x + d);
          placementObj.nudges.x += d;
        }

        // Right
        if (rect.right > rightViewportEdge) {
          d = Math.abs(rect.right - rightViewportEdge);
          if (rect.left <= leftViewportEdge) {
            d -= placementObj.containerOffsetX;
          }
          placementObj.width = rect.width - d;
        }
      }

      if (useY) {
        // Top
        if (rect.top < topViewportEdge) {
          d = Math.abs(topViewportEdge - rect.top);
          if (rect.bottom >= bottomViewportEdge) {
            d -= placementObj.containerOffsetY;
          }
          placementObj.height = rect.height - d;
          placementObj.setCoordinate('y', placementObj.y + d);
          placementObj.nudges.y += d;
        }

        // Bottom
        if (rect.bottom > bottomViewportEdge) {
          d = Math.abs(rect.bottom - bottomViewportEdge);
          if (rect.top <= topViewportEdge) {
            d -= placementObj.containerOffsetY;
          }
          placementObj.height = rect.height - d;
        }
      }

      return placementObj;
    },


    // Giving up causes all the placementObj settings to revert
    giveup: function giveup(placementObj) {
      placementObj.giveup = true;
      placementObj.strategy = this.settings.strategy;
      placementObj.placement = this.settings.placement;
      return placementObj;
    },


    // Clears the old styles that may be present
    clearOldStyles: function clearOldStyles() {
      this.element[0].style.left = '';
      this.element[0].style.top = '';
      this.element[0].style.width = '';
      this.element[0].style.height = '';

      var os = this.originalStyles;
      if (os) {
        if (os.width) {
          this.element[0].style.width = os.width;
        }

        if (os.height) {
          this.element[0].style.height = os.height;
        }
      }

      return this;
    },


    // Built-in method for handling positon of optional arrow elements.
    // Used for tooltip/popovers/popupmenus
    setArrowPosition: function setArrowPosition(e, placementObj, element) {
      var target = placementObj.parent;
      var arrow = element.find('div.arrow');
      var dir = placementObj.placement;
      var isXCoord = ['left', 'right'].indexOf(dir) > -1;
      var targetRect = {};
      var elementRect = element[0].getBoundingClientRect();
      var arrowRect = {};
      var newArrowRect = {};
      var hideArrow = false;

      if (!target || !target.length || !arrow.length) {
        return;
      }

      arrow[0].removeAttribute('style');

      // if (placementObj.attemptedFlips) { TJM Removed for pager bug. Seems to work.
      element.removeClass('top right bottom left').addClass(dir);
      // }

      // Flip the arrow if we're in RTL mode
      if (this.isRTL && isXCoord) {
        var opposite = dir === 'right' ? 'left' : 'right';
        element.removeClass('right left').addClass(opposite);
      }

      // Custom target for some scenarios
      if (target.is('.colorpicker')) {
        target = target.next('.trigger');
      }
      if (target.is('.datepicker, .timepicker')) {
        target = target.next('.icon');
      }
      if (target.is('.btn-split-menu, .btn-menu, .btn-actions, .btn-filter, .tab, .tab-more')) {
        target = target.find('.icon').last();
      }
      if (target.is('.searchfield-category-button')) {
        target = target.find('.icon.icon-dropdown');
      }
      if (target.is('.colorpicker-editor-button')) {
        target = target.find('.trigger .icon');
      }

      // reset if we borked the target
      if (!target.length) {
        target = placementObj.parent;
      }

      targetRect = target.length ? target[0].getBoundingClientRect() : targetRect;
      arrowRect = arrow.length ? arrow[0].getBoundingClientRect() : arrowRect;
      newArrowRect = {};

      function getMargin(placement) {
        return placement === 'right' || placement === 'left' ? 'margin-top' : 'margin-left';
      }

      function getDistance() {
        var targetCenter = 0;
        var currentArrowCenter = 0;
        var d = 0;

        if (dir === 'left' || dir === 'right') {
          targetCenter = targetRect.top + targetRect.height / 2;
          currentArrowCenter = arrowRect.top + arrowRect.height / 2;
          d = targetCenter - currentArrowCenter;
          newArrowRect.top = arrowRect.top + d;
          newArrowRect.bottom = arrowRect.bottom + d;

          if (newArrowRect.top <= elementRect.top || newArrowRect.bottom >= elementRect.bottom) {
            hideArrow = true;
          }
        }
        if (dir === 'top' || dir === 'bottom') {
          targetCenter = targetRect.left + targetRect.width / 2;
          currentArrowCenter = arrowRect.left + arrowRect.width / 2;
          d = targetCenter - currentArrowCenter;
          newArrowRect.left = arrowRect.left + d;
          newArrowRect.right = arrowRect.right + d;

          if (newArrowRect.left <= elementRect.left || newArrowRect.right >= elementRect.right) {
            hideArrow = true;
          }
        }

        return d;
      }

      // line the arrow up with the target element's "dropdown icon", if applicable
      var positionOpts = {};
      positionOpts[getMargin(dir)] = getDistance();
      if (hideArrow) {
        positionOpts.display = 'none';
      }
      arrow.css(positionOpts);
    },


    // Handle Updating Settings
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },


    // Simple Teardown - remove events & rebuildable markup.
    teardown: function teardown() {
      this.clearOldStyles();
      this.element.removeClass('placeable');

      this.element.off('updated.' + COMPONENT_NAME$3 + ' place.' + COMPONENT_NAME$3);

      this.element.trigger('afterteardown');
      return this;
    },


    // Teardown - Remove added markup and events
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$3);
    }
  };

  /**
   * jQuery Component Wrapper for Place
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.place = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$3);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$3, new Place(this, settings));
      }
    });
  };

  // component name
  var COMPONENT_NAME$4 = 'icon';

  // Default Options
  var ICON_DEFAULTS = {
    use: 'user-profile', // Match this to one of the SoHo Xi icons, prefixed with an ID of '#icon-'
    focusable: false
  };

  /**
   * Icon Control
   * Wraps SVG Icons with a Javascript control that can change the icon type, reference
   * relative or absolute URLs, and clean up after itself.  Works with the Base tag.
   * @constructor
   * @param {jQuery[]|HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   * @param {string} [settings.use = 'user-profile'] the type of icon that will appear.
   *  (gets added to the `<use>` tag's `xlink:href` property)
   * @param {boolean} [settings.focusable = false] whether or not this icon gets a `tabIndex` and
   *  becomes a focusable element on the page.
   */
  function Icon(element, settings) {
    this.settings = utils.mergeSettings(element, settings, ICON_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Icon.prototype = {

    /**
     * @private
     * @chainable
     * @returns {this} component instance
     */
    init: function init() {
      this.getExistingUseTag();

      // Do other init (change/normalize settings, load externals, etc)
      return this.render().handleEvents();
    },


    /**
     * Add markup to the control
     * @private
     * @chainable
     * @returns {this} component instance
     */
    render: function render() {
      var self = this;
      this.element.addClass('icon');

      if (!this.element.is('svg')) {
        // TODO: Possibly work with span-based icons here?
        return this;
      }

      // Get a "base-tag-proof" version of the Use tag's definition.
      // jQuery can't work with SVG elements, so we just modify it with regular DOM APIs
      var use = this.element[0].getElementsByTagName('use')[0];
      if (!use) {
        return this;
      }

      if (use.getAttribute('xlink:href') !== self.getBasedUseTag()) {
        use.setAttribute('xlink:href', self.getBasedUseTag());
      }

      return this;
    },


    /**
     * Gets the currently used base tag.
     * @returns {string} a version of this icon's definition prefixed with the current base tag's URL.
     */
    getBasedUseTag: function getBasedUseTag() {
      return base.getBaseURL('#icon-' + this.settings.use);
    },


    /**
     * Changes this icon instance's `use` setting to match an existing `<use> tag's
     * `xlink:href` attribute. In the event that a <use> tag pre-exists on an icon,
     * we want to retain it, and simply replace the settings.
     * @chainable
     * @returns {this} component instance
     */
    getExistingUseTag: function getExistingUseTag() {
      if (!this.element.is('svg')) {
        return this;
      }

      var useTag = this.element.children('use');
      if (!useTag.length) {
        return this;
      }

      var xlinkHref = useTag.attr('xlink:href');
      this.settings.use = xlinkHref.replace('#icon-', '');

      return this;
    },


    /**
     * Sets up event handlers for this control and its sub-elements
     * @private
     * @chainable
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.on('updated.' + COMPONENT_NAME$4, function () {
        self.updated();
      });

      return this;
    },


    /**
     * Handle Updating Settings
     * @chainable
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      return this.teardown().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @chainable
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$4);
      return this;
    },


    /**
     * Teardown - Remove added markup and events
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$4);
    }
  };

  /**
   * jQuery component wrappers
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on.
   */
  $.fn.icon = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$4);
      if (!instance) {
        instance = $.data(this, COMPONENT_NAME$4, new Icon(this, settings));
      } else {
        instance.updated(settings);
      }
    });
  };

  /**
   * Factory Function for instantly building icons.
   * Use this for building icons that don't exist yet.
   * Scoped Privately on purpose...
   */
  (function () {
    function normalizeIconOptions(options) {
      var defaults = {
        icon: 'user-profile', // omit the "icon-" if you want; this code strips it out.
        classes: ['icon']
      };
      options = options || $.extend({}, defaults);

      if (typeof options === 'string') {
        options = $.extend({}, defaults, {
          icon: options.replace('icon-', '')
        });
      }

      // reroute "options.class" if that exists
      if (!options.classes && options.class) {
        options.classes = options.class;
        delete options.class;
      }

      if (!options.classes) {
        options.classes = [].concat(defaults.classes);
      }

      if (typeof options.classes === 'string') {
        options.classes = options.classes.split(' ');
      }

      if (options.classes.indexOf('icon') === -1) {
        options.classes.push('icon');
      }

      return options;
    }

    // Returns the RAW HTML for creating a new icon in string form
    $.createIcon = function createIcon(options) {
      options = normalizeIconOptions(options);

      return ['<svg class="' + options.classes.join(' ') + '" focusable="false" aria-hidden="true" role="presentation">' + ('<use xlink:href="#icon-' + options.icon + '"></use>') + '</svg>'].join('');
    };

    // Returns a jQuery-wrapped element containing a new icon
    $.createIconElement = function createIconElement(options) {
      return $($.createIcon(options));
    };

    // Returns just the path part
    $.createIconPath = function createIconElement(options) {
      options = normalizeIconOptions(options);
      return $.getBaseURL('#icon-' + options.icon.replace('icon-', ''));
    };

    // Toggle the use or entire svg icon in the case of the polyfill
    $.fn.changeIcon = function (icon) {
      $(this).find('use').attr('xlink:href', $.createIconPath({ icon: icon }));
    };

    $.fn.getIconName = function () {
      var svg = $(this);
      var use = svg.find('use');

      if (use.length === 1) {
        return use.attr('xlink:href').substr(use.attr('xlink:href').indexOf('#icon-') + 6);
      }
      return svg.attr('data-icon');
    };
  })();

  // The name of this component.
  var COMPONENT_NAME$5 = 'button';

  /**
   * Soho Button Element
   * @class Button
   * @param {string} element The component element.
   * @param {string} [settings] The component settings.
   * @param {string} [settings.toggleOnIcon=null]  The icon to use for on state on toggle buttons
   * @param {string} [settings.toggleOffIcon=null]  The icon to use for off state on toggle buttons
   * @param {string} [settings.replaceText=false]  If true the selection will be used to replace the content
   */
  var BUTTON_DEFAULTS = {
    toggleOnIcon: null,
    toggleOffIcon: null,
    replaceText: false
  };

  function Button(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(element, settings, BUTTON_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Button.prototype = {
    init: function init() {
      var self = this;

      this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      this.isSafari = $('html').is('.is-safari');
      this.isFirefox = $('html').is('.is-firefox');

      if (this.element.hasClass('no-ripple')) {
        return;
      }

      if (this.element.hasClass('btn-menu') && !this.element.hasClass('btn-icon') && !this.element.hasClass('btn-actions')) {
        var ddIcon = this.element.children('svg.icon');
        var use = ddIcon.find('use');
        var hasIcon = false;

        if (ddIcon.length > 0 && use.length === 1) {
          hasIcon = use.attr('xlink:href').indexOf('#icon-dropdown') > -1;
        }

        if (!hasIcon) {
          ddIcon = $.createIconElement({ icon: 'dropdown', classes: ['icon-dropdown'] });
          this.element.append(ddIcon);
        }

        if (!ddIcon.hasClass('icon-dropdown')) {
          ddIcon.addClass('icon-dropdown');
        }

        if (this.settings.replaceText) {
          this.element.on('selected.content', function (e, a) {
            $(this).find('span').text(a.text());
          });
        }
      }

      if (this.element.hasClass('btn-toggle') || this.element.hasClass('icon-favorite')) {
        this.element.on('click.favorite', function () {
          var elem = $(this);
          var svg = elem.find('svg:not(.ripple-effect)');
          var isPressed = elem.attr('aria-pressed') === 'true';

          elem.attr('aria-pressed', isPressed ? 'false' : 'true');
          if (self.settings.toggleOffIcon && self.settings.toggleOnIcon) {
            svg.changeIcon(isPressed ? self.settings.toggleOffIcon : self.settings.toggleOnIcon);
          } else {
            elem.toggleClass('is-pressed');
          }

          if (elem.hasClass('icon-favorite') && !elem.hasClass('btn-toggle') && svg.find('use').attr('xlink:href') === '#icon-star-filled') {
            svg.changeIcon('star-outlined');
          } else if (elem.hasClass('icon-favorite') && !elem.hasClass('btn-toggle')) {
            svg.changeIcon('star-filled');
          }
        });

        if (!this.element.attr('aria-pressed')) {
          this.element.attr('aria-pressed', 'false');
        }
      }

      // Standalone action buttons need a "More Actions" tooltip.
      // This is handled internally on most components that implement an action button.
      if (this.element.hasClass('btn-actions') && !this.element.parents('.field').length && !this.element.parents('.toolbar').length) {
        if (!this.element.data('tooltip')) {
          this.element.attr('title', Locale.translate('More')).tooltip({
            content: Locale.translate('More')
          });
        }
      }

      this.element.hideFocus();

      this.element.on('touchstart.button click.button', function (e) {
        if (self.element.attr('disabled') || self.element.is('.is-disabled') || !self.isTouch && e.which !== 1 || $('.ripple-effect', this).length || self.isTouch && e.type !== 'touchstart') {
          return;
        }

        var element = $(this);
        var btnOffset = element.offset();
        var xPos = e.pageX - btnOffset.left;
        var yPos = e.pageY - btnOffset.top;
        var ripple = $('<svg class="ripple-effect" focusable="false" aria-hidden="true" role="presentation"><circle r="0" class="ripple-circle"></circle></svg>');

        if (self.isTouch) {
          // Make sure the user is using only one finger and then get the touch position relative
          // to the ripple wrapper
          e = e.originalEvent;
          if (e && e.touches && e.touches.length === 1) {
            xPos = e.touches[0].pageX - btnOffset.left;
            yPos = e.touches[0].pageY - btnOffset.top;
          }
        }

        // Using keyboard to click
        xPos = xPos < 0 ? self.element.outerWidth() / 2 : xPos;
        yPos = yPos < 0 ? self.element.outerHeight() / 2 : yPos;

        $('svg.ripple-effect', element).remove();
        ripple[0].style.left = xPos + 'px';
        ripple[0].style.top = yPos + 'px';
        element.prepend(ripple);

        // Start the JS Animation Loop if IE9
        // Or Safari/Firefox has bug with combination like: animation, overflow, position,
        // border-radius etc.)
        if (!$.fn.cssPropSupport('animation') || self.isSafari && !Environment.features.touch || self.isFirefox) {
          ripple.removeClass('is-animation');
          self.animateWithJS(ripple);
        } else {
          var elem = $('svg.ripple-effect', element);
          elem.addClass('is-animation');
        }

        setTimeout(function () {
          ripple.remove();
        }, 1000);
      });
    },


    // Browsers that don't support CSS-based animation can still show the animation
    animateWithJS: function animateWithJS(el) {
      var scale = 200;
      var elStyle = el[0].style;
      var xPos = parseFloat(elStyle.left) - scale / 2 + 'px';
      var yPos = parseFloat(elStyle.top) - scale / 2 + 'px';

      el[0].style.opacity = '0.4';
      el.animate({
        opacity: 0,
        left: xPos,
        top: yPos,
        width: scale,
        height: scale
      }, 1000);
    },


    /**
     * Update the component with new settings.
     * @param  {object} settings The settings you would like to modify.
     * @returns {object} The api.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.extend({}, this.settings, settings);
      }
      return this;
    },


    /**
    * Teardown and remove any added markup and events.
    * @returns {void}
    */
    destroy: function destroy() {
      this.element.off('click.button touchstart.button focusin.hide-focus focusout.hide-focus mousedown.hide-focus touchstart.hide-focus');

      var moreTooltip = this.element.data('tooltip');
      if (this.element.hasClass('btn-actions') && moreTooltip) {
        moreTooltip.destroy();
      }

      $.removeData(this.element[0], COMPONENT_NAME$5);
    }
  };

  /**
   * jQuery Component Wrapper for the Soho Button Element
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */
  $.fn.button = function jQueryButton(settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$5);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$5, new Button(this, settings));
      }
    });
  };

  var COMPONENT_NAME$6 = 'hyperlink';

  /**
   * Soho component wrapper for Hyperlinks.
   * @class Hyperlink
   *
   * @param {HTMLElement} element the base Hyperlink element
   * @param {object} [settings] incoming settings
   * @returns {this} component instance
   */

  var HYPERLINK_DEFAULTS = {};

  function Hyperlink(element, settings) {
    return this.init(element, settings);
  }

  Hyperlink.prototype = {
    init: function init(element, settings) {
      if (!this.element && element instanceof HTMLElement) {
        this.element = element;
      }

      if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {
        var previousSettings = this.settings || HYPERLINK_DEFAULTS;
        this.settings = utils.mergeSettings(this.element, settings, previousSettings);
      }

      if (!this.focusBehavior) {
        this.focusBehavior = new HideFocus(this.element);
      }

      return this;
    },


    /**
     * Attach Events used by the Hyperlinks
     * @private
     * @returns {this} The component api for chaining.
     */
    handleEvents: function handleEvents() {
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      return this.teardown().init();
    },


    /**
     * Removes the events and pseudo-markup created by the hyperlinks
     * @returns {this} component instance
     */
    teardown: function teardown() {
      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Hyperlink
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */
  $.fn.hyperlink = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$6);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$6, new Hyperlink(this, settings));
        instance.destroy = function destroy() {
          this.teardown();
          $.removeData(this, COMPONENT_NAME$6);
        };
      }
    });
  };

  /**
   * Contains various Mask-related utilities, settings, masking functions, etc.
   * Available globally under `Soho.masks`.
   * @property {string} EMPTY_STRING just an empty string
   * @property {string} PLACEHOLDER_CHAR the default placeholder used in guides
   * @property {string} CARET_TRAP the string of characters representing a caret trap in mask arrays
   * @property {regexp} NON_DIGITS_REGEX regular expression that matches non-digit characters
   * @property {regexp} DIGITS_REGEX regular expression that matches digit characters
   * @property {regexp} ALPHAS_REGEX regular expression that matches alphabetic, non-special characters
   * @property {regexp} ANY_REGEX regular expression that matches any non-special characters
   * @property {object} LEGACY_DEFS mask definitions used by the old Soho Mask component.
   *  Will be translated to RegExp when a string-based pattern is convered to an array in the new Mask.
   * @property {object} DEFAULT_API_OPTIONS base options passed to a Mask API.
   * @property {object} DEFAULT_CONFORM_OPTIONS default set of options that get passed to `maskAPI.conformToMask()`
   */
  var masks = {

    EMPTY_STRING: '',

    PLACEHOLDER_CHAR: '_',

    CARET_TRAP: '[]',

    NON_DIGITS_REGEX: /\D+/g,

    DIGITS_REGEX: /\d/,

    ALPHAS_REGEX: /[\u00C0-\u017Fa-zA-Z]/,

    ANY_REGEX: /[\u00C0-\u017Fa-zA-Z0-9]/,

    DEFAULT_API_OPTIONS: {
      locale: 'en-US',
      pattern: undefined,
      pipe: undefined
    }

  };

  // Legacy Mask pattern definitions.
  // The New Mask works based on an array of RegExps and Strings.
  masks.LEGACY_DEFS = {
    '#': /[0-9]/,
    0: /[0-9]/,
    x: masks.ALPHAS_REGEX,
    '*': masks.ANY_REGEX,
    '?': /./,
    '~': /[-0-9]/,
    a: /[APap]/,
    m: /[Mm]/
  };

  // Default options that get passed for the _conformToMask()_ method.
  masks.DEFAULT_CONFORM_OPTIONS = {
    caretTrapIndexes: [],
    guide: true,
    previousMaskResult: masks.EMPTY_STRING,
    placeholderChar: masks.PLACEHOLDER_CHAR,
    placeholder: masks.EMPTY_STRING,
    selection: {
      start: 0
    },
    keepCharacterPositions: true
  };

  // Default Number Mask Options
  var DEFAULT_NUMBER_MASK_OPTIONS = {
    prefix: masks.EMPTY_STRING,
    suffix: masks.EMPTY_STRING,
    allowThousandsSeparator: true,
    symbols: {
      currency: '$',
      decimal: '.',
      negative: '-',
      thousands: ','
    },
    allowDecimal: true,
    decimalLimit: 2,
    requireDecimal: false,
    allowNegative: false,
    allowLeadingZeroes: false,
    integerLimit: null
  };

  // Converts a string representing a formatted number into a Number Mask.
  // @param {string} strNumber incoming string
  // @returns {array} contains strings representing character literals and regex patterns.
  function convertToMask(strNumber) {
    return strNumber.split(masks.EMPTY_STRING).map(function (char) {
      return masks.DIGITS_REGEX.test(char) ? masks.DIGITS_REGEX : char;
    });
  }

  // Adds thousands separators to the correct spot in a formatted number string.
  // @param {string} n - the string
  // @param {string} thousands - the thousands separator.
  // @returns {string} the incoming string formatted with a thousands separator.
  // http://stackoverflow.com/a/10899795/604296
  function addThousandsSeparator(n, thousands) {
    return n.replace(/\B(?=(\d{3})+(?!\d))/g, thousands);
  }

  // Gets an array of Regex objects matching the number of digits present in a source string
  // @param {string} part string representing the mark part.
  // @param {string} type 'any', 'digits', or 'alphas'
  // @returns {array} regex representing the part that was passed in.
  function getRegexForPart(part, type) {
    var types = {
      any: masks.ANY_REGEX,
      digits: masks.DIGITS_REGEX,
      alphas: masks.ALPHAS_REGEX
    };

    if (!types[type]) {
      type = 'any';
    }

    var size = part.toString().length;
    var arr = [];

    while (size > 0) {
      arr.push(types[type]);
      size -= 1;
    }
    return arr;
  }

  /**
   * Soho Number Mask Function
   * @param {string} rawValue the un-formatted value that will eventually be masked.
   * @param {object} options masking options
   * @returns {array} representing a mask that will match a formatted number.
   */
  masks.numberMask = function sohoNumberMask(rawValue, options) {
    options = utils.mergeSettings(undefined, options, DEFAULT_NUMBER_MASK_OPTIONS);

    var PREFIX = options.prefix;
    var SUFFIX = options.suffix;
    var DECIMAL = options.symbols.decimal;
    var THOUSANDS = options.symbols.thousands;
    var prefixLength = PREFIX && PREFIX.length || 0;
    var suffixLength = SUFFIX && SUFFIX.length || 0;
    var thousandsSeparatorSymbolLength = THOUSANDS && THOUSANDS.length || 0;

    function numberMask(thisRawValue) {
      if (typeof thisRawValue !== 'string') {
        thisRawValue = masks.EMPTY_STRING;
      }

      var rawValueLength = thisRawValue.length;

      if (thisRawValue === masks.EMPTY_STRING || thisRawValue[0] === PREFIX[0] && rawValueLength === 1) {
        return PREFIX.split(masks.EMPTY_STRING).concat([masks.DIGITS_REGEX]).concat(SUFFIX.split(masks.EMPTY_STRING));
      } else if (thisRawValue === DECIMAL && options.allowDecimal) {
        return PREFIX.split(masks.EMPTY_STRING).concat(['0', DECIMAL, masks.DIGITS_REGEX]).concat(SUFFIX.split(masks.EMPTY_STRING));
      }

      var indexOfLastDecimal = thisRawValue.lastIndexOf(DECIMAL);
      var hasDecimal = indexOfLastDecimal !== -1;
      var isNegative = thisRawValue[0] === options.symbols.negative && options.allowNegative;
      var integer = void 0;
      var fraction = void 0;
      var mask = void 0;

      // remove the suffix
      if (thisRawValue.slice(suffixLength * -1) === SUFFIX) {
        thisRawValue = thisRawValue.slice(0, suffixLength * -1);
      }

      if (hasDecimal) {
        integer = thisRawValue.slice(thisRawValue.slice(0, prefixLength) === PREFIX ? prefixLength : 0, indexOfLastDecimal);

        fraction = thisRawValue.slice(indexOfLastDecimal + 1, rawValueLength);
        fraction = convertToMask(fraction.replace(masks.NON_DIGITS_REGEX, masks.EMPTY_STRING));
      } else if (thisRawValue.slice(0, prefixLength) === PREFIX) {
        integer = thisRawValue.slice(prefixLength);
      } else {
        integer = thisRawValue;
      }

      if (options.integerLimit && typeof options.integerLimit === 'number') {
        var thousandsSeparatorRegex = THOUSANDS === '.' ? '[.]' : '' + THOUSANDS;
        var numberOfThousandSeparators = (integer.match(new RegExp(thousandsSeparatorRegex, 'g')) || []).length;

        integer = integer.slice(0, options.integerLimit + (isNegative ? 1 : 0) + numberOfThousandSeparators * thousandsSeparatorSymbolLength);
      }

      integer = integer.replace(masks.NON_DIGITS_REGEX, masks.EMPTY_STRING);

      if (!options.allowLeadingZeroes) {
        integer = integer.replace(/^0+(0$|[^0])/, '$1');
      }

      integer = options.allowThousandsSeparator ? addThousandsSeparator(integer, THOUSANDS) : integer;

      mask = convertToMask(integer);

      if (hasDecimal && options.allowDecimal || options.requireDecimal === true) {
        if (thisRawValue[indexOfLastDecimal - 1] !== DECIMAL) {
          mask.push(masks.CARET_TRAP);
        }

        mask.push(DECIMAL, masks.CARET_TRAP);

        if (fraction) {
          if (typeof options.decimalLimit === 'number') {
            fraction = fraction.slice(0, options.decimalLimit);
          }

          mask = mask.concat(fraction);
        }

        if (options.requireDecimal === true && thisRawValue[indexOfLastDecimal - 1] === DECIMAL) {
          mask.push(masks.DIGITS_REGEX);
        }
      }

      if (prefixLength > 0) {
        mask = PREFIX.split(masks.EMPTY_STRING).concat(mask);
      }

      if (isNegative) {
        // If user is entering a negative number, add a mask placeholder spot to
        // attract the caret to it.
        // TODO: Allow the negative symbol as the suffix as well (SOHO-3259)
        if (mask.length === prefixLength) {
          mask.push(masks.DIGITS_REGEX);
        }

        mask = [/-/].concat(mask);
      }

      if (SUFFIX.length > 0) {
        mask = mask.concat(SUFFIX.split(masks.EMPTY_STRING));
      }

      return mask;
    }

    numberMask.instanceOf = 'createNumberMask';

    return numberMask(rawValue);
  };

  // Default Date Mask Options
  var DEFAULT_DATETIME_MASK_OPTIONS = {
    format: 'M/d/yyyy',
    symbols: {
      timeSeparator: ':',
      dayPeriodSeparator: ' ',
      dateSeparator: '/'
    }
  };

  // Maximum Values for various section maps of date strings.
  var DATE_MAX_VALUES = {
    dd: 31,
    d: 31,
    MMM: undefined,
    MM: 12,
    M: 12,
    yy: 99,
    yyyy: 9999,
    h: 12,
    hh: 12,
    H: 24,
    HH: 24,
    mm: 60,
    ss: 60,
    a: undefined
  };

  /**
   * Soho Date Mask Function
   * @param {string} rawValue the un-formatted value that will eventually be masked.
   * @param {object} options masking options
   * @returns {array} representing a mask that will match a formatted date.
   */
  masks.dateMask = function dateMask(rawValue, options) {
    options = utils.mergeSettings(undefined, options, DEFAULT_DATETIME_MASK_OPTIONS);

    var mask = [];
    var digitRegex = masks.DIGITS_REGEX;
    var format = options.format;
    var splitterStr = stringUtils.removeDuplicates(format.replace(/[dMyHhmsa]+/g, ''));
    var splitterRegex = new RegExp('[' + splitterStr + ']+');
    var formatArray = format.split(/[^dMyHhmsa]+/);
    var rawValueArray = rawValue.split(splitterRegex);
    var maxValue = DATE_MAX_VALUES;

    formatArray.forEach(function (part, i) {
      var value = maxValue[part];
      var size = void 0;

      if (part === 'a') {
        // Match the day period
        mask.push(/[aApP]/, /[Mm]/);
      } else if (!value) {
        mask = mask.concat(getRegexForPart(part, 'alphas'));
      } else if (rawValueArray[i]) {
        // Detect based on the size of a pre-existing formatted value, if possible.
        var rawValueStr = rawValueArray[i].toString();
        var rawValueFirstDigit = parseInt(rawValueStr.substr(0, 1), 10);
        var maxFirstDigit = parseInt(maxValue[part].toString().substr(0, 1), 10);

        if (part.length === 1 && rawValueFirstDigit > maxFirstDigit) {
          mask.push(digitRegex);
        } else if (rawValueStr !== '0' && rawValueStr.length === 1 && rawValueFirstDigit <= maxFirstDigit && rawValueArray[i + 1] !== undefined && part.toUpperCase() !== 'HH') {
          mask.push(digitRegex);
        } else {
          mask = mask.concat(getRegexForPart(value, 'digits'));
        }
      } else {
        // If NOT possible, pass back the maximum digit length that can be entered here
        size = value.toString().length;
        while (size > 0) {
          mask.push(digitRegex);
          size -= 1;
        }
      }

      // If this is not the last part, add whatever literals come after this part,
      // but before the next part.
      var nextPart = formatArray[i + 1];
      if (nextPart !== undefined) {
        var thisPartSize = part.toString().length;
        var start = format.indexOf(part) + thisPartSize;
        var end = format.indexOf(nextPart);
        var literals = format.substring(start, end).split(masks.EMPTY_STRING);

        mask = mask.concat(literals);
      }
    });

    return mask;
  };

  /**
   * Soho Range Date Mask Function
   * @param {string} rawValue the un-formatted value that will eventually be masked.
   * @param {object} options masking options
   * @returns {array} representing a mask that will match a formatted date.
   */
  masks.rangeDateMask = function (rawValue, options) {
    var parts = rawValue.split(options.delimeter);
    var delimiterArr = options.delimeter.split('');
    var firstDate = masks.dateMask(parts[0], options);
    var secondDate = [];

    if (parts[1]) {
      secondDate = masks.dateMask(parts[1], options);
    }

    return firstDate.concat(delimiterArr.concat(secondDate));
  };

  /**
   * Generates a pipe function that can be applied to a Mask API that will correct
   * shorthand numeric dates.
   * NOTE: DOES NOT WORK FOR DATES WITH ALPHABETIC CONTENT. Do not use this if your
   * dates contain "MMM" or the full month name.
   * @param {object} processResult the results object of a mask process
   * @param {object} options settings for the date pipe function
   * @returns {object} the result of the piping function's changes
   */
  masks.autocorrectedDatePipe = function autoCorrectedDatePipe(processResult, options) {
    if (!options.dateFormat) {
      options.dateFormat = Locale.calendar().dateFormat.short;
    }

    var indexesOfPipedChars = [];
    var dateFormatArray = options.dateFormat.split(/[^dMy]+/);
    var maxValue = { d: 31, M: 12, yy: 99, yyyy: 9999 };
    var minValue = { d: 1, M: 1, yy: 0, yyyy: 1 };
    var conformedValueArr = processResult.conformedValue.split('');

    // Check first digit
    dateFormatArray.forEach(function (format) {
      var position = options.dateFormat.indexOf(format);
      var maxFirstDigit = parseInt(maxValue[format].toString().substr(0, 1), 10);

      if (parseInt(conformedValueArr[position], 10) > maxFirstDigit) {
        conformedValueArr[position + 1] = conformedValueArr[position];
        conformedValueArr[position] = 0;
        indexesOfPipedChars.push(position);
      }
    });

    var placeholderRegex = new RegExp('[^' + processResult.placeholderChar + ']');
    var maskPieces = processResult.placeholder.split(placeholderRegex);
    var conformedPieces = processResult.conformedValue.split(/\D/g);

    // Check for invalid date
    var isInvalid = dateFormatArray.some(function (format, i) {
      var length = maskPieces[i].length > format.length ? maskPieces[i].length : format.length;
      var textValue = conformedPieces[i] || '';
      var value = parseInt(textValue, 10);

      return value > maxValue[format] || textValue.length === length && value < minValue[format];
    });

    if (isInvalid) {
      return false;
    }

    return {
      value: conformedValueArr.join(''),
      characterIndexes: indexesOfPipedChars
    };
  };

  /* eslint-disable no-continue, no-underscore-dangle, no-restricted-syntax, no-labels */

  /**
   * @class MaskAPI
   * @constructor
   * @param {object} [settings] incoming settings
   */
  function MaskAPI(settings) {
    this.configure(settings);
    return this;
  }

  MaskAPI.prototype = {

    /**
     * Configure the API for an incoming mask request.
     * Set up patterns, change locale, basically 'pre-render'
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    configure: function configure(settings) {
      if (!this.settings) {
        this.settings = {};
      }

      if (!settings) {
        return this;
      }

      if (settings.locale) {
        // TODO: store references to thousands sep, decimal, currency symbols,
        // etc for the specified locale.
        this.locale = settings.locale;
      }

      // Pre-define a stored Mask pattern.
      // In cases where the mask is a string (Legacy Soho Mask), the string is automatically converted
      // to an array containing regex patterns.
      // In cases where the mask is a function, the function call is stored and called when the mask
      // needs to be processed.
      if (settings.pattern) {
        if (Array.isArray(settings.pattern) || typeof settings.pattern === 'function') {
          this.pattern = settings.pattern;
        } else if (typeof settings.pattern === 'string') {
          var defs = utils.mergeSettings(undefined, settings.definitions || {}, masks.LEGACY_DEFS);
          this.pattern = this._convertPatternFromString(settings.pattern, defs);
        }
      }

      if (settings.patternOptions) {
        this.patternOptions = settings.patternOptions;
      }

      return this;
    },


    /**
     * Process a string against the masking algorithm
     * @param {string} rawValue the original, unmasked value
     * @param {object} [opts] process options
     * @returns {object} containing the processed mask along with some meta-data
     */
    process: function process(rawValue, opts) {
      if (typeof rawValue !== 'string') {
        throw new Error('No string provided');
      }

      var providedMask = void 0;
      var processResult = {
        originalValue: rawValue,
        caretPos: opts.selection.start,
        maskResult: false
      };

      // Setup the pattern if it's a function.
      if (typeof this.pattern === 'function') {
        if (!opts.patternOptions) {
          opts.patternOptions = {};
        }

        // Merge incoming settings
        var maskOpts = utils.extend({}, this.patternOptions, opts.patternOptions, {
          caretPos: opts.selection.start,
          previousMaskResult: opts.previousMaskResult
        });

        // Get a processed mask pattern from the function
        providedMask = this.pattern(rawValue, maskOpts);

        // mask functions can setup caret traps to have some control over how the caret
        // moves. We need to process the mask for any caret traps. `processCaretTraps`
        // will remove the caret traps from the mask and return the indexes of the caret traps.
        var caretTrapInfo = this._processCaretTraps(providedMask);

        // The processed mask is what we're interested in
        providedMask = caretTrapInfo.maskWithoutCaretTraps;

        // And we need to store these indexes because they're needed by `adjustCaretPosition`
        opts.caretTrapIndexes = caretTrapInfo.indexes;
      } else {
        // Use a provided array
        providedMask = this.pattern;
      }

      // As a convenience, setting the mask to false will cause it to return without processing.
      if (providedMask === false) {
        return processResult;
      }

      try {
        processResult = this._conformToMask(rawValue, providedMask, opts);
      } catch (e) {
        // console.error('Couldn\'t complete masking process: "'+ e.message +'"');
        return processResult;
      }

      // Handle the optional "pipe" cleanup method, if applicable.
      if (typeof opts.pipe === 'function') {
        var pipeResult = {};

        // `pipe` receives the entire `processResult` object and the configurations with which
        // `conformToMask` was called.
        try {
          pipeResult = opts.pipe(processResult, opts);
        } catch (e) {
          // console.error('Couldn\'t complete mask\'s pipe function: "'+ e.message +'"');
          pipeResult = false;
        }

        // `pipeResults` should be an object. But as a convenience, we allow the pipe
        // author to just return `false` to indicate rejection. Or return just a string when there
        // are no piped characters.
        // If the `pipe` returns `false` or a string, the block below turns it into an
        // object that the rest of the code can work with.
        if (pipeResult === false) {
          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`,
          // and set `rejected` to `true`.
          processResult.pipeResult = false;
          processResult.pipedValue = opts.previousMaskResult;
        } else if (utils.isString(pipeResult)) {
          processResult.pipeResult = true;
          processResult.pipedValue = pipeResult;
          processResult.pipedCharIndexes = [];
        } else {
          processResult = utils.extend({}, processResult, {
            pipeResult: pipeResult.result,
            pipedValue: pipeResult.value,
            pipedCharIndexes: pipeResult.characterIndexes
          });
        }
      }

      return processResult;
    },


    /**
     * Processes a raw string value against a masking algorithm and removes unfavorable chracters.
     * @private
     * @param {string} rawValue incoming full text string to process.
     * @param {array} mask the mask to be used for modifying the raw value.
     * @param {object} [settings] incoming settings for mask parsing.
     * @returns {object} containing the conformation result and some meta-data
     */
    _conformToMask: function _conformToMask(rawValue, mask, settings) {
      // Set default settings
      settings = utils.mergeSettings(undefined, settings, masks.DEFAULT_CONFORM_OPTIONS);

      // Setup the placeholder version of the mask
      settings.placeholder = this._convertMaskToPlaceholder(mask, settings.placeholderChar);

      // Setup booleans and numbers for various settings (speed)
      var charactersRejected = false;
      var suppressGuide = settings.guide === false && settings.previousMaskResult !== undefined;
      var rawValueLength = rawValue.length;
      var prevMaskResultLength = settings.previousMaskResult.length;
      var maskLength = this.pattern.length;
      var placeholderLength = settings.placeholder.length || 0;
      var placeholderChar = settings.placeholderChar;
      var caretPos = settings.selection.start;
      var resultStr = masks.EMPTY_STRING;

      var editDistance = rawValueLength - prevMaskResultLength;
      var isAddition = editDistance > 0;
      var indexOfFirstChange = caretPos + (isAddition ? -editDistance : 0);
      var indexOfLastChange = indexOfFirstChange + Math.abs(editDistance);

      // If `_conformToMask()` is configured to keep character positions, that is,
      // for mask 111, previous value _2_ and raw value 3_2_, the new conformed value
      // should be 32_, not 3_2 (default behavior). That's in the case of addition.
      // And in the case of deletion, previous value _23, raw value _3, the new conformed
      // string should be __3, not _3_ (default behavior)
      //
      // The next block of logic handles keeping character positions for the case
      // of deletion. (Keeping character positions for the case of addition is further
      // down since it is handled differently.)
      // To do this, we want to compensate for all characters that were deleted
      if (settings.keepCharacterPositions === true && !isAddition) {
        // We will be storing the new placeholder characters in this variable.
        var compensatingPlaceholderChars = masks.EMPTY_STRING;

        // For every character that was deleted from a placeholder position, we add a placeholder char
        for (var i = indexOfFirstChange; i < indexOfLastChange; i++) {
          if (settings.placeholder[i] === placeholderChar) {
            compensatingPlaceholderChars += placeholderChar;
          }
        }

        // Now we trick our algorithm by modifying the raw value to make it contain
        // additional placeholder characters. That way when the we start laying the
        // characters again on the mask, it will keep the non-deleted characters
        // in their positions.
        rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);
      }

      // Convert `rawValue` string to an array, and mark characters based on whether
      // they are newly added or have existed in the previous conformed value. Identifying new
      // and old characters is needed for `_conformToMask()` to work if it is configured
      // to keep character positions.
      function markAddedChars(char, j) {
        return {
          char: char,
          isNew: j >= indexOfFirstChange && j < indexOfLastChange
        };
      }
      var rawValueArr = rawValue.split(masks.EMPTY_STRING).map(markAddedChars);

      // The loop below removes masking characters from user input. For example, for mask
      // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below
      // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm
      // then would lay `234` on top of the available placeholder positions in the mask.
      for (var k = rawValueLength - 1; k >= 0; k--) {
        var char = rawValueArr[k];

        if (char !== settings.placeholderChar) {
          var shouldOffset = k >= indexOfFirstChange && prevMaskResultLength === maskLength;

          if (char === settings.placeholder[shouldOffset ? k - editDistance : k]) {
            rawValueArr.splice(k, 1);
          }
        }
      }

      // Loop through the placeholder string to find characters that need to be filled.
      placeholderLoop: for (var l = 0; l < placeholderLength; l++) {
        var charInPlaceholder = settings.placeholder[l];

        // We see one. Let's find out what we can put in it.
        if (charInPlaceholder === placeholderChar) {
          // But before that, do we actually have any user characters that need a place?
          if (rawValueArr.length > 0) {
            // We will keep chipping away at user input until either we run out of characters
            // or we find at least one character that we can map.
            while (rawValueArr.length > 0) {
              // Let's retrieve the first user character in the queue of characters we have left
              var rawValueChar = rawValueArr.shift();

              // If the character we got from the user input is a placeholder character (which happens
              // regularly because user input could be something like (540) 90_-____, which includes
              // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,
              // then we map this placeholder character to the current spot in the placeholder
              if (rawValueChar.char === placeholderChar && suppressGuide !== true) {
                resultStr += placeholderChar;

                // And we go to find the next placeholder character that needs filling
                continue placeholderLoop;

                // Else if, the character we got from the user input is not a placeholder, let's see
                // if the current position in the mask can accept it.
              } else if (mask[l].test(rawValueChar.char)) {
                // we map the character differently based on whether we are keeping character
                // positions or not. If any of the conditions below are met, we simply map the
                // raw value character to the placeholder position.
                if (settings.keepCharacterPositions !== true || rawValueChar.isNew === false || settings.previousMaskResult === masks.EMPTY_STRING || settings.guide === false || !isAddition) {
                  resultStr += rawValueChar.char;
                } else {
                  // We enter this block of code if we are trying to keep character positions and
                  // none of the conditions above is met. In this case, we need to see if there's
                  // an available spot for the raw value character to be mapped to. If we couldn't
                  // find a spot, we will discard the character.
                  //
                  // For example, for mask `1111`, previous conformed value `_2__`, raw value
                  // `942_2__`. We can map the `9`, to the first available placeholder position,
                  // but then, there are no more spots available for the `4` and `2`. So, we
                  // discard them and end up with a conformed value of `92__`.
                  var rawValueArrLength = rawValueArr.length;
                  var indexOfNextAvailablePlaceholderChar = null;

                  // Let's loop through the remaining raw value characters. We are looking for
                  // either a suitable spot, ie, a placeholder character or a non-suitable spot,
                  // ie, a non-placeholder character that is not new. If we see a suitable spot
                  // first, we store its position and exit the loop. If we see a non-suitable spot
                  // first, we exit the loop and our `indexOfNextAvailablePlaceholderChar`
                  // will stay as `null`.
                  for (var x = 0; x < rawValueArrLength; x++) {
                    var charData = rawValueArr[x];

                    if (charData.char !== placeholderChar && charData.isNew === false) {
                      break;
                    }

                    if (charData.char === placeholderChar) {
                      indexOfNextAvailablePlaceholderChar = x;
                      break;
                    }
                  }

                  // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the
                  // character is not blocked. We can map it. And to keep the character positions,
                  // we remove the placeholder character from the remaining characters
                  if (indexOfNextAvailablePlaceholderChar !== null) {
                    resultStr += rawValueChar.char;
                    rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1);

                    // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the
                    // character is blocked. We have to discard it.
                  } else {
                    l--;
                  }
                }

                // Since we've mapped this placeholder position. We move on to the next one.
                continue placeholderLoop;
              } else {
                charactersRejected = true;
              }
            }
          }

          // We reach this point when we've mapped all the user input characters to placeholder
          // positions in the mask. In *guide* mode, we append the left over characters in the
          // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.
          //
          // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.
          if (suppressGuide === false) {
            resultStr += settings.placeholder.substr(l, placeholderLength);
          }

          // And we break
          break;

          // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it
          // with user input. So we just map it to the final output
        } else {
          resultStr += charInPlaceholder;
        }
      }

      // The following logic is needed to deal with the case of deletion in *no guide* mode.
      //
      // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder
      // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.
      // That's why the logic below finds the last filled placeholder character,
      // and removes everything from that point on.
      if (suppressGuide && isAddition === false) {
        var indexOfLastFilledPlaceholderChar = null;

        // Find the last filled placeholder position and substring from there
        for (var m = 0; m < resultStr.length; m++) {
          if (settings.placeholder[m] === placeholderChar) {
            indexOfLastFilledPlaceholderChar = m;
          }
        }

        if (indexOfLastFilledPlaceholderChar !== null) {
          // We substring from the beginning until the position after the last filled
          // placeholder char.
          resultStr = resultStr.substr(0, indexOfLastFilledPlaceholderChar + 1);
        } else {
          // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted
          // the first character in the mask. So we return an empty string.
          resultStr = masks.EMPTY_STRING;
        }
      }

      return {
        caretPos: caretPos,
        caretTrapIndexes: settings.caretTrapIndexes,
        conformedValue: resultStr,
        charactersRejected: charactersRejected,
        placeholder: settings.placeholder,
        placeholderChar: placeholderChar,
        maskResult: true
      };
    },


    /**
     * Detects Caret Traps inside of a Mask Array and identifies them with a rich object
     * @private
     * @param {array} mask the mask being checked
     * @returns {object} containing a modified Mask array without caret traps, and an array of
     *  indices with locations of the caret traps.
     */
    _processCaretTraps: function _processCaretTraps(mask) {
      var indexes = [];
      var indexOfCaretTrap = mask.indexOf(masks.CARET_TRAP);

      while (indexOfCaretTrap !== -1) {
        indexes.push(indexOfCaretTrap);
        mask.splice(indexOfCaretTrap, 1);
        indexOfCaretTrap = mask.indexOf(masks.CARET_TRAP);
      }

      return {
        maskWithoutCaretTraps: mask,
        indexes: indexes
      };
    },


    /**
     * Converts an array-based mask into a placeholder string.
     * @private
     * @param {array} mask - contains string "literal" characters and Regex matchers.
     * @param {string} placeholderChar - a character that will be used as the placeholder.
     * @returns {string} representing the placeholder
     */
    _convertMaskToPlaceholder: function _convertMaskToPlaceholder(mask, placeholderChar) {
      if (!Array.isArray(mask)) {
        mask = [];
      }
      if (!placeholderChar) {
        placeholderChar = masks.PLACEHOLDER_CHAR;
      }

      if (mask.indexOf(placeholderChar) !== -1) {
        throw new Error('' + ('Placeholder character must not be used as part of the mask. Please specify a character ' + 'that is not present in your mask as your placeholder character.\n\n' + 'The placeholder character that was received is:') + JSON.stringify(placeholderChar) + '\n\n' + ('The mask that was received is: ' + JSON.stringify(mask)));
      }

      var ret = mask.map(function (char) {
        return char instanceof RegExp ? placeholderChar : char;
      }).join(masks.EMPTY_STRING);

      return ret;
    },


    /**
     * Takes an index representing a caret and changes it based on mask modifications
     * @private
     * @param {object} opts information about the caret placement.
     * @returns {number} the index of the text caret.
     */
    adjustCaretPosition: function adjustCaretPosition(opts) {
      //eslint-disable-line
      if (opts.caretPos === 0) {
        return 0;
      }

      function nonPlaceholderFilter(char) {
        return char !== nonPlaceholderFilter;
      }

      // Store lengths for faster performance?
      var rawValueLength = opts.rawValue.length;
      var previousConformedValueLength = opts.previousMaskResult.length;
      var placeholderLength = opts.placeholder ? opts.placeholder.length : 0;
      var conformedValueLength = opts.conformedValue ? opts.conformedValue.length : 0;

      // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,
      // we know the user in this instance pasted two characters
      var editLength = rawValueLength - previousConformedValueLength;

      // If the edit length is positive, that means the user is adding characters, not deleting.
      var isAddition = editLength > 0;

      // This is the first raw value the user entered that needs to be conformed to mask
      var isFirstRawValue = previousConformedValueLength === 0;

      // A partial multi-character edit happens when the user makes a partial selection in their
      // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by
      // selecting the first 3 digits and pressing backspace.
      //
      // Such cases can also happen when the user presses the backspace while holding down the ALT
      // key.
      var isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue;

      // This algorithm doesn't support all cases of multi-character edits, so we just return
      // the current caret position.
      //
      // This works fine for most cases.
      if (isPartialMultiCharEdit) {
        return opts.caretPos;
      }

      // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter
      // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the
      // same as the original `previousConformedValue`. We handle this case differently for caret
      // positioning.
      var possiblyHasRejectedChar = isAddition && (opts.previousMaskResult === opts.conformedValue || opts.conformedValue === opts.placeholder);

      var startingSearchIndex = 0;
      var trackRightCharacter = void 0;
      var targetChar = void 0;

      if (possiblyHasRejectedChar) {
        startingSearchIndex = opts.caretPos - editLength;
      } else {
        // At this point in the algorithm, we want to know where the caret is right
        // before the raw input has been conformed, and then see if we can find that
        // same spot in the conformed input.
        //
        // We do that by seeing what character lies immediately before the caret,
        // and then look for that same character in the conformed input and place
        // the caret there.
        //
        // First, we need to normalize the inputs so that letter capitalization between raw input and
        // conformed input wouldn't matter.
        var normalizedConformedValue = opts.conformedValue.toLowerCase();
        var normalizedRawValue = opts.rawValue.toLowerCase();

        // Then we take all characters that come before where the caret currently is.
        var leftHalfChars = normalizedRawValue.substr(0, opts.caretPos).split(masks.EMPTY_STRING);

        // Now we find all the characters in the left half that exist in the conformed
        // input. This step ensures that we don't look for a character that was filtered
        // out or rejected by `conformToMask`.
        var intersection = leftHalfChars.filter(function (char) {
          return normalizedConformedValue.indexOf(char) !== -1;
        });

        // The last character in the intersection is the character we want to
        // look for in the conformed value and the one we want to adjust the caret close to
        targetChar = intersection[intersection.length - 1];

        // Calculate the number of mask characters in the previous placeholder
        // from the start of the string up to the place where the caret is
        var previousLeftMaskChars = opts.previousPlaceholder.substr(0, intersection.length).split(masks.EMPTY_STRING).filter(nonPlaceholderFilter).length;

        // Calculate the number of mask characters in the current placeholder
        // from the start of the string up to the place where the caret is
        var leftMaskChars = opts.placeholder.substr(0, intersection.length).split(masks.EMPTY_STRING).filter(nonPlaceholderFilter).length;

        // Has the number of mask characters up to the caret changed?
        var masklengthChanged = leftMaskChars !== previousLeftMaskChars;

        // Detect if `targetChar` is a mask character and has moved to the left
        var targetIsMaskMovingLeft = opts.previousPlaceholder[intersection.length - 1] !== undefined && opts.placeholder[intersection.length - 2] !== undefined && opts.previousPlaceholder[intersection.length - 1] !== opts.placeholderChar && opts.previousPlaceholder[intersection.length - 1] !== opts.placeholder[intersection.length - 1] && //eslint-disable-line
        opts.previousPlaceholder[intersection.length - 1] === opts.placeholder[intersection.length - 2] //eslint-disable-line
        ;

        // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true
        // or the mask is moving to the left, we can't use the selected `targetChar` any longer
        // if we are not at the end of the string.
        // In this case, change tracking strategy and track the character to the right of the caret.
        if (!isAddition && (masklengthChanged || targetIsMaskMovingLeft) && previousLeftMaskChars > 0 && opts.placeholder.indexOf(targetChar) > -1 && opts.rawValue[opts.caretPos] !== undefined) {
          trackRightCharacter = true;
          targetChar = opts.rawValue[opts.caretPos];
        }

        // It is possible that `targetChar` will appear multiple times in the conformed value.
        // We need to know not to select a character that looks like our target character
        // from the placeholder or the piped characters, so we inspect the piped characters
        // and the placeholder to see if they contain characters that match our target character.

        // If the `conformedValue` got piped, we need to know which characters were piped in so
        // that when we look for our `targetChar`, we don't select a piped char by mistake.
        var pipedChars = [];
        if (opts.indexesOfPipedChars) {
          pipedChars = opts.indexesOfPipedChars.map(function (index) {
            return normalizedConformedValue[index];
          });
        }

        // We need to know how many times the `targetChar` occurs in the piped characters.
        var countTargetCharInPipedChars = pipedChars.filter(function (char) {
          return char === targetChar;
        }).length;

        // We need to know how many times it occurs in the intersection
        var countTargetCharInIntersection = intersection.filter(function (char) {
          return char === targetChar;
        }).length;

        // We need to know if the placeholder contains characters that look like
        // our `targetChar`, so we don't select one of those by mistake.
        var countTargetCharInPlaceholder = opts.placeholder.substr(0, opts.placeholder.indexOf(opts.placeholderChar)).split(masks.EMPTY_STRING).filter(function (char, index) {
          return (
            // Check if `char` is the same as our `targetChar`, so we account for it
            char === targetChar &&

            // but also make sure that both the `rawValue` and placeholder don't have the same
            // character at the same index because if they are equal, that means we are already
            // counting those characters in `countTargetCharInIntersection`
            opts.rawValue[index] !== char
          );
        }).length;

        // The number of times we need to see occurrences of the `targetChar` before we
        // know it is the one we're looking for is:
        var requiredNumberOfMatches = countTargetCharInPlaceholder + countTargetCharInIntersection + countTargetCharInPipedChars + (
        // The character to the right of the caret isn't included in `intersection`
        // so add one if we are tracking the character to the right
        trackRightCharacter ? 1 : 0);

        // Now we start looking for the location of the `targetChar`.
        // We keep looping forward and store the index in every iteration. Once we have encountered
        // enough occurrences of the target character, we break out of the loop
        // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.
        var numberOfEncounteredMatches = 0;
        for (var i = 0; i < conformedValueLength; i++) {
          var conformedValueChar = normalizedConformedValue[i];

          startingSearchIndex = i + 1;

          if (conformedValueChar === targetChar) {
            numberOfEncounteredMatches++;
          }

          if (numberOfEncounteredMatches >= requiredNumberOfMatches) {
            break;
          }
        }
      }

      // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,
      // most cases would be handled. However, we want to fast forward or rewind the caret to the
      // closest placeholder character if it happens to be in a non-editable spot.
      // That's what the next logic is for.
      //
      // In case of addition, we fast forward.
      if (isAddition) {
        // We want to remember the last placeholder character encountered so that if the mask
        // contains more characters after the last placeholder character, we don't forward the caret
        // that far to the right. Instead, we stop it at the last encountered placeholder character.
        var lastPlaceholderChar = startingSearchIndex;

        for (var j = startingSearchIndex; j <= placeholderLength; j++) {
          if (!opts.placeholder) {
            return lastPlaceholderChar;
          }

          if (opts.placeholder[j] === opts.placeholderChar) {
            lastPlaceholderChar = j;
          }

          if (
          // If we're adding, we can position the caret at the next placeholder character.
          opts.placeholder[j] === opts.placeholderChar ||

          // If a caret trap was set by a mask function, we need to stop at the trap.
          opts.caretTrapIndexes.indexOf(j) !== -1 ||

          // This is the end of the placeholder. We cannot move any further.
          // Let's put the caret there.
          j === placeholderLength) {
            return lastPlaceholderChar;
          }
        }
      } else {
        // In case of deletion, we rewind.
        if (trackRightCharacter) {
          //eslint-disable-line
          // Searching for the character that was to the right of the caret
          // We start at `startingSearchIndex` - 1 because it includes one character
          // extra to the right
          for (var k = startingSearchIndex - 1; k >= 0; k--) {
            // If tracking the character to the right of the cursor, we move to the left until
            // we found the character and then place the caret right before it

            if (
            // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just
            // to the right of the caret
            opts.conformedValue[k] === targetChar ||

            // If a caret trap was set by a mask function, we need to stop at the trap.
            opts.caretTrapIndexes.indexOf(k) !== -1 ||

            // This is the beginning of the placeholder. We cannot move any further.
            // Let's put the caret there.
            k === 0) {
              return k;
            }
          }
        } else {
          // Searching for the first placeholder or caret trap to the left

          for (var l = startingSearchIndex; l >= 0; l--) {
            // If we're deleting, we stop the caret right before the placeholder character.
            // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user
            // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret
            // right after the first `6`

            if (
            // If we're deleting, we can position the caret right before the placeholder character
            opts.placeholder[l - 1] === opts.placeholderChar ||

            // If a caret trap was set by a mask function, we need to stop at the trap.
            opts.caretTrapIndexes.indexOf(l) !== -1 ||

            // This is the beginning of the placeholder. We cannot move any further.
            // Let's put the caret there.
            l === 0) {
              return l;
            }
          }
        }
      }
    },


    /**
     * Converts the legacy Soho Mask pattern format from a string into an array.
     * If character is a defined pattern matcher, the corresponding item at the
     * array index is converted to its regex form.
     * @private
     * @param {string} pattern a legacy Soho Mask Pattern
     * @param {object} [defs] mask conversion definitions
     * @returns {array} contains string "literal" characters and Regex matchers
     */
    _convertPatternFromString: function _convertPatternFromString(pattern, defs) {
      var arr = [];
      var legacyKeys = Object.keys(defs);

      function getRegex(char) {
        var idx = legacyKeys.indexOf(char);

        if (idx > -1) {
          char = defs[legacyKeys[idx]];
        }
        return char;
      }

      for (var i = 0; i < pattern.length; i++) {
        arr.push(getRegex(pattern[i]));
      }

      // TODO: Attach an object here that contains an analysis of the original mask
      // that can be used to configure the new API accordingly.

      return arr;
    }
  };

  /* eslint-disable no-underscore-dangle, new-cap */

  // The name of this component
  var COMPONENT_NAME$7 = 'mask';

  /**
   * Component Wrapper for input elements that gives them the ability to become "masked".
   * @class MaskInput
   * @constructor
   * @param {HTMLInputElement} element regular HTML Input Element (not wrapped with jQuery)
   * @param {MaskInputOptions} [settings] incoming settings
   *
   * @param {object} [settings.definitions=false] if defined, passes additional string-based pattern match "types".
   * @param {boolean} [settings.guide=false] if true, causes a guide to show inside the input field, represented by the placeholder,
   *  that demonstrates how the mask can be filled in.
   * @param {boolean} [settings.keepCharacterPositions=false] if defined alongside of `settings.guide`, will allow indiviual characters
   *  to be removed from the mask without moving the positions of other characters that have been written into the field.
   *  Works well with things like credit card or phone numbers, which have sections that are separate from each other.
   * @param {array|function|string} [settings.pattern] the pattern that is used by the mask for determining input to keep or throw out.
   *  Arrays of strings representing individual characters, and regex matching individual characters, is the perferred way of supplying a pattern.
   *  For some `settings.process` types (date/time/number), a function that dynamically generates a mask is automatically used.
   *  It's also possible to define a custom mask function and supply it here. The legacy string style is also supported.
   * @param {object} [settings.patternOptions] If using a function to define `settings.pattern`, any options that must be passed
   *  to the masking function can be supplied in this object.
   * @param {string} [settings.patternOptions.format] [date/time masks only] contains a basic date format string that will be used to properly display a date mask.
   * @param {string} [settings.patternOptions.prefix] [number masks only] will be automatically prepended to the beginning of the masked value, but will not be counted as part of the masked value.
   * @param {string} [settings.patternOptions.suffix] [number masks only] will be automatically appended to the end of the masked value, but will not be counted as part of the masked value.
   * @param {boolean} [settings.patternOptions.allowThousandsSeparator] [number masks only] If true, displays a localized thousands separator in the masked value
   * @param {object} [settings.patternOptions.symbols] [number masks only] contains default, localized special characters used in numbers
   * @param {string} [settings.patternOptions.symbols.currency] [number masks only]
   * @param {string} [settings.patternOptions.symbols.decimal] [number masks only]
   * @param {string} [settings.patternOptions.symbols.negative] [number masks only]
   * @param {string} [settings.patternOptions.symbols.thousands] [number masks only]
   * @param {boolean} [settings.patternOptions.allowDecimal] [number masks only] allows the entry of a decimal point into a number mask with a decimal limit defined (negated when using `requireDecimal` to force its placement)
   * @param {boolean} [settings.patternOptions.requireDecimal] [number masks only] forces the placement of a decimal point in a number mask with a decimal limit defined.
   * @param {number} [settings.patternOptions.decimalLimit] [number masks only] defines the number of characters allowed after the decimal point.
   * @param {number} [settings.patternOptions.integerLimit] [number masks only] defines the number of characters allowed before the decimal point.
   * @param {boolean} [settings.patternOptions.allowNegative] [number masks only] allows a number to be negative (adds/retains a "minus" symbol at the beginning of the value)
   * @param {boolean} [settings.patternOptions.allowLeadingZeroes] [number masks only] allows a zero be placed before a decimal or other numbers.
   * @param {string} [settings.placeholderChar='_'] If using the `settings.guide`, will be used as the placeholder
   *  for characters that are not yet typed.
   * @param {function} [settings.pipe] provides a way of adjusting the masked content, caret position,
   *  etc after the input field has been processed by the mask API.
   * @param {string} [settings.process=undefined] can be defined as a quick way to create certain complex masks.  Defaults to the regular pattern mask,
   *  but can automatically configure the field for "date", "time", and "number"
   * @param {boolean} [settings.processOnBlur=true] if defined, causes the mask API to process this input field whenever it becomes blurred.
   * @param {boolean} [settings.processOnInitialize=true] if defined, causes the mask API to process this input field when the component is initialized.
   * @returns {MaskInput} component instance
   */
  var DEFAULT_MASK_INPUT_OPTIONS = {
    definitions: undefined,
    guide: false,
    maskAPI: MaskAPI,
    keepCharacterPositions: false,
    pattern: undefined,
    patternOptions: undefined,
    placeholderChar: '_',
    pipe: undefined,
    process: undefined,
    processOnBlur: true,
    processOnInitialize: true
  };

  function MaskInput(element, settings) {
    this.element = element;

    if (!settings) {
      settings = {};
    }

    return this.init(settings);
  }

  MaskInput.prototype = {

    /**
     * Initialization/things that need to be called on `updated()` in addition to initialization
     * @private
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    init: function init(settings) {
      // Define internal settings
      if (!this.settings) {
        this.settings = utils.mergeSettings(this.element, settings, DEFAULT_MASK_INPUT_OPTIONS);
      } else {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }
      if (!this.settings.patternOptions) {
        this.settings.patternOptions = {};
      }

      // TODO: Deprecate legacy settings in v4.4.0, remove in v4.5.0
      this._replaceLegacySettings();

      var styleClasses = ['is-number-mask'];

      // If the 'process' setting is defined, connect a pre-defined Soho Mask/Pattern
      if (typeof this.settings.process === 'string') {
        switch (this.settings.process) {
          case 'number':
            {
              this.settings.pattern = masks.numberMask;
              this.element.classList.add('is-number-mask');
              break;
            }
          case 'date':
            {
              // Check for an instance of a Datepicker/Timepicker Component, and grab the date format
              var datepicker = $(this.element).data('datepicker');
              if ($.fn.datepicker && $(this.element).data('datepicker')) {
                if (!this.settings.patternOptions && !this.settings.patternOptions.format) {
                  this.settings.patternOptions.format = datepicker.settings.dateFormat;
                }
              }
              this.settings.pattern = masks.dateMask;
              break;
            }
          case 'rangeDate':
            {
              var _datepicker = $(this.element).data('datepicker');
              if ($.fn.datepicker && $(this.element).data('datepicker')) {
                this.settings.patternOptions.format = _datepicker.settings.dateFormat;
              }
              this.settings.pattern = masks.rangeDateMask;
              break;
            }
          default:
            {
              this.element.classList.remove(styleClasses.join(' '));
              break;
            }
        }
      }

      this.mask = new this.settings.maskAPI(this.settings);
      this.state = {
        previousMaskResult: ''
      };

      this.handleEvents();

      if (this.settings.processOnInitialize) {
        this.process();
      }

      return this;
    },


    /**
     * Sets up events
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      // Store an initial value on focus
      this.focusEventHandler = function () {
        self.state.initialValue = self.element.value;
      };
      this.element.addEventListener('focus', this.focusEventHandler);

      // Handle all masking on the `input` event
      this.inputEventHandler = function () {
        return self.process();
      };
      this.element.addEventListener('input', this.inputEventHandler);

      // Remove an initial value from the state object on blur
      this.blurEventHandler = function (e) {
        // Handle mask processing on blur, if settings allow.  Otherwise, return out.
        if (self.settings.processOnBlur) {
          if (self.element.readOnly) {
            e.preventDefault();
            return false;
          }

          // in IE11 or Edge, change event doesn't fire for some unknown reason.
          // Added this for backwards compatility with this OS/Browser combo.
          // See http://jira.infor.com/browse/SOHO-6895
          if (self._hasChangedValue() && self._isEdgeIE()) {
            $(self.element).trigger('change');
          }
        }

        delete self.state.initialValue;
        return self.process();
      };
      this.element.addEventListener('blur', this.blurEventHandler);

      return this;
    },


    /**
     * Main Process for conforming a mask against the API.
     * @returns {boolean} whether or not the mask process was successful
     */
    process: function process() {
      // If no pattern's defined, act as if no mask component is present.
      if (!this.settings.pattern) {
        return true;
      }

      // Get a reference to the desired Mask API (by default, the one setup
      // during Soho initialization).
      var api = this.mask;
      if (!api.pattern) {
        api.configure({
          pattern: this.settings.pattern,
          patternOptions: this.settings.patternOptions
        });
      }

      // Get all necessary bits of data from the input field.
      var rawValue = this.element.value;

      // Don't continue if there was no change to the input field's value
      if (rawValue === this.state.previousMaskResult) {
        return false;
      }

      var posBegin = this.element.selectionStart;
      var posEnd = this.element.selectionEnd;

      // On Android, the first character inserted into a field is automatically
      // selected when it shouldn't be. This snippet fixes that problem.
      if (this._isAndroid() && this.state.previousMaskResult === '' && posBegin !== posEnd) {
        utils.safeSetSelection(rawValue.length, rawValue.length);
        posBegin = rawValue.length;
        posEnd = rawValue.length;
      }

      // Attempt to make the raw value safe to use.  If it's not in a viable format
      // this will throw an error.
      rawValue = this._getSafeRawValue(rawValue);

      var opts = {
        guide: this.settings.guide,
        keepCharacterPositions: this.settings.keepCharacterPositions,
        patternOptions: this.settings.patternOptions,
        placeholderChar: this.settings.placeholderChar,
        previousMaskResult: this.state.previousMaskResult,
        selection: {
          start: posBegin,
          end: posEnd
        }
      };

      if (posBegin !== posEnd) {
        opts.selection.contents = rawValue.substring(posBegin, posEnd);
      }
      if (typeof this.settings.pipe === 'function') {
        opts.pipe = this.settings.pipe;
      }

      // Perform the mask processing.
      var processed = api.process(rawValue, opts);
      if (!processed.maskResult) {
        // Error during masking.  Simply return out and don't mask this field.
        return processed.maskResult;
      }

      // Use the piped value, if applicable.
      var finalValue = processed.pipedValue ? processed.pipedValue : processed.conformedValue;
      var patternOptions = this.settings.patternOptions;
      if (finalValue !== '' && patternOptions && patternOptions.suffix && finalValue.indexOf(patternOptions.suffix) < 0) {
        finalValue += this.settings.patternOptions.suffix;
      }

      // Setup values for getting corrected caret position
      // TODO: Improve this by eliminating the need for an extra settings object.
      var adjustCaretOpts = {
        previousMaskResult: this.state.previousMaskResult || '',
        previousPlaceholder: this.state.previousPlaceholder || '',
        conformedValue: finalValue,
        placeholder: processed.placeholder,
        rawValue: rawValue,
        caretPos: processed.caretPos,
        placeholderChar: this.settings.placeholderChar
      };
      if (processed.pipedCharIndexes) {
        adjustCaretOpts.indexesOfPipedChars = processed.pipedCharIndexes;
      }
      if (processed.caretTrapIndexes) {
        adjustCaretOpts.caretTrapIndexes = processed.caretTrapIndexes;
      }

      // Get a corrected caret position.
      processed.caretPos = api.adjustCaretPosition(adjustCaretOpts);

      var previousValue = this.state.previousMaskResult;

      // Set the internal component state
      this.state.previousMaskResult = finalValue;
      this.state.previousPlaceholder = processed.placeholder;

      // Set state of the input field
      this.element.value = finalValue;
      utils.safeSetSelection(this.element, processed.caretPos);

      // Return out if there was no visible change in the conformed result
      // (causes state not to change, events not to fire)
      if (previousValue !== finalValue) {
        return false;
      }

      /**
       * Fire the 'write' event
       * @event write
       * @memberof MaskInput
       * @param {jQuery.Event} e the event object
       * @param {string} finalValue the final, masked value
       */
      $(this.element).trigger('write.mask', [finalValue]);

      // return event handler true/false
      return processed.maskResult;
    },


    /**
     * Obfuscates the operating system/browser check from Soho.env into internal methods
     * NOTE: Helps compartmentalize us from using calls to global "Soho" object until we can
     * properly setup import/export for unit tests.
     * TODO: deprecate eventually (v4.4.0?)
     * @private
     * @returns {boolean} whether or not the current device is running the Android OS.
     */
    _isAndroid: function _isAndroid() {
      var os = Environment && Environment.os && Environment.os.name ? Environment.os.name : '';
      return os === 'android';
    },


    /**
     * Determine if browser is IE11 or Edge
     * @private
     * @returns {boolean} whether or not the current device is running Windows 7
     *  using the IE11 browser.
     */
    _isEdgeIE: function _isEdgeIE() {
      var browser = Environment && Environment.browser && Environment.browser.name ? Environment.browser.name : '';
      return browser === 'ie' || browser === 'edge';
    },


    /**
     * Checks the current value of this masked input against it's stored "previousMaskResult"
     *  state to see if the value changed.
     * @private
     * @returns {boolean} whether or not the previous mask state matches the current one.
     */
    _hasChangedValue: function _hasChangedValue() {
      if (!this.state || !this.state.previousMaskResult) {
        return true;
      }

      return this.state.previousMaskResult !== this.state.initialValue;
    },


    /**
     * Gets the safe raw value of an input field
     * @private
     * @param {?} inputValue the original value that came from an input field or other source
     * @returns {string} the string-ified version of the original value
     */
    _getSafeRawValue: function getSafeRawValue(inputValue) {
      if (utils.isString(inputValue)) {
        return inputValue;
      } else if (utils.isNumber(inputValue)) {
        return String(inputValue);
      } else if (inputValue === undefined || inputValue === null) {
        return '';
      }
      throw new Error('' + ('The "value" provided to the Masked Input needs to be a string or a number. The value ' + 'received was:\n\n') + JSON.stringify(inputValue));
    },

    /**
     * Changes a bunch of "legacy" setting definitions into more apt names.  Additionally handles
     * the old data-attribute system that is still occasionally used.
     * @private
     * @returns {void}
     */
    _replaceLegacySettings: function _replaceLegacySettings() {
      var modes = ['group', 'number', 'date', 'time'];

      // pre-set a bunch of objects if they don't already exist
      this.settings.patternOptions = this.settings.patternOptions || {};
      this.settings.patternOptions.symbols = this.settings.patternOptions.symbols || {};

      //= =====================================
      // Deprecated as of v4.3.2
      //= =====================================
      // Order of operations when choosing pattern strings:
      // HTML5 'data-mask' attribute > Generic pattern string based on "type" attribute > nothing.
      //
      // if no pattern is provided in settings, use a pre-determined pattern based
      // on element type, or grab the pattern from the element itself.
      var html5DataMask = this.element.getAttribute('data-mask') || false;
      if (typeof html5DataMask === 'string' && html5DataMask.length) {
        this.settings.pattern = html5DataMask;
      }

      // If a "mode" is defined, special formatting rules may apply to this mask.
      // Otherwise, the standard single-character pattern match will take place.
      var html5DataMaskMode = this.element.getAttribute('data-mask-mode') || false;
      if (html5DataMaskMode && modes.indexOf(html5DataMaskMode) > -1) {
        this.settings.mode = html5DataMaskMode;
      }

      // map deprecated "mode" setting to "process".  Triggers additional settings in
      // some cases.
      if (this.settings.mode) {
        if (modes.indexOf(this.settings.mode) === -1) {
          delete this.settings.mode;
        }

        if (this.settings.mode === 'group') {
          this.settings.process = undefined;
        } else if (this.settings.mode === 'date') {
          this.settings.process = 'date';
        } else {
          this.settings.process = this.settings.mode;
        }

        delete this.settings.mode;
      }

      if (this.settings.process === 'number') {
        // map deprecated "thousandsSeparator" to "patternOptions.allowThousandsSeparator"
        if (this.settings.thousandsSeparator) {
          this.settings.patternOptions.allowThousandsSeparator = this.settings.thousandsSeparator;
          delete this.settings.thousandsSeparator;
        }

        // If "thousands" is defined, the thousands separator for numbers (comma or decimal, based on
        // localization) will be inserted wherever necessary during typing. Will automatically set to
        // "true" if the localized thousands separator is detected inside the mask.
        var html5DataThousands = this.element.getAttribute('data-thousands') || false;
        if (html5DataThousands) {
          this.settings.patternOptions.allowThousandsSeparator = html5DataThousands === 'true';
        }

        if (typeof this.settings.pattern === 'string') {
          // If "negative" is defined, you can type the negative symbol in front of the number.
          // Will automatically set to "true" if a negative symbol is detected inside the mask.
          var allowNegative = this.settings.pattern.indexOf('-') !== -1;
          if (allowNegative) {
            this.settings.patternOptions.allowNegative = allowNegative;
            this.settings.patternOptions.symbols.negative = '-';
          }

          // Detect the thousands separator and see if we use it.
          var group = Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.group : ',';
          var thousandsSep = this.settings.patternOptions && this.settings.patternOptions.symbols && this.settings.patternOptions.symbols.thousands ? this.settings.patternOptions.symbols.thousands : group;

          var hasThousandsInPattern = this.settings.pattern.indexOf(thousandsSep) !== -1;
          this.settings.patternOptions.allowThousandsSeparator = hasThousandsInPattern;
          if (hasThousandsInPattern) {
            this.settings.patternOptions.symbols.thousands = thousandsSep;
          }

          // The new masking algorithm requires an "integerLimit" defined to function.
          // This grabs the number of items currently inside this part of the mask, and sets it.
          var decimal = typeof this.settings.patternOptions.symbols.decimal === 'string' ? this.settings.patternOptions.symbols.decimal : '.';
          var decimalParts = this.settings.pattern.split(decimal);

          this.settings.patternOptions.integerLimit = decimalParts[0].replace(/[^#0]/g, '').length;

          if (decimalParts[1]) {
            this.settings.patternOptions.allowDecimal = true;
            this.settings.patternOptions.decimalLimit = decimalParts[1].toString().replace(/[^#0]/g, '').length;
            if (!this.settings.patternOptions.symbols.decimal) {
              this.settings.patternOptions.symbols.decimal = decimal;
            }
          }
        }
      }

      // If 'mustComplete' is defined, you MUST complete the full mask, or the mask
      // will revert to empty once the field is blurred.
      var html5DataMustComplete = this.element.getAttribute('data-must-complete') || false;
      if (html5DataMustComplete) {
        this.settings.mustComplete = html5DataMustComplete;
      }

      // Backwards compat with the old "data-show-currency"
      var html5DataCurrency = this.element.getAttribute('data-show-currency');
      if (html5DataCurrency) {
        this.settings.showSymbol = 'currency';
      }

      // Handle the currency/percent symbols automatically
      var symbolSetting = this.settings.showSymbol;
      var symbolTypes = ['currency', 'percent'];
      var symbol = void 0;

      if (symbolTypes.indexOf(symbolSetting) > -1) {
        symbol = function (s) {
          if (s === 'currency') {
            return {
              char: Locale.currentLocale.data.currencySign,
              format: Locale.currentLocale.data.currencyFormat
            };
          }
          if (s === 'percent') {
            return {
              char: Locale.currentLocale.data.numbers.percentSign,
              format: Locale.currentLocale.data.numbers.percentFormat
            };
          }
          return {};
        }(this.settings.showSymbol);

        // derive the location of the symbol
        var detectableSymbol = symbolSetting === 'currency' ? '¤' : symbol.char;
        var symbolRegex = new RegExp(detectableSymbol, 'g');
        var match = symbolRegex.exec(symbol.format);
        var replacementRegex = void 0;
        var symbolWithWhitespace = void 0;
        var index = -1;
        var placementType = void 0;

        if (match && match.length) {
          index = symbol.format.indexOf(match[0]);
          if (index === 0) {
            placementType = 'prefix';
            replacementRegex = new RegExp('[^' + detectableSymbol + ']\\S', 'g');
            symbolWithWhitespace = symbol.format.replace(replacementRegex, '');
          } else if (index > 0) {
            placementType = 'suffix';
            replacementRegex = new RegExp('\\S[^' + detectableSymbol + ']', 'g');

            while (/\s/.test(symbol.format.charAt(index - 1))) {
              --index;
            }
            symbolWithWhitespace = symbol.format.substr(index).replace(replacementRegex, '');
          }

          if (symbolSetting === 'currency') {
            symbolWithWhitespace = symbolWithWhitespace.replace('¤', symbol.char);
          }
          this.settings.patternOptions[placementType] = symbolWithWhitespace;
        }
      }
    },


    /**
     * Updates the component instance with new settings.
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      return this.teardown().init(settings);
    },


    /**
     * Tears down the current component instance
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.element.removeEventListener('focus', this.focusEventHandler);
      delete this.focusEventHandler;

      this.element.removeEventListener('input', this.inputEventHandler);
      delete this.inputEventHandler;

      if (this.blurEventHandler) {
        this.element.removeEventListener('blur', this.blurEventHandler);
        delete this.blurEventHandler;
      }

      return this;
    }
  };

  /**
   * Wrap Mask as a jQuery component, and attach the factory function to $.fn
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements to be acted on.
   */
  $.fn.maskinput = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$7);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$7, new MaskInput(this, settings));
        instance.destroy = function () {
          this.teardown();
          $.removeData(this.element, COMPONENT_NAME$7);
        };
      }
    });
  };

  /**
   * Backwards Compatibility with the old Mask
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements to be acted on.
   */
  $.fn.maskedinput = $.fn.maskinput;
  $.fn.mask = $.fn.maskinput;

  // Component Name
  var COMPONENT_NAME$8 = 'popupmenu';

  /**
   * Responsive Popup Menu Control aka Context Menu when doing a right click action.
   * @class PopupMenu
   *
   * @constructor
   * @param {jquery[]|htmlelement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.menu]  Menu's ID Selector, or a jQuery object representing a menu.
   * @param {string} [settings.trigger='click']  Action on which to trigger a menu can be: click, rightClick, immediate ect.
   * @param {boolean} [settings.autoFocus=true]  If false the focus will not focus the first list element. (At the cost of accessibility).
   * @param {boolean} [settings.mouseFocus=true]  If false the focus will not highlight the first list element. (At the cost of accessibility).
   * @param {boolean} [settings.attachToBody=false]  If true the menu will be moved out to the body. To be used in certin overflow situations.
   * @param {function} [settings.beforeOpen]  Callback that can be used for populating the contents of the menu.
   * @param {string} [settings.ariaListbox=false]   Switches aria to use listbox construct instead of menu construct (internal).
   * @param {string} [settings.eventObj]  Can pass in the event object so you can do a right click with immediate.
   * @param {string} [settings.triggerSelect]  If false select event will not be triggered.
   * @param {string} [settings.showArrow]  If true you can explicitly set an arrow on the menu.
   * @param {boolean|function} [settings.returnFocus]  If set to false, focus will not be
    returned to the calling element. Can also be defined as a callback that can determine how
    to return focus.  It usually should be for accessibility purposes.
   * @param {object} [settings.placementOpts=new PlacementObject({
     containerOffsetX: 10,
     containerOffsetY: 10,
     strategies: ['flip', 'shrink']
  })] Gets passed to this control's Place behavior.
   * @param {object} [settings.offset={x: 0, y: 0}] Can tweak the menu position in the x and y direction. Takes an object of form: `{x: 0, y: 0}`.
   * @param {jQuery[]} [settings.predefined=$()] containing references to menu items that should be passed to the "predefined" hash.
   */

  var POPUPMENU_DEFAULTS = {
    menu: null,
    trigger: 'click',
    autoFocus: true,
    mouseFocus: true,
    attachToBody: false,
    beforeOpen: null,
    ariaListbox: false,
    eventObj: undefined,
    returnFocus: true,
    showArrow: null,
    triggerSelect: true,
    placementOpts: new PlacementObject({
      containerOffsetX: 10,
      containerOffsetY: 10,
      strategies: ['flip', 'shrink']
    }),
    offset: {
      x: 0,
      y: 0
    },
    predefined: $()
  };

  function PopupMenu(element, settings) {
    this.settings = utils.mergeSettings(element, settings, POPUPMENU_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  PopupMenu.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup();
      this.addMarkup();
      this.handleEvents();
      this.iconFilteringSetup();

      // Allow for an external click event to be passed in from outside this code.
      // This event can be used to pass clientX/clientY coordinates for mouse cursor positioning.
      if (this.settings.trigger === 'immediate') {
        this.open(this.settings.eventObj);
      }

      // Use some css rules on submenu parents
      if (this.menu.find('.submenu').length) {
        this.menu.addClass('has-submenu');
      }
    },


    /**
     * Checks whether or not Right-To-Left reading mode is active.
     * @private
     * @returns {boolean} whether or not the reading/writing direction is RTL
     */
    isRTL: function isRTL() {
      return Environment.rtl;
    },


    /**
     * @private
     * @returns {void}
     */
    setup: function setup() {
      if (this.element.attr('data-popupmenu') && !this.settings.menu) {
        this.settings.menu = this.element.attr('data-popupmenu').replace(/#/g, '');
      }
      // Backwards compatibility for "menuId" menu options coming from other controls
      // that utilize the Popupmenu.
      if (this.settings.menuId) {
        this.settings.menu = this.settings.menuId;
        this.settings.menuId = undefined;
      }

      // keep track of how many popupmenus there are with an ID.
      // Used for managing events that are bound to $(document)
      if (!this.id) {
        this.id = (parseInt($('.popupmenu-wrapper').length, 10) + 1).toString();
      }

      // Set a reference collection for containing "pre-defined" menu items that should never
      // be replaced during an AJAX call.
      this.predefinedItems = $().add(this.settings.predefined);
    },


    /**
     * Add markip including Aria
     * @private
     * @returns {void}
     */
    addMarkup: function addMarkup() {
      var id = void 0;
      var leftClick = this.settings.trigger !== 'rightClick';
      var immediate = this.settings.trigger === 'immediate';

      switch (_typeof(this.settings.menu)) {
        case 'string':
          // ID Selector
          id = this.settings.menu;
          this.menu = $('#' + this.settings.menu);
          break;
        case 'object':
          // jQuery Object
          if (this.settings.menu === null) {
            this.menu = this.element.next('.popupmenu, .popupmenu-wrapper');
          } else {
            this.menu = $(this.settings.menu);
          }

          id = this.menu.attr('id');
          if (!id || id === '') {
            this.menu.attr('id', 'popupmenu-' + this.id);
            id = this.menu.attr('id');
          }
          break;
        default:
          break;
      }

      // If markup already exists for the wrapper, use that instead of rebuilding.
      if (this.menu.is('.popupmenu-wrapper')) {
        this.preExistingWrapper = true;
        this.wrapper = this.menu;
        this.menu = this.wrapper.children('.popupmenu').first();
      }

      // Similar check as above, assuming the menu wasn't a popupmenu wrapper.
      if (this.menu.parent().is('.popupmenu-wrapper')) {
        this.preExistingWrapper = true;
        this.wrapper = this.menu.parent();
      }

      // If we still don't have a menu reference at this point, fail gracefully by returning out
      // and simply acting like a button.
      if (this.menu.length === 0) {
        return;
      }

      // if the menu is deeply rooted inside the markup, detach it and append it to the <body> tag
      // to prevent containment issues. (Now a Preference)
      if (this.settings.attachToBody && this.menu.parent().not('body').length > 0) {
        this.originalParent = this.menu.prev();
        this.menu.detach().appendTo('body');
      }

      if (!this.menu.is('.popupmenu')) {
        this.menu.addClass('popupmenu').attr('role', this.settings.ariaListbox ? 'listbox' : 'menu');
      }

      // Always store a reference to the trigger element under jQuery data.
      this.menu.data('trigger', this.element);

      this.wrapper = this.menu.parent('.popupmenu-wrapper');
      if (!this.wrapper.length) {
        this.wrapper = this.menu.wrap('<div class="popupmenu-wrapper"></div>');
      }

      // Invoke all icons as icons
      this.wrapper.find('svg').each(function () {
        if (!$(this).data('icon')) {
          $(this).icon();
        }
      });

      // Enforce Correct Modality
      this.menu.parent('.popupmenu-wrapper').attr('role', 'application').attr('aria-hidden', 'true');

      // Use "absolute" positioning on the menu insead of "fixed", only when the
      // menu lives <body> tag and we have a <body> element that is tall enough to
      // scroll and is allowed to scroll.
      function scrollableFilter() {
        var c = this ? this.style.overflow : null;
        return c !== 'auto' && c !== 'visible' && c !== 'scroll';
      }
      if (this.wrapper.parents().filter(scrollableFilter).length === 0) {
        this.wrapper[0].style.position = 'absolute';
      }

      // Wrap submenu ULs in a 'wrapper' to help break it out of overflow.
      this.menu.find('.popupmenu').each(function (i, elem) {
        var popup = $(elem);

        if (!popup.parent().hasClass('wrapper')) {
          popup.wrap('<div class="wrapper"></div>');
        }
      });

      // If the trigger element is a button with no border append arrow markup
      var containerClass = this.element.parent().attr('class');
      if (this.element.hasClass('btn-menu') || this.element.hasClass('btn-actions') || this.element.hasClass('btn-icon') && this.element.find('use').attr('xlink:href') === '#icon-more' || this.settings.menu === 'colorpicker-menu' || this.element.closest('.toolbar').length > 0 || this.element.closest('.masthead').length > 0 || this.element.is('.searchfield-category-button') || containerClass && containerClass.indexOf('more') >= 0 || containerClass && containerClass.indexOf('btn-group') >= 0 || this.settings.showArrow) {
        var arrow = $('<div class="arrow"></div>');
        var wrapper = this.menu.parent('.popupmenu-wrapper');

        wrapper.addClass('bottom').append(arrow);
      }

      // If inside of a ".field-short" container, make smaller
      var addFieldShort = this.element.closest('.field-short').length;
      this.menu[addFieldShort ? 'addClass' : 'removeClass']('popupmenu-short');

      // If button is part of a header/masthead or a container using the "alternate"
      // UI color, add the "alternate" class.
      if (containerClass !== undefined && this.element.closest('.masthead').not('.search-results .masthead').length > 0) {
        this.menu.parent('.popupmenu-wrapper').addClass('inverse');
      }

      this.element.attr('aria-haspopup', true);
      this.element.attr('aria-controls', id);

      this.markupItems();

      // Add an Audible Label
      if (!leftClick && !immediate) {
        var audibleSpanId = 'popupmenu-f10-label';
        if ($('#' + audibleSpanId).length === 0) {
          this.element.after('\n          <span class="audible" id="' + audibleSpanId + '">\n            ' + Locale.translate('PressShiftF10') + '\n          </span>\n        ');
        }
        // PressShiftF10
        this.element.attr('aria-describedby', audibleSpanId);
      }

      // Unhide the menu markup, if hidden
      if (this.menu.is('.hidden')) {
        this.menu.removeClass('hidden');
      }
    },


    /**
     * Renders a menu item in the UI.
     * @private
     * @param {object|object[]} settings JSON-friendly object that represents a popupmenu item, or array of items.
     * @param {string} [settings.id] adds an ID to the item's anchor tag
     * @param {boolean} [settings.separator=false] causes this menu item to be a separator (overrides everything else)
     * @param {string} [settings.heading=""] Produces a heading element after a separator with text content.
     * @param {string} [settings.nextSectionSelect] can be null, "single", or "multiple"
     * @param {string} settings.text contains the text that will be displayed.
     * @param {string|null} [settings.icon=null] applies an icon to the menu item
     * @param {string|null} [settings.selectable] can be null, "single", or "multiple"
     * @param {boolean} [settings.disabled=false] causes the item to be disabled.
     * @param {object[]} [settings.submenu] array of settings object contstructed just like this one, that represent submenu items.
     * @param {boolean} [settings.noMenuWrap=false] if true, causes multiple top-level menu items not to be wrapped by a `<ul class="popupmenu"></ul>`
     * @returns {string} HTML representing a Popupmenu item with the settings passed.
     */
    renderItem: function renderItem(settings) {
      if (settings === undefined) {
        return '';
      }

      var self = this;
      function wrapMenuItems(settingsArr) {
        var items = '';
        settingsArr.forEach(function (menuObj) {
          items += self.renderItem(menuObj);
        });
        return items;
      }

      // Top-level arrays run this method on each sub-item.
      if (Array.isArray(settings)) {
        var items = wrapMenuItems(settings);
        var template = '<ul class="popupmenu">' + items + '</ul>';
        return stringUtils.stripWhitespace(template);
      }

      var headingText = '';
      var sectionSelectClass = '';

      // separators get rendered out first
      if (settings.separator !== undefined) {
        if (settings.heading) {
          headingText += '<li class="heading">' + settings.heading + '</li>';
        }
        if (settings.nextSectionSelect === 'single' || settings.nextSectionSelect === 'multiple') {
          sectionSelectClass = ' ' + settings.nextSectionSelect;
        }

        return stringUtils.stripWhitespace('\n        <li class="separator' + sectionSelectClass + '"></li>\n        ' + headingText + '\n      ');
      }

      // Top-level Menus can have settings.
      // Handle an object-based settings with a `menu` definition here
      if (settings.menu) {
        var menuId = '';
        if (settings.menuId) {
          menuId = ' id="' + settings.menuId + '"';
        }

        var iconsClass = '';
        if (settings.hasIcons) {
          iconsClass += ' has-icons';
        }

        var _items = '';
        if (Array.isArray(settings.menu)) {
          _items = wrapMenuItems(settings.menu);
        }

        if (settings.noMenuWrap) {
          return _items;
        }

        return stringUtils.stripWhitespace('\n        <ul' + menuId + ' class="popupmenu' + iconsClass + '">\n          ' + _items + '\n        </ul>\n      ');
      }

      var disabledClass = '';
      var hiddenClass = '';
      var icon = '';
      var id = '';
      var selectableClass = '';
      var submenuClass = '';
      var submenu = '';
      var ddicon = '';

      if (settings.disabled) {
        disabledClass += ' is-disabled';
      }

      if (settings.visible === false) {
        hiddenClass += ' hidden';
      }

      if (settings.id) {
        id = ' id="' + settings.id + '"';
      }

      if (settings.selectable === 'single') {
        selectableClass += ' is-selectable';
      }

      if (settings.selectable === 'multiple') {
        selectableClass += ' is-multiselectable';
      }

      if (settings.icon) {
        icon = '<svg class="icon" focusable="false" aria-hidden="true" role="presentation">\n        <use xlink:href="#icon-' + settings.icon + '"></use>\n      </svg>';
      }

      if (Array.isArray(settings.submenu)) {
        submenuClass += ' submenu';
        submenu += this.renderItem(settings.submenu);
        ddicon += '<svg class="arrow icon-dropdown icon" focusable="false" aria-hidden="true" role="presentation">\n        <use xlink:href="#icon-dropdown"></use>\n      </svg>';
      }

      return stringUtils.stripWhitespace('<li class="popupmenu-item' + disabledClass + hiddenClass + selectableClass + submenuClass + '">\n      <a' + id + ' href="#">\n        ' + icon + '\n        <span>' + settings.text + '</span>\n        ' + ddicon + '\n      </a>\n      ' + submenu + '\n    </li>');
    },


    /**
     * Converts the contents of a popupmenu or submenu to a JSON-friendly object structure.
     * @private
     * @param {object} [settings={}] incoming conversion settings
     * @param {jQuery[]|HTMLElement} [settings.contextElement] the top-most element that will
     *  be modified (defaults to the top-level menu).
     * @param {boolean} [settings.noMenuWrap] if true, will pass an array as the top-level data instead
     *  of an object with a `menu` property.
     * @returns {object|object[]} an object representation of this popupmenu's current state.
     */
    toData: function toData(settings) {
      var data = {};
      var menu = [];

      settings = settings || {};

      // Figure out Context Element
      if (!settings.contextElement) {
        settings.contextElement = this.menu;
      }
      if (settings.contextElement instanceof HTMLElement) {
        settings.contextElement = $(settings.contextElement);
      }
      if (settings.contextElement.is('.popupmenu-wrapper')) {
        settings.contextElement = settings.contextElement.children('ul');
      }

      var menuId = '' + settings.contextElement.attr('id');
      if (menuId) {
        data.menuId = menuId;
      }

      var hasIcons = settings.contextElement.hasClass('has-icons');
      data.hasIcons = hasIcons;

      if (settings.noMenuWrap) {
        data = menu;
      } else {
        data.menu = menu;
      }

      function decodeListItem(item) {
        var li = $(item);
        var liData = {};

        // Ignore headings, which are included as part of separators inside data
        if (li.hasClass('heading')) {
          return undefined;
        }

        // separators include different metadata
        if (li.hasClass('separator')) {
          liData.separator = true;

          if (li.hasClass('single-selectable-section')) {
            liData.nextSectionSelect = 'single';
          }
          if (li.hasClass('multi-selectable-section')) {
            liData.nextSectionSelect = 'multiple';
          }

          var next = li.next();
          if (next.hasClass('heading')) {
            liData.heading = next.text().trim();
          }

          return liData;
        }

        var a = li.children('a');
        var icon = a.children('.icon:not(.close):not(.icon-dropdown)');
        var id = a.attr('id');

        liData.text = a.text().trim();
        liData.disabled = li.hasClass('is-disabled');
        liData.visible = !li.hasClass('hidden');

        if (typeof id === 'string' && id.length) {
          liData.id = id;
        }

        if (icon.length && icon[0] instanceof SVGElement) {
          liData.icon = icon[0].querySelector('use').getAttribute('xlink:href').replace('#icon-', '');
        }

        if (li.hasClass('is-selectable')) {
          liData.selectable = 'single';
        } else if (li.hasClass('is-multiselectable')) {
          liData.selectable = 'multiple';
        }

        var submenu = li.find('.popupmenu');
        if (submenu.length) {
          liData.submenu = [];
          submenu.first().children().each(function (i, submenuItem) {
            var submenuLiData = decodeListItem(submenuItem);
            if (!submenuLiData) {
              return;
            }
            liData.submenu.push(submenuLiData);
          });
        }

        return liData;
      }

      var lis = settings.contextElement.children('li');
      lis.each(function (i, item) {
        var liData = decodeListItem(item);
        if (!liData) {
          return;
        }
        menu.push(liData);
      });

      return data;
    },


    /**
     * Marks up menu items in the UI
     * @private
     * @param {jQuery[]|HTMLElement} [contextElement] the top-most element that will
     *  be modified (defaults to the top-level menu).
     * @returns {void}
     */
    markupItems: function markupItems(contextElement) {
      var self = this;

      if (!contextElement) {
        contextElement = this.menu;
      } else if (contextElement instanceof HTMLElement) {
        contextElement = $(contextElement);
      }

      var lis = contextElement.find('li:not(.heading):not(.separator)');
      var menuClassName = contextElement[0].className;
      var isTranslatable = DOM.hasClassName(menuClassName, 'isTranslatable');
      var hasIcons = false;

      lis.each(function (i, li) {
        var a = $(li).children('a')[0]; // TODO: do this better when we have the infrastructure
        var span = $(a).children('span')[0];
        var submenu = $(li).children('ul')[0];
        var icon = $(li).find('.icon:not(.close):not(.icon-dropdown)');
        var submenuWrapper = $(li).children('.wrapper')[0];

        li.setAttribute('role', 'presentation');

        if (a) {
          a.setAttribute('tabindex', '-1');
          a.setAttribute('role', self.settings.ariaListbox ? 'option' : 'menuitem');

          // Should be translated
          if (isTranslatable) {
            span.innerText = Locale.translate(span.innerText) || span.innerText;
          }

          // disabled menu items, by prop and by className
          var $a = $(a);
          var $li = $(li);

          if ($li.hasClass('is-disabled') || a.getAttribute('disabled') === 'true' || a.getAttribute('disabled') === 'disabled') {
            $li.addClass('is-disabled');
            a.setAttribute('aria-disabled', 'true');
            a.setAttribute('disabled', true);
          } else {
            $li.removeClass('is-disabled');
            $a.removeAttr('aria-disabled');
            a.removeAttribute('disabled');
          }

          // menu items that contain submenus
          if (submenu instanceof HTMLElement) {
            submenu.classList.add('popupmenu');
          }
          if (submenuWrapper instanceof HTMLElement) {
            li.className += (DOM.classNameExists(li) ? ' ' : '') + 'submenu';
            submenu = $(submenuWrapper).children('ul')[0];
            submenu.classList.add('popupmenu');
          }
          if (DOM.hasClassName(li.className, 'submenu')) {
            // Add a span
            if (!span) {
              a.innerHTML = '<span>' + a.innerHTML + '</span>';
              span = $a.children('span')[0];
            }

            if ($a.find('svg.arrow').length === 0) {
              $a.append($.createIconElement({ classes: ['arrow', 'icon-dropdown'], icon: 'dropdown' }));
            }
            a.setAttribute('aria-haspopup', 'true');

            // Check for existing menus, and if present, apply a `.popupmenu` class automatically.
          }

          // is-checked
          if (DOM.hasClassName(li.className, 'is-checked')) {
            a.setAttribute('role', 'menuitemcheckbox');
            a.setAttribute('aria-checked', true);
          }

          // is-not-checked
          if (DOM.hasClassName(li.className, 'is-not-checked')) {
            li.className = li.className.replace('is-not-checked', '');
            a.setAttribute('role', 'menuitemcheckbox');
            a.removeAttribute('aria-checked');
          }
        }

        if (icon && icon.length > 0) {
          hasIcons = true;
        }
      });

      if (hasIcons) {
        contextElement.addClass('has-icons');
      } else {
        contextElement.removeClass('has-icons');
      }
    },


    /**
     * Takes a pre-existing menu item and refreshes its state.
     * @private
     * @param {HTMLElement} item the menu item to be refreshed
     * @param {object} data representing a Popupmenu data structure, containing updated state information
     * @param {function} [callback] runs on completion of the item refresh.  Can be used for adding additional
     *  important flags/properties to the Menu Item for a specific implementation.
     * @returns {void}
     */
    refreshMenuItem: function refreshMenuItem(item, data, callback) {
      if (!item || !(item instanceof HTMLElement) || !data) {
        return;
      }

      // Don't refresh the menu item if it doesn't belong to this menu
      if (!$(this.menu)[0].contains(item)) {
        return;
      }

      var itemA = item.querySelector('a');
      var itemIcon = item.querySelector('.icon:not(.close):not(.icon-dropdown)');
      var itemIconUse = void 0;

      if (data.text) {
        if (itemA.innerText.trim() !== data.text) {
          itemA.innerText = '' + data.text;
        }
      }

      if (data.disabled === true) {
        if (item.className.indexOf('hidden') === -1) {
          item.classList.add('is-disabled');
        }
      } else if (item.className.indexOf('is-disabled') > -1) {
        item.classList.remove('is-disabled');
      }

      if (data.visible === true) {
        if (item.className.indexOf('hidden') > -1) {
          item.classList.remove('hidden');
        }
      } else if (item.className.indexOf('hidden') === -1) {
        item.classList.add('visible');
      }

      if (data.icon) {
        // TODO: fragile?
        if (itemIcon) {
          itemIconUse = itemIcon.querySelector('use');
          if (itemIconUse && itemIconUse.getAttribute('xlink:href').replace('#icon-', '') !== data.icon) {
            itemIcon.remove();
          }
          itemIconUse.setAttribute('xlink:href', '#icon-' + data.icon);
        }
      } else if (itemIcon) {
        itemIcon.remove();
      }

      // TODO: Submenus
      // Build so the submenu data structure is used to rerun this method against each submenu item.
      if (data.submenu) {
        var submenuItems = item.querySelector('.popupmenu').children;
        for (var i = 0; i < data.submenu.length; i++) {
          data.submenu[i].isSubmenuItem = true;
          this.refreshMenuItem(submenuItems.item(i), data.submenu[i], callback);
        }
      }

      // Run callback to apply additional refresh changes, if applicable.
      if (typeof callback === 'function') {
        callback.apply(this, [item, data]);
      }
    },


    /**
     * Sets up the event listener structure for the popupmenu
     * @private
     * @listens dragstart
     * @listens contextmenu
     * @listens keydown
     * @listens updated
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var self = this;
      var leftClick = this.settings.trigger !== 'rightClick';
      var immediate = this.settings.trigger === 'immediate';

      function disableBrowserContextMenu(e) {
        e.stopPropagation();
        e.preventDefault();
        return false;
      }

      function doOpen(e) {
        if (self.element.hasClass('is-disabled')) {
          e.stopPropagation();
          e.preventDefault();
          return;
        }

        var rightClick = self.settings.trigger === 'rightClick';

        e.stopPropagation();
        e.preventDefault();

        if (rightClick && self.menu.hasClass('is-open')) {
          self.close();
          self.open(e);
          return;
        }

        if (self.menu.hasClass('is-open')) {
          self.close();
        } else {
          self.open(e);
        }
      }

      function contextMenuHandler(e, isLeftClick) {
        e.preventDefault();

        if (self.keydownThenClick) {
          delete self.keydownThenClick;
          return;
        }

        var btn = isLeftClick === true ? 0 : 2;
        if (e.button > btn || self.element.is(':disabled')) {
          return;
        }

        var allowedOS = ['android', 'ios'];
        if (allowedOS.indexOf(Environment.os.name) > -1) {
          self.holdingDownClick = true;
        }

        doOpen(e);
      }

      if (!immediate) {
        // Left-Click activation
        if (leftClick) {
          this.element.on('click.popupmenu', function (e) {
            contextMenuHandler(e, true);
          });
        }

        // Right-Click activation
        if (!leftClick) {
          this.menu.parent().on('contextmenu.popupmenu', disableBrowserContextMenu);

          var disallowedOS = ['android', 'ios'];
          if (disallowedOS.indexOf(Environment.os.name) === -1) {
            // Normal desktop operation
            this.element.on('contextmenu.popupmenu', function (e) {
              disableBrowserContextMenu(e);
              contextMenuHandler(e);
            });
          } else {
            // Touch-based operation on a mobile device
            this.element.on('touchstart.popupmenu', function (e) {
              // iOS needs this prevented to prevent its own longpress feature in Safari
              if (Environment.os.name === 'ios') {
                e.preventDefault();
              }
              $(e.target).addClass('longpress-target');
            }).on('touchend.popupmenu', function (e) {
              $(e.target).removeClass('longpress-target');
            }).on('longpress.popupmenu', function (e, originalE) {
              self.openedWithTouch = true;
              contextMenuHandler(originalE);
            });
          }
        }
      }

      // Disable dragging text to a new browser tab
      this.menu.off('dragstart.popupmenu').on('dragstart.popupmenu', 'a', function () {
        return false;
      });

      // Setup these next events no matter what trigger type is
      this.element.not('.autocomplete, ul').on('keydown.popupmenu', function (e) {
        switch (e.which) {
          case 13:
          case 32:
            if (self.settings.trigger === 'click') {
              self.keydownThenClick = true;
              self.open(e);
            }
            break;
          case 121:
            if (e.shiftKey) {
              // Shift F10
              self.open(e);
            }
            break;
          default:
            break;
        }
      }).on('updated.popupmenu', function (e, settings) {
        e.stopPropagation();
        self.updated(settings);
      });
    },
    handleKeys: function handleKeys() {
      var self = this;
      // http://access.aol.com/dhtml-style-guide-working-group/#popupmenu

      // Handle Events in Anchors
      this.menu.on('click.popupmenu', 'li', function (e) {
        var a = $(this).find('a');
        self.handleItemClick(e, a);
      });

      var excludes = 'li:not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)';

      // Select on Focus
      if (this.settings.mouseFocus) {
        this.menu.on('mouseenter.popupmenu', 'li', function () {
          self.highlight($(this).children('a'));
        });
      }

      setTimeout(function () {
        $(document).off('keydown.popupmenu.' + this.id).on('keydown.popupmenu.' + this.id, function (e) {
          var key = e.which;

          // Close on escape
          if (key === 27) {
            e.stopPropagation();
            e.stopImmediatePropagation();
            self.close(true);
            return false;
          }

          // Close on tab
          if (key === 9) {
            e.stopPropagation();
            self.close(true);
          }

          // Select Checkboxes
          if (key === 32) {
            e.stopPropagation();

            var target = $(e.target);
            var checkbox = target.find('input:checkbox');

            if (checkbox.length) {
              checkbox.trigger('click');
              return true;
            }

            var a = $();

            // Return here and let Tabs control handle the spacebar
            if (target.is('.tab') || target.parent().is('.tab') || target.is('.tab-more')) {
              // Spacebar acts like Enter if there aren't any checkboxes (trigger links, etc)
              e.preventDefault();
              return true;
            }

            if (target.is('li')) {
              a = target.children('a');
            }

            if (target.is('a')) {
              a = target;
            }

            if (a.length) {
              a.trigger('click');
              return true;
            }
          }

          var focus = self.menu.find(':focus');

          // Sets focus for functional testing
          if (!focus[0]) {
            focus = $(self.menu[0].querySelector('.is-focused a'));
          }

          var isPicker = self.settings.menu === 'colorpicker-menu';
          var isAutocomplete = self.element.is('.autocomplete');

          // Close Submenu
          if (key === 37 && !isAutocomplete) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.closest('.popupmenu')[0] !== self.menu[0] && focus.closest('.popupmenu').length > 0) {
              focus.closest('.popupmenu').removeClass('is-open').parent().parent().removeClass('is-submenu-open');
              self.highlight(focus.closest('.popupmenu').parent().prev('a'));
            }
          }

          var getPrev = void 0;
          var getNext = void 0;
          var getLast = void 0;
          var getFirst = void 0;

          getPrev = function getPrev(a) {
            //eslint-disable-line
            var prevs = a.parent().prevAll(excludes);
            var prev = void 0;

            prevs.each(function () {
              if (prev) {
                return;
              }

              var li = $(this);
              var targetA = li.children('a');

              if (li.is('.is-disabled') || targetA.prop('disabled') === true) {
                return;
              }
              prev = targetA;
            });

            if (!prev) {
              return getFirst(a);
            }

            return prev;
          };

          getFirst = function getFirst(a) {
            //eslint-disable-line
            var first = a.parent().prevAll(excludes).last();
            var targetA = first.children('a');

            if (first.is('.is-disabled') || targetA.prop('disabled') === true) {
              return getNext(targetA);
            }

            return targetA;
          };

          getNext = function getNext(a) {
            //eslint-disable-line
            var nexts = a.parent().nextAll(excludes);
            var next = void 0;

            nexts.each(function () {
              if (next) {
                return;
              }

              var li = $(this);
              var targetA = li.children('a');

              if (li.is('.is-disabled') || targetA.prop('disabled') === true) {
                return;
              }
              next = targetA;
            });

            if (!next) {
              return getFirst(a);
            }

            return next;
          };

          getLast = function getLast(a) {
            //eslint-disable-line
            var last = a.parent().nextAll(excludes).last();
            var targetA = last.children('a');

            if (last.is('.is-disabled') || targetA.prop('disabled') === true) {
              return getPrev(targetA);
            }

            return targetA;
          };

          // Count number of rows in picker
          var rowCount = 0;
          var colors = self.menu.children(excludes);
          var colorsLength = colors.length;
          var currentOffsetTop = 0;

          for (var i = 0; i < colorsLength; i++) {
            var colorItem = colors[i];

            if (currentOffsetTop === 0) {
              currentOffsetTop = colorItem.offsetTop;
            }

            if (colorItem.offsetTop === currentOffsetTop) {
              rowCount++;
            } else {
              break;
            }
          }

          // Up on Up
          if (!isPicker && key === 38 || isPicker && key === 37) {
            e.stopPropagation();
            e.preventDefault();

            // Go back to Top on the last one
            if (focus.parent().prevAll(excludes).length === 0) {
              if (focus.length === 0) {
                self.highlight(self.menu.children(excludes).last().find('a'));
              } else {
                self.highlight(getLast(focus));
              }
              return undefined;
            }
            self.highlight(getPrev(focus));
          }

          // Up a square
          if (isPicker && key === 38) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.parent().prevAll(excludes).length > 0) {
              self.highlight($(focus.parent().prevAll(excludes)[rowCount - 1]).find('a'));
            }
          }

          // Right Open Submenu
          if (key === 39 && !isAutocomplete) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.parent().hasClass('submenu')) {
              self.openSubmenu(focus.parent());
              self.highlight(focus.parent().find('.popupmenu a:first'));
            }
          }

          // Down
          if (!isPicker && key === 40 || isPicker && key === 39 && !isAutocomplete) {
            e.stopPropagation();
            e.preventDefault();

            // Go back to Top on the last one
            if (focus.parent().nextAll(excludes).length === 0) {
              if (focus.length === 0) {
                self.highlight(self.menu.children(excludes).first().find('a'));
              } else {
                self.highlight(getFirst(focus));
              }
              return undefined;
            }
            self.highlight(getNext(focus));
          }

          // Down a square
          if (isPicker && key === 40) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.parent().nextAll(excludes).length > 0) {
              self.highlight($(focus.parent().nextAll(excludes)[rowCount - 1]).find('a'));
            }
          }
          return undefined;
        });
      }, 1);
    },


    /**
     * Handles the action of clicking items in the popupmenu.
     * @private
     * @param {jQuery.Event} e jQuery `click` event
     * @param {jQuery[]} anchor the anchor tag element that was clicked
     * @returns {boolean} whether or not the click handler successfully passed.
     */
    handleItemClick: function handleItemClick(e, anchor) {
      var href = anchor.attr('href');
      var selectionResult = [anchor];

      if (!e && !anchor) {
        return false;
      }

      if (anchor.parent().is('.submenu, .hidden, .is-disabled') || anchor[0].disabled) {
        // Do not close parent items of submenus on click
        e.preventDefault();
        return false;
      }

      if (anchor.find('input[checkbox]').length > 0) {
        return false;
      }

      if (this.element.hasClass('btn-filter')) {
        this.iconFilteringUpdate(anchor);
        e.preventDefault();
      }

      if (this.isInSelectableSection(anchor) || this.menu.hasClass('is-selectable') || this.menu.hasClass('is-multiselectable')) {
        selectionResult = this.select(anchor);
      }

      // Single toggle on off of checkbox class
      if (anchor.parent().hasClass('is-toggleable')) {
        anchor.parent().toggleClass('is-checked');
      }

      // Trigger a selected event containing the anchor that was selected
      // If an event object is not passed to `handleItemClick()`, assume it was due to this
      // event being triggered already, making it not necessary to re-trigger it.
      if (e && this.settings.triggerSelect) {
        if (selectionResult.length === 1) {
          selectionResult.push(undefined);
        }

        selectionResult.push(true);
        /**
         * Fires on selected.
         *
         * @event selected
         * @memberof PopupMenu
         * @property {object} event - The jquery event object
         * @property {object} selected anchor
         */
        this.element.triggerHandler('selected', selectionResult);
      }

      // MultiSelect Lists should act like other "multiselect" items and not
      // close the menu when options are chosen.
      if (this.menu.hasClass('is-multiselectable') || this.isInMultiselectSection(anchor)) {
        return true;
      }

      this.close();

      if (this.element.is('.autocomplete')) {
        return true;
      }

      if (href && href.charAt(0) !== '#') {
        if (anchor.attr('target') === '_blank') {
          window.open(href, '_blank');
        } else {
          window.location.href = href;
        }
        return true;
      }

      if (e) {
        e.preventDefault();
        e.stopPropagation();
      }

      return true;
    },


    /**
     * Filtering icon initial setup
     * @private
     * @param {jQuery[]} [alink] menu item to be targeted
     * @returns {void}
     */
    iconFilteringSetup: function iconFilteringSetup(alink) {
      if (this.element.hasClass('btn-filter')) {
        var svg = this.element.find('svg.icon-dropdown');
        var link = alink || $('li.is-checked a', this.menu) || $('li:first a', this.menu);
        var audibleText = link.find('span').text();

        if (svg.length === 1) {
          this.element.append($.createIconElement({ classes: 'icon-dropdown', icon: 'dropdown' }));
        }

        svg.first().changeIcon(link.find('svg').getIconName());
        this.element.find('.audible').text(audibleText);
      }
    },


    /**
     * Filtering icon update
     * @private
     * @param {jQuery[]} [alink] menu item to be targeted
     * @returns {void}
     */
    iconFilteringUpdate: function iconFilteringUpdate(alink) {
      if (this.element.hasClass('btn-filter')) {
        var link = alink || $('li.is-checked a', this.menu) || $('li:first a', this.menu);
        var audibleText = link.find('span').text();

        this.element.find('.audible').text(audibleText);
        this.element.find('svg:not(.ripple-effect):first').changeIcon(link.find('svg').getIconName());
      }
    },


    /**
     * Get the event position, handling browser cases (IE,FF) as well as SVG
     * @private
     * @param {jQuery.Event} e the mouse event to be checked for pageX/pageY
     * @returns {object} containing x/y coordinates
     */
    getPositionFromEvent: function getPositionFromEvent(e) {
      var x = 0;
      var y = 0;

      if (!e) {
        e = window.event;
      }

      if (!e) {
        return {};
      }

      if (e.changedTouches) {
        var touch = e.changedTouches[0];
        x = touch.pageX;
        y = touch.pageY;
      } else if (e.pageX || e.pageY) {
        x = e.pageX;
        y = e.pageY;
      } else if (e.clientX || e.clientY) {
        x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
      }

      return {
        x: x,
        y: y
      };
    },


    /**
     * Sets the position of the context menu.
     * @private
     * @param {jQuery.Event} e jQuery Event that caused the menu to open (can be several types)
     * @returns {void}
     */
    position: function position(e) {
      var self = this;
      var target = this.element;
      var isRTL = this.isRTL();
      var wrapper = this.menu.parent('.popupmenu-wrapper');
      var mouse = this.getPositionFromEvent(e);
      var menuDimensions = {
        width: this.menu[0].offsetWidth,
        height: this.menu[0].offsetHeight
      };

      if (!wrapper.length) {
        return;
      }

      // Make the field the same size
      var elemWidth = this.element[0].offsetWidth;
      if (this.settings.trigger === 'click' && elemWidth > menuDimensions.width) {
        this.menu.width(elemWidth);
      }

      if (target.is('svg, .icon') && target.closest('.tab').length) {
        target = target.closest('.tab');
      }

      function getCoordinates(thisE, axis) {
        axis = axis === 'x' || axis === 'y' ? axis : 'x';
        return mouse[axis]; // use mouseX/mouseY if this doesn't work
      }

      // Reset the arrow
      wrapper.find('.arrow').removeAttr('style');

      var opts = $.extend({}, this.settings.placementOpts);
      var strategies = ['flip'];

      /*
      if (!target.is('.autocomplete, .searchfield')) {
        strategies.push('nudge');
      }
      */
      strategies.push('shrink-y');
      opts.strategies = strategies;

      // If right-click or immediate (with an incoming event object), use coordinates from the event
      if (this.settings.trigger === 'immediate' && this.settings.eventObj || this.settings.trigger === 'rightClick') {
        opts.x = getCoordinates(e, 'x') - (isRTL ? menuDimensions.width : 0) + (isRTL ? -1 : 1) * this.settings.offset.x;
        opts.y = getCoordinates(e, 'y') + this.settings.offset.y;

        if (opts.x === 0 && opts.y === 0) {
          opts.x = this.settings.offset.x || 0;
          opts.y = this.settings.offset.y || 0;
          opts.parent = this.element;
          opts.placement = 'bottom';
          opts.parentXAlignment = isRTL ? 'right' : 'left';
        }
      } else {
        opts.x = this.settings.offset.x || 0;
        opts.y = this.settings.offset.y || 0;
        opts.parent = this.element;
        opts.placement = 'bottom';
        opts.strategies.push('nudge');
      }

      //= ======================================================
      // BEGIN Temporary stuff until we sort out passing these settings
      // from the controls that utilize them
      //= ======================================================

      var toolbarParent = target.parents('.toolbar');
      var insideToolbar = toolbarParent.length > 0;
      var insideToolbarTitle = target.parents('.title').length > 0;
      var isNotFullToolbar = insideToolbar && toolbarParent.children('.buttonset, .title').length > 1;
      var isPagerMenu = target.parents('.pager-pagesize').length > 0;

      function alignLeft() {
        opts.parentXAlignment = isRTL ? 'right' : 'left';
      }

      function alignRight() {
        opts.parentXAlignment = isRTL ? 'left' : 'right';
      }

      function shiftDown() {
        opts.y += 15;
      }

      // Change the alignment of the popupmenu based on certain conditions
      (function doAlignment() {
        if (target.is('.btn-menu')) {
          if (isPagerMenu) {
            return alignRight();
          }

          if (insideToolbar) {
            if (!isNotFullToolbar) {
              return alignLeft();
            }
            if (insideToolbarTitle) {
              return alignLeft();
            }
            return alignRight();
          }

          return alignLeft();
        }

        if (target.is('.btn-actions')) {
          return alignRight();
        }

        if (target.is('.tab-more')) {
          return alignRight();
        }

        if (target.is('.btn-split-menu, .tab, .searchfield-category-button') && !target.parent('.pager-pagesize').length) {
          return alignLeft();
        }

        return undefined;
      })();

      if (target.parents('.masthead').length > 0) {
        shiftDown();
      }

      // If inside a "page-container" element, constrain the popupmenu to that element
      // (fixes SOHO-6223)
      var container = this.element.parents('.page-container:not(.tab-container)');
      if (container.length) {
        opts.container = container.first();
      }

      //= ======================================================
      // END Temporary stuff until we sort out passing these settings
      // from the controls that utilize them
      //= ======================================================

      wrapper.one('afterplace.popupmenu', function (thisE, positionObj) {
        self.handleAfterPlace(thisE, positionObj);
      });

      this.wrapperPlace = new Place(wrapper, opts);
      this.wrapperPlace.place(opts);
    },
    handleAfterPlace: function handleAfterPlace(e, placementObj) {
      var wrapper = this.menu.parent('.popupmenu-wrapper');
      this.wrapperPlace.setArrowPosition(e, placementObj, wrapper);

      if (placementObj.height) {
        wrapper[0].style.height = '';
        this.menu[0].style.height = placementObj.height + (/(px|%)/i.test('' + placementObj.height) ? '' : 'px');
      }
      if (placementObj.width) {
        wrapper[0].style.width = '';
        this.menu[0].style.width = placementObj.width + (/(px|%)/i.test('' + placementObj.width) ? '' : 'px');
      }

      wrapper.triggerHandler('popupmenuafterplace', [placementObj]);
      return placementObj;
    },


    /**
     * Calls an external source.
     * @private
     * @param {jQuery.Event} [e] an event that triggered the Popupmenu to open
     *  (could be several types)
     * @param {boolean} [doOpen] causes the menu to re-open once the data has been reloaded.
     * @param {jQuery[]|HTMLElement} [contextElement] if passed, represents a submenu
     *  as the actionable, replaceable menu element instead of the main menu.
     * @param {boolean} [isSubmenu] Note that the request is a submenu for the callback.
    */
    callSource: function callSource(e, doOpen, contextElement, isSubmenu) {
      if (typeof this.settings.beforeOpen !== 'function') {
        return;
      }

      var self = this;
      var targetMenu = this.menu;

      // Use a different menu, if applicable
      if (DOM.isElement(contextElement) && $(contextElement).is('.popupmenu, .submenu')) {
        targetMenu = $(contextElement);
        // Skip calling external source if submenu is already open
        if (contextElement.hasClass('is-open')) {
          return;
        }
      }

      var response = function response(content) {
        var existingMenuItems = targetMenu.children();

        existingMenuItems.filter(function (i, item) {
          return self.predefinedItems.index(item) === -1;
        }).off().remove();

        if (content === false) {
          return false;
        }

        var newContent = $(content);
        targetMenu.append(newContent);

        var wrapper = targetMenu.parent('.wrapper, .popupmenu-wrapper');
        if (!wrapper.length) {
          wrapper = targetMenu.wrap('<div class="wrapper">').parent();
        }
        wrapper.removeAttr('style');
        self.markupItems(targetMenu);

        if (doOpen) {
          if (!targetMenu.is(self.menu)) {
            self.openSubmenu(wrapper.parent('li'), true);
          } else {
            self.open(e, true);
          }
        }
        return true;
      };

      var callbackOpts = {};
      if (!targetMenu.is(this.menu)) {
        callbackOpts.contextElement = targetMenu;
      }

      callbackOpts.element = this.element;
      callbackOpts.isSubmenu = isSubmenu;

      if (typeof this.settings.beforeOpen === 'string') {
        window[this.settings.beforeOpen](response, callbackOpts);
        return;
      }

      this.settings.beforeOpen(response, callbackOpts);
    },


    /**
     * Opens the popupmenu, including repopulating data and setting up visual delays, if necessary.
     * @param {jQuery.Event} e the event that caused the menu to open
     * @param {boolean} ajaxReturn set to true if the open routine should not include a source call
     * @param {boolean} useDelay set to true if the menu should open on a delay (used in mobile environments where a software keybord is present)
     * @returns {void}
     */
    open: function open(e, ajaxReturn, useDelay) {
      var self = this;
      /**
       * Fires before open.
       *
       * @event beforeopen
       * @memberof PopupMenu
       * @property {object} event - The jquery event object
       * @property {object} this menu instance
       */
      var canOpen = this.element.triggerHandler('beforeopen', [this.menu]);
      if (canOpen === false) {
        return;
      }

      // Check external AJAX source, if applicable
      if (!ajaxReturn) {
        canOpen = this.callSource(e, true);

        if (this.settings.beforeOpen) {
          return;
        }
      }

      // If there's no explicit run of this method without this flag, setup a delay and re-run the open method
      if (!useDelay) {
        if (Environment.os.name === 'ios') {
          setTimeout(function () {
            self.open(e, ajaxReturn, true);
          }, 400);
          return;
        }
      }

      var otherMenus = $('.popupmenu.is-open').filter(function () {
        return $(this).parents('.popupmenu').length === 0;
      }).not(this.menu); // close others.

      otherMenus.each(function () {
        var trigger = $(this).data('trigger');
        if (!trigger || !trigger.length) {
          return;
        }

        var api = $(this).data('trigger').data('popupmenu');
        if (api && typeof api.close === 'function') {
          api.close();
        }
      });

      // Close open dropdowns
      $('#dropdown-list').remove();

      this.element.addClass('is-open');
      this.menu.addClass('is-open').attr('aria-hidden', 'false');

      if (this.element.hasClass('inverse')) {
        this.menu.parent('.popupmenu-wrapper').addClass('inverse');
      }

      this.position(e);
      utils.fixSVGIcons(this.menu);

      if (this.element.closest('.header').length > 0) {
        this.menu.parent()[0].style.zIndex = '9001';
      }

      // Check every anchor tag to see if it should be disabled.
      // Use the CSS class on its parent to determine whether or not to disable.
      this.menu.find('a').each(function () {
        var a = $(this);
        var li = a.parent();

        if (li.hasClass('is-disabled')) {
          li.addClass('is-disabled');
          a.attr('aria-disabled', 'true');
          a.attr('disabled', 'disabled');
        } else {
          li.removeClass('is-disabled');
          a.removeAttr('aria-disabled');
          a.removeAttr('disabled');
        }
      });

      // Close on Document Click ect..
      setTimeout(function () {
        $(document).on('touchend.popupmenu.' + self.id + ' click.popupmenu.' + self.id, function (thisE) {
          if (thisE.button === 2) {
            return;
          }

          if (self.holdingDownClick) {
            delete self.holdingDownClick;
            return;
          }

          // Click functionality will toggle the menu - otherwise it closes and opens
          if ($(thisE.target).is(self.element)) {
            return;
          }

          if ($(thisE.target).closest('.popupmenu').length === 0) {
            self.close(true, self.settings.trigger === 'rightClick');
          }
        });

        // in desktop environments, close the list on viewport resize
        if (window.orientation === undefined) {
          $('body').on('resize.popupmenu', function () {
            self.handleCloseEvent();
          });
        }

        $(window).on('scroll.popupmenu', function () {
          self.close();
        });

        $('.scrollable, .modal.is-visible .modal-body-wrapper').on('scroll.popupmenu', function () {
          self.close();
        });

        /**
         * Fires on open.
         *
         * @event open
         * @memberof PopupMenu
         * @property {object} event - The jquery event object
         * @property {object} this menu instance
         */
        self.element.triggerHandler('open', [self.menu]);
      }, 300);

      // Hide on iFrame Clicks - only works if on same domain
      $('iframe').each(function () {
        var frame = $(this);
        frame.ready(function () {
          try {
            frame.contents().find('body').on('click.popupmenu', function () {
              self.close();
            });
          } catch (thisE) {
            // Ignore security errors on out of iframe
          }
        });
      });

      this.handleKeys();

      // hide and decorate submenus - we use a variation on
      var tracker = 0;
      var startY = void 0;
      var menuToClose = void 0;
      var timeout = void 0;

      self.menu.find('.popupmenu').removeClass('is-open');
      self.menu.on('mouseenter.popupmenu touchstart.popupmenu', '.submenu', function (thisE) {
        var menuitem = $(this);
        startY = thisE.pageX;

        clearTimeout(timeout);
        timeout = setTimeout(function () {
          self.openSubmenu(menuitem);
        }, 300);

        $(document).on('mousemove.popupmenu.' + this.id, function (documentE) {
          tracker = documentE.pageX;
        });
      }).on('mouseleave.popupmenu', '.submenu', function () {
        $(document).off('mousemove.popupmenu.' + this.id);

        menuToClose = $(this).find('ul');

        var hasWrapper = menuToClose.parent('.wrapper').length > 0;
        var isLeft = (hasWrapper ? parseInt(menuToClose.parent('.wrapper')[0].style.left, 10) : 0) < 0;
        var canClose = tracker - startY < 3.5;

        if (isLeft) {
          canClose = tracker - startY >= 0;
        }

        if (canClose) {
          // We are moving slopie to the menu
          menuToClose.removeClass('is-open').removeAttr('style');
          menuToClose.parent('.wrapper').removeAttr('style');
          menuToClose.parent().parent().removeClass('is-submenu-open');
          menuToClose = null;
        }
        clearTimeout(timeout);
      });

      if (self.settings.autoFocus) {
        setTimeout(function () {
          var excludes = ':not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)';
          var selection = self.menu.children(excludes).find('.is-selected').children('a');

          if (!selection.length) {
            selection = self.menu.children(excludes).first().children('a');
          }

          self.highlight(selection);
          /**
           * Fires after open.
           *
           * @event afteropen
           * @memberof PopupMenu
           * @property {object} event - The jquery event object
           * @property {object} this menu instance
           */
          self.element.triggerHandler('afteropen', [self.menu]);
        }, 1);
      }
    },


    /**
     * Only allows a menu to close if a key is no longer being pressed
     * @private
     * @returns {void}
     */
    handleCloseEvent: function handleCloseEvent() {
      if (this.holdingDownClick) {
        return;
      }

      this.close();
    },


    /**
     * Opens a top-level menu item's submenu, if applicable
     * @private
     * @param {jQuery[]} li the list item that needs to be opened.
     * @param {boolean} [ajaxReturn] if defined, prevents an external source from
     *  re-populating the menu before it opens.
     * @returns {void}
     */
    openSubmenu: function openSubmenu(li, ajaxReturn) {
      if (DOM.hasClassName(li[0].className, 'is-disabled') || li[0].disabled) {
        return;
      }

      var submenu = li.children('.wrapper, .popupmenu');
      if (submenu.length && submenu.is('.wrapper')) {
        submenu = submenu.children('.popupmenu');
      }

      var canOpen = this.element.triggerHandler('beforeopen', [submenu]);
      if (canOpen === false) {
        return;
      }

      // Check external AJAX source, if applicable
      if (!ajaxReturn) {
        canOpen = this.callSource(null, true, submenu, true);
        if (this.settings.beforeOpen) {
          return;
        }
      }

      this.showSubmenu(li);
    },


    /**
     * Opens a top-level menu item's submenu, if applicable
     * @private
     * @param {jQuery[]} li the list item that needs to be opened.
     * @returns {void}
     */
    showSubmenu: function showSubmenu(li) {
      // Trigger an event so other components can listen to this element as a popupmenu trigger.
      this.element.triggerHandler('show-submenu', [li]);

      var wrapper = li.children('.wrapper').filter(':first');
      var isRTL = this.isRTL();
      var rtlPadding = 30;

      // Wrap if not wrapped (dynamic menu situation)
      if (wrapper.length === 0) {
        var ul = li.children('ul').filter(':first');
        ul.wrap('<div class="wrapper"></div>');
        wrapper = ul.parent();
      }

      var menu = wrapper.children('.popupmenu');
      var mainWrapperOffset = li.parents('.popupmenu-wrapper:first').offset().top;
      var wrapperLeft = li.position().left + li.outerWidth();
      var wrapperWidth = 0;

      li.parent().find('.popupmenu').removeClass('is-open').removeAttr('style');

      wrapper.children('.popupmenu').addClass('is-open');
      wrapperWidth = wrapper.outerWidth();

      if (isRTL) {
        wrapperLeft = li.position().left - wrapperWidth;
      }
      wrapper[0].style.left = wrapperLeft + 'px';
      wrapper[0].style.top = parseInt(li.position().top, 10) - 5 + 'px';

      // Handle Case where the menu is off to the right
      var menuWidth = menu.outerWidth();
      if (wrapper.offset().left + menuWidth > $(window).width() + $(document).scrollLeft() || isRTL && wrapper.offset().left < 0) {
        wrapper[0].style.left = '-9999px';
        menuWidth = menu.outerWidth();
        wrapperLeft = li.position().left - menuWidth;

        if (isRTL) {
          var parentMenuWidth = wrapper.closest('.popupmenu').outerWidth();
          wrapperLeft = parentMenuWidth - 4; // Move back across the parent menu
        }
        wrapper[0].style.left = wrapperLeft + 'px';

        // Did it fit?
        if (wrapper.offset().left < 0 || isRTL && wrapper.offset().left + menuWidth > $(window).width() + $(document).scrollLeft()) {
          // No. Push the menu's left offset onto the screen.
          wrapperLeft = li.position().left - menuWidth + Math.abs(wrapper.offset().left) + 40;
          if (isRTL) {
            wrapperLeft = li.position().left - menuWidth - rtlPadding;
          }
          wrapper[0].style.left = wrapperLeft + 'px';
          menuWidth = menu.outerWidth();
        }

        // Do one more check to see if the right edge bleeds off the screen.
        // If it does, shrink the menu's X size.
        if (wrapper.offset().left + menuWidth > $(window).width() + $(document).scrollLeft() || isRTL && wrapper.offset().left < 0) {
          var differenceY = wrapper.offset().left + menuWidth - ($(window).width() + $(document).scrollLeft());
          menuWidth -= differenceY;
          menu[0].style.width = menuWidth + 'px';
        }
      }

      // Handle Case where menu is off bottom
      var menuHeight = menu.outerHeight();
      if (wrapper.offset().top + menuHeight > $(window).height() + $(document).scrollTop()) {
        // First try bumping up the menu to sit just above the bottom edge of the window.
        var bottomEdgeCoord = wrapper.offset().top + menuHeight;
        var differenceFromBottomY = bottomEdgeCoord - ($(window).height() + $(document).scrollTop());

        wrapper[0].style.top = wrapper.position().top - differenceFromBottomY + 'px';

        // Does it fit?
        if (wrapper.offset().top + menuHeight > $(window).height() + $(document).scrollTop()) {
          // No. Bump the menu up higher based on the menu's height and the extra
          // space from the main wrapper.
          wrapper[0].style.top = $(window).height() + $(document).scrollTop() - menuHeight - mainWrapperOffset + 'px';
        }

        // Does it fit now?
        if (wrapper.offset().top - $(document).scrollTop() < 0) {
          // No. Push the menu down onto the screen from the top of the window edge.
          wrapper[0].style.top = 0;
          wrapper[0].style.top = wrapper.offset().top * -1 + 'px';
          menuHeight = menu.outerHeight();
        }

        // Do one more check to see if the bottom edge bleeds off the screen.
        // If it does, shrink the menu's Y size and make it scrollable.
        if (wrapper.offset().top + menuHeight > $(window).height() + $(document).scrollTop()) {
          var differenceX = wrapper.offset().top + menuHeight - ($(window).height() + $(document).scrollTop());
          menuHeight = menuHeight - differenceX - 32;
          menu[0].style.height = menuHeight + 'px';
        }
      }

      li.parent().find('.is-submenu-open').removeClass('is-submenu-open');
      li.addClass('is-submenu-open');
    },


    /**
     * Places a highlighted visual state on an item inside the menu
     * @private
     * @param {jQuery[]} anchor the anchor tag representing the menu item.
     * @returns {void}
     */
    highlight: function highlight(anchor) {
      if (!anchor || !anchor.length) {
        return;
      }

      var li = anchor.parent();

      li.parent().children('li').removeClass('is-focused');
      li.addClass('is-focused');

      // Prevent chrome from scrolling - toolbar
      anchor.focus();
      li.closest('.header').scrollTop(0);
    },


    /**
     * Adds/removes checkmarks that are in selectable groups inside the Popupmenu
     * @param {jQuery[]} anchor the anchor tag representing the menu item.
     * @returns {array} updated references to the anchor and its state.
     */
    select: function select(anchor) {
      var singleMenu = this.menu.is('.is-selectable');
      var multipleMenu = this.menu.is('.is-multiselectable');
      var singleSection = this.isInSingleSelectSection(anchor);
      var multipleSection = this.isInMultiselectSection(anchor);
      var parent = anchor.parent();
      var returnObj = [anchor];

      // If the entire menu is "selectable", place the checkmark where it's supposed to go.
      if (singleMenu || singleSection) {
        parent.prevUntil('.heading, .separator').add(parent.nextUntil('.heading, .separator')).removeClass('is-checked');
        parent.addClass('is-checked');
        returnObj.push('selected');
        return returnObj;
      }

      if (multipleMenu || multipleSection) {
        if (parent.hasClass('is-checked')) {
          parent.removeClass('is-checked');
          returnObj.push('deselected');
          return returnObj;
        }
        parent.addClass('is-checked');
        returnObj.push('selected');
        return returnObj;
      }

      return returnObj;
    },


    /**
     * Gets references to top-level menu items that are currently selected.
     * @returns {jQuery[]} elements inside the top-level menu that are selected.
     */
    getSelected: function getSelected() {
      if (!this.menu.is('.is-selectable, .is-multiselectable')) {
        return $();
      }

      return this.menu.children('.is-checked').children('a');
    },


    /**
     * Determines whether or not an anchor resides inside of a selectable Popupmenu section.
     * @param {jQuery[]} anchor the anchor tag being checked.
     * @returns {jQuery[]} elements inside the top-level menu that are selected.
     */
    isInSelectableSection: function isInSelectableSection(anchor) {
      var separator = anchor.parent().prevAll().filter('.separator').first();
      return separator.hasClass('multi-selectable-section') || separator.hasClass('single-selectable-section');
    },


    /**
     * Determines whether or not an anchor resides inside of a single-selectable Popupmenu section.
     * @param {jQuery[]} anchor the anchor tag being checked.
     * @returns {jQuery[]} elements inside the top-level menu that are selected
     *  within a single-selectable section.
     */
    isInSingleSelectSection: function isInSingleSelectSection(anchor) {
      return anchor.parent().prevAll().filter('.separator').first().hasClass('single-selectable-section');
    },


    /**
     * Determines whether or not an anchor resides inside of a multi-selectable Popupmenu section.
     * @param {jQuery[]} anchor the anchor tag being checked.
     * @returns {jQuery[]} elements inside the top-level menu that are selected
     *  within a multi-selectable section.
     */
    isInMultiselectSection: function isInMultiselectSection(anchor) {
      return anchor.parent().prevAll().filter('.separator').first().hasClass('multi-selectable-section');
    },


    /**
     * Removes event listeners from all popupmenu elements.
     * @private
     * @returns {void}
     */
    detach: function detach() {
      $(document).off('touchend.popupmenu.' + this.id + ' click.popupmenu.' + this.id + ' keydown.popupmenu');
      $(window).off('scroll.popupmenu orientationchange.popupmenu');
      $('body').off('resize.popupmenu');
      $('.scrollable').off('scroll.popupmenu');

      this.menu.off('click.popupmenu touchend.popupmenu touchcancel.popupmenu');

      $('iframe').each(function () {
        var frame = $(this);
        try {
          frame.contents().find('body').off('click.popupmenu touchend.popupmenu touchcancel.popupmenu');
        } catch (e) {
          // Ignore security errors on out of iframe
        }
      });
    },


    /**
     * Close the open menu
     * @param {boolean} isCancelled Internally set option used if the operation is a cancel.
     *  Wont matter for manual api call.
     * @param {boolean} [noFocus] Do not return focus to the calling element (fx a button)
     */
    close: function close(isCancelled, noFocus) {
      if (!isCancelled || isCancelled === undefined) {
        isCancelled = false;
      }

      if (!this.menu.hasClass('is-open')) {
        return;
      }

      var wrapper = this.menu.parent('.popupmenu-wrapper');
      var menu = this.menu.find('.popupmenu');

      this.menu.removeClass('is-open').attr('aria-hidden', 'true');
      if (this.menu[0]) {
        this.menu[0].style.height = '';
        this.menu[0].style.width = '';
      }

      if (wrapper[0]) {
        wrapper[0].style.left = '-999px';
        wrapper[0].style.height = '';
        wrapper[0].style.width = '';
      }

      this.menu.find('.submenu').off(['mouseenter.popupmenu', 'mouseleave.popupmenu'].join(' ')).removeClass('is-submenu-open');

      if (menu[0]) {
        menu[0].style.left = '';
        menu[0].style.top = '';
        menu[0].style.height = '';
        menu[0].style.width = '';
      }

      this.menu.find('.is-focused').removeClass('is-focused');

      // Close all events
      $(document).off(['keydown.popupmenu.' + this.id, 'click.popupmenu.' + this.id, 'mousemove.popupmenu.' + this.id, 'touchend.popupmenu.' + self.id].join(' '));

      this.menu.off(['click.popupmenu', 'touchend.popupmenu', 'touchcancel.popupmenu', 'mouseenter.popupmenu', 'mouseleave.popupmenu'].join(' '));

      // Get rid of internal flags that check for how the menu was opened
      delete this.keydownThenClick;
      delete this.holdingDownClick;

      /**
       * Fires when close.
       *
       * @event close
       * @memberof PopupMenu
       * @property {object} event - The jquery event object
       * @property {object} close by cancelled
       */
      this.element.removeClass('is-open').triggerHandler('close', [isCancelled]);
      this.detach();

      if (this.settings.trigger === 'immediate') {
        this.destroy();
      }

      // On text input targets, don't refocus the input if the opening event was called by a touch
      if (this.element[0].tagName === 'INPUT' && this.openedWithTouch) {
        this.element.removeClass('longpress-target');
        delete this.openedWithTouch;
        return;
      }

      delete this.openedWithTouch;

      if (noFocus || !this.settings.returnFocus || Environment.features.touch) {
        return;
      }

      if (typeof this.settings.returnFocus === 'function') {
        this.settings.returnFocus(this, {
          triggerElement: this.element[0],
          menuElement: this.menu[0]
        });
        return;
      }

      if (document.activeElement && document.activeElement.tagName === 'INPUT') {
        return;
      }
      this.element.focus();
    },


    /**
     * Removes bound events and generated markup from this component
     * @private
     * @returns {void}
     */
    teardown: function teardown() {
      var self = this;
      var wrapper = this.menu.parent('.popupmenu-wrapper');

      if (this.ajaxContent) {
        this.ajaxContent.off().remove();
      }

      this.predefinedItems = $();

      this.menu.parent().off('contextmenu.popupmenu');
      if (this.element.hasClass('btn-actions')) {
        this.menu.parent().removeClass('bottom').find('.arrow').remove();
      }

      this.menu.off('dragstart.popupmenu');

      if (this.originalLocation) {
        this.originalLocation.after(this.menu);
      } else {
        // TODO: Fix when we have time - shouldn't be referencing other controls here
        var insertTarget = this.element;
        var searchfield = this.element.parent().children('.searchfield');

        if (searchfield.length) {
          insertTarget = searchfield.first();
        }
        if (this.settings.attachToBody && insertTarget) {
          this.menu.unwrap();
        }
        if (this.menu && insertTarget && !this.settings.attachToBody) {
          this.menu.insertAfter(insertTarget);
        }
      }

      this.menu.find('.submenu').children('a').each(function (i, item) {
        var spantext = $(item).find('span').text();
        var text = spantext || $(item).text();
        $(item).find('span, svg').remove();
        $(item).text(text);
      });
      this.menu.find('.submenu').removeClass('submenu');

      function unwrapPopup(menu) {
        var thisWrapper = menu.parent();
        if (thisWrapper.is('.popupmenu-wrapper, .wrapper')) {
          menu.unwrap();
        }
      }

      // Unwrap submenus
      this.menu.find('.popupmenu').each(function () {
        unwrapPopup($(this));
      });

      if (self.wrapperPlace) {
        self.wrapperPlace.destroy();
        delete self.wrapperPlace;
      }
      wrapper.off().remove();

      if (this.menu[0]) {
        $.removeData(this.menu[0], 'trigger');
      }

      this.detach();
      this.element.removeAttr('aria-controls').removeAttr('aria-haspopup').off('touchend.popupmenu touchcancel.popupmenu click.popupmenu keydown.popupmenu keypress.popupmenu contextmenu.popupmenu updated.popupmenu');

      return this;
    },


    /**
     * Updates this Popupmenu instance with new settings
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      return this.teardown().init();
    },


    /**
     * Teardown markup and detach all events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.close();
      this.teardown();
      this.menu.trigger('destroy');
      $.removeData(this.element[0], COMPONENT_NAME$8);
    }
  };

  /**
   * jQuery Component Wrapper for Popupmenu
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.popupmenu = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$8);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$8, new PopupMenu(this, settings));
      }
    });
  };

  var COMPONENT_NAME$9 = 'about';

  /**
   * The About Dialog Component is displays information regarding the application.
   * @class About
   * @param {object} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.appName='Infor Application Name'] The Main Application Name to display in the header.
   * @param {string} [settings.content] Additional text content to display at the top.
   * @param {string} [settings.copyrightYear=new Date().getFullYear()] The year displayed in the copyright, defaults to current year.
   * @param {boolean} [settings.deviceSpecs=true] Determines whether or not to display device information.
   * This information includes Browser, Platform, Locale and if Cookies are Enabled.
   * @param {string} [settings.productName] Additional product name information to display.
   * @param {boolean} [settings.useDefaultCopyright=true] Add the Legal Approved Infor Copyright Text.
   * @param {string} [settings.version] Semantic Version Number for example (4.0.0).
   */
  var ABOUT_DEFAULTS = {
    appName: 'Infor Application Name',
    content: undefined,
    copyrightYear: new Date().getFullYear(),
    deviceSpecs: true,
    productName: undefined,
    useDefaultCopyright: true,
    version: undefined
  };

  function About(element, settings) {
    this.settings = utils.mergeSettings(element, settings, ABOUT_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  About.prototype = {
    init: function init() {
      return this.setup().build().handleEvents();
    },
    setup: function setup() {
      var appName = this.element.attr('data-appname');

      this.isBody = $(this.element).is('body');
      this.settings.appName = appName !== undefined ? appName.toString() : this.settings.appName;

      var content = this.element.attr('data-about-content');
      this.settings.content = content !== undefined ? content.toString() : this.settings.content;

      var copyrightYear = this.element.attr('data-copyright-year');
      this.settings.copyrightYear = copyrightYear !== undefined ? copyrightYear.toString() : this.settings.copyrightYear;

      var deviceSpecs = this.element.attr('data-device-specs');
      if (deviceSpecs) {
        this.settings.deviceSpecs = deviceSpecs === 'true';
      }

      var productName = this.element.attr('data-product-name');
      this.settings.productName = productName !== undefined ? productName.toString() : this.settings.productName;

      var useDefaultCopyright = this.element.attr('data-use-default');
      if (useDefaultCopyright !== undefined) {
        this.settings.useDefaultCopyright = useDefaultCopyright === 'true';
      }

      var version = this.element.attr('data-version');
      this.settings.version = version !== undefined ? version.toString() : this.settings.version;

      // Get the default copyright text and cut in the current year
      this.defaultCopyright = Locale.translate('AboutText') + ' <a class="hyperlink" href="http://www.infor.com" target="_blank">www.infor.com</a>.';
      this.defaultCopyright = this.defaultCopyright.replace('{0}', this.settings.copyrightYear);

      return this;
    },
    build: function build() {
      this.modal = $('<div class="modal about" id="about-modal"></div>');
      $('<div class="modal-content"></div>').appendTo(this.modal);

      var header = $('<div class="modal-header"></div>').appendTo(this.modal.find('.modal-content'));
      $('<div class="close-container"></div>').append($('<button name="close" type="button" class="btn-icon hide-focus"></button>').append($.createIconElement({ icon: 'close', classes: 'icon-close' })).append('<span>' + Locale.translate('Close') + '\'</span>')).appendTo(header);

      $.createIconElement({ icon: 'logo-trademark', classes: ['icon', 'about-logo'] }).attr({ viewBox: '0 0 44 44' }).appendTo(header);
      this.title = $('<h1 class="title"></h1>').text(this.settings.appName).appendTo(this.modal.find('.modal-header'));

      var body = $('<div class="modal-body"></div>').appendTo(this.modal.find('.modal-content'));

      if (this.settings.version || this.settings.productName) {
        var productAndVersion = this.settings.productName ? this.settings.productName + ' ' + this.settings.version : '' + this.settings.version;

        $('<p></p>').text(productAndVersion).appendTo(body);
      }

      if (this.settings.content) {
        $('<div class="additional-content"></div>').html(this.settings.content).appendTo(body);
      }

      if (this.settings.useDefaultCopyright || !this.settings.content) {
        $('<p></p>').html(this.defaultCopyright).appendTo(body);
      }

      if (this.settings.deviceSpecs) {
        var specs = this.getDeviceSpecs();
        var specsver = this.settings;
        var text = '<span class="browser">' + Locale.translate('Browser') + ' : ' + Environment.devicespecs.currentBrowser + ' ' + Environment.devicespecs.browserMajorVersion + ' (' + Environment.devicespecs.browserVersion + ')</span><br>\n        <span class="ds">' + Locale.translate('OperatingSystem') + ' : ' + Environment.devicespecs.os + ' ' + Environment.devicespecs.currentOSVersion + '</span><br>\n        <span class="platform">' + Locale.translate('Platform') + ' : ' + specs.os + '</span><br>\n        <span class="ds">' + Locale.translate('Mobile') + ' : ' + Environment.devicespecs.isMobile + '</span><br>\n        <span class="locale">' + Locale.translate('Locale') + ' : ' + specs.locale + '</span><br>\n        <span class="cookiesEnabled">' + Locale.translate('CookiesEnabled') + ' : ' + specs.cookiesEnabled + '</span><br>\n        <span class="version">' + Locale.translate('Version') + ' : ' + specsver.version + '</span><br>';

        $('<p></p>').html(text).appendTo(body);
      }

      this.buttons = this.modal.find('button');

      this.modal.find('.hide-focus').one('blur', function () {
        $(this).removeClass('hide-focus');
      });

      this.element.attr('data-modal', 'about-modal');

      $('.modal-body', this.modal)[0].tabIndex = 0;

      this.modal.appendTo('body');
      this.modal.modal({ trigger: this.isBody ? 'immediate' : 'click' });
      return this;
    },


    /**
     * Return the browser specs. Currently returns browse, os, cookiesEnabled and locale
     * @returns {string} The specs of the browser.
     */
    getDeviceSpecs: function getDeviceSpecs() {
      var locale = navigator.appName === 'Microsoft Internet Explorer' ? navigator.userLanguage : navigator.language;
      var browser = function () {
        var ua = navigator.userAgent;
        var result = [];
        var M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

        if (/trident/i.test(M[1])) {
          result = /\brv[ :]+(\d+)/g.exec(ua) || [];
          return 'IE \'' + result[1];
        }

        if (M[1] === 'Chrome') {
          result = ua.match(/\b(OPR|Edge)\/(\d+)/);
          if (result != null) {
            return result.slice(1).join(' ').replace('OPR', 'Opera');
          }
        }

        M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
        result = ua.match(/version\/(\d+)/i);
        if (result !== null) {
          M.splice(1, 1, result[1]);
        }

        return M.join(' ');
      }();

      return {
        browser: browser,
        os: navigator.platform,
        cookiesEnabled: navigator.cookieEnabled,
        locale: locale
      };
    },


    /**
     * Update the component and optionally apply new settings.
     *
     * @param  {object} settings the settings to update to.
     * @returns {object} The plugin api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      return this;
    },


    /**
     * Progamatically close the About dialog.
     * @returns {void}
     */
    close: function close() {
      var modalApi = this.modal.data('modal');

      /**
      * Fires when the dialog is closing.
      * @event close
      * @memberof About
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */
      if (modalApi) {
        modalApi.close();
      }

      /**
      * Fires after the dialog is done closing and removed.
      * @event afterclose
      * @memberof About
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */

      if (this.isBody) {
        this.destroy();
      }
    },


    /**
     * Teardown and remove any added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      var modalApi = this.modal.data('modal');

      if (modalApi) {
        modalApi.element.off('beforeopen.about');
        modalApi.destroy();
      }

      this.buttons.off();
      this.element.off('open.about');
      $.removeData(this.element[0], COMPONENT_NAME$9);
    },


    /**
     * Add component event handlers.
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on('open.about', function (e) {
        e.stopPropagation();
        _this.element.trigger('click');
      });

      this.buttons.filter('[name="done"], [name="close"]').on('click.about', function () {
        _this.close();
      });

      /**
      * Fires when the about dialog is opening, allowing you to veto by returning false.
      *
      * @event beforeopen
      * @memberof About
      * @property {object} event The jquery event object.
      * @property {object} ui The dialog object
      */
      this.modal.data('modal').element.on('beforeopen.about', function () {
        _this.modal.find('.modal-body').scrollTop(0);
      });

      $(document).on('keydown.about', function (e) {
        // Close on Escape.
        if (e.which === 0 || e.which === 27) {
          _this.close();
        }
      });

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for About.
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} Elements being acted on.
   */
  $.fn.about = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$9);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$9, new About(this, settings));
      }
    });
  };

  // Height Animation Controls
  // Adapted from: http://n12v.com/css-transition-to-from-auto/
  // Contains a handful of animation helper methods that attempt
  // to DRY up CSS-powered sliding animations.

  /**
   * animateOpen default settings
   * @namespace
   * @property {string} direction horizontal or vertical
   * @property {string|number} distance in pixels that the animation covers. defaults to 'auto',
   *  or can pixel value size.
   * @property {number} timing delay in Miliseconds
   * @property {string} transition settings for the CSS Transition Timing Function
   */
  var ANIMATE_OPEN_DEFAULTS = {
    direction: 'vertical',
    distance: 'auto',
    timing: 300,
    transition: 'cubic-bezier(.17, .04, .03, .94)'
  };

  // Use CSS Transitions to animate from "0" to "auto" widths
  $.fn.animateOpen = function (settings) {
    var eventName = $.fn.transitionEndName();
    settings = utils.mergeSettings(undefined, settings, ANIMATE_OPEN_DEFAULTS);

    // Initialize the plugin (Once)
    return this.each(function () {
      var self = this;
      var $self = $(this);
      var dim = settings.direction === 'horizontal' ? 'width' : 'height';
      var cDim = dim.charAt(0).toUpperCase() + dim.slice(1);
      var distance = !isNaN(settings.distance) ? parseInt(settings.distance, 10) + 'px' : 'auto';
      var timeout = void 0;

      function transitionEndCallback() {
        if (timeout) {
          clearTimeout(timeout);
        }

        if ($self.data('ignore-animation-once')) {
          $.removeData($self[0], 'ignore-animation-once');
        }

        if ($self.data('is-animating')) {
          $.removeData($self[0], 'is-animating');
        }

        $self.off(eventName + '.animateopen');
        self.style.transition = '';
        self.style[dim] = distance;
        $self.trigger('animateopencomplete');
      }

      // Clear any previous attempt at this animation when the animation starts new
      $self.one('animateopenstart.animation', function (e) {
        e.stopPropagation();
        $self.off(eventName + '.animateopen');
      });
      $self.trigger('animateopenstart');

      // Trigger the callback either by Timeout or by TransitionEnd
      if (eventName) {
        $self.one(eventName + '.animateopen', transitionEndCallback);
      }

      // Animate
      $self.data('is-animating', true);
      var prevVal = this.style[dim];
      this.style[dim] = distance;
      var endVal = getComputedStyle(this)[dim];
      this.style[dim] = prevVal;
      // next line forces a repaint
      this['offset' + cDim]; // eslint-disable-line
      this.style.transition = dim + ' ' + settings.timing + 'ms ' + settings.transition;

      timeout = setTimeout(transitionEndCallback, settings.timing);
      this.style[dim] = endVal;

      // Trigger immediately if this element is invisible or has the 'no-transition' class
      if ($self.is(':hidden') || $self.is('.no-transition') || $self.data('ignore-animation-once')) {
        transitionEndCallback();
      }
    });
  };

  /**
   * Animate closed defaults
   * @namespace
   * @property {string} direction horizontal or vertical
   * @property {number} timing delay in Miliseconds
   * @property {string} transition settings for the CSS Transition Timing Function
   */
  var ANIMATE_CLOSED_DEFAULTS = {
    direction: 'vertical',
    timing: 300,
    transition: 'cubic-bezier(.17, .04, .03, .94)'
  };

  // Use CSS Transitions to animate from "auto" to "0" widths
  $.fn.animateClosed = function (settings) {
    var eventName = $.fn.transitionEndName();
    settings = utils.mergeSettings(undefined, settings, ANIMATE_CLOSED_DEFAULTS);

    // Initialize the plugin (Once)
    return this.each(function () {
      var self = this;
      var $self = $(this);
      var dim = settings.direction === 'horizontal' ? 'width' : 'height';
      var cDim = dim.charAt(0).toUpperCase() + dim.slice(1);
      var timeout = void 0;

      function transitionEndCallback() {
        if (timeout) {
          clearTimeout(timeout);
        }

        if ($self.data('ignore-animation-once')) {
          $.removeData($self[0], 'ignore-animation-once');
        }

        if ($self.data('is-animating')) {
          $.removeData($self[0], 'is-animating');
        }

        $self.off(eventName + '.animatedclosed');
        self.style.transition = '';
        self.style[dim] = '0px';
        $self.trigger('animateclosedcomplete');
      }

      // Clear any previous attempt at this animation when the animation starts new
      $self.one('animateclosedstart', function (e) {
        e.stopPropagation();
        $self.off(eventName + '.animatedclosed');
      });
      $self.trigger('animateclosedstart');

      // Trigger the callback either by Timeout or by TransitionEnd
      if (eventName) {
        $self.one(eventName + '.animatedclosed', transitionEndCallback);
      }

      // Animate
      $self.data('is-animating', true);
      this.style[dim] = getComputedStyle(this)[dim];
      // next line forces a repaint
      this['offset' + cDim]; // eslint-disable-line
      this.style.transition = dim + ' ' + settings.timing + 'ms ' + settings.transition;

      timeout = setTimeout(transitionEndCallback, settings.timing);
      this.style[dim] = '0px';

      // Trigger immediately if this element is invisible or has the 'no-transition' class
      if ($self.is(':hidden') || $self.is('.no-transition') || $self.data('ignore-animation-once')) {
        transitionEndCallback();
      }
    });
  };

  // Chainable jQuery plugin that checks if an element is in the process of animating
  $.fn.isAnimating = function () {
    return this.each(function () {
      return $(this).data('is-animating') === true;
    });
  };

  /* eslint-disable consistent-return */

  // Component Name
  var COMPONENT_NAME$a = 'accordion';

  /**
   * The Accordion is a grouped set of collapsible panels used to navigate sections of
   * related content. Each panel consists of two levels: the top level identifies the
   * category or section header, and the second level provides the associated options.
   *
   * @class Accordion
   * @param {object} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.allowOnePane=true] If set to true, allows only one pane of the Accordion to be open at a
   * time.  If an Accordion pane is open, and that pane contains sub-headers only one of the pane's sub-headers can be open at a time. (default true)
   * @param {string} [settings.displayChevron=true]  Displays a "Chevron" icon that sits off to the right-most
   * side of a top-level accordion header. Used in place of an Expander (+/-) if enabled.
   * @param {string} [settings.rerouteOnLinkClick=true]  Can be set to false if routing is externally handled
   * @param {boolean} [settings.source=null]  A callback function that when implemented provided a call back for "ajax loading" of tab contents on open.
   */
  var ACCORDION_DEFAULTS = {
    allowOnePane: true,
    displayChevron: true,
    rerouteOnLinkClick: true,
    source: null
  };

  function Accordion(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, ACCORDION_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Accordion.prototype = {

    /**
    * Initialization kickoff point
    * @private
    * @param {jQuery[]} [headers] - if provided, only attempts to build the specified headers and
    * their related anchors/panes
    */
    init: function init(headers) {
      this.build(headers).handleEvents(headers);
    },


    /**
     * Takes a barebones Accordion markup definition and fleshes out any missing parts,
     * as well as storing references to headers, anchors, and panes.
     * @private
     * @param {jQuery[]} [headers] if provided, only attempts to build the specified headers and
     *  their related anchors/panes
     * @param {boolean} [noFilterReset] if provided, will not reset the contents of the
     * `currentlyFiltered` property.
     * @returns {object} The component api for chaining.
     */
    build: function build(headers, noFilterReset) {
      var anchors = void 0;
      var panes = void 0;
      var self = this;
      var isGlobalBuild = true;

      if (!headers || !(headers instanceof jQuery)) {
        this.headers = this.element.find('.accordion-header');
        headers = this.element.find('.accordion-header');
        this.anchors = headers.children('a');
        anchors = headers.children('a');
        this.panes = headers.next('.accordion-pane');
        panes = headers.next('.accordion-pane');
      } else {
        anchors = headers.children('a');
        panes = headers.next('.accordion-pane');
        isGlobalBuild = false;

        // update internal refs
        this.headers = this.headers.add(headers);
        this.anchors = this.anchors.add(anchors);
        this.panes = this.panes.add(panes);
      }

      var headersHaveIcons = false;

      // Accordion Headers that have an expandable pane need to have an
      // expando-button added inside of them
      headers.each(function addExpander() {
        var header = $(this);
        var hasIcons = false;
        var containerPane = header.parent();
        var isTopLevel = containerPane.is('.accordion');

        function checkIfIcons() {
          if (isTopLevel) {
            return;
          }

          if (!hasIcons) {
            header.addClass('no-icon');
            return;
          }

          containerPane.addClass('has-icons');
        }

        header.attr('role', 'presentation').hideFocus();

        // For backwards compatibility:  If an icon is found inside an anchor, bring it up to the
        // level of the header.
        header.children('a').find('svg').detach().insertBefore(header.children('a'));

        var outerIcon = header.children('.icon, svg');
        outerIcon.addClass('icon').attr({ role: 'presentation', 'aria-hidden': 'true', focusable: 'false' });
        if (isTopLevel && outerIcon.length) {
          headersHaveIcons = true;
        }

        if (header.is('.list-item') || !isTopLevel && header.find('button').length || !isTopLevel && header.find('svg').length) {
          hasIcons = true;
        }

        // Enable/Disable
        if (header.hasClass('is-disabled')) {
          header.children('a, button').attr('tabindex', '-1');
        }

        // Don't continue if there's no pane
        if (!header.next('.accordion-pane').length) {
          checkIfIcons();
          return;
        }

        hasIcons = true;

        var expander = header.children('.btn');
        if (!expander.length) {
          expander = $('<button class="btn" type="button"></button>');

          var method = 'insertBefore';
          if (self.settings.displayChevron && isTopLevel) {
            header.addClass('has-chevron');
            method = 'insertAfter';
          }
          expander[method](header.children('a'));
          header.data('addedExpander', expander);
        }

        // Hide Focus functionality
        expander.hideFocus();

        // If Chevrons are turned off and an icon is present, it becomes the expander
        if (outerIcon.length && !self.settings.displayChevron) {
          outerIcon.appendTo(expander);
        }

        var expanderIcon = expander.children('.icon, .svg, .plus-minus');
        if (!expanderIcon.length) {
          if (self.settings.displayChevron && isTopLevel) {
            expanderIcon = $.createIconElement({ icon: 'caret-down', classes: ['chevron'] });
          } else {
            var isActive = self.isExpanded(header) ? ' active' : '';
            expanderIcon = $('<span class="icon plus-minus' + isActive + '" aria-hidden="true" role="presentation"></span>');
          }
          expanderIcon.appendTo(expander);
        }
        var expanderIconOpts = {
          role: 'presentation',
          'aria-hidden': 'true'
        };
        if (!expanderIcon.is('span')) {
          expanderIconOpts.focusable = 'false';
        }
        expanderIcon.attr(expanderIconOpts);

        // Move around the Expander depending on whether or not it's a chevron
        if (expanderIcon.is('.chevron')) {
          header.addClass('has-chevron');
          expander.insertAfter(header.children('a'));
        } else {
          header.removeClass('has-chevron');
          expander.insertBefore(header.children('a'));
        }

        // Double check to see if we have left-aligned expanders or icons present,
        // so we can add classes that do alignment
        if (!self.settings.displayChevron && isTopLevel) {
          headersHaveIcons = true;
        }
        checkIfIcons();

        // Add an Audible Description to the button
        var description = expander.children('.audible');
        if (!description.length) {
          description = $('<span class="audible"></span>').appendTo(expander);
        }
        description.text(Locale.translate('Expand'));
      });

      if (headersHaveIcons) {
        this.element.addClass('has-icons');
      }

      // Setup correct ARIA for accordion panes, and auto-collapse them
      panes.each(function addPaneARIA() {
        var pane = $(this);
        var header = pane.prev('.accordion-header');

        header.children('a').attr({ 'aria-haspopup': 'true', role: 'button' });

        if (!self.isExpanded(header)) {
          pane.data('ignore-animation-once', true);
          self.collapse(header);
        }
      });

      // Expand to the current accordion header if we find one that's selected
      if (isGlobalBuild && !this.element.data('updating')) {
        var targetsToExpand = headers.filter('.is-selected, .is-expanded');
        targetsToExpand.next('.accordion-pane').addClass('no-transition');

        if (this.settings.allowOnePane) {
          targetsToExpand = targetsToExpand.first();
        }

        this.expand(targetsToExpand);
        this.select(targetsToExpand.last());
        targetsToExpand.next('.accordion-pane').removeClass('no-transition');
      }

      // Retain an internal storage of available filtered accordion headers.
      if (!noFilterReset) {
        this.currentlyFiltered = $();
      }

      return this;
    },


    /**
     * Header Click Handler
     * @private
     * @param {jQuery.Event} e The click event object
     * @param {jQuery[]} header The header query object
     * @returns {boolean} Returns false is the event should be ignored.
     */
    handleHeaderClick: function handleHeaderClick(e, header) {
      if (!header || !header.length || this.isDisabled(header) || this.isFiltered(header) || header.data('is-animating')) {
        e.preventDefault();
        return;
      }

      // Check that we aren't clicking the expando button.  If we click that, this listener dies
      if ($(e.target).is('[class^="btn"]')) {
        e.preventDefault();
        return;
      }

      var anchor = header.children('a');
      return this.handleAnchorClick(e, anchor);
    },


    /**
     * Anchor Click Handler
     * @private
     * @param {object} e The click event object.
     * @param {object} anchor The anchor jQuery object.
     * @returns {boolean} Returns false is the event should be ignored.
     */
    handleAnchorClick: function handleAnchorClick(e, anchor) {
      var self = this;
      var header = anchor.parent('.accordion-header');
      var pane = header.next('.accordion-pane');
      var ngLink = anchor.attr('ng-reflect-href');

      if (e && !ngLink) {
        e.preventDefault();
      }

      if (!header.length || this.isDisabled(header) || this.isFiltered(header)) {
        return false;
      }

      var canSelect = this.element.triggerHandler('beforeselect', [anchor]);
      if (canSelect === false) {
        return;
      }

      // Set the original element for DOM traversal by keyboard
      this.originalSelection = anchor;

      this.select(anchor);

      function followLink() {
        var href = anchor.attr('href');
        if (href && href !== '' && href !== '#') {
          if (!self.settings.rerouteOnLinkClick) {
            return true;
          }

          window.location.href = href;
          return true;
        }
        return false;
      }

      // Stop propagation here because we don't want to bubble up to the Header and
      // potentially click the it twice
      if (e) {
        e.stopPropagation();
      }

      /**
       * If the anchor is a real link, follow the link and die here.
       * This indicates the link has been followed.
       *
       * @event followlink
       * @memberof Accordion
       * @param {array} anchor - The anchor in an array
       */
      if (followLink()) {
        this.element.trigger('followlink', [anchor]);
        return true;
      }

      // If it's not a real link, try and toggle an expansion pane.
      if (pane.length) {
        self.toggle(header);
        return true;
      }

      // This flag is set by the List/Detail Pattern Wrapper.
      // If this component is controlling a detail area, the anchor shouldn't focus,
      // and it should trigger an event that will bubble to the pattern to give
      // context to the detail area.
      if (this.isControllingDetails) {
        if (!pane.length) {
          self.element.trigger('drilldown', [header[0]]);
        }
      } else {
        anchor.focus();
      }

      /**
      * Fires when an accordion header is truly selected.
      *
      * @event selected
      * @memberof Accordion
      * @param {object} event - The jquery event object
      * @param {object} header - The header object
      */
      this.element.trigger('selected', header);

      return true;
    },


    /**
    * Expander-Button Click Handler
    * @private
    * @param {object} e The click event object.
    * @param {object} expander The jquery expander DOM element.
    * @returns {boolean} Returns false in some cases if the event should stop propagating.
    */
    handleExpanderClick: function handleExpanderClick(e, expander) {
      var header = expander.parent('.accordion-header');
      if (!header.length || this.isDisabled(header) || this.isFiltered(header) || header.data('is-animating')) {
        return;
      }

      // Set the original element for DOM traversal by keyboard
      this.originalSelection = expander;

      // Don't propagate when clicking the expander.  Propagating can cause the link to be clicked in
      // cases where it shouldn't be clicked.
      if (e) {
        e.stopPropagation();
      }

      var pane = header.next('.accordion-pane');
      if (pane.length) {
        this.toggle(header);
        this.select(header);
        expander.focus();
        return;
      }

      // If there's no accordion pane, attempt to simply follow the link.
      return this.handleAnchorClick(null, header.children('a'));
    },


    /**
    * Keypress Event Handler for expanders and anchors
    * @private
    * @param {jQuery.Event} e The click event object.
    * @returns {boolean} Returns false in some cases if the event should stop propagating.
    */
    handleKeys: function handleKeys(e) {
      var self = this;
      var key = e.which;
      // will be either an anchor or expando button.  Should NEVER be the header itself.
      var target = $(e.target);
      var header = target.parent();
      var expander = header.children('[class^="btn"]').first();
      var anchor = header.children('a');

      function setInitialOriginalSelection(selection) {
        if (!selection) {
          selection = target;
        }

        if (!self.originalSelection) {
          self.originalSelection = selection;
        }
      }

      if (key === 9) {
        // Tab (also triggered by Shift + Tab)
        this.headers.removeClass('is-selected');

        if (target.is('a') && expander.length) {
          setInitialOriginalSelection(expander);
        } else {
          setInitialOriginalSelection(anchor);
        }
      }

      if (key === 32) {
        // Spacebar
        e.preventDefault();

        // Don't let this propagate and run against the header element, if it's a button
        if (target.is('[class^="btn"]')) {
          e.stopPropagation();
          e.stopImmediatePropagation();

          // Firefox will attempt to run this twice, despite the fact that we're stopping propagation.
          // Just cancel the whole thing if Firefox is running this method.
          if ($('html').hasClass('is-firefox')) {
            return;
          }
        }

        if (expander.length) {
          setInitialOriginalSelection(expander);
          return this.handleExpanderClick(null, target);
        }
        setInitialOriginalSelection(anchor);
        return this.handleAnchorClick(null, target);
      }

      if (key === 37 || key === 38) {
        // Left Arrow/Up Arrow
        e.preventDefault();
        setInitialOriginalSelection();
        if (e.shiftKey) {
          return this.ascend(header);
        }
        return this.prevHeader(header);
      }

      if (key === 39 || key === 40) {
        // Right Arrow/Down Arrow
        e.preventDefault();
        setInitialOriginalSelection();
        if (e.shiftKey) {
          return this.descend(header);
        }
        return this.nextHeader(header);
      }
    },


    /**
     * Translates all existing markup inside the accordion to a JSON-compatible object structure.
     * @param {boolean} flatten If true, places all accordion headers in the root array.
     * @param {boolean} addElementReference - if true, includes a reference to the original
     * header element inside the structure (NOT valid JSON).
     * @returns {object} The data the represents the accodion structure
     */
    toData: function toData(flatten, addElementReference) {
      var data = [];
      var topHeaders = this.element.children('.accordion-header');

      function buildHeaderJSON(el, index, parentNesting, parentArr) {
        var $el = $(el);
        var pane = $(el).next('.accordion-pane');
        var headerData = {
          text: $(el).children('a, span').text().trim(),
          index: '' + (parentNesting !== undefined ? parentNesting + '.' : '') + index
        };

        if (el.getAttribute('id')) {
          headerData.id = el.getAttribute('id');
        }

        var icon = $el.children('.icon');
        if (icon.length) {
          headerData.icon = icon[0].tagName.toLowerCase() === 'svg' ? icon[0].getElementsByTagName('use')[0].getAttribute('xlink:href') : '';
        }

        if (addElementReference) {
          headerData.element = el;
        }

        if ($el.hasClass('is-disabled')) {
          headerData.disabled = true;
        }

        if (pane.length) {
          var content = pane.children('.accordion-content');
          var subheaders = pane.children('.accordion-header');
          var subheaderData = [];

          if (content.length) {
            headerData.content = '' + content.html();
          }

          if (subheaders.length) {
            // Normally this will nest.
            // If "flatten" is true, don't nest and add straight to the parent array.
            var targetArray = subheaderData;
            if (flatten) {
              targetArray = parentArr;
            }

            subheaders.each(function (j, subitem) {
              buildHeaderJSON(subitem, j, headerData.index, targetArray);
            });

            headerData.children = subheaderData;
          }
        }

        parentArr.push(headerData);
      }

      // Start traversing the accordion
      topHeaders.each(function (i, item) {
        buildHeaderJSON(item, i, undefined, data);
      });

      return data;
    },


    /**
    * Makes a header "selected" if its expander button or anchor tag is focused.
    * @param {object} element - a jQuery object containing either an expander button or an anchor tag.
    * @returns {void}
    */
    select: function select(element) {
      if (!element || !element.length) {
        return;
      }

      // Make sure we select the anchor
      var anchor = element;
      var header = anchor.parent();

      if (element.is('.accordion-header')) {
        header = element;
        anchor = header.children('a');
      }

      if (anchor.is('[class^="btn"]')) {
        anchor = element.next('a');
      }

      if (this.isDisabled(header) || this.isFiltered(header)) {
        return;
      }

      this.headers.removeClass('child-selected').removeClass('is-selected');

      header.addClass('is-selected');

      var items = header.parentsUntil(this.element, '.accordion-pane').prev('.accordion-header');

      items.addClass('child-selected');
    },


    /**
     * Gets the currently-selected Accordion Header, if applicable.
     * @returns {jQuery[]} the currently selected Accoridon Header, or an empty jQuery selector
     *  if there are currently no headers selected.
     */
    getSelected: function getSelected() {
      return this.element.find('.is-selected');
    },


    /**
    * Checks if a particular header is disabled, or if the entire accordion is disabled..
    * @param {object} header The jquery header element
    * @returns {boolean} Whether or not the element is enabled.
    */
    isDisabled: function isDisabled(header) {
      if (this.element.hasClass('is-disabled')) {
        return true;
      }

      if (!header) {
        return false;
      }

      return header.hasClass('is-disabled');
    },


    /**
     * Checks if the header is filtered out or not
     * @param {object} header  The jquery header element
     * @returns {boolean} Whether or not the element is filtered.
     */
    isFiltered: function isFiltered(header) {
      if (!header || !header.length) {
        return false;
      }

      var cl = header[0].classList;
      return cl.contains('filtered') && !cl.contains('has-filtered-children');
    },


    /**
    * Checks if an Accordion Section is currently expanded.
    * @param {object} header The jquery header element
    * @returns {boolean} Whether or not the element is expanded.
    */
    isExpanded: function isExpanded(header) {
      if (!header || !header.length) {
        return;
      }

      return header.children('a').attr('aria-expanded') === 'true';
    },


    /**
    * Toggle the given Panel on the Accordion between expanded and collapsed.
    * @param {object} header The jquery header element.
    * @returns {void}
    */
    toggle: function toggle(header) {
      if (!header || !header.length || this.isDisabled(header) || this.isFiltered(header)) {
        return;
      }

      if (this.isExpanded(header)) {
        this.collapse(header);
        return;
      }
      this.expand(header);
    },


    /**
    * Expand the given Panel on the Accordion.
    * @param {object} header The jquery header element.
    * @param {boolean} dontCollapseHeaders if defined, will not collapse any open accordion headers
    *  (generally used while filtering)
    * @returns {$.Deferred} resolved on the completion of an accoridon pane's
    *  collapse animation (or immediately, if animation is disabled).
    */
    expand: function expand(header, dontCollapseHeaders) {
      if (!header || !header.length) {
        return;
      }

      var self = this;
      var pane = header.next('.accordion-pane');
      var a = header.children('a');
      var dfd = $.Deferred();

      var canExpand = this.element.triggerHandler('beforeexpand', [a]);
      if (canExpand === false) {
        return dfd.reject();
      }

      function continueExpand() {
        // Change the expander button into "collapse" mode
        var expander = header.children('.btn');
        if (expander.length) {
          expander.children('.plus-minus, .chevron').addClass('active');
          expander.children('.audible').text(Locale.translate('Collapse'));
        }

        var headerParents = header.parentsUntil(self.element).filter('.accordion-pane').prev('.accordion-header').add(header);

        // If we have the correct settings defined, close other accordion
        // headers that are not parents of this one.
        var collapseDfds = [];
        if (self.settings.allowOnePane && !dontCollapseHeaders) {
          self.headers.not(headerParents).each(function () {
            var h = $(this);
            if (self.isExpanded(h)) {
              collapseDfds.push(self.collapse(h));
            }
          });
        }

        // Expand all headers that are parents of this one, if applicable
        var expandDfds = [];
        headerParents.not(header).each(function () {
          var h = $(this);
          if (!self.isExpanded(h)) {
            expandDfds.push(self.expand(h));
          }
        });

        pane.addClass('is-expanded');

        /**
        * Fires when expanding a pane is initiated.
        *
        * @event expand
        * @memberof Accordion
        * @param {object} event - The jquery event object
        * @param {array} anchor - The anchor tag in an array.
        */
        self.element.trigger('expand', [a]);

        /**
         * Fires after a pane is expanded.
         *
         * @event afterexpand
         * @memberof Accordion
         * @param {jQuery.Event} [e] - The jquery event object
         * @param {array} anchor - The anchor tag in an array.
         */
        function handleAfterExpand(e) {
          var _$;

          if (e) {
            e.stopPropagation();
          }
          header.children('a').attr('aria-expanded', 'true');
          pane.triggerHandler('afterexpand', [a]);
          self.element.trigger('afterexpand', [a]);
          (_$ = $).when.apply(_$, expandDfds.concat(collapseDfds)).done(function () {
            dfd.resolve();
          });
        }

        if (pane.hasClass('no-transition')) {
          pane[0].style.display = 'block';
          pane[0].style.height = 'auto';
          handleAfterExpand();
        } else {
          pane.one('animateopencomplete', handleAfterExpand).css('display', 'block').animateOpen();
        }
      }

      // Load from an external source, if applicable
      if (!this.callSource(a, continueExpand)) {
        continueExpand.apply(this);
      }

      return dfd;
    },


    /**
     * Expands all accordion headers, if possible.
     * @returns {$.Deferred} resolved when all the accordion panes being expanded
     *  complete their animations.
     */
    expandAll: function expandAll() {
      var _$2;

      if (this.settings.allowOnePane === true) {
        return;
      }

      var self = this;
      var dfd = $.Deferred();
      var dfds = [];

      this.headers.each(function () {
        var h = $(this);
        if (!self.isExpanded(h)) {
          dfds.push(self.expand(h));
        }
      });

      (_$2 = $).when.apply(_$2, dfds).always(function () {
        dfd.resolve();
      });

      return dfd;
    },


    /**
    * Collapse the given Panel on the Accordion.
    * @param {object} header The jquery header element.
    * @returns {$.Deferred} resolved on the completion of an accoridon pane's
    *  collapse animation (or immediately, if animation is disabled).
    */
    collapse: function collapse(header) {
      if (!header || !header.length) {
        return;
      }

      var self = this;
      var pane = header.next('.accordion-pane');
      var a = header.children('a');
      var dfd = $.Deferred();

      var canExpand = this.element.triggerHandler('beforecollapse', [a]);
      if (canExpand === false) {
        return dfd.reject();
      }

      // Change the expander button into "expand" mode
      var expander = header.children('.btn');
      if (expander.length) {
        expander.children('.plus-minus, .chevron').removeClass('active');
        expander.children('.audible').text(Locale.translate('Expand'));
      }

      pane.removeClass('is-expanded').closeChildren();
      a.attr('aria-expanded', 'false');

      /**
      *  Fires when collapsed a pane is initiated.
      *
      * @event collapse
      * @memberof Accordion
      * @param {jQuery.Event} event - The jquery event object
      * @param {array} anchor - The anchor tag in an array.
      */
      self.element.trigger('collapse', [a]);

      /**
       * Fires after a pane is collapsed.
       *
       * @event aftercollapse
       * @memberof Accordion
       * @param {jQuery.Event} [e] - The jquery event object
       */
      function handleAfterCollapse(e) {
        if (e) {
          e.stopPropagation();
        }
        pane[0].style.display = 'none';
        pane[0].style.height = '0px';
        pane.triggerHandler('aftercollapse', [a]);
        self.element.trigger('aftercollapse', [a]);
        dfd.resolve();
      }

      if (pane.hasClass('no-transition')) {
        handleAfterCollapse();
      } else {
        pane.one('animateclosedcomplete', handleAfterCollapse).animateClosed();
      }

      return dfd;
    },


    /**
    * Collapses all accordion headers.
    * @returns {void}
    * @returns {$.Deferred} resolved when all the accordion panes being collapsed
    *  complete their animations.
    */
    collapseAll: function collapseAll() {
      var _$3;

      var self = this;
      var dfd = $.Deferred();
      var dfds = [];

      this.headers.each(function () {
        var h = $(this);
        if (self.isExpanded(h)) {
          dfds.push(self.collapse(h));
        }
      });

      (_$3 = $).when.apply(_$3, dfds).always(function () {
        dfd.resolve();
      });

      return dfd;
    },


    /**
     * Uses a function (this.settings.source()) to call out to an external API to fill the
     * inside of an accordion pane.
     * @param {jQuery[]} anchor The anchor element
     * @param {Function} animationCallback The call back function
     * @returns {Function} The call back function
     */
    callSource: function callSource(anchor, animationCallback) {
      if (!this.settings.source || typeof this.settings.source !== 'function') {
        return false;
      }

      var self = this;
      var header = anchor.parent();
      var pane = header.next('.accordion-pane');
      var ui = {
        anchor: anchor,
        header: header,
        pane: pane
      };

      function response() {
        self.updated();
        setTimeout(function () {
          animationCallback.apply(self);
        }, 1);
      }

      // Trigger the external method and wait for a response.
      return this.settings.source(ui, response);
    },


    /**
    * Prepares a handful of references for dealing with a specific accordion header
    * @param {object} eventTarget The event we are working with.
    * @returns {object} An object with the accordion dom elements in it.
    */
    getElements: function getElements(eventTarget) {
      var target = $(eventTarget);
      var header = void 0;
      var anchor = void 0;
      var expander = void 0;
      var pane = null;

      if (target.is('.accordion-header')) {
        header = target;
        expander = target.children('[class^="btn"]');
        anchor = target.children('a');
      }

      if (target.is('.btn')) {
        expander = target;
        header = expander.parent();
        anchor = header.children('a');
      }

      if (target.is('a')) {
        anchor = target;
        header = anchor.parent();
        expander = header.children('.btn');
      }

      pane = header.next('.accordion-pane');

      return {
        header: header,
        expander: expander,
        anchor: anchor,
        pane: pane
      };
    },


    /**
    * Selects an adjacent Accordion Header that sits directly before the currently selected
    * Accordion Header.
    * @param {object} element - a jQuery object containing either an expander button or an anchor tag.
    * @param {boolean} noDescend - if it's normally possible to descend into a sub-accordion, prevent
    * against descending.
    * @returns {void}
    */
    prevHeader: function prevHeader(element, noDescend) {
      var elem = this.getElements(element);
      var adjacentHeaders = elem.header.parent().children();
      var currentIndex = adjacentHeaders.index(elem.header);
      var target = $(adjacentHeaders.get(xssUtils.ensureAlphaNumeric(currentIndex) - 1));

      if (!adjacentHeaders.length || currentIndex === 0) {
        if (elem.header.parent('.accordion-pane').length) {
          return this.ascend(elem.header);
        }
        target = adjacentHeaders.last();
      }

      while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
        if (target.is(':only-child') || target.is(':first-child')) {
          return this.ascend(elem.header);
        }
        target = target.prev();
      }

      if (target.is('.accordion-pane')) {
        var prevHeader = target.prev('.accordion-header');
        if (this.isExpanded(prevHeader)) {
          var descendantChildren = prevHeader.next('.accordion-pane').children(':not(.accordion-content)');
          if (descendantChildren.length && !noDescend) {
            return this.descend(prevHeader, -1);
          }
        }
        target = prevHeader;

        // if no target's available here, we've hit the end and need to wrap around
        if (!target.length) {
          if (elem.header.parent('.accordion-pane').length) {
            return this.ascend(elem.header);
          }

          target = adjacentHeaders.last();
          while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
            target = target.prev();
          }
        }
      }

      this.focusOriginalType(target);
    },


    /**
    * Selects an adjacent Accordion Header that sits directly after the currently selected
    * Accordion Header.
    * @param {jQuery[]} element - a jQuery object containing either an expander button
    * or an anchor tag.
    * @param {boolean} noDescend - if it's normally possible to descend into a sub-accordion,
    * prevent against descending.
    * @returns {void}
    */
    nextHeader: function nextHeader(element, noDescend) {
      var elem = this.getElements(element);
      var adjacentHeaders = elem.header.parent().children();
      var currentIndex = adjacentHeaders.index(elem.header);
      var target = $(adjacentHeaders.get(xssUtils.ensureAlphaNumeric(currentIndex) + 1));

      if (!adjacentHeaders.length || currentIndex === adjacentHeaders.length - 1) {
        if (elem.header.parent('.accordion-pane').length) {
          return this.ascend(elem.header, -1);
        }
        target = adjacentHeaders.first();
      }

      while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
        if (target.is(':only-child') || target.is(':last-child')) {
          return this.ascend(elem.header);
        }
        target = target.next();
      }

      if (target.is('.accordion-pane')) {
        var prevHeader = target.prev('.accordion-header');
        if (this.isExpanded(prevHeader)) {
          var descendantChildren = prevHeader.next('.accordion-pane').children(':not(.accordion-content)');
          if (descendantChildren.length && !noDescend) {
            return this.descend(prevHeader);
          }
        }
        target = $(adjacentHeaders.get(xssUtils.ensureAlphaNumeric(currentIndex) + 2));

        // if no target's available here, we've hit the end and need to wrap around
        if (!target.length) {
          if (elem.header.parent('.accordion-pane').length) {
            return this.ascend(elem.header, -1);
          }

          target = adjacentHeaders.first();
          while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
            target = target.next();
          }
        }
      }

      this.focusOriginalType(target);
    },


    /**
    * Selects the first Accordion Header in the parent container of the current Accordion Pane.
    * If we're at the top level, jump out of the accordion to the last focusable element.
    * @param {object} header A jQuery object containing an Accordion header.
    * @param {number} direction If -1, sets the position to be at the end of this set of
    * headers instead of at the beginning.
    * @returns {void}
    */
    ascend: function ascend(header, direction) {
      if (!direction) {
        direction = 0;
      }

      var pane = header.parent('.accordion-pane');
      var target = pane.prev();

      if (direction === -1) {
        target = pane.next('.accordion-header');
        if (!target.length) {
          if (pane.parent('.accordion').length) {
            return this.nextHeader(pane.prev().children('a'), true);
          }

          return this.ascend(pane.prev(), -1);
        }
      }

      this.focusOriginalType(target);
    },


    /**
    * Selects the first Accordion Header in the child container of the current Accordion Header.
    * @param {jQuery[]} header - a jQuery object containing an Accordion header.
    * @param {integer} direction - if -1, sets the position to be at the end of this set of
    * headers instead of at the beginning.
    * @returns {void}
    */
    descend: function descend(header, direction) {
      if (!direction) {
        direction = 0;
      }

      var pane = header.next('.accordion-pane');
      var target = pane.children('.accordion-header').first();

      if (direction === -1) {
        target = pane.children('.accordion-header').last();
      }

      // No headers may be present.  In which case, it may be necessary to simply focus
      // the header for the current pane.
      if (!target.length) {
        return this.focusOriginalType(header);
      }

      if (this.isExpanded(target)) {
        return this.descend(target, -1);
      }

      this.focusOriginalType(target);
    },


    /**
    * Selects an Accordion Header, then focuses either an expander button or an anchor.
    * Governed by the property "this.originalSelection".
    * @param {object} header - a jQuery object containing an Accordion header.
    * @returns {void}
    */
    focusOriginalType: function focusOriginalType(header) {
      // this.select(header.children('a'));

      if (this.originalSelection.is('.btn') && header.children('.btn').length) {
        header.children('.btn').focus();
      } else {
        header.children('a').focus();
      }
    },


    /**
     * @param {jQuery[]} headers element references representing accordion headers.
     * @param {boolean} [doReset] if defined, causes the filtering system to reset.
     */
    filter: function filter(headers, doReset) {
      var _this = this;

      if (!headers || !headers.length) {
        return;
      }

      var self = this;

      if (doReset) {
        var collapsePromise = this.collapseAll();
        this.headers.removeClass('filtered has-filtered-children hide-focus');

        $.when(collapsePromise).then(function () {
          _this.currentlyFiltered = $();
          _this.build(undefined, true);
          _this.filter(headers);
        });
        return;
      }

      // If headers are included in the currentlyFiltered storage, removes the ones that
      // have previously been filtered
      var toFilter = headers.not(this.currentlyFiltered);
      var panes = toFilter.next('.accordion-pane');

      // Store a list of all modified parent headers
      var allParentHeaders = $();

      // Perform filtering
      this.headers.not(toFilter).addClass('filtered');
      toFilter.each(function (i, header) {
        var parentPanes = $(header).parents('.accordion-pane');
        if (parentPanes.length) {
          panes = panes.add(parentPanes.filter(function (j, item) {
            return panes.index(item) === -1;
          }));
          // only add headers that weren't already in the collection
          var parentHeaders = parentPanes.prev('.accordion-header').filter(function (j, item) {
            return allParentHeaders.index(item) === -1;
          });
          allParentHeaders = allParentHeaders.add(parentHeaders);
        }
      });

      allParentHeaders.addClass('has-filtered-children');
      var expandPromise = this.expand(allParentHeaders.add(panes.prev('.accordion-header')), true);

      $.when(expandPromise).done(function () {
        _this.currentlyFiltered = _this.currentlyFiltered.add(toFilter);
        self.build(undefined, true);
      });
    },


    /**
     * @param {jQuery[]} [headers] element references representing accordion headers.
     *  If provided, will cause only specific items to become unfiltered.  If not
     *  provided, removes all filtering from the accordion.
     */
    unfilter: function unfilter(headers) {
      var _this2 = this;

      if (!this.currentlyFiltered.length) {
        return;
      }

      if (!headers || !headers.length) {
        headers = this.currentlyFiltered;
      }

      // Store a list of all modified parent headers
      var allParentHeaders = $();

      this.headers.removeClass('filtered');
      headers.each(function (i, header) {
        var parentPanes = $(header).parents('.accordion-pane');
        if (parentPanes.length) {
          var parentHeaders = parentPanes.prev('.accordion-header').filter(function (j, item) {
            return allParentHeaders.index(item) === -1;
          });
          allParentHeaders = allParentHeaders.add(parentHeaders);
        }
      });

      allParentHeaders.removeClass('has-filtered-children');

      var collapseDfds = [this.collapse(headers), this.collapse(allParentHeaders)];

      $.when(collapseDfds).done(function () {
        _this2.currentlyFiltered = _this2.currentlyFiltered.not(headers);
        _this2.build(undefined, true);
      });
    },


    /**
    * Disable an accordion from events
    * @returns {void}
    */
    disable: function disable() {
      this.element.addClass('is-disabled');

      this.anchors.add(this.headers.children('[class^="btn"]')).attr('tabindex', '-1');
    },


    /**
    * Enable a disabled accordion.
    * @returns {void}
    */
    enable: function enable() {
      this.element.removeClass('is-disabled');

      this.anchors.add(this.headers.children('[class^="btn"]')).removeAttr('tabindex');
    },


    /**
       * Updates an entire accordion, or specific portion(s).
       * @param {jQuery[]} [headers] Optional jQuery object containing accordion headers whose
       * contents need to be torndown/rebound
       * @param {object} settings The current settings.
       * @returns {this} The api object
       */
    updated: function updated(headers, settings) {
      this.element.data('updating', true);

      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      var currentFocus = $(document.activeElement);
      if (!$.contains(this.element[0], currentFocus[0])) {
        currentFocus = undefined;
      }

      // If accordion headers are passed in, simply teardown/rebind events only for those sections.
      // Otherwise, re-init the entire accordion.
      if (headers && headers instanceof jQuery) {
        this.teardown(headers).init(headers);
      } else {
        this.teardown().init();
      }

      if (currentFocus && currentFocus.length) {
        currentFocus.focus();
      }

      $.removeData(this.element[0], 'updating');
      return this;
    },


    /**
    * Teardown process for accordion elements
    * @param {jQuery} [headers] The header elements to tear down (optional).
    * @returns {void}
    */
    teardown: function teardown(headers) {
      var globalEventTeardown = false;
      var headerElems = headers;

      if (this.currentlyFiltered) {
        this.unfilter(this.currentlyFiltered);
      }

      if (!headers || !(headers instanceof jQuery)) {
        headerElems = this.headers;
        globalEventTeardown = true;
      }
      var anchors = headerElems.find('a');

      headerElems.off('touchend.accordion click.accordion focusin.accordion focusout.accordion keydown.accordion mousedown.accordion mouseup.accordion').each(function () {
        var header = $(this);
        var icon = header.children('.icon');

        var hideFocus = header.data('hidefocus');
        if (hideFocus) {
          hideFocus.destroy();
        }

        if (icon.length) {
          var iconAPI = icon.data('icon');
          if (iconAPI) {
            iconAPI.destroy();
          }
        }

        var expander = header.data('addedExpander');
        if (expander) {
          expander.remove();
          $.removeData(this, 'addedExpander');
        }
      });

      anchors.off('touchend.accordion keydown.accordion click.accordion');

      headerElems.children('[class^="btn"]').off('touchend.accordion click.accordion keydown.accordion');

      if (globalEventTeardown) {
        this.element.off('updated.accordion selected.accordion');
      }

      return this;
    },


    /**
    * Teardown and remove any added markup and events.
    * @returns {void}
    */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], 'accordion');
    },


    /**
     * Teardown and remove any events.
     * @private
     * @param  {object} headers The headers to destroy
     * @returns {void}
     */
    handleEvents: function handleEvents(headers) {
      var self = this;
      var headerWhereMouseDown = null;
      var headerElems = headers;
      var globalEventSetup = false;

      // If no header elements are passed in, simply default to ALL headers.
      if (!headers || !(headers instanceof jQuery)) {
        headerElems = this.headers;
        globalEventSetup = true;
      }
      var anchors = headerElems.find('a');

      // Returns "Header", "Anchor", or "Expander" based on the element's tag
      function getElementType(element) {
        var elementType = 'Header';
        if (element.is('a')) {
          elementType = 'Anchor';
        }
        if (element.is('button')) {
          elementType = 'Expander';
        }
        return elementType;
      }

      // Intercepts a 'click' event in order to either prevent a link from being followed,
      // or allows it to continue.
      function clickInterceptor(e, element) {
        var type = getElementType(element);

        // Trigger a document click since we stop propgation, to close any open menus/popups.
        $('body').children().not('.application-menu, .modal-page-container').closeChildren();

        return self['handle' + type + 'Click'](e, element);
      }

      headerElems.on('click.accordion', function (e) {
        return clickInterceptor(e, $(this));
      }).on('focusin.accordion', function (e) {
        var target = $(e.target);

        if (!self.originalSelection) {
          self.originalSelection = target;
        }

        if (target.is(':not(.btn)')) {
          $(this).addClass('is-focused').removeClass('hide-focus');
        }
      }).on('focusout.accordion', function () {
        if (!$.contains(this, headerWhereMouseDown) || $(this).is($(headerWhereMouseDown))) {
          $(this).removeClass('is-focused');
        }
      }).on('keydown.accordion', function (e) {
        self.handleKeys(e);
      }).on('mousedown.accordion', function (e) {
        $(this).addClass('is-focused').removeClass('hide-focus');
        headerWhereMouseDown = e.target;
      }).on('mouseup.accordion', function () {
        headerWhereMouseDown = null;
      });

      anchors.on('click.accordion', function (e) {
        return clickInterceptor(e, $(this));
      });

      headerElems.children('[class^="btn"]').on('click.accordion', function (e) {
        return clickInterceptor(e, $(this));
      }).on('keydown.accordion', function (e) {
        self.handleKeys(e);
      });

      if (globalEventSetup) {
        this.element.on('selected.accordion', function (e) {
          // Don't propagate this event above the accordion element
          e.stopPropagation();
        }).on('updated.accordion', function (e, settings) {
          // Don't propagate just in case this is contained by an Application Menu
          e.stopPropagation();
          self.updated(settings);
        });
      }

      return this;
    }
  };
  /* eslint-enable no-multi-assign */

  /**
   * jQuery component wrapper for the Accordion
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.accordion = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$a);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$a, new Accordion(this, settings));
      }
    });
  };

  // Lifecycle Methods for jQuery Controls
  // Recursive methods that "globally" call certain methods on large groups of controls
  var EXCLUDED_FROM_CLOSE_CHILDREN = ['.expandable-area', '.accordion'];
  var EXCLUDED_FROM_HANDLE_RESIZE = [];

  // Used by several of these plugins to detect whether or not the "data" property in question
  // is a valid SoHo Xi Control.
  function canAccessAPI(prop) {
    return prop && !(prop instanceof jQuery);
  }

  // Used by several of these plugins to detect whether or not there is a method on a "data" api
  // that can be called.
  function canCall(prop, method) {
    var api = canAccessAPI(prop);
    if (!api) {
      return false;
    }

    return prop[method] && typeof prop[method] === 'function';
  }

  // Actually triggers the method on the control if it's possible
  function triggerAPIMethod(prop, method) {
    if (canCall(prop, method)) {
      prop[method]();
      return true;
    }
    return false;
  }

  // Tracks each element that attempts to trigger an API method.
  // If a trigger is successful, it stores it in an array that's used later.
  function findControlsOnElements(elems, method) {
    var foundControls = [];

    $.each(elems, function (index, elem) {
      $.each($(elem).data(), function (i, dataEntry) {
        if (triggerAPIMethod(dataEntry, method)) {
          foundControls.push({ elem: $(elem), control: dataEntry });
        }
      });
    });

    return foundControls;
  }

  // Kicks it all off
  function siftFor(rootElem, method, filteredOutElements) {
    if (!rootElem || !method) {
      return undefined;
    }

    rootElem = $(rootElem);
    var DOMelements = rootElem.find('*').add(rootElem);

    if (filteredOutElements) {
      DOMelements = DOMelements.not(filteredOutElements.join(', '));
    }
    var siftedControls = findControlsOnElements(DOMelements, method);

    rootElem.trigger('sift-' + method + '-complete', [siftedControls]);
    return rootElem;
  }

  // =========================================================
  // Actual Control Plugins
  // =========================================================

  $.fn.destroy = function () {
    return siftFor($(this), 'destroy');
  };

  $.fn.closeChildren = function () {
    return siftFor($(this), 'close', EXCLUDED_FROM_CLOSE_CHILDREN);
  };

  $.fn.handleResize = function () {
    return siftFor($(this), 'handleResize', EXCLUDED_FROM_HANDLE_RESIZE);
  };

  // Possible Filter Modes
  var filterModes = ['startsWith', 'contains'];

  /**
   * Abstracted search/filter for use in other controls
   * @class ListFilter
   * @constructor
   *
   * @param {object} [settings] incoming settings
   * @param {boolean} [settings.caseSensitive=false]  Set to true if searches ARE case sensitive
   * @param {string} [settings.filterMode='startsWith']  Type of search can current be either 'startsWith' or 'contains'
   * @param {function} [settings.searchableTextCallback] If defined, will take each
    filterable item passed and return user-defined, searchable text content
   */

  var LISTFILTER_DEFAULTS = {
    caseSensitive: false,
    filterMode: filterModes[0],
    searchableTextCallback: undefined
  };

  function ListFilter(settings) {
    this.settings = utils.mergeSettings(undefined, settings, LISTFILTER_DEFAULTS);
    this.init();
  }

  ListFilter.prototype = {

    /**
     * Sanitize Incoming Options
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      function setReasonableDefaults(setting, limits, preset) {
        if ($.inArray(setting, limits) === -1) {
          setting = preset;
        }
      }

      var checks = [{
        setting: this.settings.filterMode,
        limits: filterModes,
        preset: LISTFILTER_DEFAULTS.filterMode
      }];

      for (var i = 0; i < checks.length; i++) {
        setReasonableDefaults(checks[i].setting, checks[i].limits, checks[i].preset);
      }

      return this;
    },


    /**
     * Run the filter on the list for the given search term.
     * @param {array} list The array to search.
     * @param {string} term The term to look for.
     * @returns {boolean|array|jquery[]} false if filtering failed,
     *  or an array/jQuery of items that matched the filter.
     */
    filter: function filter(list, term) {
      if (!list) {
        return false;
      }

      // Check incoming list type
      if (!$.isArray(list) && !(list instanceof jQuery)) {
        return false;
      }

      // Search term must exist and must not be nothing
      if (!term || typeof term !== 'string' || !term.length) {
        return false;
      }

      var self = this;
      var items = [];
      var isJQuery = false;

      // make search term lowercase if the search is not case-senstive
      if (!this.settings.caseSensitive) {
        term = term.toLowerCase();
      }

      // If it's not an array, build an array of the incoming object(s) for iterating through
      if (!$.isArray(list)) {
        if (list instanceof jQuery || (typeof list === 'undefined' ? 'undefined' : _typeof(list)) === 'object') {
          list = $.makeArray(list);
          isJQuery = true;
        }
      }

      // If a custom callback for getting searchable content is defined, return a
      // string result from that callback. Otherwise, perform the standard method
      // of grabbing text content.
      function getSearchableContent(item) {
        if (typeof self.settings.searchableTextCallback === 'function') {
          return self.settings.searchableTextCallback(item);
        }

        var isString = typeof item === 'string';
        return xssUtils.sanitizeHTML(isString ? item : $(item).text());
      }

      // Iterates through each list item and attempts to find the provided search term.
      function searchItemIterator(item) {
        var text = getSearchableContent(item);
        var parts = text.split(' ');
        var match = false;

        if (self.settings.filterMode === 'startsWith') {
          for (var a = 0; a < parts.length; a++) {
            if (parts[a].toLowerCase().indexOf(term) === 0) {
              match = true;
              break;
            }
          }

          // Direct Match
          if (text.toLowerCase().indexOf(term) === 0) {
            match = true;
          }

          // Partial dual word match
          if (term.indexOf(' ') > 0 && text.toLowerCase().indexOf(term) > 0) {
            match = true;
          }
        }

        if (self.settings.filterMode === 'contains') {
          if (text.toLowerCase().indexOf(term) >= 0) {
            match = true;
          }
        }

        if (self.settings.filterMode === 'keyword') {
          var keywords = term.split(' ');
          for (var i = 0; i < keywords.length; i++) {
            var keyword = keywords[i];
            if (text.toLowerCase().indexOf(keyword) >= 0) {
              match = true;
              break;
            }
          }
        }

        // assume filtered server side
        if (self.settings.filterMode === null) {
          match = true;
        }

        if (match) {
          items.push(item);
        }
      }

      // Run the iterator
      list.forEach(searchItemIterator);

      // If we originally took in a jQuery selector, rebuild that jQuery selector
      // with the relevant results.
      if (isJQuery) {
        items = $(items);
      }

      // If we're not dealing with jQuery, an empty array shouldn't be returned.
      if (!isJQuery && !items.length) {
        return false;
      }

      return items;
    },


    /**
     * Updates the ListFilter with new settings
     * @param {object} [settings] incoming settings
     * @returns {object} component instance
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(undefined, settings, this.settings);

      return this.teardown().init();
    },


    /**
     * @private
     * @returns {object} component instance
     */
    teardown: function teardown() {
      return this;
    },


    /**
     * @returns {object} component instance
     */
    destroy: function destroy() {
      return this.teardown();
    }
  };

  var Tmpl = {};

  /**
   * Recursive compile function for minimal mustache templates.
   * @param  {string} template The template string.
   * @param  {object} self The data / datacontext
   * @param  {object} parent When running recursively this is the parents data when nested.
   * @param  {boolean} invert An inverted expression.
   * @returns {string} The markup
   */
  Tmpl.compile = function compile(template, self, parent, invert) {
    var render = compile;
    var output = '';
    var i = void 0;

    function get$$1(ctx, path) {
      path = path.pop ? path : path.split('.');
      ctx = ctx[path.shift()] || '';
      return 0 in path ? get$$1(ctx, path) : ctx;
    }

    self = Array.isArray(self) ? self : self ? [self] : []; // eslint-disable-line
    self = invert ? 0 in self ? [] : [1] : self; // eslint-disable-line

    var _loop = function _loop() {
      var childCode = '';
      var depth = 0;
      var inverted = void 0;
      var ctx = _typeof(self[i]) === 'object' ? self[i] : {};
      ctx = utils.extend({}, parent, ctx); // Same as Object.assign({}, parent, ctx); but safe on IE
      ctx[''] = { '': self[i] };

      template.replace(/([\s\S]*?)({{((\/)|(\^)|#)(.*?)}}|$)/g, function (match, code, y, z, close, invert, name) {
        //eslint-disable-line
        if (!depth) {
          output += code.replace(/{{{(.*?)}}}|{{(!?)(&?)(>?)(.*?)}}/g, function (match, raw, comment, isRaw, partial, name) {
            return raw ? get$$1(ctx, raw) //eslint-disable-line
            : isRaw ? get$$1(ctx, name) //eslint-disable-line
            : partial ? render(get$$1(ctx, name), ctx) //eslint-disable-line
            : !comment ? new Option(get$$1(ctx, name)).innerHTML : '';
          });
          inverted = invert;
        } else {
          childCode += depth && !close || depth > 1 ? match : code;
        }
        if (close) {
          if (! --depth) {
            name = get$$1(ctx, name);
            if (/^f/.test(typeof name === 'undefined' ? 'undefined' : _typeof(name))) {
              output += name.call(ctx, childCode, function (template) {
                return render(template, ctx);
              }); //eslint-disable-line
            } else {
              output += render(childCode, name, ctx, inverted);
            }
            childCode = '';
          }
        } else {
          ++depth;
        }
      });
    };

    for (i = 0; i < self.length; i++) {
      _loop();
    }
    return output;
  };

  /* eslint-disable no-nested-ternary, prefer-template */

  // The Name of this components
  var COMPONENT_NAME$c = 'autocomplete';

  /*
   * Default Autocomplete Result Item Template.  This can be modified to add data points that
   * will be populated by adding properties to the object created
   * in `DEFAULT_AUTOCOMPLETE_RESULT_ITERATOR_CALLBACK`.
   */
  var DEFAULT_AUTOCOMPLETE_TEMPLATE = '<li id="{{listItemId}}" data-index="{{index}}" {{#hasValue}}data-value="{{value}}"{{/hasValue}} role="listitem">\n <a href="#" tabindex="-1">\n   <span>{{{label}}}</span>\n </a>\n</li>';

  /*
  * Autocomplete's method for obtaining the string that will be tested against a provided search
  * term for a match. This is configurable in the event that the component you attach this to
  * needs a specific part of it searched (instead of the whole thing).
  * @param {String|Object} item - text string, or an object containing a 'label'.
  * @returns {string} The item or item label.
  */
  var DEFAULT_AUTOCOMPLETE_SEARCHABLE_TEXT_CALLBACK = function DEFAULT_AUTOCOMPLETE_SEARCHABLE_TEXT_CALLBACK(item) {
    var isString = typeof item === 'string';
    return isString ? item : item.label;
  };

  /*
  * Autocomplete provides a method that will be run on every result that is passed back from the
  * filtering API. This method can be replaced, allowing developers to customize the output of the
  * returned dataset to add values that can also be displayed on each list item with a modified
  * `DEFAULT_AUTOCOMPLETE_TEMPLATE`.
  */
  var DEFAULT_AUTOCOMPLETE_RESULT_ITERATOR_CALLBACK = function resultIterator(item, index) {
    // For standard autocompletes with a popupmenu, build the dataset that
    // will be submitted to the template.
    var isString = typeof item === 'string';
    var dataset = {
      highlightTarget: 'label',
      index: index,
      listItemId: 'ac-list-option' + index
    };

    if (!isString) {
      dataset = utils.extend({}, dataset, item);
    } else {
      dataset.label = item;
    }

    dataset.hasValue = item.value !== undefined;
    if (dataset.hasValue) {
      dataset.value = item.value;
    }

    return dataset;
  };

  var DEFAULT_AUTOCOMPLETE_HIGHLIGHT_CALLBACK = function highlightMatch(item, options) {
    var targetProp = item;
    var hasAlias = false;

    // If this is an object and we need to replace text within a specific property,
    // look for an "alias" property to use instead of the item itself.
    if (typeof options.alias === 'string' && item[options.alias] !== undefined) {
      hasAlias = true;
      targetProp = item[options.alias];
    }

    // Easy match for 'contains'-style filterMode.
    if (options.filterMode === 'contains') {
      targetProp = targetProp.replace(new RegExp('(' + options.term + ')', 'ig'), '<i>$1</i>');
    } else if (options.filterMode === 'keyword') {
      // Handle "keyword" filterMode
      var keywords = options.term.split(' ');
      for (var i = 0; i < keywords.length; i++) {
        var keyword = keywords[i];

        if (keyword) {
          targetProp = targetProp.replace(new RegExp('(' + keyword + ')', 'ig'), '<i>$1</i>');
        }
      }
    } else {
      // Handle "startsWith" filterMode highlighting a bit differently.
      var originalItem = targetProp;
      var pos = Locale.toLowerCase(originalItem).indexOf(options.term);

      if (pos > 0) {
        targetProp = originalItem.substr(0, pos) + '<i>' + originalItem.substr(pos, options.term.length) + '</i>' + originalItem.substr(options.term.length + pos);
      } else if (pos === 0) {
        targetProp = '<i>' + originalItem.substr(0, options.term.length) + '</i>' + originalItem.substr(options.term.length);
      }
    }

    // place result back
    if (hasAlias) {
      item[options.alias] = targetProp;
    } else {
      item = targetProp;
    }

    return item;
  };

  /**
  * The Autocomplete control provides an easier means of searching through a large amount of data by filtering
  * down the results based on keyboard input from the user.
  * @class Autocomplete
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [settings.source=[]] Defines the data to use, must be specified.
  * @param {string} [settings.sourceArguments={}] If a source method is defined, this flexible object can be passed
  * into the source method, and augmented with parameters specific to the implementation.
  * @param {boolean} [settings.template If defined, use this to draw the contents of each search result instead of the default draw routine.
  * @param {string} [settings.filterMode='startsWith'] The matching algorithm, startsWith and contains are supported - false will not filter client side
  * @param {boolean} [settings.delay=300] The delay between key strokes on the keypad before it thinks you stopped typing
  * @param {string} [settings.width=null] Width of the open auto complete menu
  * @param {string} [settings.offset=null] For the open menu, the left or top offset
  * @param {string} [settings.autoSelectFirstItem=false] Whether or not to select he first item in the list to be selected
  * @param {boolean} [settings.highlightMatchedText=true] The highlightMatchText property.
  * @param {function} [settings.highlightCallback] The highlightCallback property.
  * @param {function} [settings.resultIteratorCallback] The resultIteratorCallback property.
  * @param {function} [settings.clearResultsCallback] the clearResultsCallback property.
  * @param {function} [settings.displayResultsCallback] The displayResultsCallback property.
  * @param {function} [settings.searchableTextCallback] The searchableTextCallback property.
  */
  var AUTOCOMPLETE_DEFAULTS = {
    source: [],
    sourceArguments: {},
    template: undefined,
    filterMode: 'startsWith',
    delay: 300,
    width: null,
    offset: null,
    autoSelectFirstItem: false,
    highlightMatchedText: true,
    highlightCallback: DEFAULT_AUTOCOMPLETE_HIGHLIGHT_CALLBACK,
    resultIteratorCallback: DEFAULT_AUTOCOMPLETE_RESULT_ITERATOR_CALLBACK,
    clearResultsCallback: undefined,
    displayResultsCallback: undefined,
    searchableTextCallback: DEFAULT_AUTOCOMPLETE_SEARCHABLE_TEXT_CALLBACK
  };

  function Autocomplete(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, AUTOCOMPLETE_DEFAULTS);
    this.init();
  }

  // Plugin Object
  Autocomplete.prototype = {
    init: function init() {
      // data-autocomplete can be a url, 'source' or an array
      var data = this.element.attr('data-autocomplete');
      if (data && data !== 'source') {
        this.settings.source = data;
        this.element.removeAttr('data-autocomplete');
      }

      var listFilterSettings = {
        filterMode: this.settings.filterMode,
        highlightMatchedText: this.settings.highlightMatchedText,
        searchableTextCallback: this.settings.searchableTextCallback
      };
      if (!this.listFilter) {
        this.listFilter = new ListFilter(listFilterSettings);
      } else {
        this.listFilter.updated(listFilterSettings);
      }

      this.addMarkup();
      this.handleEvents();
    },
    addMarkup: function addMarkup() {
      this.element.addClass('autocomplete').attr({
        role: 'combobox',
        autocomplete: 'off'
      });
    },
    isLoading: function isLoading() {
      return this.element.hasClass('is-loading') && this.element.hasClass('is-blocked');
    },
    openList: function openList(term, items) {
      if (this.element.is('[disabled], [readonly]') || this.isLoading()) {
        return;
      }

      var self = this;
      term = Locale.toLowerCase(term);

      // append the list
      this.list = $('#autocomplete-list');
      if (this.list.length === 0) {
        this.list = $('<ul id="autocomplete-list" aria-expanded="true"></ul>').appendTo('body');
      }

      this.list[0].style.height = 'auto';
      this.list[0].style.width = this.element.outerWidth() + 'px';
      this.list.addClass('autocomplete');
      this.list.empty();

      if (this.settings.width) {
        this.list[0].style.width = this.settings.width + (/(px|%)/i.test('' + this.settings.width) ? '' : 'px');
      }

      // Pre-compile template.
      // Try to get an element first, and use its contents.
      // If the string provided isn't a selector, attempt to use it as a string, or fall back
      // to the default template.
      var templateAttr = $(this.element.attr('data-tmpl'));
      this.tmpl = $(templateAttr).length ? $(templateAttr).text() : typeof templateAttr === 'string' ? templateAttr : $(this.settings.template).length ? $(this.settings.template).text() : typeof this.settings.template === 'string' ? this.settings.template : DEFAULT_AUTOCOMPLETE_TEMPLATE;

      // Send full item list to the ListFilter for filtering.
      var filterResult = this.listFilter.filter(items, term);
      var modifiedFilterResults = [];

      // Modify filtered results for a specific template with a `resultIteratorCallback`,
      // if applicable. Each of these results is deep-copied.
      if (filterResult !== false) {
        filterResult.forEach(function (val, index) {
          if (typeof val === 'string') {
            val = { label: val, value: val };
          }

          var result = utils.extend(true, {}, val);
          result = self.settings.resultIteratorCallback(result, index);

          if (self.settings.highlightMatchedText) {
            var filterOpts = {
              filterMode: self.settings.filterMode,
              term: term
            };
            if (result.highlightTarget) {
              filterOpts.alias = result.highlightTarget;
            }
            result = self.settings.highlightCallback(result, filterOpts);
          }

          modifiedFilterResults.push(result);
        });
      }

      this.currentDataSet = modifiedFilterResults;

      // If a "resultsCallback" method is defined, pipe the filtered items to that method and skip
      // building a popupmenu.
      if (typeof this.settings.displayResultsCallback === 'function') {
        this.settings.displayResultsCallback(modifiedFilterResults, function () {
          self.element.trigger('listopen', [modifiedFilterResults]);
        });
        return;
      }

      this.handleListResults(term, items, modifiedFilterResults);
    },
    handleListResults: function handleListResults(term, items, filterResult) {
      var self = this;

      var afterPlaceCallback = function afterPlaceCallback(placementObj) {
        if (placementObj.wasFlipped === true) {
          self.list.add(self.element).addClass('is-ontop');
          placementObj.y += 1;
        }
        return placementObj;
      };

      var popupOpts = {
        menuId: 'autocomplete-list',
        ariaListbox: true,
        mouseFocus: false,
        trigger: 'immediate',
        attachToBody: true,
        autoFocus: false,
        returnFocus: false,
        triggerSelect: false,
        placementOpts: {
          parent: this.element,
          callback: afterPlaceCallback
        }
      };

      filterResult.forEach(function (dataset) {
        if (typeof Tmpl !== 'undefined') {
          var renderedTmpl = Tmpl.compile(self.tmpl, dataset);
          DOM.append(self.list, renderedTmpl, '*');
        }
      });

      this.element.addClass('is-open').popupmenu(popupOpts).one('close.autocomplete', function () {
        self.closeList(true);
      });

      // Optionally select the first item in the list
      if (self.settings.autoSelectFirstItem) {
        self.list.children().filter(':not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)').first().addClass('is-selected');
      }

      this.noSelect = true;
      /**
      * Fires after the menu is populated with its contents.
      *
      * @event populated
      * @memberof Autocomplete
      * @param {object} event - The jquery event object
      * @param {object} filterResult - The results of the filtering
      */
      this.element.trigger('populated', [filterResult]).focus();

      // Overrides the 'click' listener attached by the Popupmenu plugin
      self.list.on('touchend.' + COMPONENT_NAME$c + ' click.' + COMPONENT_NAME$c, 'a', function (e) {
        self.select(e);
      }).on('focusout.' + COMPONENT_NAME$c, function () {
        self.checkActiveElement();
      });

      // Highlight anchors on focus
      var all = self.list.find('a').on('focus.' + COMPONENT_NAME$c + ' touchend.' + COMPONENT_NAME$c, function () {
        self.highlight($(this), all);
      });

      if (this.settings.offset) {
        var domListParent = this.list.parent()[0];

        if (this.settings.offset.left) {
          domListParent.style.left = parseInt(domListParent.style.left, 10) + this.settings.offset.left + 'px';
        }
        if (this.settings.offset.top) {
          domListParent.style.top = parseInt(domListParent.style.top, 10) + this.settings.offset.top + 'px';
        }
      }

      // As chars are typed into the edit field, nothing was announced to indicate
      // that a value has been suggested, for the non-sighted user an offscreen span
      // added and will remove soon popup close that includes aria-live="polite"
      // which have the first suggested item automatically announced when it
      // appears without moving focus.
      self.list.parent('.popupmenu-wrapper').append('' + ('' + '<span id="ac-is-arialive" aria-live="polite" class="audible">') + $.trim(this.list.find('>li:first-child').text()) + '</span>');

      this.noSelect = true;
      this.element.trigger('listopen', [filterResult]);
    },
    closeList: function closeList(dontClosePopup) {
      // Remove events
      this.list.off(['click.' + COMPONENT_NAME$c, 'touchend.' + COMPONENT_NAME$c, 'focusout.' + COMPONENT_NAME$c].join(' '));
      this.list.find('a').off('focus.' + COMPONENT_NAME$c + ' touchend.' + COMPONENT_NAME$c);

      this.element.trigger('listclose');

      if (typeof this.settings.clearResultsCallback === 'function') {
        this.settings.clearResultsCallback();
        return;
      }

      var popup = this.element.data('popupmenu');
      if (!popup) {
        return;
      }
      if (!dontClosePopup) {
        popup.close();
      }

      $('#autocomplete-list').parent('.popupmenu-wrapper').remove();
      $('#autocomplete-list').remove();
      this.element.add(this.list).removeClass('is-open is-ontop');
    },
    listIsOpen: function listIsOpen() {
      return this.list instanceof $ && this.list.length && this.list.is(':visible');
    },


    // Handles the Autocomplete's "keydown" event
    handleAutocompleteKeydown: function handleAutocompleteKeydown(e) {
      var self = this;

      if (this.isLoading()) {
        e.preventDefault();
        return false;
      }

      if (!this.listIsOpen()) {
        return null;
      }

      function getHighlighted(items) {
        return items.filter('.is-selected');
      }

      function unhighlight(item) {
        item.removeClass('is-selected is-focused');
      }

      function highlight(item) {
        item.addClass('is-selected').find('a').focus();
      }

      var excludes = 'li:not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)';
      var items = this.list.find(excludes);
      var highlighted = getHighlighted(items);

      // Down - select next
      if (e.keyCode === 40 && this.listIsOpen()) {
        if (highlighted.length) {
          self.noSelect = true;
          unhighlight(highlighted);
          highlight(items.eq(items.index(highlighted) + 1));
          e.preventDefault();
          e.stopPropagation();
        }
      }

      // Up select prev
      if (e.keyCode === 38 && this.listIsOpen()) {
        if (highlighted.length) {
          self.noSelect = true;
          unhighlight(highlighted);
          highlight(items.eq(items.index(highlighted) - 1));
          e.preventDefault();
          e.stopPropagation();
        }
      }

      // Enter/Tab - apply selected item
      if ((e.keyCode === 9 || e.keyCode === 13) && this.listIsOpen()) {
        // Apply selection if an item is selected, otherwise close list and
        // allow default tab/enter behavior to happen
        if (highlighted.length) {
          e.stopPropagation();
          e.preventDefault();
          self.noSelect = true;
          self.select(highlighted);
        } else {
          self.closeList();
        }
      }

      return null;
    },


    // Handles the Autocomplete's "input" event
    handleAutocompleteInput: function handleAutocompleteInput(e) {
      var self = this;

      if (self.isLoading()) {
        e.preventDefault();
        return false;
      }

      // Makes a new AJAX call every time a key is pressed.
      var waitForSource = this.getDataFromSource();
      waitForSource.done(function (term, response) {
        self.currentDataSet = response;
        self.openList(term, response);
      });

      return null;
    },


    /**
     * Check to see whether or not the currently-focused element resides within
     * the Autocomplete's field or list, and if not, fires a "safe-blur" event on the element.
     *
     * @private
     * @param {object} e The event object passed in from the jQuery `.on()` listener.
     * @returns {void}
     */
    checkActiveElement: function checkActiveElement() {
      var self = this;
      setTimeout(function () {
        var activeElem = document.activeElement;

        if (self.listIsOpen() && $.contains(self.list[0], activeElem) || self.element.is(activeElem)) {
          return;
        }

        /**
        *  Fires after the input (and menu) both loose focus
        *
        * @event safe-blur
        * @memberof Autocomplete
        * @param {object} event The input event object
        */
        self.element.trigger('safe-blur');
      }, 0);
    },
    getDataFromSource: function getDataFromSource() {
      var self = this;

      // Don't attempt to load if we're already loading.
      if (self.isLoading()) {
        return false;
      }

      var field = this.element;
      var dfd = $.Deferred();
      var buffer = void 0;

      clearTimeout(this.loadingTimeout);

      function done(searchTerm, response, deferredStatus) {
        self.element.triggerHandler('complete'); // For Busy Indicator

        /**
        *  Fires when the ajax request (source option) is completed
        *
        * @event requestend
        * @memberof Autocomplete
        * @param {object} event The input event object
        * @param {array} An array containing the searchTerm and call back function
        */
        self.element.trigger('requestend', [searchTerm, response]);

        if (deferredStatus === false) {
          return dfd.reject(searchTerm);
        }
        return dfd.resolve(xssUtils.stripTags(searchTerm), response);
      }

      this.loadingTimeout = setTimeout(function () {
        if (self.isLoading()) {
          return;
        }

        buffer = field.val();

        if (buffer === '') {
          if (self.element.data('popupmenu')) {
            self.element.data('popupmenu').close();
          }
          return;
        }

        var sourceType = _typeof(self.settings.source);
        self.element.triggerHandler('start'); // For Busy Indicator

        /**
        * Fires when the ajax request (source option) is initiated
        *
        * @event requeststart
        * @memberof Autocomplete
        * @param {object} event The input event object
        * @param {array} event An array with the buffer in it
        */
        self.element.trigger('requeststart', [buffer]);

        if (sourceType === 'function') {
          // Call the 'source' setting as a function with the done callback.
          self.settings.source(buffer, done, self.settings.sourceArguments);
        } else if (sourceType === 'object') {
          // Use the 'source' setting as pre-existing data.
          // Sanitize accordingly.
          var sourceData = $.isArray(self.settings.source) ? self.settings.source : [self.settings.source];
          done(buffer, sourceData, true);
        } else if (!self.settings.source) {
          dfd.reject(buffer);
        } else if (self.settings.filterMode === 'keyword') {
          var keywordData = [];
          var mergeData = function mergeData(data) {
            if (keywordData.length === 0) {
              keywordData = data;
            } else {
              // Check for duplicate entries
              for (var i = 0; i < data.length; i++) {
                var dataItem = data[i];

                var isExists = false;

                for (var ii = 0; ii < keywordData.length; ii++) {
                  var keywordItem = keywordData[ii];

                  for (var iii = 0; iii < Object.getOwnPropertyNames(keywordItem).length; iii++) {
                    var dataPropVal = dataItem[Object.getOwnPropertyNames(dataItem)[iii]];
                    var keywordPropVal = keywordItem[Object.getOwnPropertyNames(keywordItem)[iii]];

                    if (dataPropVal === keywordPropVal) {
                      isExists = true;
                      break;
                    }
                  }
                }

                if (!isExists) {
                  keywordData.push(dataItem);
                }
              }
            }
          };

          var doneData = function doneData(data) {
            mergeData(data);

            done(buffer, keywordData, true);
          };

          var keywords = buffer.split(' ');
          if (keywords[keywords.length - 1] === '') {
            keywords.splice(-1, 1);
          }

          for (var i = 0; i < keywords.length; i++) {
            var keyword = keywords[i];

            if (keyword.length > 0) {
              var sourceURL = self.settings.source.toString();
              var request = $.getJSON(sourceURL + keyword);

              if (i < keywords.length - 1) {
                request.done(mergeData).fail(mergeData);
              } else {
                request.done(doneData).fail(doneData);
              }
            }
          }
        } else {
          // Attempt to resolve source as a URL string.  Do an AJAX get with the URL
          var _sourceURL = self.settings.source.toString();
          var _request = $.getJSON(_sourceURL + buffer);

          _request.done(function (data) {
            done(buffer, data, true);
          }).fail(function () {
            done(buffer, [], false);
          });
        }
      }, self.settings.delay);

      return dfd;
    },


    /**
    * Resets a filtered autocomplete back to its original state.
    * @returns {void}
    */
    resetFilters: function resetFilters() {
      this.openList('', this.currentDataSet);
    },


    // Handles the Autocomplete's "focus" event
    handleAutocompleteFocus: function handleAutocompleteFocus() {
      var self = this;
      if (this.noSelect) {
        this.noSelect = false;
        return;
      }

      // select all text (after a delay since works better across browsers), but only if element is
      // still focused to avoid flashing cursor focus trap (since select causes focus event to
      // fire if no longer focused)
      setTimeout(function () {
        if (self.element.is(':focus')) {
          self.element.select();
        }
      }, 10);
    },


    /**
     * Highlights (and focuses) an Autocomplete list option
     * @param {jQuery} anchor the anchor to be highlighted
     * @param {jQuery[]} [allAnchors=null] optional list of anchors to deselect when the new one becomes selected.
     * @returns {void}
     */
    highlight: function highlight(anchor, allAnchors) {
      var text = anchor.text().trim();

      if (anchor.find('.display-value').length > 0) {
        text = anchor.find('.display-value').text().trim();
      }

      if (allAnchors && allAnchors.length) {
        allAnchors.parent('li').removeClass('is-selected');
      }
      anchor.parent('li').addClass('is-selected');

      this.noSelect = true;
      this.element.val(text).focus();
    },


    /**
     * Selects an Autocomplete result.
     * @param {jQuery|jQuery.Event} anchorOrEvent either a reference to a jQuery-wrapped HTMLElement, or a jQuery Event object with a target.
     * @param {object[]} [items=this.currentDataSet] an array of objects representing autocomplete options.
     * @returns {object} contains information about the selected item.
     */
    select: function select(anchorOrEvent, items) {
      var a = void 0;
      var li = void 0;
      var ret = {};
      var isEvent = false;

      // Initial Values
      if (anchorOrEvent instanceof $.Event) {
        isEvent = true;
        a = $(anchorOrEvent.currentTarget);
      } else {
        a = anchorOrEvent;
      }

      if (a.is('li')) {
        li = a;
        a = a.children('a');
      }

      li = a.parent('li');
      var dataIndex = li.attr('data-index');
      var dataValue = li.attr('data-value');

      this.element.attr('aria-activedescendant', li.attr('id'));

      if (!items || !items.length) {
        items = this.currentDataSet;
      }

      // If the data-index attr is supplied, use it to get the item
      // (since two items could have same value)
      if (dataIndex) {
        ret = items[parseInt(dataIndex, 10)];
      } else if (dataValue) {
        // Otherwise use data-value to get the item (a custom template may not supply data-index)
        for (var i = 0, value; i < items.length; i++) {
          if (_typeof(items[i]) === 'object' && items[i].value !== undefined) {
            value = items[i].value.toString();
          } else {
            value = items[i].toString();
          }

          if (value === dataValue) {
            if (_typeof(items[i]) === 'object') {
              ret = items[i];
            }
            ret.value = value;
          }
        }
      }

      // Use the label as the value, if we're not working from a true dataset
      if (!ret.value || !ret.value.length === 0) {
        ret.value = a.text().trim();
      }

      this.closeList();
      this.highlight(a);

      this.noSelect = true;

      // Update the data for the event
      ret.label = xssUtils.stripHTML(ret.label);

      // Add these elements for key down vs click consistency
      if (!ret.highlightTarget) {
        ret.highlightTarget = 'label';
        ret.index = parseInt(dataIndex, 10);
        ret.listItemId = 'ac-list-option' + ret.index;
        ret.hasValue = true;
      }

      /**
      *  Fires when an element is selected from the list.
      *
      * @event selected
      * @memberof Autocomplete
      * @param {array} args An array containing the link and the return object.
      */
      this.element.trigger('selected', [a, ret]).focus();

      if (isEvent) {
        anchorOrEvent.preventDefault();
      }

      return ret;
    },


    /*
    * Handle after list open.
    */
    handleAfterListOpen: function handleAfterListOpen() {
      // Fix one pixel off list by element
      if (this.element.offset().left > this.list.offset().left) {
        this.list.width(this.list.width() + 1);
      }

      return this;
    },


    /**
     * Update the component with new settings.
     * @param {object} settings The new settings object to use.
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.teardown().init();
      return this;
    },


    /**
    * Enable the input from readonly or disabled state.
    * @returns {void}
    */
    enable: function enable() {
      this.element.prop('disabled', false);
    },


    /**
    * Disable the input from editing
    * @returns {void}
    */
    disable: function disable() {
      this.element.prop('disabled', true);
    },
    teardown: function teardown() {
      var popup = this.element.data('popupmenu');
      if (popup) {
        popup.destroy();
      }

      this.element.off(['focus.' + COMPONENT_NAME$c, 'focusout.' + COMPONENT_NAME$c, 'input.' + COMPONENT_NAME$c, 'keydown.' + COMPONENT_NAME$c, 'listopen.' + COMPONENT_NAME$c, 'requestend.' + COMPONENT_NAME$c, 'resetfilter.' + COMPONENT_NAME$c, 'updated.' + COMPONENT_NAME$c].join(' '));
      return this;
    },


    /**
    * Teardown and remove any added markup and events.
    * @returns {void}
    */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$c);
    },


    /**
    * Setup the event handlers.
    * @private
    * @returns {void}
    */
    handleEvents: function handleEvents() {
      // similar code as dropdown but close enough to be dry
      var self = this;

      this.element.on('updated.' + COMPONENT_NAME$c, function () {
        self.updated();
      }).on('keydown.' + COMPONENT_NAME$c, function (e) {
        self.handleAutocompleteKeydown(e);
      }).on('input.' + COMPONENT_NAME$c, function (e) {
        self.handleAutocompleteInput(e);
      }).on('focus.' + COMPONENT_NAME$c, function () {
        self.handleAutocompleteFocus();
      }).on('focusout.' + COMPONENT_NAME$c, function () {
        self.checkActiveElement();
      })
      /**
      * Fires when the menu is opened.
      * @event listopen
      * @memberof Autocomplete
      * @param {object} event - The jquery event object
      * @param {object} ui - The dialog object
      */
      .on('listopen.' + COMPONENT_NAME$c, function () {
        self.handleAfterListOpen();
      })
      /**
      * Comes from Searchfields wrapping an autocomplete - resets
      * a filtered autocomplete back to normal.
      * @event listopen
      * @memberof Autocomplete
      * @param {object} event - The jquery event object
      */
      .on('resetfilter.' + COMPONENT_NAME$c, function () {
        self.resetFilters();
      });
    }
  };

  /**
   * jQuery Component Wrapper for Autocomplete
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */
  $.fn.autocomplete = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$c);

      // NOTE: This is modified due to a conflict between a legacy Soho attribute, `data-autocomplete`,
      // having the same value as jQuery's `$.data('autocomplete')`.
      if (typeof instance === 'string') {
        var stringSource = '' + instance;
        var modifiedSettings = utils.extend({}, settings, {
          source: stringSource || settings.source
        });
        instance = $.data(this, COMPONENT_NAME$c, new Autocomplete(this, modifiedSettings));
      } else if (!instance) {
        instance = $.data(this, COMPONENT_NAME$c, new Autocomplete(this, settings));
      } else {
        instance.updated(settings);
      }
    });
  };

  // Name of this component
  var COMPONENT_NAME$d = 'searchfield';

  // Types of collapse modes
  var SEARCHFIELD_COLLAPSE_MODES = [false, 'mobile', true];

  // Search Field Defaults
  var SEARCHFIELD_DEFAULTS = {
    resultsCallback: undefined,
    allResultsCallback: undefined,
    showAllResults: true,
    showGoButton: false,
    goButtonCopy: undefined,
    goButtonAction: undefined,
    categories: undefined,
    categoryMultiselect: false,
    showCategoryText: false,
    source: undefined,
    template: undefined,
    clearable: false,
    collapsible: SEARCHFIELD_COLLAPSE_MODES[0]
  };

  // Used throughout:
  var TOOLBARSEARCHFIELD_EXPAND_SIZE = 280;
  var MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE = 450;

  /**
   * The search field component.
   * @class SearchField
   * @param {jQuery[]|HTMLElement} element the base searchfield element
   * @param {object} [settings] incoming settings
   * @param {function} [settings.resultsCallback] Callback function for getting typahead results on search.
   * @param {function} [settings.allResultsCallback] Callback function for getting "all results".
   * @param {boolean} [settings.showAllResults = true] If true the show all results link is showin in the list.
   * @param {boolean} [settings.showGoButton = false] If true a go button is associated.
   * @param {string} [settings.goButtonCopy] The text to use on the go button.
   * @param {function} [settings.goButtonAction] If defined as a function, will fire this callback on the Go Button "click"
   * @param {array} [settings.categories] If defined as an array, displays a dropdown containing categories that can be used to filter results.
   * @param {boolean} [settings.categoryMultiselect = false]  If true, creates a multiselectable categories list.
   * @param {boolean} [settings.showCategoryText = false]  If true, will show any available categories that are selected
   * to the left of the Dropdown field.
   * @param {function} [settings.source] Callback function for getting type ahead results.
   * @param {string} [settings.template] The html template to use for the search list
   * @param {boolean} [settings.clearable = true] If "true", provides an "x" button on the right edge that clears the field
   * @param {boolean} [settings.collapsible = true] If "true", allows the field to expand/collapse on larger breakpoints when
   * focused/blurred respectively
   * @param {boolean} [settings.collapsibleOnMobile = true] If true, overrides `collapsible` only on mobile settings.
   */
  function SearchField(element, settings) {
    this.element = $(element);

    // Backwards compatibility for old toolbars that had `collapsible` and `clearable` as the defaults
    if (this.toolbarParent && settings !== undefined) {
      if (settings.clearable === undefined) {
        settings.clearable = true;
      }
      if (settings.collapsible === undefined) {
        settings.collapsible = true;
      }
    }

    this.settings = utils.mergeSettings(element, settings, SEARCHFIELD_DEFAULTS);
    this.init();
  }

  SearchField.prototype = {

    /**
     * @returns {HTMLElement} a toolbar parent element, or `undefined`
     */
    get toolbarParent() {
      var toolbarParents = this.element.parents('.toolbar');
      var toolbarFlexParents = this.element.parents('.flex-toolbar');

      if (toolbarParents.add(toolbarFlexParents).length < 1) {
        return undefined;
      }

      if (toolbarFlexParents.length > 0) {
        return toolbarFlexParents.first()[0];
      }

      return toolbarParents.first()[0];
    },

    /**
     * @returns {HTMLElement} a buttonset element, or `undefined`
     */
    get buttonsetElem() {
      if (!this.toolbarParent) {
        return undefined;
      }
      return this.toolbarParent.querySelector('.buttonset');
    },

    /**
     * @returns {HTMLElement} a toolbar `.title` area, if one is present.
     */
    get titleElem() {
      if (!this.toolbarParent) {
        return undefined;
      }
      return this.toolbarParent.querySelector('.title');
    },

    /**
     * @returns {HTMLElement} a toolbar parent element, or `undefined`
     */
    get containmentParent() {
      var moduleTabs = this.element.closest('.module-tabs');
      if (moduleTabs.length) {
        return moduleTabs.first()[0];
      }
      return this.toolbarParent;
    },

    /**
     * @returns {HTMLElement} a reference to the input field
     */
    get input() {
      return this.element[0];
    },

    /**
      @returns {HTMLElement} a reference to an optional button with an attached Category selection menu
     */
    get categoryButton() {
      return this.wrapper.find('.searchfield-category-button');
    },

    /**
     * @returns {boolean} whether or not the searchfield can ever be collapsible.
     */
    get isCollapsible() {
      return this.settings.collapsible !== false;
    },

    /**
     * @returns {boolean} whether or not the searchfield is currently able to be collapsed.
     */
    get isCurrentlyCollapsible() {
      return this.settings.collapsible === true || this.settings.collapsible === 'mobile' && this.shouldBeFullWidth();
    },

    /**
     * Initialization Kickoff
     * @private
     * @returns {void}
     */
    init: function init() {
      this.coerceBooleanSettings();
      this.build();
      this.setupEvents();
    },


    /**
     * Builds the markup for this component.
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      // Used for managing events that are bound to $(document)
      if (!this.id) {
        this.id = utils.uniqueId(this.element, COMPONENT_NAME$d);
      }

      this.label = this.element.prev('label, .label');
      this.inlineLabel = this.element.closest('label');
      this.isInlineLabel = this.element.parent().is('.inline');

      // Invoke Autocomplete and store references to that and the popupmenu created by autocomplete.
      // Autocomplete settings are fed the same settings as Searchfield
      // NOTE: The `source` setting can be modified due to a conflict between a legacy Soho attribute,
      // `data-autocomplete`, having the same value as jQuery's `$.data('autocomplete')`.
      var autocompleteDataAttr = this.element.attr('data-autocomplete');
      if (autocompleteDataAttr && autocompleteDataAttr !== 'source') {
        this.settings.source = autocompleteDataAttr;
        this.element.removeAttr('data-autocomplete');
        $.removeData(this.element, 'autocomplete');
      }

      if (this.settings.source) {
        this.autocomplete = this.element.data('autocomplete');
        if (!this.autocomplete) {
          this.element.autocomplete(this.settings);
          this.autocomplete = this.element.data('autocomplete');
        } else {
          this.autocomplete.updated(this.settings);
        }
      }

      // Prevent browser typahead
      this.element.attr('autocomplete', 'off');

      // Setup ARIA
      var label = this.element.attr('placeholder') || this.element.prev('label, .label').text().trim();
      if (!label || label === '') {
        label = Locale.translate('Keyword');
      }
      this.element.attr({
        'aria-label': label
      });

      // Build the wrapper
      this.wrapper = this.element.parent('.searchfield-wrapper');
      if (!this.wrapper || !this.wrapper.length) {
        if (this.isInlineLabel) {
          this.wrapper = this.inlineLabel.addClass('searchfield-wrapper');
        } else {
          this.wrapper = this.element.wrap('<span class="searchfield-wrapper"></span>').parent();
        }
      }

      this.checkContents();

      // Label for toolbar-inlined searchfields needs to be inside the
      // wrapper to help with positioning.
      if (this.toolbarParent) {
        this.label.prependTo(this.wrapper);
      }

      var customClasses = ['context', 'alternate'];
      var c = void 0;

      for (var i = 0; i < customClasses.length; i++) {
        if (this.element.hasClass(customClasses[i])) {
          c = customClasses[i];
          this.wrapper.addClass(c);
          this.element.removeClass(c);
        }
      }

      // Backwards compatibility with collapsibleOnMobile
      // TODO: Remove in v4.9.0
      if (this.settings.collapsibleOnMobile === true) {
        this.settings.collapsible = SEARCHFIELD_COLLAPSE_MODES[1];
      }

      // Add/remove the collapsible functionality
      this.wrapper[0].classList[!this.settings.collapsible === true ? 'add' : 'remove']('non-collapsible');

      // Add/remove `toolbar-searchfield-wrapper` class based on existence of Toolbar Parent
      this.wrapper[0].classList[this.toolbarParent ? 'add' : 'remove']('toolbar-searchfield-wrapper');

      // Initially disable animations on toolbar searchfields
      // An event listener on Toolbar's `rendered` event removes these at the correct time
      if (this.toolbarParent) {
        this.element.add(this.wrapper).addClass('no-transition no-animation');
      }

      // Add Icon
      var icon = this.wrapper.find('.icon:not(.icon-dropdown)');
      if (!icon || !icon.length) {
        icon = $.createIconElement('search');
      }

      // Swap icon position to in-front if we have "context/has-categories" CSS class.
      var insertIconInFront = this.wrapper.hasClass('context') || this.wrapper.hasClass('has-categories');
      icon[insertIconInFront ? 'insertBefore' : 'insertAfter'](this.element).icon();

      // Change icon to a trigger button if we're dealing with categories
      if (this.hasCategories()) {
        this.wrapper.addClass('has-categories');

        if (!this.categoryButton.length) {
          $('<button type="button" class="btn searchfield-category-button"></button>').insertBefore(this.element);
        }
        icon.appendTo(this.categoryButton);
        icon = this.categoryButton;

        if (this.settings.showCategoryText) {
          this.wrapper.addClass('show-category');
        }

        var ddIcon = icon.find('.icon-dropdown');
        if (!ddIcon.length) {
          ddIcon = $.createIconElement({ classes: 'icon-dropdown', icon: 'dropdown' }).icon();
        }
        ddIcon.appendTo(icon);

        var popupAPI = this.categoryButton.data('popupmenu');
        if (!popupAPI) {
          this.list = this.wrapper.find('ul.popupmenu');
          if (!this.list || !this.list.length) {
            this.list = $('<ul class="popupmenu"></ul>');
          }

          // Handle Single vs Multi-Selectable Lists
          var categoryListType = this.settings.categoryMultiselect ? 'is-multiselectable' : 'is-selectable';
          this.list.addClass(categoryListType);
          var removeListType = 'is-selectable';
          if (!this.settings.categoryMultiselect) {
            removeListType = 'is-multiselectable';
          }
          this.list.removeClass(removeListType);

          this.setCategories(this.settings.categories);

          this.list.insertAfter(this.element);

          var _self = this;
          this.categoryButton.popupmenu({
            menu: this.list,
            offset: {
              y: 10
            },
            returnFocus: function returnFocus() {
              if (_self.isFocused) {
                _self.element.focus();
              }
            }
          });
        } else {
          this.setCategories(this.settings.categories);
        }

        this.setCategoryButtonText();
      }

      // Pull a Go Button from markup, if applicable.
      var goButton = this.wrapper.next('.go-button');
      if (!goButton.length) {
        goButton = this.wrapper.find('.go-button');
      }

      if (goButton.length) {
        this.settings.showGoButton = true;
        this.goButton = goButton;
        this.element.after(this.goButton);
      }

      // Add a "Go" Button from scratch if we enable the setting
      if (this.settings.showGoButton) {
        if (!this.goButton || !this.goButton.length) {
          this.goButton = $('\n          <button class="btn-secondary go-button">\n            <span>' + (this.settings.goButtonCopy || Locale.translate('Go')) + '</span>\n          </button>\n        ');
        }
        this.goButton.attr('id', utils.uniqueId(this.goButton, 'searchfield-go-button-'));
        this.wrapper.addClass('has-go-button');
        this.element.after(this.goButton);
      } else {
        this.wrapper.removeClass('has-go-button');
      }

      /*
      // Hoist the 'alternate' CSS class to the wrapper, if applicable
      const isAlternate = this.element.hasClass('alternate');
      this.wrapper[isAlternate ? 'addClass' : 'removeClass']('alternate');
      */

      if (this.settings.clearable) {
        this.element.clearable();
        this.xButton = this.wrapper.children('.icon.close');
      }

      // Stagger a calculation for setting the size of the Searchfield element, if applicable
      var self = this;
      var resizeTimer = new RenderLoopItem({
        duration: 1,
        updateCallback: function updateCallback() {},
        // TODO: make this work without an empty function
        timeoutCallback: function timeoutCallback() {
          self.calculateSearchfieldWidth();
        }
      });
      renderLoop.register(resizeTimer);

      if (this.settings.collapsible === false || this.settings.collapsible === 'mobile' && breakpoints.isAbove('phone-to-tablet')) {
        this.expand(true);
      }

      return this;
    },


    /**
     * Makes necessary adjustments to the DOM surrounding the Searchfield element to accommodate
     * breakpoint changes.
     * @private
     * @returns {void}
     */
    adjustOnBreakpoint: function adjustOnBreakpoint() {
      // On smaller form-factor (tablet/phone)
      if (this.shouldBeFullWidth()) {
        this.wrapper.removeAttr('style');
        this.input.removeAttribute('style');

        if (this.isFocused) {
          this.appendToParent();

          this.calculateOpenWidth();
          this.setOpenWidth();

          if (this.isExpanded) {
            return;
          }

          this.expand(true);
          return;
        }

        if (this.isCurrentlyCollapsible && this.isExpanded) {
          this.collapse();
        }

        return;
      }

      // On larger form-factor (desktop)
      this.appendToButtonset();

      if (this.isFocused || this.settings.collapsible === 'mobile') {
        if (!this.isExpanded) {
          this.expand(true);
        }
        return;
      }

      if (this.isExpanded) {
        this.collapse();
      }
    },


    /**
     * If focused, we need to store a reference to the element with focus
     * (for example: searchfield, internal buttons, etc) because once the element
     * becomes removed from the DOM, focus is lost.
     * @private
     * @returns {void}
     */
    saveFocus: function saveFocus() {
      if (!this.isFocused) {
        return;
      }
      this.focusElem = document.activeElement;
    },


    /**
     * Restores focus to an element reference that was previously focused.
     * @private
     * @returns {void}
     */
    restoreFocus: function restoreFocus() {
      if (!this.focusElem) {
        return;
      }

      var self = this;

      var focusTimer = new RenderLoopItem({
        duration: 1,
        updateCallback: function updateCallback() {},
        // TODO: make this work without an empty function
        timeoutCallback: function timeoutCallback() {
          if (!self.focusElem) {
            return;
          }
          self.focusElem.focus();
          delete self.focusElem;
        }
      });
      renderLoop.register(focusTimer);
    },


    /**
     * Appends this searchfield to the `containmentParent` element
     * Used when the small-form-factor searchfield needs to be established.
     * @private
     * @returns {void}
     */
    appendToParent: function appendToParent() {
      if (!this.containmentParent || this.wrapper.parent().is($(this.containmentParent))) {
        return;
      }

      this.saveFocus();

      this.elemBeforeWrapper = this.wrapper.prev();
      $(this.containmentParent).prepend(this.wrapper);

      utils.fixSVGIcons(this.wrapper);

      this.restoreFocus();
    },


    /**
     * Removes this searchfield from the `containmentParent` element,
     * and places it back into the buttonset. Used when the small-form-factor
     * searchfield needs to be established.
     * @private
     * @returns {void}
     */
    appendToButtonset: function appendToButtonset() {
      if (!this.containmentParent || !this.wrapper.parent().is($(this.containmentParent))) {
        return;
      }

      this.saveFocus();

      if (!(this.elemBeforeWrapper instanceof $) || !this.elemBeforeWrapper.length) {
        this.wrapper.prependTo($(this.buttonsetElem));
      } else {
        this.wrapper.insertAfter(this.elemBeforeWrapper);
        this.elemBeforeWrapper = null;
      }

      $(this.toolbarParent).triggerHandler('scrollup');
      utils.fixSVGIcons(this.wrapper);

      this.restoreFocus();
    },


    /**
     * Determines whether or not, when the Searchfield is expanded, the Searchfield should be placed
     *  over top of its sibling Toolbar elements, and take up 100% of its container's space.
     * @private
     * @returns {boolean} whether or not the Toolbar should be full width.
     */
    shouldBeFullWidth: function shouldBeFullWidth() {
      var header = this.wrapper.closest('.header');
      var headerCondition = false;

      if (header.length) {
        headerCondition = header.width() < breakpoints.phone;
      }

      return headerCondition || breakpoints.isBelow('phone-to-tablet');
    },


    /**
     * Determines whether or not the Searchfields should expand on the Mobile breakpoint.
     * @private
     * @returns {boolean} whether or not the searchfield should expand on mobile.
     */
    shouldExpandOnMobile: function shouldExpandOnMobile() {
      if (this.settings.collapsible === true) {
        return false;
      }
      if (this.settings.collapsible === 'mobile') {
        return true;
      }
      return this.shouldBeFullWidth();
    },


    /**
     * Set boolean value if strings
     * @private
     * @returns {void}
     */
    coerceBooleanSettings: function coerceBooleanSettings() {
      var arr = ['showAllResults', 'categoryMultiselect', 'showCategoryText', 'clearable'];
      this.settings = utils.coerceSettingsToBoolean(this.settings, arr);
    },


    /**
     * Reveals whether or not categories are active on this searchfield.
     * @returns {boolean} whether or not categories are active on this searchfield.
     */
    hasCategories: function hasCategories() {
      return this.settings.categories && $.isArray(this.settings.categories) && this.settings.categories.length > 0;
    },


    /**
     * Detects the existence of a "Go" button added to the main searchfield API
     * @returns {boolean} whether or not a "Go" button is present
     */
    hasGoButton: function hasGoButton() {
      return this.settings.showGoButton && this.goButton && this.goButton.length;
    },


    /**
    * Fires when the searchfield is focused.
    * @event focusin
    * @memberof ToolbarSearchfield
    * @property {object} event - The jquery event object
    * /
    /**
    * Fires when a key is pressed inside of the searchfield.
    * @event keydown
    * @memberof ToolbarSearchfield
    * @property {object} event - The jquery event object
    */
    /**
    *  Fires when a `collapse` event is triggered externally on the searchfield.
    * @event collapse
    * @memberof ToolbarSearchfield
    * @property {object} event - The jquery event object
    */
    /**
    *  Fires when a `beforeopen` event is triggered on the searchfield's optional categories menubutton.
    * @event beforeopen
    * @memberof ToolbarSearchfield
    * @property {object} event - The jquery event object
    */
    /**
    * Fires when a `navigate` event is triggered on the searchfield's parent toolbar.
    * @event navigate
    * @memberof ToolbarSearchfield
    * @property {object} event - The jquery event object
    */
    /**
    * Fires when a `keydown` event is triggered at the `document` level.
    * @event keydown
    * @memberof ToolbarSearchfield
    * @property {object} event - The jquery event object
    */
    /**
     * Fires when a `resize` event is triggered at the `body` level.
     * @event resize
     * @memberof ToolbarSearchfield
     * @property {object} event - The jquery event object
     */

    /**
     * Sets up the event-listening structure for this component instance.
     * @private
     * @returns {this} component instance
     */
    setupEvents: function setupEvents() {
      var _this = this;

      var self = this;

      self.element.on('updated.' + this.id, function (e, settings) {
        self.updated(settings);
      }).on('focus.' + this.id, function (e) {
        self.handleFocus(e);
      }).on('click.' + this.id, function (e) {
        self.handleClick(e);
      }).on('keydown.' + this.id, function (e) {
        self.handleKeydown(e);
      }).on('beforeopen.' + this.id, function (e, menu) {
        // propagates from Autocomplete's Popupmenu
        self.handlePopupBeforeOpen(e, menu);
      }).on('safe-blur.' + this.id, function () {
        // Triggered by Autocomplete
        self.handleSafeBlur();
      }).on('listclose.' + this.id, function () {
        // Triggered by Autocomplete
        self.handleSafeBlur();
      }).on('input.' + this.id, function () {
        self.checkContents();
      });

      self.wrapper.on('mouseenter.' + this.id, function () {
        $(this).addClass('is-hovered');
      }).on('mouseleave.' + this.id, function () {
        $(this).removeClass('is-hovered');
      });

      if (this.hasCategories()) {
        this.categoryButton.on('selected.' + this.id, function (e, anchor) {
          self.handleCategorySelected(e, anchor);
        }).on('focus.' + this.id, function (e) {
          self.handleCategoryFocus(e);
        }).on('blur.' + this.id, function () {
          self.handleSafeBlur();
        }).on('close.' + this.id, function () {
          // Popupmenu Close
          self.handleSafeBlur();
        }).on('beforeopen.' + this.id, function (e, menu) {
          // Popupmenu beforeOpen
          self.handlePopupBeforeOpen(e, menu);
        });
      }

      if (self.hasGoButton()) {
        self.goButton.on('click.' + this.id, function (e) {
          return self.handleGoButtonClick(e);
        }).on('click.' + this.id, function (e) {
          return self.handleGoButtonFocus(e);
        }).on('blur.' + this.id, function () {
          return self.handleSafeBlur();
        });
      }

      if (this.isCollapsible) {
        this.wrapper.on('focusin.' + this.id, function (e) {
          self.handleFocus(e);
        }).on('focusout.' + this.id, function (e) {
          self.handleBlur(e);
        }).on('keydown.' + this.id, function (e) {
          self.handleKeydown(e);
        }).on('collapse.' + this.id, function () {
          self.collapse();
        });

        $('body').on('resize.' + this.id, function () {
          self.adjustOnBreakpoint();
        });
        self.adjustOnBreakpoint();
      }

      if (this.toolbarParent) {
        $(this.toolbarParent).on('navigate.' + this.id, function () {
          if (self.isFocused || !self.isCurrentlyCollapsible) {
            return;
          }
          self.collapse();
        }).on('rendered.' + this.id, function () {
          self.element.removeClass('no-transition no-animation');
          self.wrapper.removeClass('no-transition no-animation');
        });
      }

      // Insert the "view more results" link on the Autocomplete control's "populated" event
      self.element.on('populated.' + this.id, function (e, items) {
        if (items.length > 0) {
          if (self.settings.showAllResults) {
            self.addMoreLink();
          }
        } else {
          self.addNoneLink();
        }
      });

      // Setup a listener for the Clearable behavior, if applicable
      if (self.settings.clearable) {
        self.element.on('cleared.' + this.id, function () {
          if (self.autocomplete) {
            self.autocomplete.closeList();
          }
        });
      }

      // Override the 'click' listener created by Autocomplete (which overrides the
      // default Popupmenu method) to act differntly when the More Results link is activated.
      self.element.on('listopen.' + this.id, function (e, items) {
        var list = $('#autocomplete-list');

        // Visual indicator class
        self.wrapper.addClass('popup-is-open');

        list.on('click.' + _this.id, 'a', function (thisE) {
          var a = $(thisE.currentTarget);
          var ret = a.text().trim();
          var isMoreLink = a.hasClass('more-results');
          var isNoneLink = a.hasClass('no-results');

          if (!isMoreLink && !isNoneLink) {
            // Only write text into the field on a regular result pick.
            self.element.attr('aria-activedescendant', a.parent().attr('id'));
          }

          if (isMoreLink) {
            // Trigger callback if one is defined
            var callback = self.settings.allResultsCallback;
            if (callback && typeof callback === 'function') {
              callback(ret);
            }
          }

          if (a.parent().attr('data-value')) {
            for (var i = 0; i < items.length; i++) {
              if (items[i].value.toString() === a.parent().attr('data-value')) {
                ret = items[i];
              }
            }
          }

          self.element.trigger('selected', [a, ret]);

          var popup = self.element.data('popupmenu');
          if (popup) {
            popup.close();
          }
          return false;
        });

        // Override the focus event created by the Autocomplete control to make the more link
        // and no-results link blank out the text inside the input.
        list.find('.more-results, .no-results').on('focus.' + _this.id, function () {
          var anchor = $(this);
          list.find('li').removeClass('is-selected');
          anchor.parent('li').addClass('is-selected');
          self.element.val('');
        });
      }).on('listclose.' + this.id, function () {
        var list = $('#autocomplete-list');

        list.off('click.' + _this.id);
        list.off('focus.' + _this.id);
      });

      return this;
    },


    /**
     * Activates a toolbar-based searchfield and keeps it "open".  Instead of closing
     * it on blur, sets up an explicit, out-of-bounds click/tap that will serve to close
     * it when the user acts.
     * @private
     * @param {boolean} force ignore any attempt to return out first
     * @param {boolean} doFocus focus the searchfield element.
     * @returns {void}
     */
    setAsActive: function setAsActive(force, doFocus) {
      if (!force && this.wrapper.hasClass('active')) {
        return;
      }

      this.addDocumentDeactivationEvents();

      this.wrapper.addClass('has-focus');
      this.expand(true);

      // Activate
      this.wrapper.addClass('active');
      var toolbar = this.element.closest('.toolbar, [class$="-toolbar"]');
      if (toolbar.length) {
        toolbar.addClass('searchfield-active');
      }

      if (this.isExpanded) {
        return;
      }

      if (doFocus === true) {
        this.element.focus();
      }
    },


    /**
     * @returns {boolean} whether or not one of elements inside the Searchfield wrapper has focus.
     */
    get isFocused() {
      var active = document.activeElement;
      var wrapperElem = this.wrapper[0];

      // If another element inside the Searchfield Wrapper is focused, the entire component
      // is considered "focused".
      if (wrapperElem.contains(active)) {
        return true;
      }

      // Retain focus if the autocomplete menu is focused
      if (this.autocomplete) {
        var autocompleteListElem = this.autocomplete.list;
        if (autocompleteListElem && autocompleteListElem[0].contains(active)) {
          return true;
        }
      }

      // Retain focus if a category is being selected from a category menu
      if (this.categoryButton && this.categoryButton.length) {
        var menu = this.categoryButton.data('popupmenu').menu;
        if (menu.has(active).length) {
          return true;
        }
      }

      return false;
    },

    /**
     * Detects whether or not the Searchfield has focus.
     * @deprecated in v4.8.x
     * @returns {boolean} whether or not the Searchfield has focus.
     */
    hasFocus: function hasFocus() {
      return this.isFocused;
    },


    /**
     * Focus event handler
     * @private
     * @returns {void}
     */
    handleFocus: function handleFocus() {
      this.setAsActive(true);
    },


    /**
     * Blur event handler
     * @private
     * @returns {void}
     */
    handleBlur: function handleBlur() {
      var self = this;

      if (Environment.os.name === 'ios') {
        $('head').triggerHandler('disable-zoom');
      }

      self.handleSafeBlur();
    },


    /**
     * Custom event handler for Autocomplete's `safe-blur` and `listclose` events.
     * Fired on the base element when any Autocomplete-related focusable element loses focus to
     * something outside the Autocomplete's wrapper
     * @private
     * @returns {void}
     */
    handleSafeBlur: function handleSafeBlur() {
      var self = this;
      function safeBlurHandler() {
        // Do a check for searchfield-specific elements
        if (self.isFocused) {
          return;
        }

        var wrapperElem = self.wrapper[0];
        wrapperElem.classList.remove('has-focus', 'active');

        self.removeDocumentDeactivationEvents();

        if (self.isCurrentlyCollapsible) {
          self.collapse();
        }
      }

      // Stagger the check for the activeElement on a timeout in order to accurately detect focus.
      if (this.blurTimer) {
        this.blurTimer.destroy(true);
      }
      this.blurTimer = new RenderLoopItem({
        duration: 1,
        updateCallback: function updateCallback() {},
        // TODO: make this work without an empty function
        timeoutCallback: safeBlurHandler
      });
      renderLoop.register(this.blurTimer);
    },


    /**
     * Click event handler
     * @private
     * @returns {void}
     */
    handleClick: function handleClick() {
      this.setAsActive();
    },


    /**
     * Sets up event listeners that need to be handled at the global (document) level, since they deal
     * with general keystrokes.
     * @private
     * @returns {void}
     */
    addDocumentDeactivationEvents: function addDocumentDeactivationEvents() {
      if (this.hasDeactivationEvents === true) {
        return;
      }

      var self = this;
      $(document).on('click.' + this.id, function (e) {
        self.handleOutsideClick(e);
      }).on('keydown.' + this.id, function (e) {
        self.handleOutsideKeydown(e);
      });

      this.hasDeactivationEvents = true;
    },


    /**
     * Removes global (document) level event handlers.
     * @private
     * @returns {void}
     */
    removeDocumentDeactivationEvents: function removeDocumentDeactivationEvents() {
      $(document).off('click.' + this.id + ' keydown.' + this.id);
      this.hasDeactivationEvents = false;
    },


    /**
     * Event Handler for dealing with global (document) level clicks.
     * @private
     * @param {jQuery.Event} e `click` event
     * @returns {void}
     */
    handleOutsideClick: function handleOutsideClick(e) {
      var target = e.target;
      if (this.isSearchfieldElement(target)) {
        return;
      }
      this.handleSafeBlur();
    },


    /**
     * Keydown event handler
     * @private
     * @param {jQuery.Event} e jQuery `keydown`
     * @returns {void}
     */
    handleKeydown: function handleKeydown(e) {
      var key = e.which;

      if (key === 27 && Environment.browser.isIE11()) {
        e.preventDefault();
      }

      if (e.ctrlKey && key === 8) {
        this.element.val('');
      }

      if (key === 9) {
        // Tab
        this.handleSafeBlur();
      }
    },


    /**
     * Handles global (document) level keydown events that are established to help
     * collapse/de-highlight searchfields on a timer.
     * @private
     * @param {jQuery.Event} e jQuery-wrapped Keydown event
     * @returns {void}
     */
    handleOutsideKeydown: function handleOutsideKeydown(e) {
      var key = e.which;
      var target = e.target;

      if (key === 9 && !this.isSearchfieldElement(target)) {
        this.handleSafeBlur();
      }
    },


    /**
     * Modifies the menu at $('#autocomplete-list') to propagate/remove style
     *  classes on the Searchfield element.
     * @private
     * @param {jQuery.Event} e custom jQuery `beforeopen` event from the Popupmenu Component.
     * @param {jQuery[]} menu element that represents the popupmenu that is being opened.
     * @returns {boolean} the ability to cancel the menu's opening.
     */
    handlePopupBeforeOpen: function handlePopupBeforeOpen(e, menu) {
      if (this.isCollapsible && (this.isExpanding || !this.isExpanded) || !menu) {
        return false;
      }

      var contextClassMethod = this.wrapper.hasClass('context') ? 'addClass' : 'removeClass';
      var altClassMethod = this.wrapper.hasClass('alternate') ? 'addClass' : 'removeClass';

      menu[contextClassMethod]('context');
      menu[altClassMethod]('alternate');

      if (!this.isExpanded) {
        this.categoryButton.focus();
        return false;
      }

      return true;
    },


    /**
     * @private
     * @param {jQuery.Event} e jQuery `click` event
     * @returns {void}
     */
    handleGoButtonClick: function handleGoButtonClick(e) {
      var action = this.settings.goButtonAction;
      if (typeof action !== 'function') {
        return undefined;
      }

      var searchfieldValue = this.element.val();
      var categorySelection = void 0;

      if (this.hasCategories()) {
        categorySelection = this.getCategoryData();
      }

      // gives access to the current searchfield value, and category data if applicable.
      return action(e, searchfieldValue, categorySelection);
    },


    /**
     * @private
     * @returns {void}
     */
    handleGoButtonFocus: function handleGoButtonFocus() {
      this.setAsActive(true);
    },


    /**
     * Sets the text content on the category button.  Will either display a single category
     * name, or a translated "[x] Selected." string.
     * @param {string} [textContent] Optional incoming text that will be subtituted for the
     * selected element count.
     * @returns {undefined}
     */
    setCategoryButtonText: function setCategoryButtonText(textContent) {
      if (!this.settings.showCategoryText || !this.categoryButton.length) {
        return;
      }

      var text = '';
      var button = this.wrapper.find('.btn');
      var span = button.find('span');

      if (!span || !span.length) {
        span = $('<span class="category"></span>').insertAfter(button.find('.icon').first());
      }

      span.empty();

      // incoming text takes precedent
      if (typeof textContent === 'string' && textContent.length) {
        span.text(textContent.trim());
        return;
      }

      // Otherwise, grab currently selected categories and set text
      // (or clear, if no options are selected).
      var item = this.getSelectedCategories();
      if (!item.length) {
        return;
      }

      if (item.length > 1) {
        text = item.length + ' ' + Locale.translate('Selected');
      } else {
        text = item.text().trim();
      }

      span.text(text);
    },


    /**
     * Detects whether or not an element is part of this instance of the Searchfield component
     * @private
     * @param {HTMLElement} element the element being checked.
     * @returns {boolean} whether or not the element provided is part of this Searchfield component
     */
    isSearchfieldElement: function isSearchfieldElement(element) {
      if ($.contains(this.wrapper[0], element)) {
        return true;
      }

      // Don't close if a category is being selected from a category menu
      if (this.categoryButton && this.categoryButton.length) {
        var menu = this.categoryButton.data('popupmenu').menu;
        if (menu.has(element).length) {
          return true;
        }
      }

      return false;
    },


    /**
     * Retrieves the distance between a left and right boundary.
     * Used on controls like Lookup, Contextual Panel, etc. to fill the space remaining in a toolbar.
     * @private
     * @param {Number|jQuery[]} leftBoundary left boundary in pixels
     * @param {Number|jQuery[]} rightBoundary right boundary in pixels
     * @returns {number} the fill size area
     */
    getFillSize: function getFillSize(leftBoundary, rightBoundary) {
      var leftBoundaryNum = 0;
      var rightBoundaryNum = 0;

      function sanitize(boundary) {
        if (!boundary) {
          return 0;
        }

        // Return out if the boundary is just a number
        if (!isNaN(parseInt(boundary, 10))) {
          return parseInt(boundary, 10);
        }

        if (boundary instanceof jQuery) {
          if (!boundary.length) {
            return 0;
          }

          if (boundary.is('.title')) {
            boundary = boundary.next('.buttonset');
          }

          boundary = boundary[0];
        }

        return boundary;
      }

      function getEdgeFromBoundary(boundary, edge) {
        if (!isNaN(boundary)) {
          return boundary === null || boundary === undefined ? 0 : boundary;
        }

        if (!edge || typeof edge !== 'string') {
          edge = 'left';
        }

        var edges = ['left', 'right'];
        if ($.inArray(edge, edges) === -1) {
          edge = edges[0];
        }

        var rect = void 0;

        if (boundary instanceof HTMLElement || boundary instanceof SVGElement) {
          rect = boundary.getBoundingClientRect();
        }

        return rect[edge];
      }

      leftBoundary = sanitize(leftBoundary);
      rightBoundary = sanitize(rightBoundary);

      function whichEdge() {
        var e = 'left';
        if (leftBoundary === rightBoundary || $(rightBoundary).length && $(rightBoundary).is('.buttonset')) {
          e = 'right';
        }

        return e;
      }

      leftBoundaryNum = getEdgeFromBoundary(leftBoundary);
      rightBoundaryNum = getEdgeFromBoundary(rightBoundary, whichEdge());

      if (!leftBoundaryNum && !rightBoundaryNum) {
        return TOOLBARSEARCHFIELD_EXPAND_SIZE;
      }

      var distance = rightBoundaryNum - leftBoundaryNum;

      // TODO: Remove this once we figure out how to definitively fix the searchfield sizing.
      // Toolbar Searchfield needs a way to demand that the parent toolbar increase
      // the size of its buttonset and decrease the size of its title under this condition
      // -- currently there is no way.
      if (distance <= TOOLBARSEARCHFIELD_EXPAND_SIZE) {
        return TOOLBARSEARCHFIELD_EXPAND_SIZE;
      }

      if (distance >= MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE) {
        return MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE;
      }

      return distance;
    },


    /**
     * @private
     * @returns {void}
     */
    setClosedWidth: function setClosedWidth() {
      var closedWidth = 0;

      // If the searchfield category button exists, change the width of the
      // input field on the inside to provide space for the (variable) size of the currently-selected
      // category (or categories)
      if (this.categoryButton instanceof $ && this.categoryButton.length) {
        var buttonStyle = window.getComputedStyle(this.categoryButton[0]);
        var buttonWidth = this.categoryButton.width();
        var buttonBorder = parseInt(buttonStyle.borderLeftWidth, 10) * 2;
        var buttonPadding = parseInt(buttonStyle.paddingLeft, 10) + parseInt(buttonStyle.paddingRight, 10);

        closedWidth += buttonWidth + buttonBorder + buttonPadding + 4;
      }

      if (this.wrapper[0]) {
        this.wrapper[0].style.width = closedWidth + 'px';
      }
    },


    /**
     * @private
     * @returns {void}
     */
    setOpenWidth: function setOpenWidth() {
      var subtractWidth = 0;

      if (this.wrapper[0]) {
        this.wrapper[0].style.width = this.openWidth;
      }

      // If the searchfield category button exists, change the width of the
      // input field on the inside to provide space for the (variable) size of the currently-selected
      // category (or categories)
      if (this.hasCategories()) {
        var categoryButtonStyle = window.getComputedStyle(this.categoryButton[0]);
        var categoryButtonWidth = this.categoryButton.width();
        var categoryButtonPadding = parseInt(categoryButtonStyle.paddingLeft, 10) + parseInt(categoryButtonStyle.paddingRight, 10);
        var categoryButtonBorder = parseInt(categoryButtonStyle.borderLeftWidth, 10) * 2;

        subtractWidth += categoryButtonWidth + categoryButtonPadding + categoryButtonBorder;
      }

      if (this.hasGoButton()) {
        var goButtonStyle = window.getComputedStyle(this.goButton[0]);
        var goButtonWidth = this.goButton.width();
        var goButtonPadding = parseInt(goButtonStyle.paddingLeft, 10) + parseInt(goButtonStyle.paddingRight, 10);
        var goButtonBorder = parseInt(goButtonStyle.borderLeftWidth, 10) * 2;

        subtractWidth += goButtonWidth + goButtonPadding + goButtonBorder;
      }

      if (subtractWidth > 0) {
        this.input.style.width = 'calc(100% - ' + subtractWidth + 'px)';
      }

      delete this.openWidth;
    },


    /**
     * @private
     * @returns {void}
     */
    calculateOpenWidth: function calculateOpenWidth() {
      var buttonset = this.element.parents('.toolbar').children('.buttonset');
      var nextElem = this.wrapper.next();
      var width = void 0;

      if (!buttonset.length) {
        return;
      }
      // If small form factor, use the right edge
      if (nextElem.is('.title')) {
        nextElem = buttonset;
      }

      if (this.shouldBeFullWidth()) {
        width = '100%';

        if ($(this.toolbarParent).closest('.header').length) {
          width = 'calc(100% - 40px)';
        }
        if ($(this.toolbarParent).closest('.tab-container.module-tabs').length) {
          width = 'calc(100% - 1px)';
        }

        this.openWidth = width;
        return;
      }

      // Figure out boundaries
      // +10 on the left boundary reduces the likelyhood that the toolbar pushes other elements
      // into the spillover menu whenever the searchfield opens.
      var leftBoundary = buttonset.offset().left + 10;
      var rightBoundary = nextElem;

      // If the search input sits alone, just use the other side of the buttonset to measure
      if (!rightBoundary.length) {
        rightBoundary = buttonset.offset().left + 10 + buttonset.outerWidth(true);
      }

      width = this.getFillSize(leftBoundary, rightBoundary);
      this.openWidth = width - 6 + 'px';
    },


    /**
     * Ensures that the size of the Searchfield Wrapper does not change whenever a category
     * is chosen from a category searchfield.
     * NOTE: this method must be run AFTER changes to DOM elements (text/size changes) have been made.
     * @private
     */
    calculateSearchfieldWidth: function calculateSearchfieldWidth() {
      var subtractWidth = 0;
      var targetWidthProp = void 0;

      if (this.hasCategories()) {
        subtractWidth += this.categoryButton.outerWidth(true);
      }
      if (this.hasGoButton()) {
        subtractWidth += this.goButton.outerWidth(true);
      }

      // NOTE: final width can only be 100% if no value is subtracted for other elements
      if (subtractWidth > 0) {
        targetWidthProp = 'calc(100% - ' + subtractWidth + 'px)';
      }
      if (targetWidthProp) {
        this.element[0].style.width = targetWidthProp;
      }
    },


    /**
     * Category Selection event handler
     * @private
     * @param  {object} e The event.
     * @param  {object} anchor the link object
     */
    handleCategorySelected: function handleCategorySelected(e, anchor) {
      this.element.trigger('selected', [anchor]);

      // Only change the text and searchfield size if we can
      if (!this.settings.showCategoryText) {
        return;
      }

      this.setCategoryButtonText(e, anchor.text().trim());
      this.calculateSearchfieldWidth();

      if (!this.settings.categoryMultiselect) {
        this.setAsActive(true, true);
      }
    },


    /**
     * Category Button Focus event handler
     * @private
     * @returns {undefined}
     */
    handleCategoryFocus: function handleCategoryFocus() {
      this.saveFocus();
      this.setAsActive(true);
    },


    /**
     * Gets a complete list of categories in jQuery-collection form.
     * @returns {jQuery} categories
     */
    getCategories: function getCategories() {
      return this.list.children('li:not(.separator)');
    },


    /**
     * Gets the currently selected list of categories in jQuery-collection form.
     * @returns {jQuery} selectedCategories
     */
    getSelectedCategories: function getSelectedCategories() {
      return this.getCategories().filter('.is-checked');
    },


    /**
     * Gets the currently selected categories as data.
     * @param {boolean} [onlyReturnSelected=false] - If set to true, will only return
     *  checked list items.
     * @returns {Object[]} data -
     * @returns {string} name - Category name
     * @returns {string|number} id - Category element's ID (if applicable)
     * @returns {string|number} value - Category element's value (if applicable)
     * @returns {boolean} [checked=true] - Category's selection status
     */
    getCategoryData: function getCategoryData(onlyReturnSelected) {
      var categories = this.getCategories();
      var data = [];

      categories.each(function () {
        var classList = this.classList;
        var checked = classList.contains('is-checked');

        if (onlyReturnSelected === true && checked === false) {
          return;
        }

        var category = {
          name: this.innerText,
          checked: checked
        };

        if (this.id) {
          category.id = this.id;
        }

        var value = this.getAttribute('data-value');
        if (value !== undefined) {
          category.value = value;
        }

        data.push(category);
      });

      return data;
    },


    /**
     * Updates just the categories setting and rerenders the category list.
     * @param {Object[]} categories - Array of category object definitions.
     * @param {string} categories[].name - Category name.
     * @param {string|number} [id] - Category element's ID (if applicable).
     * @param {string|number} [value] - Category element's value (if applicable).
     * @param {boolean} [checked=true] - Category's selection status
     * @returns {undefined}
     */
    updateCategories: function updateCategories(categories) {
      this.settings.categories = categories;
      this.setCategories(this.settings.categories);
    },


    /**
     * Creates a new set of categories on the Searchfield and rerenders it.
     * @param {Object[]} categories - Array of category object definitions.
     * @param {string} categories[].name - Category name.
     * @param {string|number} [id] - Category element's ID (if applicable).
     * @param {string|number} [value] - Category element's value (if applicable).
     * @param {boolean} [checked=true] - Category's selection status
     * @returns {undefined}
     */
    setCategories: function setCategories(categories) {
      this.list.empty();

      var self = this;
      var valueTypes = ['string', 'number'];
      var previouslySelected = false;

      categories.forEach(function (val) {
        // if passed a string, typecast to an object.
        if (typeof val === 'string') {
          val = {
            name: val
          };
        }

        // Object types get a bit more customization.
        // Don't continue if there's no name present.
        if (!val.name) {
          return;
        }

        var id = '';
        if (typeof val.id === 'string' && val.id.length) {
          id = ' id="' + val.id + '"';
        }

        var value = '';
        if (valueTypes.indexOf(_typeof(val.value)) > -1) {
          value = ' data-value="' + val.value + '"';
        }

        var selected = '';
        if (val.checked === true && previouslySelected !== true) {
          selected = ' class="is-checked"';

          if (!self.settings.categoryMultiselect) {
            previouslySelected = true;
          }
        }

        self.list.append('<li' + selected + id + value + '><a href="#">' + val.name + '</a></li>');
      });

      var api = this.categoryButton.data('popupmenu');
      if (api && typeof api.updated === 'function') {
        api.updated();
      }
    },


    /**
     * Expands the Searchfield
     * @param {boolean} [noFocus] If defined, causes the searchfield component not to become focused
     *  at the end of the expand method. Its default functionality is that it will become focused.
     * @returns {void}
     */
    expand: function expand(noFocus) {
      if (this.isExpanded || this.isExpanding) {
        return;
      }

      var self = this;
      var notFullWidth = !this.shouldBeFullWidth();

      this.isExpanding = true;

      // Places the input wrapper into the toolbar on smaller breakpoints
      if (!notFullWidth) {
        this.appendToParent();
      }

      // Re-adjust the size of the buttonset element if the expanded searchfield would be
      // too large to fit.
      var buttonsetWidth = 0;
      if (this.buttonsetElem) {
        buttonsetWidth = parseInt(window.getComputedStyle(this.buttonsetElem).width, 10);
      }

      var buttonsetElemWidth = buttonsetWidth + TOOLBARSEARCHFIELD_EXPAND_SIZE;
      var containerSizeSetters = {
        buttonset: buttonsetElemWidth
      };

      this.wrapper.addClass('is-open');
      this.calculateOpenWidth();
      this.setOpenWidth();

      // Some situations require adjusting the focused element
      if (!noFocus || Environment.os.name === 'ios' || self.isFocused && document.activeElement !== self.input) {
        if (self.focusElem) {
          self.focusElem = self.input;
        }
        self.input.focus();
      }

      // Recalculate the Toolbar Buttonset/Title sizes.
      var eventArgs = [];
      if (containerSizeSetters) {
        eventArgs.push(containerSizeSetters);
      }

      $(self.toolbarParent).triggerHandler('recalculate-buttons', eventArgs);

      var expandTimer = new RenderLoopItem({
        duration: 30,
        updateCallback: function updateCallback() {},
        // TODO: make this work without an empty function
        timeoutCallback: function timeoutCallback() {
          $(self.toolbarParent).triggerHandler('recalculate-buttons', eventArgs);
          self.wrapper.triggerHandler('expanded');
          delete self.isExpanding;
          self.isExpanded = true;

          if (self.isCurrentlyCollapsible && !self.isFocused && !self.focusElem) {
            self.handleSafeBlur();
          }
        }
      });
      renderLoop.register(expandTimer);
    },


    /**
     * Collapses the Searchfield
     * @returns {void}
     */
    collapse: function collapse() {
      if (!this.isExpanded || this.isCollapsing) {
        return;
      }

      var self = this;

      this.isCollapsing = true;

      // Puts the input wrapper back where it should be if it's been moved due to small form factors.
      this.appendToButtonset();

      this.checkContents();

      this.wrapper[0].classList.remove('active', 'is-open');
      if (Environment.browser.isIE11) {
        this.wrapper[0].classList.remove('is-open');
      }
      if (!this.isFocused) {
        this.wrapper[0].classList.remove('has-focus');
      }

      this.wrapper.removeAttr('style');
      this.input.removeAttribute('style');

      if (this.categoryButton && this.categoryButton.length) {
        this.categoryButton.data('popupmenu').close(false, true);
      }

      this.wrapper.triggerHandler('collapsed');

      if (Environment.os.name === 'ios') {
        $('head').triggerHandler('enable-zoom');
      }

      delete this.isExpanded;
      delete this.isExpanding;

      var collapseTimer = new RenderLoopItem({
        duration: 30,
        updateCallback: function updateCallback() {},
        // TODO: make this work without an empty function
        timeoutCallback: function timeoutCallback() {
          delete self.isCollapsing;
          $(self.toolbarParent).triggerHandler('recalculate-buttons');
        }
      });
      renderLoop.register(collapseTimer);
    },


    /**
     * Adds/removes a CSS class to the searchfield wrapper depending on whether or not the input field is empty.
     * Needed for expand/collapse scenarios, for proper searchfield resizing.
     * @private
     * @returns {void}
     */
    checkContents: function checkContents() {
      var textMethod = 'removeClass';
      if (this.input.value.trim() !== '') {
        textMethod = 'addClass';
      }
      this.wrapper[textMethod]('has-text');
    },


    /**
     * Adds a link at the bottom of a searchfield with more than (0) results that can be used to link out to a
     * larger display of search results.
     * @private
     * @returns {void}
     */
    addMoreLink: function addMoreLink() {
      var list = $('#autocomplete-list');
      var val = this.element.val();

      if ($('.more-results', list).length > 0) {
        return;
      }

      $('<li class="separator" role="presentation"></li>').appendTo(list);
      var more = $('<li role="presentation"></li>').appendTo(list);
      this.moreLink = $('<a href="#" class="more-results" tabindex="-1" role="menuitem"></a>').html('<span>' + Locale.translate('AllResults') + ' "' + xssUtils.ensureAlphaNumeric(val) + '"</span>').appendTo(more);
    },


    /**
     * Adds a link at the bottom of a searchfield with no results that announces no search results.
     * @private
     * @returns {void}
     */
    addNoneLink: function addNoneLink() {
      var list = $('#autocomplete-list');
      if ($('.no-results', list).length > 0) {
        return;
      }

      var none = $('<li role="presentation"></li>').appendTo(list);

      this.noneLink = $('<a href="#" class="no-results" tabindex="-1" role="menuitem"></a>').html('<span>' + Locale.translate('NoResults') + '</span>').appendTo(none);
    },


    /**
     * Tears down and rebuilds the Searchfield. Can be called directly, but is also
     * triggered by calling the "updated.searchfield" event on the searchfield element.
     * @param {object} [settings] incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }
      this.teardown().init();
    },


    /**
     * Disables the Searchfield
     * @returns {void}
     */
    disable: function disable() {
      this.wrapper.addClass('is-disabled');
      this.element.prop('disabled', true);
    },


    /**
     * Enables the Searchfield
     * @returns {void}
     */
    enable: function enable() {
      this.wrapper.removeClass('is-disabled');
      this.element.prop('disabled', false);
    },


    /**
     * Unbinds events and removes unnecessary markup.
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.element.off(['updated.' + this.id, 'click.' + this.id, 'keydown.' + this.id, 'beforeopen.' + this.id, 'listopen.' + this.id, 'listclose.' + this.id, 'safe-blur.' + this.id, 'populated.' + this.id, 'cleared.' + this.id].join(' '));

      // ToolbarSearchfield events
      this.wrapper.off(['focusin.' + this.id, 'focusout.' + this.id, 'keydown.' + this.id, 'collapse.' + this.id].join(' '));

      if (this.toolbarParent) {
        $(this.toolbarParent).off('navigate.toolbarsearchfield');
      }

      if (this.goButton && this.goButton.length) {
        this.goButton.off('click.' + this.id + ' blur.' + this.id);
      }

      if (this.categoryButton && this.categoryButton.length) {
        this.categoryButton.off();
      }

      // Used to determine if the "Tab" key was involved in switching focus to the searchfield.
      this.removeDocumentDeactivationEvents();
      $('body').off('resize.' + this.id);

      if (this.autocomplete) {
        this.autocomplete.destroy();
      }

      if (this.wrapper.hasClass('context')) {
        this.element.addClass('context');
      }

      this.element.next('.icon').remove();
      if (this.element.parent().hasClass('searchfield-wrapper')) {
        this.element.parent().find('ul').remove();
        this.element.parent().find('.icon').remove();
      }

      if (this.xButton && this.xButton.length) {
        this.xButton.remove();
      }

      return this;
    },


    /**
     * Destroys the Searchfield and removes all jQuery component instancing.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$d);
    }
  };

  /**
   * jQuery Component Wrapper for SearchField
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.searchfield = function (settings) {
    return this.each(function () {
      // Normal invoke setup
      var instance = $.data(this, COMPONENT_NAME$d);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$d, new SearchField(this, settings));
      }
    });
  };

  /* eslint-disable no-underscore-dangle, prefer-arrow-callback */

  // Name of the component in this file.
  var COMPONENT_NAME$e = 'applicationmenu';

  /**
   * The Application Menu provides access to all the functions, pages, and forms in an application.
   * @class ApplicationMenu
   * @param {object} element The element that gets the plugin established on it.
   * @param {object} [settings] The settings to use on this instance.
   * @param {string} [settings.breakpoint='phone-to-tablet'] Can be 'tablet' or 'phone-to-tablet' (+767),
   * 'phablet (+610)', 'desktop' +(1024) or 'tablet-to-desktop' (+1280). Default is 'phone-to-tablet' (767)
   * @param {boolean} [settings.dismissOnClickMobile=false] If true, causes a clicked menu option to dismiss on click when the responsive view is shown.
   * @param {boolean} [settings.filterable=false] If true a search / filter option will be added.
   * @param {boolean} [settings.openOnLarge=false]  If true, will automatically open the Application Menu when a large screen-width breakpoint is met.
   * @param {array} [settings.triggers=[]]  An Array of jQuery-wrapped elements that are able to open/close this nav menu.
   */
  var APPLICATIONMENU_DEFAULTS = {
    breakpoint: 'phone-to-tablet',
    dismissOnClickMobile: false,
    filterable: false,
    openOnLarge: false,
    triggers: []
  };

  function ApplicationMenu(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, APPLICATIONMENU_DEFAULTS);

    return this.init();
  }

  // Plugin Methods
  ApplicationMenu.prototype = {

    /**
     * Initialize the plugin.
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup().handleEvents();
    },


    /**
     * @private
     * @returns {this} component instance
     */
    setup: function setup() {
      this.hasTrigger = false;
      this.isAnimating = false;

      if (!this.hasTriggers()) {
        this.triggers = $();
      }

      this.menu = this.element;

      var openOnLarge = this.element.attr('data-open-on-large');
      this.settings.openOnLarge = openOnLarge !== undefined ? openOnLarge === 'true' : this.settings.openOnLarge;

      var dataBreakpoint = this.element.attr('data-breakpoint');
      this.settings.breakpoint = breakpoints[dataBreakpoint] !== undefined ? dataBreakpoint : this.settings.breakpoint;

      // Pull in the list of Nav Menu trigger elements and store them internally.
      this.modifyTriggers(this.settings.triggers, false, true);

      this.scrollTarget = this.menu.parents('.header');
      var masthead = this.menu.prevAll('.masthead');
      var moduleTabs = this.menu.prevAll('.module-tabs');

      if (masthead.length > 0) {
        this.scrollTarget = masthead;
        this.menu.addClass('short');
      }
      if (moduleTabs.length > 0) {
        this.scrollTarget = moduleTabs;
      }

      this.accordion = this.menu.find('.accordion');
      this.accordion.addClass('panel').addClass('inverse');

      // Check to make sure that the internal Accordion Control is invoked
      var accordion = this.accordion.data('accordion');
      if (!accordion) {
        this.accordion.accordion();
        accordion = this.accordion.data('accordion');
      }
      this.accordionAPI = accordion;

      // detect the presence of a searchfield
      this.searchfield = this.element.children('.searchfield, .searchfield-wrapper');

      // Setup filtering, if applicable.
      if (this.settings.filterable && typeof $.fn.searchfield === 'function') {
        if (this.searchfield.length) {
          if (this.searchfield.is('.searchfield-wrapper')) {
            this.searchfield = this.searchfield.children('.searchfield');
          }
        } else {
          this.searchfield = $('' + ('<div class="searchfield-wrapper">' + '<label for="application-menu-searchfield">') + Locale.translate('Search') + '</label>' + '<input id="application-menu-searchfield" class="searchfield" /></div>').prependTo(this.element);
        }

        this.element.addClass('has-searchfield');
        var self = this;
        this.searchfield.searchfield({
          clearable: true,
          source: function source(term, done, args) {
            done(term, self.accordion.data('accordion').toData(true, true), args);
          },
          searchableTextCallback: function searchableTextCallback(item) {
            return item.text || '';
          },
          resultIteratorCallback: function resultIteratorCallback(item) {
            item.highlightTarget = 'text';
            return item;
          },
          clearResultsCallback: function clearResultsCallback() {
            self.accordionAPI.unfilter();
          },
          displayResultsCallback: function displayResultsCallback(results, done) {
            return self.filterResultsCallback(results, done);
          }
        });
      } else if (this.searchfield.length) {
        this.searchfield.off();
        this.searchfield.parent('.searchfield-wrapper').remove();
        delete this.searchfield;
      }

      // Sync with application menus that have an 'is-open' CSS class.
      // Otherwise, just adjust the height.
      if (this.isOpen()) {
        this.openMenu(false, false, true);
      } else {
        this.adjustHeight();
      }

      return this;
    },


    /**
     * Gets a reference to this Application Menu's adjacent container element.
     * @returns {jQuery[]} the adjacent container element
     */
    getAdjacentContainerElement: function getAdjacentContainerElement() {
      var container = this.element.next('.page-container');
      if (!container.length) {
        container = $('body');
      }
      return container;
    },


    /**
     * Setup click events on this.element if it's not the menu itself.
     * (this means that it's a trigger button).
     * @returns {void}
     */
    handleTriggerEvents: function handleTriggerEvents() {
      var self = this;

      function triggerClickHandler(e) {
        // Don't allow hamburger buttons that have changed state to activate/deactivate the app menu.
        if ($(e.currentTarget).find('.icon.app-header').hasClass('go-back')) {
          return false;
        }

        if (self.isAnimating) {
          return false;
        }

        var isOpen = self.menu.hasClass('is-open');
        if (!isOpen) {
          self.openMenu(undefined, true);
        } else {
          self.closeMenu(true);
        }
        return true;
      }

      if (this.triggers.length) {
        this.triggers.off('click.applicationmenu').on('click.applicationmenu', triggerClickHandler);
      }

      $(document).on('keydown.applicationmenu', function (e) {
        self.handleKeyDown(e);
      });
    },


    /**
     * Handles Keydown Events on the App Menu
     * @param {jQuery.Event} e `keydown` events
     * @returns {boolean} whether or not the keydown event was successful
     */
    handleKeyDown: function handleKeyDown(e) {
      var key = e.which;

      if (key === 121) {
        // F10
        e.preventDefault();

        if (this.isOpen()) {
          this.closeMenu(true);
          if (this.triggers.length) {
            this.triggers.eq(0).focus();
          }
        } else {
          this.openMenu();
        }

        return false;
      }

      return true;
    },


    /**
     * Adds a visual badge-style notification to an Application Menu accordion header
     * @param {jQuery[]} anchor the anchor to target
     * @param {number} value the numeric value to attach
     * @returns {jQuery[]|undefined} a reference to the new tag markup, if applicable
     */
    notify: function notify(anchor, value) {
      if (!anchor || anchor === undefined) {
        return undefined;
      }
      if (anchor instanceof HTMLElement) {
        anchor = $(anchor);
      }
      if (!anchor.is('a')) {
        return undefined;
      }

      var tag = anchor.find('.tag');

      // Close the tag if an undefined or '0' value is passed
      if (!value || value === undefined || parseInt(value, 10) === 0) {
        if (tag.length) {
          tag.remove();
        }
        return undefined;
      }

      if (!tag.length) {
        tag = $('<span class="tag"></span>').appendTo(anchor);
      }

      tag.text(value.toString());
      return tag;
    },


    /**
     * Adjusts the application menu's height to fit the page.
     * @private
     * @returns {void}
     */
    adjustHeight: function adjustHeight() {
      var isSticky = this.scrollTarget.is('.is-sticky');
      var totalHeight = this.scrollTarget.outerHeight(true);
      var offset = totalHeight - (!isSticky ? $(window).scrollTop() : 0);

      if (this.scrollTarget.prev().is('.masthead')) {
        offset += this.scrollTarget.prev().outerHeight(true);
      }

      this.menu[0].style.height = offset > 0 ? 'calc(100% - ' + offset + 'px)' : '100%';
    },


    /**
     * Checks the window size against the defined breakpoint.
     * @private
     * @returns {boolean} whether or not the window size is larger than the
     *  settings-defined breakpoint
     */
    isLargerThanBreakpoint: function isLargerThanBreakpoint() {
      return breakpoints.isAbove(this.settings.breakpoint);
    },


    /**
     * Detects whether or not the application menu is open
     * @returns {boolean} whether or not the application menu is open
     */
    isOpen: function isOpen() {
      return this.menu[0].classList.contains('is-open');
    },


    /**
     * Detects a change in breakpoint size that can cause the Application Menu's state to change.
     * @returns {void}
     */
    testWidth: function testWidth() {
      if (this.isOpen()) {
        if (breakpoints.isAbove(this.settings.breakpoint)) {
          this.element[0].classList.remove('show-shadow');
          return;
        }

        this.element[0].classList.add('show-shadow');

        if (this.isAnimating) {
          return;
        }

        if (!this.userOpened) {
          this.closeMenu();
        }
        return;
      }

      if (breakpoints.isBelow(this.settings.breakpoint)) {
        return;
      }

      if (this.userClosed || !this.settings.openOnLarge || this.isAnimating) {
        return;
      }

      this.openMenu(true);
    },


    /**
     * Opens the Application Menu
     * @param {boolean} noFocus If true, sets focus on the first item in the application menu.
     * @param {boolean} [userOpened] If true, notifies the component that the menu was
     *  manually opened by the user.
     * @param {boolean} [openedByClass] If true, only adjusts bare-miniumum requirements
     *  for the application menu to appear open (should be used in cases where the application
     *  menu has the `is-open` CSS appended to it via markup).  This skips events, animation, etc.
     */
    openMenu: function openMenu(noFocus, userOpened, openedByClass) {
      if (this.isAnimating === true) {
        return;
      }

      var self = this;
      var transitionEnd = $.fn.transitonEndName;

      if (!openedByClass) {
        this.isAnimating = true;
      }
      this.adjustHeight();

      function isOpen() {
        if (self.timeout !== null) {
          clearTimeout(self.timeout);
          self.timeout = null;
        }

        if (userOpened) {
          self.userOpened = true;
          self.userClosed = undefined;
        }

        /**
        * Fires the menu is opened
        *
        * @event applicationmenuopen
        * @memberof ApplicationMenu
        * @param {object} event - The jquery event object
        */
        if (!openedByClass) {
          self.isAnimating = false;
          self.element.trigger('applicationmenuopen');
          $('body').triggerHandler('resize');
        }

        self.menu.removeClass('no-transition');
        $('.page-container').removeClass('no-transition');
      }

      this.triggers.each(function () {
        var trig = $(this);
        if (trig.parents('.header').length > 0 || trig.parents('.masthead').length > 0) {
          var header = trig.parents('.header, .masthead');
          if (header.parents('.page-container').length) {
            return;
          }

          trig.find('.icon.app-header').removeClass('go-back').addClass('close');
          trig.trigger('icon-change');
        }
      });

      // Animate the application menu open.
      // If opened by class, `is-open` is already applied to the app menu at this
      // point in the render cycle, and should not be re-applied.
      if (!openedByClass) {
        this.menu.off(transitionEnd + '.applicationmenu');
        this.menu[0].style.display = '';
        // next line forces a repaint
        // eslint-disable-next-line
        this.menu[0].offsetHeight;
        this.menu.addClass('is-open');
      }

      if (breakpoints.isBelow(this.settings.breakpoint)) {
        this.menu.addClass('show-shadow');
      }

      if (!noFocus || noFocus !== true) {
        this.menu.find('.is-selected > a').focus();
      }

      if (Environment.os.name === 'ios') {
        var container = this.getAdjacentContainerElement();
        container.addClass('ios-click-target');
      }

      if (!openedByClass) {
        this.menu.one(transitionEnd + '.applicationmenu', isOpen);
        this.timeout = setTimeout(isOpen, 300);
      } else {
        isOpen();
      }

      // Events that will close the nav menu
      // On a timer to prevent conflicts with the Trigger button's click events
      setTimeout(function () {
        $(document).on('click.applicationmenu', function (e) {
          if ($(e.target).parents('.application-menu').length < 1 && !self.isLargerThanBreakpoint()) {
            self.closeMenu(true);
          }
        });
      }, 0);
    },


    /**
     * Closes the Application Menu
     * @param {boolean} [userClosed] if true, sets a flag notifying the component
     *  that the user was responsible for closing.
     */
    closeMenu: function closeMenu(userClosed) {
      if (this.isAnimating === true) {
        return;
      }

      var self = this;
      var transitionEnd = $.fn.transitionEndName();

      this.isAnimating = true;

      function close() {
        if (self.timeout !== null) {
          clearTimeout(self.timeout);
          self.timeout = null;
        }

        self.menu.off(transitionEnd + '.applicationmenu');
        self.menu[0].style.display = 'none';
        self.isAnimating = false;

        if (userClosed) {
          self.userOpened = undefined;
          self.userClosed = true;
        }

        /**
        * Fires the menu is closed
        *
        * @event applicationmenuclose
        * @memberof ApplicationMenu
        * @param {object} event - The jquery event object
        */
        self.element.trigger('applicationmenuclose');
        $('body').triggerHandler('resize');
      }

      this.triggers.each(function () {
        var trig = $(this);
        if (trig.parents('.header').length > 0 || trig.parents('.masthead').length > 0) {
          trig.find('.icon.app-header').removeClass('close');
          trig.trigger('icon-change');
        }
      });

      if (Environment.os.name === 'ios') {
        var container = this.getAdjacentContainerElement();
        container.removeClass('ios-click-target');
      }

      this.menu.one(transitionEnd + '.applicationmenu', close);
      this.timeout = setTimeout(close, 300);

      this.menu.removeClass('is-open show-shadow').find('[tabindex]');
      $(document).off('click.applicationmenu');
    },


    /**
     * Detects whether or not the Application Menu has external trigger buttons setup to control it.
     * @returns {boolean} whether or not external triggers have been defined.
     */
    hasTriggers: function hasTriggers() {
      return this.triggers !== undefined && this.triggers instanceof $ && this.triggers.length;
    },


    /**
     * Externally Facing function that can be used to add/remove application nav menu triggers.
     * @param {Array[]} triggers an array of HTMLElements or jQuery-wrapped elements that
     *  will be used as triggers.
     * @param {boolean} [remove] if defined, triggers that are defined will be removed
     *  internally instead of added.
     * @param {boolean} [norebuild] if defined, this control's events won't automatically
     *  be rebound to include the new triggers.
     */
    modifyTriggers: function modifyTriggers(triggers, remove, norebuild) {
      if (!triggers || !triggers.length) {
        return;
      }
      var changed = $();

      $.each(triggers, function (i, obj) {
        changed = changed.add($(obj));
      });

      this.triggers = this.triggers[!remove ? 'add' : 'not'](changed);
      this.handleTriggerEvents();

      if (norebuild && norebuild === true) {
        return;
      }

      this.updated();
    },


    /**
     * @param {array} results list of items that passed the filtering process
     * @param {function} done method to be called when the display of filtered items completes.
     * @returns {void}
     */
    filterResultsCallback: function filterResultsCallback(results, done) {
      if (!results || !results.length) {
        this.accordionAPI.unfilter();
        done();
        return;
      }

      var headers = $(results.map(function (item) {
        return item.element;
      }));
      this.accordionAPI.filter(headers, true);

      this.element.triggerHandler('filtered', [results]);
      done();
    },


    /**
     * handles the Searchfield Input event
     * @param {jQuery.Event} e jQuery `input` event
     */
    handleSearchfieldInputEvent: function handleSearchfieldInputEvent() {
      if (!this.searchfield || !this.searchfield.length) {
        return;
      }

      var val = this.searchfield.val();

      if (!val || val === '') {
        var filteredParentHeaders = this.accordion.find('.has-filtered-children');
        this.accordionAPI.headers.removeClass('filtered has-filtered-children');
        this.accordionAPI.collapse(filteredParentHeaders);
        this.accordionAPI.updated();
        this.element.triggerHandler('filtered', [[]]);
      }
    },


    /**
     * @param {jQuery} anchor the anchor being checked
     * @returns {void}
     */
    handleDismissOnClick: function handleDismissOnClick(anchor) {
      if (!this.settings.dismissOnClickMobile) {
        return;
      }

      this.userOpened = false;
      $(anchor).blur();
      if (this.isLargerThanBreakpoint()) {
        return;
      }

      this.closeMenu();
    },


    /**
     * Unbinds event listeners and removes extraneous markup from the Application Menu.
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.menu.off('animateopencomplete animateclosedcomplete').removeClass('short').removeAttr('style');

      $(window).off('scroll.applicationmenu');
      $('body').off('resize.applicationmenu');
      $(document).off('click.applicationmenu open-applicationmenu close-applicationmenu keydown.applicationmenu');

      this.accordion.off('blur.applicationmenu selected.applicationmenu followlink.applicationmenu');
      if (this.accordionAPI && typeof this.accordionAPI.destroy === 'function') {
        if (this.isFiltered) {
          this.accordionAPI.collapse();
        }
        this.accordionAPI.destroy();
      }

      if (this.searchfield && this.searchfield.length) {
        this.searchfield.off('input.applicationmenu');
        var sfAPI = this.searchfield.data('searchfield');
        if (sfAPI) {
          sfAPI.destroy();
        }
      }

      if (this.hasTriggers()) {
        this.triggers.off('click.applicationmenu');
      }

      return this;
    },


    /**
     * Triggers a UI Resync.
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },


    /**
     * Teardown - Remove added markup and events
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$e);
    },


    /**
     * This component fires the following events.
     * @fires Applicationmenu#events
     * @listens applicationmenuopen  Fires when the menu is opened.
     * @listens applicationmenuclose  Fires as the menu is closed.
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.handleTriggerEvents();

      // Setup notification change events
      this.menu.on('notify.applicationmenu', function (e, anchor, value) {
        self.notify(anchor, value);
      }).on('updated.applicationmenu', function () {
        self.updated();
      });

      this.accordion.on('blur.applicationmenu', function () {
        self.closeMenu();
      }).on('selected.applicationmenu', function (e, header) {
        var a = $(header).children('a');
        self.handleDismissOnClick(a);
      }).on('followlink.applicationmenu', function (e, anchor) {
        self.handleDismissOnClick(anchor);
      });

      $(document).on('open-applicationmenu', function () {
        self.openMenu(undefined, true);
      }).on('close-applicationmenu', function () {
        self.closeMenu();
      });

      $(window).on('scroll.applicationmenu', function () {
        self.adjustHeight();
      });

      $('body').on('resize.applicationmenu', function () {
        self.testWidth();
      });

      if (this.settings.filterable === true && this.searchfield && this.searchfield.length) {
        this.searchfield.on('input.applicationmenu', function (e) {
          self.handleSearchfieldInputEvent(e);
        });
      }

      if (this.settings.openOnLarge && this.isLargerThanBreakpoint()) {
        this.menu.addClass('no-transition');
        $('.page-container').addClass('no-transition');
      }
      this.testWidth();

      // Remove after initial transition
      setTimeout(function () {
        self.menu.removeClass('no-transition');
        $('.page-container').removeClass('no-transition');
      }, 800);

      return this;
    }
  };

  /**
   * jQuery component wrapper for the Application Menu
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.applicationmenu = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$e);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$e, new ApplicationMenu(this, settings));
      }
      return instance;
    });
  };

  // Settings and Options
  var COMPONENT_NAME$f = 'blockgrid';

  /**
   * Component Name - Does this and that.
   * @class Blockgrid
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {array} [settings.dataset=[]] An array of data objects
   * @param {string} [settings.selectable=false] Controls the selection mode this can be:
   * @param {boolean} paging Enable paging mode
   * @param {number} pagesize Number of rows per page
   * @param {array} pagesizes Array of page sizes to show in the page size dropdown.
   * false, 'single' or 'multiple' or 'mixed'
   */
  var BLOCKGRID_DEFAULTS = {
    dataset: [],
    selectable: false, // false, 'single' or 'multiple' or mixed
    paging: false,
    pagesize: 25,
    pagesizes: [10, 25, 50, 75]
  };

  function Blockgrid(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(element, settings, BLOCKGRID_DEFAULTS);
    if (settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.init();
  }

  // Plugin Methods
  Blockgrid.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    init: function init() {
      // Do initialization. Build or Events ect
      this.handlePaging();

      return this.build().handleEvents();
    },


    /**
     * Add any needed markup to the component.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    build: function build() {
      this.renderBlock();
      this.selectedRows = [];
      return this;
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.on('click.' + COMPONENT_NAME$f, '.block', function (e) {
        var activeBlock = $(e.currentTarget);
        var target = $(e.target);
        var isCheckbox = target.is('.checkbox-label') || target.is('.checkbox');

        setTimeout(function () {
          self.selectBlock(activeBlock, isCheckbox);
        }, 0);

        e.stopPropagation();
        e.preventDefault();
      });

      this.element.on('focus.' + COMPONENT_NAME$f, '.checkbox', function (e) {
        var block = $(e.currentTarget).parent();
        block.addClass('has-focus');
      });

      this.element.on('blur.' + COMPONENT_NAME$f, '.checkbox', function (e) {
        var block = $(e.currentTarget).parent();
        block.removeClass('has-focus');
      });

      this.element.on('keypress.' + COMPONENT_NAME$f, '.block', function (e) {
        if (e.which !== 32) {
          return;
        }

        var activeBlock = $(e.target);
        self.selectBlock(activeBlock, false);
      });

      this.element.on('updated.' + COMPONENT_NAME$f, function () {
        self.updated();
      });

      return this;
    },
    handlePaging: function handlePaging() {
      if (!this.settings.paging) {
        return;
      }

      var pagerElem = this.element;
      this.element.addClass('paginated');
      pagerElem.pager({
        componentAPI: this,
        dataset: this.settings.dataset,
        pagesize: this.settings.pagesize,
        pagesizes: this.settings.pagesizes
      });
    },


    /**
     * Run selection over a block item
     * @param {element} activeBlock Dom element to use
     * @param {boolean} isCheckbox True if a checkbox, used for mixed mode.
    */
    selectBlock: function selectBlock(activeBlock, isCheckbox) {
      var allBlocks = this.element.find('.block');
      var allChecks = this.element.find('.checkbox');
      var activeCheckbox = activeBlock.find('.checkbox');
      var isChecked = activeCheckbox.is(':checked');
      var action = '';
      var idx = activeBlock.index();

      if (this.settings.selectable === 'single') {
        this.selectedRows = [];
        allBlocks.removeClass('is-selected').removeAttr('aria-selected');
        allChecks.prop('checked', false);
      }

      if (this.settings.selectable === 'multiple' && isChecked || this.settings.selectable === 'mixed' && isCheckbox && isChecked) {
        activeBlock.removeClass('is-selected').removeAttr('aria-selected');
        activeCheckbox.prop('checked', false);

        for (var i = 0; i < this.selectedRows.length; i++) {
          if (idx === this.selectedRows[i].idx) {
            this.selectedRows.splice(i, 1);
          }
        }

        this.element.triggerHandler('deselected', [{ selectedRows: this.selectedRows, action: 'deselect' }]);
        return;
      }

      if (this.settings.selectable !== false && !(this.settings.selectable === 'mixed' && !isCheckbox)) {
        if (!isChecked) {
          activeBlock.addClass('is-selected').attr('aria-selected', 'true');
          activeCheckbox.prop('checked', true);
        }

        this.selectedRows.push({ idx: idx, data: this.settings.dataset[idx], elem: activeBlock });
        action = isChecked ? 'deselected' : 'selected';
      }

      if (this.settings.selectable === 'mixed' && !isCheckbox) {
        var isActivated = activeBlock.hasClass('is-activated');
        allBlocks.removeClass('is-activated');

        /**
        * Fires when a block is deactivated
        *
        * @event deactivated
        * @memberof Blockgrid
        * @property {object} event - The jquery event object
        * @property {object} ui - The dialog object
        */
        /**
        * Fires when a block is activated
        *
        * @event activated
        * @memberof Blockgrid
        * @property {object} event - The jquery event object
        * @property {object} ui - The dialog object
        */
        if (isActivated) {
          activeBlock.removeClass('is-activated');
          this.element.triggerHandler('deactivated', [{ row: idx, item: this.settings.dataset[idx] }]);
        } else {
          activeBlock.addClass('is-activated');
          this.element.triggerHandler('activated', [{ row: idx, item: this.settings.dataset[idx] }]);
        }
        return;
      }

      /**
      * Fires when a block is selected
      *
      * @event selected
      * @memberof Blockgrid
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */
      /**
      * Fires when a block is unselected
      *
      * @event deselected
      * @memberof Blockgrid
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */
      this.element.triggerHandler(isChecked ? 'deselected' : 'selected', [{ selectedRows: this.selectedRows, action: action }]);
    },


    /**
     * Render an individual block element.
     * @returns {void}
     * @private
     */
    renderBlock: function renderBlock() {
      var blockelements = '';
      var s = this.settings;
      var dslength = s.dataset.length;
      var selectText = Locale ? Locale.translate('Select') : 'Select';

      for (var i = 0; i < dslength; i++) {
        var data = s.dataset[i];
        var tabindex = this.settings.selectable === 'mixed' ? '0' : '-1';

        blockelements += '<div class="block is-selectable" role="listitem" tabindex="0">\n      <input type="checkbox" aria-hidden="true" role="presentation" class="checkbox" id="checkbox' + i + '" tabindex="' + tabindex + '" idx="' + i + '">\n      <label for="checkbox' + i + '" class="checkbox-label"><span class="audible">' + selectText + '</span></label>\n      <img alt="Placeholder Image" src="' + (data.img || data.image) + '" class="image-round">\n      <p> ' + (data.maintxt || data.title) + ' <br> ' + (data.subtxt || data.subtitle) + ' </p></div>';
      }

      this.element.attr('role', 'list').append(blockelements);
    },


    /**
     * Handle updated settings and values.
     * @param  {settings} settings The new settings to use.
     * @returns {void}
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      this.element.empty();
      if (this.element[0].classList.contains('paginated')) {
        this.element.data('pager').renderPages('initial');
      }
      this.build();

      return this;
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$f);
      this.element.off('click.' + COMPONENT_NAME$f);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$f);
    }
  };

  /**
   * jQuery component wrapper for the Accordion
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.blockgrid = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$f);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$f, new Blockgrid(this, settings));
      }
    });
  };

  // The Name of this component.
  var COMPONENT_NAME$g = 'busyindicator';

  /**
   * A Busy Indicator notifies the user that the system is processing a request, and that they must
   * wait for that request to be processed before continuing with the current task.
   * @class BusyIndicator
   * @param {object} element The plugin starting element.
   * @param {object} [settings] The settings to use.
   * @param {string} [settings.blockUI=true] makes the element that Busy Indicator is invoked on unusable while it's displayed.
   * @param {string} [settings.text=null] Custom Text To Show or Will Show Localized Loading....
   * @param {string} [settings.displayDelay=1000] Number in miliseconds to pass before the markup is displayed. If 0, displays immediately.
   * @param {boolean} [settings.timeToComplete=0] fires the 'complete' trigger at a certain timing interval. If 0, goes indefinitely.
   * @param {string} [settings.transparentOverlay=false] If true, allows the "blockUI" setting to display
   * an overlay that prevents interaction, but appears transparent instead of gray.
   * @param {string} [settings.overlayOnly=false] If true, the busy indicator will only be the overlay.
   */
  var BUSYINDICATOR_DEFAULTS = {
    blockUI: true,
    text: null,
    displayDelay: 1000,
    timeToComplete: 0,
    transparentOverlay: false,
    overlayOnly: false
  };

  function BusyIndicator(element, settings) {
    this.settings = utils.mergeSettings(element, settings, BUSYINDICATOR_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  BusyIndicator.prototype = {
    init: function init() {
      this.inlineLabel = this.element.closest('label');
      this.inlineLabelText = this.inlineLabel.find('.label-text');
      this.isInlineLabel = this.element.parent().is('.inline');

      this.setup().handleEvents();
    },


    // Sanitize incoming option values
    setup: function setup() {
      var blockUI = this.element.attr('data-block-ui');
      var delay = this.element.attr('data-display-delay');
      var completionTime = this.element.attr('data-completion-time');

      this.blockUI = blockUI !== undefined ? blockUI : this.settings.blockUI;
      if (!this.settings.overlayOnly) {
        this.loadingText = this.settings.text ? this.settings.text : Locale.translate('Loading');

        // Support updating the label while open
        if (this.label) {
          this.label.text(this.loadingText);
        }
      }

      var isDelayDefined = delay !== undefined && !isNaN(delay) && parseInt(delay, 10) > 20;
      var displayDelay = !isNaN(this.settings.displayDelay) && this.settings.displayDelay >= 20 ? this.settings.displayDelay : 20;

      this.delay = isDelayDefined ? delay : displayDelay;
      this.completionTime = completionTime !== undefined && !isNaN(completionTime) ? parseInt(completionTime, 10) : this.settings.timeToComplete;

      return this;
    },


    /**
    * Builds and starts the indicator
    * @private
    * @returns {void}
    */
    activate: function activate() {
      var self = this;

      if (self.isActive()) {
        return; // safety, don't activate this code if already active
      }

      // If the markup already exists don't do anything but clear
      if (this.container) {
        if (self.closeTimeout) {
          clearTimeout(self.closeTimeout);
        }
        this.label.remove();
        if (!this.settings.overlayOnly) {
          this.label = $('<span>' + this.loadingText + '</span>').appendTo(this.container);

          if (this.element.is('input, .dropdown, .multiselect, .busy-xs, .busy-sm')) {
            this.label.addClass('audible');
          }
        }

        this.container.removeClass('is-hidden').trigger('afterstart');

        return;
      }

      // Build all the markup
      this.container = $('<div class="busy-indicator-container is-hidden"></div>').attr({
        'aria-live': 'polite',
        role: 'status'
      });
      this.loader = $('<div class="busy-indicator active"></div>').appendTo(this.container);

      if (!this.settings.overlayOnly) {
        $('<div class="bar one"></div>' + '<div class="bar two"></div>' + '<div class="bar three"></div>' + '<div class="bar four"></div>' + '<div class="bar five"></div>').appendTo(this.loader);

        this.label = $('<span>' + this.loadingText + '</span>').appendTo(this.container);
      }

      var transparency = '';

      if (this.blockUI) {
        if (this.settings.transparentOverlay) {
          transparency = ' transparent';
        }

        this.originalPositionProp = this.element[0].style.position;
        this.element[0].style.position = 'relative';
        this.overlay = $('<div class="overlay busy is-hidden' + transparency + '"></div>').appendTo(this.element);
        this.container.addClass('blocked-ui');
      }

      if (this.label && this.element.is('.busy-xs, .busy-sm')) {
        this.label.addClass('audible');
      }

      // Append the markup to the page
      // Use special positioning logic for compatibility with certain controls
      if (this.element.is('input, .dropdown, .multiselect')) {
        this.element.addClass('is-loading');
        if (this.blockUI) {
          this.element.addClass('is-blocked');
        }
        if (this.label) {
          this.label.addClass('audible');
        }

        var target = void 0;

        if (this.element.is('input')) {
          target = this.element;
          this.container.insertAfter(this.isInlineLabel ? this.inlineLabel : this.element);
        } else {
          var dd = this.element.data('dropdown');
          target = dd.pseudoElem;
          this.container.appendTo(target.parent());
        }

        if (this.overlay) {
          this.overlay.insertAfter(this.container);
        }

        var rect = target.position();
        var h = target.outerHeight();
        var w = target.outerWidth();
        var elements = this.container.add(this.overlay);
        var setCssStyle = function setCssStyle(el, key, value) {
          el.style[key] = value + 'px';
        };

        for (var i = 0, l = elements.length; i < l; i++) {
          setCssStyle(elements[i], 'left', rect.left);
          setCssStyle(elements[i], 'top', rect.top);
          setCssStyle(elements[i], 'bottom', rect.bottom);
          setCssStyle(elements[i], 'right', rect.right);
          setCssStyle(elements[i], 'height', h);
          setCssStyle(elements[i], 'width', w);
        }
      } else {
        // Normal Operations
        this.container.appendTo(this.element);
      }

      // Fade in shortly after adding the markup to the page
      // (prevents the indicator from abruptly showing)
      setTimeout(function () {
        if (self.container) {
          self.container.removeClass('is-hidden');
        }
        if (self.overlay) {
          self.overlay.removeClass('is-hidden');
        }
      }, self.delay);

      // Lets external code know that we've successully kicked off.
      this.element.trigger('afterstart');

      // Start the JS Animation Loop if IE9
      if (!$.fn.cssPropSupport('animation')) {
        self.isAnimating = true;
        self.animateWithJS();
      }

      // Triggers complete if the "timeToComplete" option is set.
      if (this.completionTime > 0) {
        setTimeout(function () {
          self.element.trigger('complete');
        }, self.completionTime);
      }
    },


    /**
     * Removes the appended markup and hides any trace of the indicator.
     * @param {boolean} fromEvent Designates the close is coming from an event (internal)
     * @returns {void}
     */
    close: function close(fromEvent) {
      var self = this;

      if (!self.isActive()) {
        return; // safety, don't try and close this if not already active
      }

      // If closed from an event, fire the necessary event triggers
      // and removes the 'is-loading' CSS class.
      if (fromEvent) {
        this.element.removeClass('is-loading');
        this.element.removeClass('is-blocked');
      }

      if (this.container) {
        this.container.addClass('is-hidden');
      }

      if (this.overlay) {
        this.overlay.addClass('is-hidden');
      }

      // Give the indicator time to fade out before removing all of its components from view
      self.closeTimeout = setTimeout(function () {
        clearTimeout(self.closeTimeout);
        if (self.container) {
          self.container.remove();
        }

        self.container = undefined;
        self.loader = undefined;
        self.label = undefined;

        if (self.overlay) {
          self.overlay.remove();
          self.element[0].style.position = self.originalPositionProp;
          self.originalPositionProp = undefined;
        }
        self.overlay = undefined;
        self.element.trigger('aftercomplete.busyindicator');
        self.element.off('complete.busyindicator');
      }, 600);
    },


    /**
     * Browsers that don't support CSS-based animation can still show the animating Busy Indicator.
     * @private
     */
    animateWithJS: function animateWithJS() {
      var self = this;
      var bar1 = this.container.find('.bar.one');
      var bar2 = this.container.find('.bar.two');
      var bar3 = this.container.find('.bar.three');
      var bar4 = this.container.find('.bar.four');
      var bar5 = this.container.find('.bar.five');
      var t = 0;
      var interval = null;

      // Animation Loop
      function animate() {
        if (!self.isAnimating) {
          clearInterval(interval);
          return;
        }

        t += 1;

        if (t === 1) {
          bar1.addClass('half');
        }
        if (t === 13) {
          bar1.removeClass('half').addClass('full');
          bar2.addClass('half');
        }
        if (t === 26) {
          bar1.removeClass('full').addClass('half');
          bar2.removeClass('half').addClass('full');
          bar3.addClass('half');
        }
        if (t === 39) {
          bar1.removeClass('half');
          bar2.removeClass('full').addClass('half');
          bar3.removeClass('half').addClass('full');
          bar4.addClass('half');
        }
        if (t === 51) {
          bar2.removeClass('half');
          bar3.removeClass('full').addClass('half');
          bar4.removeClass('half').addClass('full');
          bar5.addClass('half');
        }
        if (t === 64) {
          bar3.removeClass('half');
          bar4.removeClass('full').addClass('half');
          bar5.removeClass('half').addClass('full');
        }
        if (t === 77) {
          bar4.removeClass('half');
          bar5.removeClass('full').addClass('half');
        }
        if (t === 90) {
          bar5.removeClass('half');
        }

        if (t === 103) {
          t = 0;
        }
      }

      setInterval(animate, 10);
    },


    /**
     * Update the component and apply current settings.
     * @param {object} settings the settings to update to.
     * @returns {this} component instance.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      return this.setup();
    },


    /**
     * Returns if the indicator is active or not.
     * @returns {boolean} If the busy indicator is active.
     */
    isActive: function isActive() {
      if (this.container) {
        return this.container.children('.busy-indicator').is('.active');
      }
      return false;
    },


    /**
     * Teardown and remove any added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.close(true);
      this.element.off('start.busyindicator complete.busyindicator afterstart.busyindicator aftercomplete.busyindicator updated.busyindicator');
      $.removeData(this.element[0], COMPONENT_NAME$g);
    },
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;

      /**
      *  Fires when the indicator starts / shows.
      *
      * @event start
      * @memberof BusyIndicator
      * @param {object} event - The jquery event object.
      */
      self.element.on('start.busyindicator', function (e) {
        e.stopPropagation();
        _this.activate();
      }).on('afterstart.busyindicator', function () {
        /**
         * Fires when the indicator is "started"
         *
         * @event complete
         * @memberof BusyIndicator
         * @param {object} event - The jquery event object.
         * @param {object} ui - The dialog object
         */
        _this.element.on('complete.busyindicator', function (e) {
          e.stopPropagation();
          _this.close(true);
        });
      })
      /**
      * Sync the UI/Settings. Fx chnaging the text in the DOM.
      * @event updated
      * @memberof BusyIndicator
      * @param {object} event - The jquery event object.
      */
      .on('updated.busyindicator', function () {
        _this.close(true);
        _this.updated();
      });

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for the BusyIndicator
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */
  $.fn.busyindicator = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$g);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$g, new BusyIndicator(this, settings));
      }
    });
  };

  var charts = {};

  // Reference to the tooltip
  charts.tooltip = {};
  charts.isIE = Environment.browser.name === 'ie';
  charts.isIEEdge = Environment.browser.name === 'edge';

  /**
   * Get the current height and widthe of the tooltip.
   * @private
   * @param  {string} content The tooltip content.
   * @returns {object} Object with the height and width.
   */
  charts.tooltipSize = function tooltipSize(content) {
    DOM.html(this.tooltip.find('.tooltip-content'), content, '*');
    return { height: this.tooltip.outerHeight(), width: this.tooltip.outerWidth() };
  };

  /**
   * Format the value based on settings.
   * @private
   * @param  {object} data The data object.
   * @param  {object} settings The sttings to use
   * @returns {string} the formatted string.
   */
  charts.formatToSettings = function formatToSettings(data, settings) {
    var d = data.data ? data.data : data;

    if (settings.show === 'value') {
      return settings.formatter ? d3.format(settings.formatter)(d.value) : d.value;
    }

    if (settings.show === 'label') {
      return d.name;
    }

    if (settings.show === 'label (percent)') {
      return d.name + ' (' + (isNaN(d.percentRound) ? 0 : d.percentRound) + '%)';
    }

    if (settings.show === 'label (value)') {
      return d.name + ' (' + (settings.formatter ? d3.format(settings.formatter)(d.value) : d.value) + ')';
    }

    if (settings.show === 'percent') {
      return (isNaN(d.percentRound) ? 0 : d.percentRound) + '%';
    }

    if (typeof settings.show === 'function') {
      return settings.show(d);
    }

    return d.value;
  };

  /**
  * Add Toolbar to the page.
  * @private
  * @param {string} extraClass class to add (needed for pie)
  * @returns {void}
  */
  charts.appendTooltip = function appendTooltip(extraClass) {
    var _this = this;

    this.tooltip = $('#svg-tooltip');
    if (this.tooltip.length === 0) {
      this.tooltip = $('<div id="svg-tooltip" class="tooltip ' + extraClass + ' right is-hidden">\n      <div class="arrow"></div>\n        <div class="tooltip-content">\n          <p><b>32</b> Element</p>\n        </div>\n      </div>').appendTo('body');

      if (this.isTouch) {
        this.tooltip[0].style.pointerEvents = 'auto';
        this.tooltip.on('touchend.svgtooltip', function () {
          _this.hideTooltip();
        });
      }
    }
  };

  /**
   * Hide the visible tooltip.
   * @private
   * @returns {void}
   */
  charts.hideTooltip = function hideTooltip() {
    var _this2 = this;

    d3.select('#svg-tooltip').classed('is-hidden', true).style('left', '-999px');

    // Remove scroll events
    $('body, .scrollable').off('scroll.chart-tooltip', function () {
      _this2.hideTooltip();
    });
  };

  /**
   * Remove the tooltip from the DOM
   * @private
   * @returns {void}
   */
  charts.removeTooltip = function removeTooltip() {
    if (this.tooltip && this.tooltip.remove) {
      this.tooltip.remove();
    }
  };

  /**
   * The color sequences to use across charts
   * @private
   * @type {array}
   */
  charts.colorRange = ['#2578A9', '#8ED1C6', '#C7B4DB', '#5C5C5C', '#F2BC41', '#76B051', '#B94E4E', '#8DC9E6', '#DB7726', '#317C73', '#EB9D9D', '#737373', '#89BF65', '#C7B4DB', '#54A1D3', '#6e5282', '#AFDC91', '#69ADA3', '#EE9A36', '#D8D8D8'];

  charts.colorNameRange = ['azure07', 'turquoise03', 'amethyst03', 'graphite06', 'amber05', 'emerald06', 'ruby06', 'azure03', 'amber09', 'turquoise08', 'ruby02', 'graphite05', 'emerald05', 'amethyst03', 'azure05', 'amethyst08', 'emerald03', 'turquoise06', 'amber07', 'graphite02'];

  /**
   * The colors as an array for placement
   * @private
   * @type {array}
   */
  charts.colors = typeof d3 !== 'undefined' ? d3.scaleOrdinal().range(charts.colorRange) : [];
  charts.colorNames = typeof d3 !== 'undefined' ? d3.scaleOrdinal().range(charts.colorNameRange) : [];

  /**
   * Calculate and return the correct color to use. Fx
   * error, alert, alertYellow, good, neutral or hex.
   * @private
   * @param  {number} i The line/bar object index.
   * @param  {string} chartType The type of chart.
   * @param  {object} data The data for this element.
   * @returns {string} The hex code
   */
  charts.chartColor = function chartColor(i, chartType, data) {
    var specifiedColor = data && data.color ? data.color : null;

    // Handle passed in colors.
    if (specifiedColor) {
      if (specifiedColor === 'error') {
        return '#e84f4f';
      }
      if (specifiedColor === 'alert') {
        return '#ff9426';
      }
      if (specifiedColor === 'alertYellow') {
        return '#ffd726';
      }
      if (specifiedColor === 'good') {
        return '#80ce4d';
      }
      if (specifiedColor === 'neutral') {
        return '#bdbdbd';
      }
      if (specifiedColor && specifiedColor.indexOf('#') === 0) {
        return data.color;
      }
    }

    // Some configuration by specific chart types
    if (/^(pie|donut)$/.test(chartType)) {
      return this.colorRange[i];
    }
    if (/^(bar-single|column-single)$/.test(chartType)) {
      return '#1D5F8A';
    }
    if (/^(bar|bar-stacked|bar-grouped|bar-normalized|line|scatterplot|column-stacked|column-grouped|column-positive-negative)$/.test(chartType)) {
      return this.colors(i);
    }

    return '';
  };

  charts.chartColorName = function chartColor(i, chartType, data) {
    var specifiedColor = data && data.color ? data.color : null;

    // Handle passed in colors.
    if (specifiedColor) {
      if (specifiedColor === 'error') {
        return 'alert01';
      }
      if (specifiedColor === 'alert') {
        return 'alert02';
      }
      if (specifiedColor === 'alertYellow') {
        return 'alert03';
      }
      if (specifiedColor === 'good') {
        return 'alert04';
      }
      if (specifiedColor === 'neutral') {
        return 'graphite03';
      }
      if (specifiedColor && specifiedColor.indexOf('#') === 0) {
        return data.color;
      }
    }

    // Some configuration by specific chart types
    if (/^(pie|donut)$/.test(chartType)) {
      return this.colorNameRange[i];
    }
    if (/^(bar-single|column-single)$/.test(chartType)) {
      return 'azure08';
    }
    if (/^(bar|bar-stacked|bar-grouped|bar-normalized|line|scatterplot|column-stacked|column-grouped|column-positive-negative)$/.test(chartType)) {
      return this.colorNames(i);
    }

    return '';
  };

  /**
   * Show Tooltip
   * @private
   * @param  {number} x The x position.
   * @param  {number} y The y position.
   * @param  {string} content The tooltip contents.
   * @param  {string} arrow The arrow direction.
   */
  charts.showTooltip = function (x, y, content, arrow) {
    var _this3 = this;

    // Simple Collision of left side
    if (x < 0) {
      x = 2;
    }

    this.tooltip[0].style.left = x + 'px';
    this.tooltip[0].style.top = y + 'px';
    DOM.html(this.tooltip.find('.tooltip-content'), content, '*');

    this.tooltip.removeClass('bottom top left right').addClass(arrow);
    this.tooltip.removeClass('is-hidden');

    // Hide the tooltip when the page scrolls.
    $('body').off('scroll.chart-tooltip').on('scroll.chart-tooltip', function () {
      _this3.hideTooltip();
    });

    $('.scrollable').off('scroll.chart-tooltip').on('scroll.chart-tooltip', function () {
      _this3.hideTooltip();
    });
  };

  /**
   * Add the legend to the Chart Container.
   * @private
   * @param  {array} series The groups series object.
   * @param  {string} chartType The type of chart.
   * @param  {object} settings The chart setting
   * @param  {object} container The dom container.
   * @returns {void}
   */
  charts.addLegend = function (series, chartType, settings, container) {
    var i = void 0;
    if (series.length === 0) {
      return;
    }

    var isTwoColumn = series[0].display && series[0].display === 'twocolumn';
    var legend = isTwoColumn ? $('<div class="chart-legend ' + (series[0].placement ? 'is-' + series[0].placement : 'is-bottom') + '"></div>') : $('<div class="chart-legend"></div>');

    if ((chartType === 'pie' || chartType === 'donut') && settings.showMobile) {
      legend = $('<div class="chart-legend"><div class="container"></div></div>');
    }

    // Legend width
    var width = 0;
    var currentWidth = void 0;

    for (i = 0; i < series.length; i++) {
      currentWidth = series[i].name.length * 6;
      width = series[i].name && currentWidth > width ? currentWidth : width;
    }

    width += 55;
    var widthPercent = width / $(container).width() * 100;

    for (i = 0; i < series.length; i++) {
      if (!series[i].name) {
        continue; // eslint-disable-line
      }

      var extraClass = '';
      if (isTwoColumn || series[i].display && series[i].display === 'block') {
        extraClass += ' lg';
      }
      if (settings.type === 'column-positive-negative' && series[i].option) {
        extraClass += ' ' + series[i].option;
      }

      var seriesLine = '<span class="chart-legend-item' + extraClass + '" tabindex="0"></span>';
      var hexColor = charts.chartColor(i, chartType || (series.length === 1 ? 'bar-single' : 'bar'), series[i]);
      var colorName = charts.chartColorName(i, chartType || (series.length === 1 ? 'bar-single' : 'bar'), series[i]);

      var color = '';
      if (colorName.substr(0, 1) === '#') {
        color = $('<span class="chart-legend-color"></span>');
        if (!series[i].pattern) {
          color.css('background-color', hexColor);
        }
      } else {
        color = $('<span class="chart-legend-color ' + (series[i].pattern ? '' : colorName) + '"></span>');
      }

      if (chartType === 'scatterplot') {
        color = $('<span class="chart-legend-color"></span>');
      }
      var textBlock = $('<span class="chart-legend-item-text">' + xssUtils.stripTags(series[i].name) + '</span>');

      if (series[i].pattern) {
        color.append('<svg width="12" height="12"><rect height="12" width="12" mask="url(#' + series[i].pattern + ')"/></svg>');
        color.find('rect').css('fill', hexColor);
      }

      if (series[i].percent) {
        var pct = $('<span class="chart-legend-percent"></span>').text(series[i].percent);
        textBlock.append(pct);
      }

      if (series[i].display && series[i].display === 'block') {
        seriesLine = '<span class="chart-legend-item' + extraClass + '" tabindex="0"></span>';
      }

      if (isTwoColumn) {
        if (widthPercent > 45 && settings.legendPlacement !== 'right') {
          seriesLine = '<span class="chart-legend-item' + extraClass + '" tabindex="0"></span>';
        } else {
          seriesLine = '<span class="chart-legend-item' + extraClass + ' is-two-column" tabindex="0" ></span>';
        }
      }
      seriesLine = $(seriesLine);
      seriesLine.append(color, textBlock);

      if ((chartType === 'pie' || chartType === 'donut') && settings.showMobile) {
        legend.find('.container').append(seriesLine);
      } else {
        legend.append(seriesLine);
      }

      if (series[i].display && series[i].display === 'block' || isTwoColumn && widthPercent > 45 && settings.legendPlacement !== 'right') {
        seriesLine.css({
          float: 'none',
          display: 'block',
          margin: '0 auto',
          width: width + 'px'
        });
      }

      // Add shapes
      if (chartType === 'scatterplot') {
        self.svg = d3.select(color[0]).append('svg').attr('width', '24').attr('height', '24').append('path').attr('class', 'symbol').attr('transform', 'translate(10, 10)').attr('d', d3.symbol().size('80').type(function () {
          return d3.symbols[i];
        })) //eslint-disable-line
        .style('fill', hexColor);
      }

      // Change text of legend depends of the width
      if (innerWidth <= 480 && series[i].data && series[i].data.legendAbbrName) {
        textBlock.replaceWith('<span class="chart-legend-item-text">' + series[i].data.legendAbbrName + '</span>');
      }
      if (innerWidth >= 481 && innerWidth <= 768 && series[i].data && series[i].data.legendShortName) {
        textBlock.replaceWith('<span class="chart-legend-item-text">' + series[i].data.legendShortName + '</span>');
      }
    }

    if (legend instanceof $) {
      legend.on('click.chart', '.chart-legend-item', function () {
        charts.handleElementClick(this, series, settings);
      }).on('keypress.chart', '.chart-legend-item', function (e) {
        if (e.which === 13 || e.which === 32) {
          charts.handleElementClick(this, series, settings);
        }
      });

      $(container).append(legend);
    }
  };

  /**
   * Helper Function to Select from legend click
   * @private
   * @param {object} line The element that was clicked.
   * @param {array} series The data series.
   * @param {object} settings [description]
   */
  charts.handleElementClick = function (line, series, settings) {
    var idx = $(line).index();
    var elem = series[idx];
    var selector = void 0;

    if (settings.type === 'radar') {
      selector = d3.select(settings.svg.selectAll('.chart-radar-area').nodes()[idx]);
    }

    if (settings.type === 'pie' || settings.type === 'donut') {
      selector = d3.select(settings.svg.selectAll('.slice').nodes()[idx]);
    } else if (settings.type === 'column-positive-negative') {
      if (!elem.option || elem.option && elem.option === 'target') {
        selector = settings.svg.select('.target-bar');
      } else {
        selector = settings.svg.select('.bar.' + elem.option);
      }
    } else if (['column', 'bar', 'bar-stacked', 'bar-grouped', 'bar-normalized', 'column-grouped', 'column-stacked', 'column-positive-negative'].indexOf(settings.type) !== -1) {
      // Grouped or singlular
      if (settings.isGrouped || settings.isSingle) {
        selector = settings.svg.select('.series-' + idx);
      } else if (settings.isStacked && !settings.isSingle) {
        // Stacked
        var thisGroup = d3.select(settings.svg.selectAll(settings.type === 'bar' || settings.type === 'bar-stacked' || settings.type === 'bar-normalized' ? '.series-group' : '.g').nodes()[idx]); // eslint-disable-line
        selector = thisGroup.select('.bar');
      }
    }

    if (['radar', 'pie', 'donut', 'column', 'bar', 'bar-stacked', 'bar-grouped', 'bar-normalized', 'column-grouped', 'column-stacked', 'column-positive-negative'].indexOf(settings.type) !== -1) {
      charts.clickedLegend = true;
      selector.on('click').call(selector.node(), selector.datum(), idx, true);
    }

    if (elem.selectionObj) {
      charts.selectElement(d3.select(elem.selectionObj.nodes()[idx]), elem.selectionInverse, elem.data); // eslint-disable-line
    }
  };

  // The selected array for this instance.
  charts.selected = [];

  /**
   * Select the element and fire the event, make the inverse selector opace.
   * @private
   * @param  {object} element The DOM element
   * @param  {object} inverse The opposite selection.
   * @param  {array} data  The data object
   * @param  {object} container  The DOM object
   */
  charts.selectElement = function (element, inverse, data, container) {
    var isSelected = element.node() && element.classed('is-selected');
    var triggerData = [{ elem: element.nodes(), data: !isSelected ? data : {} }];

    inverse.classed('is-selected', false).classed('is-not-selected', !isSelected);

    element.classed('is-not-selected', false).classed('is-selected', !isSelected);

    charts.selected = $.isEmptyObject(triggerData[0].data) ? [] : triggerData;

    // Fire Events
    $(container).triggerHandler('selected', [triggerData]);
  };

  /**
   * Style bars as selected or unselected
   * TODO: Refactor into individual components;
   * @private
   * @param  {object} o The object to handle.
   */
  charts.setSelectedElement = function (o) {
    var dataset = o.dataset;
    var isPositiveNegative = o.type === 'column-positive-negative';
    var isBar = /^(bar|bar-stacked|bar-grouped|bar-normalized)$/.test(o.type);
    var isTypePie = o.type === 'pie' || o.type === 'donut';
    var isTypeColumn = /^(column|column-grouped|column-stacked|column-positive-negative)$/.test(o.type);

    var svg = o.svg;
    var isSingle = o.isSingle;
    var isGrouped = o.isGrouped;
    var isStacked = o.isStacked;

    var taskSelected = o.task === 'selected';
    var selector = d3.select(o.selector);
    var isPositive = selector.classed('positive');
    var ticksX = o.svg.selectAll('.axis.x .tick');
    var ticksY = o.svg.selectAll('.axis.y .tick');
    var pnPositiveText = o.svg.selectAll('.bartext.positive, .target-bartext.positive');
    var pnNegativeText = o.svg.selectAll('.bartext.negative, .target-bartext.negative');
    var pnTargetText = o.svg.selectAll('.target-bartext.positive, .target-bartext.negative');
    var thisGroup = d3.select(o.selector.parentNode);
    var thisGroupId = parseInt(thisGroup.node() ? thisGroup.attr('data-group-id') : 0, 10);
    var triggerData = [];
    var selectedBars = [];
    var thisData = void 0;

    if (isStacked || isTypePie) {
      dataset = dataset || null;
    } else {
      dataset = dataset && dataset[thisGroupId] ? dataset[thisGroupId].data || dataset[thisGroupId] : null;
    }

    ticksX.style('font-weight', 'normal');
    ticksY.style('font-weight', 'normal');
    pnPositiveText.style('font-weight', 'normal');
    pnNegativeText.style('font-weight', 'normal');
    svg.selectAll('.is-selected').classed('is-selected', false);

    if (isTypePie) {
      svg.selectAll('.is-not-selected').classed('is-not-selected', false);
    }

    // Task make selected
    if (taskSelected) {
      svg.selectAll('.bar, .target-bar').style('opacity', 0.6);

      // By legends only
      if (charts.clickedLegend && !isTypePie) {
        if (isPositiveNegative) {
          if (o.isTargetBar) {
            o.svg.selectAll('.target-bar').classed('is-selected', true).style('opacity', 1);

            pnTargetText.style('font-weight', 'bolder');
          } else {
            o.svg.selectAll(isPositive ? '.bar.positive, .target-bar.positive' : '.bar.negative, .target-bar.negative').classed('is-selected', true).style('opacity', 1);

            (isPositive ? pnPositiveText : pnNegativeText).style('font-weight', 'bolder');
          }

          svg.selectAll('.bar').each(function (d, i) {
            var bar = d3.select(this);
            if (bar.classed('is-selected')) {
              selectedBars.push({ elem: bar.node(), data: dataset ? dataset[i] : d });
            }
          });
          triggerData = selectedBars;
        } else if (isTypeColumn || isBar) {
          // Grouped and stacked only -NOT singular-

          if (isGrouped || isSingle) {
            o.svg.selectAll('.series-' + o.i).classed('is-selected', true).style('opacity', 1); //eslint-disable-line
          } else {
            thisGroup.classed('is-selected', true).selectAll('.bar').classed('is-selected', true).style('opacity', 1);
          }

          svg.selectAll('.bar.is-selected').each(function (d, i) {
            var bar = d3.select(this);

            thisData = o.dataset;
            if (!thisData) {
              thisData = d;
            }

            if (isBar) {
              if (thisData[0][o.i]) {
                thisData = thisData[0][o.i];
              }

              if (thisData[o.i] && thisData[o.i][i]) {
                thisData = thisData[o.i][i];
              }

              if (thisData[i] && thisData[i][o.i]) {
                thisData = thisData[i][o.i];
              }
            } else {
              if (thisData[0].data[o.i]) {
                thisData = thisData[0].data[o.i];
              }

              if (thisData[o.i] && thisData[o.i].data[i]) {
                thisData = thisData[o.i].data[i];
              }

              if (thisData[i] && thisData[i].data[o.i]) {
                thisData = thisData[i].data[o.i];
              }
            }

            selectedBars.push({ elem: bar.node(), data: thisData });
          });
          triggerData = selectedBars;
        }
      } else if (isSingle && isStacked && isTypeColumn) {
        // Single and stacked only -NOT grouped-
        thisData = dataset[0] && dataset[0].data ? dataset[0].data : o.d;
        selector.classed('is-selected', true).style('opacity', 1);
        triggerData.push({ elem: selector.nodes(), data: thisData[o.i] });
      } else if ((isSingle || isGrouped) && !isStacked && (isTypeColumn || isBar)) {
        // Single or groups only -NOT stacked-
        svg.selectAll((isTypeColumn ? '.axis.x' : '.axis.y') + ' .tick:nth-child(' + ((isGrouped ? thisGroupId : o.i) + 2) + ')').style('font-weight', 'bolder');

        selector.classed('is-selected', true).style('opacity', 1);

        if (isPositiveNegative) {
          var thisIndex = o.isTargetBar ? o.i : o.i - o.dataset[0].data.length;
          svg.select('.target-bar.series-' + thisIndex).classed('is-selected', true).style('opacity', 1);
          svg.select('.bar.series-' + thisIndex).classed('is-selected', true).style('opacity', 1);

          d3.select(svg.selectAll('.bartext').nodes()[thisIndex]).style('font-weight', 'bolder');
          d3.select(svg.selectAll('.target-bartext').nodes()[thisIndex]).style('font-weight', 'bolder');
        }

        if (isGrouped || isPositiveNegative || isTypeColumn) {
          if (!isPositiveNegative && !isTypeColumn || isTypeColumn && isGrouped) {
            thisGroup.classed('is-selected', true).selectAll('.bar').classed('is-selected', true).style('opacity', 1);
          }

          thisGroup.selectAll('.bar').each(function (d, i) {
            var bar = d3.select(this);
            if (bar.classed('is-selected')) {
              selectedBars.push({ elem: bar.node(), data: dataset ? dataset[i] : d });
            }
          });
          if (isGrouped) {
            triggerData.push({
              groupIndex: thisGroupId,
              groupElem: thisGroup.nodes()[0], //eslint-disable-line
              groupItems: selectedBars
            });
          } else {
            triggerData = selectedBars;
          }
        }
      } else if (isTypeColumn || isBar) {
        // Stacked Only
        svg.selectAll((isTypeColumn ? '.axis.x' : '.axis.y') + ' .tick:nth-child(' + (o.i + 2) + ')').style('font-weight', 'bolder');

        svg.selectAll('.bar:nth-child(' + (o.i + 1) + ')').classed('is-selected', true).style('opacity', 1);

        svg.selectAll('.bar.is-selected').each(function (d, i) {
          var bar = d3.select(this);
          var data = d;
          if (dataset) {
            data = isBar && isStacked ? dataset[i][o.i] : dataset[i].data[o.i];
          }
          selectedBars.push({ elem: bar.node(), data: data });
        });
        triggerData = selectedBars;
      } else if (isTypePie) {
        // Pie
        // Unselect selected ones
        svg.selectAll('.slice').classed('is-selected', false).classed('is-not-selected', true).attr('transform', '');

        var thisArcData = dataset && dataset[0] && dataset[0].data ? //eslint-disable-line
        dataset[0].data[o.i] : o.d ? o.d.data : o.d; //eslint-disable-line

        selector.classed('is-selected', true).classed('is-not-selected', false).attr('transform', 'scale(1.025, 1.025)');
        triggerData.push({ elem: selector.nodes(), data: thisArcData, index: o.i });
      }
    } else {
      // Task make unselected
      svg.selectAll('.bar, .target-bar').style('opacity', 1);
      pnPositiveText.style('font-weight', 'bolder');
      pnNegativeText.style('font-weight', 'bolder');

      if (isTypePie) {
        selector.classed('is-selected', false).style('stroke', '#fff').style('stroke-width', '1px').attr('transform', '');
      }
    }

    if (charts.clickedLegend) {
      charts.clickedLegend = false;
    }

    charts.selected = triggerData;

    if (o.isTrigger) {
      $(o.container).triggerHandler(taskSelected ? 'selected' : 'unselected', [triggerData]);
    }
  };

  /**
   * Set the select element based on provided options and fire the events.
   * @private
   * @param {object} o An object with various
   * @param {boolean} isToggle If the select is a toggle of the state
   * @param {object} internals An object passing in chart internals
  */
  charts.setSelected = function (o, isToggle, internals) {
    if (!o) {
      return;
    }

    var selected = 0;
    var equals = utils.equals;
    var legendsNode = internals.isPie ? internals.svg.node().nextSibling : internals.svg.node().parentNode.nextSibling;
    var legends = d3.select(legendsNode);
    var isLegends = legends.node() && legends.classed('chart-legend');
    var barIndex = void 0;
    var selector = void 0;
    var isStackedGroup = void 0;
    var xGroup = void 0;

    var setSelectedBar = function setSelectedBar(g) {
      var isGroup = !!g;
      g = isGroup ? d3.select(g) : internals.svg;
      g.selectAll('.bar').each(function (d, i) {
        if (!d) {
          return;
        }
        if (selected < 1) {
          if (typeof o.fieldName !== 'undefined' && typeof o.fieldValue !== 'undefined' && o.fieldValue === d[o.fieldName] || typeof o.index !== 'undefined' && o.index === i || o.data && equals(o.data, internals.chartData[d.index].data[i]) || o.elem && $(this).is(o.elem)) {
            selected++;
            selector = d3.select(this);
            barIndex = i;
            if (isGroup && !internals.isStacked) {
              isStackedGroup = true;
            }
          }
        }
      });
    };

    var setSelectedGroup = function setSelectedGroup() {
      var groups = internals.svg.selectAll('.series-group');

      if (groups.nodes().length) {
        groups.each(function () {
          setSelectedBar(this);
        });
      }
    };

    if (internals.isGrouped || internals.isStacked && !internals.isSingle) {
      internals.chartData.forEach(function (d, i) {
        //eslint-disable-line
        if (selected < 1) {
          xGroup = $(internals.svg.select('[data-group-id="' + i + '"]').node()); //eslint-disable-line
          if (typeof o.groupName !== 'undefined' && typeof o.groupValue !== 'undefined' && o.groupValue === d[o.groupName] || typeof o.groupIndex !== 'undefined' && o.groupIndex === i || o.data && equals(o.data, d) || o.elem && xGroup.is(o.elem)) {
            if (typeof o.fieldName === 'undefined' && typeof o.fieldValue === 'undefined' && typeof o.index === 'undefined') {
              selected++;
              selector = internals.svg.select('[data-group-id="' + i + '"]').select('.bar'); //eslint-disable-line
              barIndex = i;

              if (internals.isStacked && !internals.isGrouped) {
                isStackedGroup = true;
              }
            }
          }
        }
      });
      if (selected < 1) {
        setSelectedGroup();
      }
    } else {
      setSelectedBar();
    }

    if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
      if (isStackedGroup) {
        if (isLegends) {
          $(legends.selectAll('.chart-legend-item').nodes()[barIndex]).trigger('click.chart');
        }
      } else {
        selector.on('click').call(selector.node(), selector.datum(), barIndex);
      }
    }
  };

  /**
   * Check if the labels collide.
   * @private
   * @param {object} svg The svg dom element.
   * @returns {boolean} True if the labels collide.
  */
  charts.labelsColide = function (svg) {
    var ticks = svg.selectAll('.x text');
    var collides = false;

    ticks.each(function (d1, i) {
      var rect1 = this.getBoundingClientRect();
      var rect2 = void 0;

      ticks.each(function (d2, j) {
        if (i !== j) {
          rect2 = this.getBoundingClientRect();

          var overlaps = !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom);

          if (overlaps) {
            collides = true;
          }
        }
      });
    });

    return collides;
  };

  /**
   * Apply a different length label
   * @private
   * @param  {object}  svg  The svg element.
   * @param  {array}  dataArray The data.
   * @param  {object}  elem The dom element
   * @param  {object}  selector The d3 selection
   * @param  {boolean} isNoEclipse True if its an eclipse.
   */
  charts.applyAltLabels = function (svg, dataArray, elem, selector, isNoEclipse) {
    var ticks = selector ? svg.selectAll(selector) : svg.selectAll('.x text');

    ticks.each(function (d1, i) {
      var text = dataArray[i] ? dataArray[i][elem] : '';

      text = text || (isNoEclipse ? d3.select(this).text().substring(0, 1) : d3.select(this).text().substring(0, 6) + '...');

      d3.select(this).text(text);
    });
  };

  /**
   * Trigger the right click event.
   * @private
   * @param  {object} container  The svg container.
   * @param  {object} elem The element that was right clicked.
   * @param  {object} d The data object
   */
  charts.triggerContextMenu = function (container, elem, d) {
    d3.event.preventDefault();
    d3.event.stopPropagation();
    d3.event.stopImmediatePropagation();

    var e = $.Event('contextmenu');
    e.target = elem;
    e.pageX = d3.event.pageX;
    e.pageY = d3.event.pageY;
    $(container).trigger(e, [elem, d]);
  };

  /**
   * Wraps SVG text http://bl.ocks.org/mbostock/7555321
   * @private
   * @param {object} node  The svg element.
   * @param {number}  width The width at which to wrap
   * @param {object} labelFactor The dom element
   */
  charts.wrap = function (node, width, labelFactor) {
    if (!labelFactor) {
      labelFactor = 1.27;
    }

    if (!width) {
      labelFactor = 60;
    }

    node.each(function () {
      var text = d3.select(this);
      var words = text.text().split(/\s+/).reverse();
      var word = '';
      var line = [];
      var lineNumber = 0;

      if (words.length <= 1) {
        return;
      }

      var lineHeight = labelFactor; // ems
      var y = text.attr('y');
      var x = text.attr('x');
      var dy = parseFloat(text.attr('dy'));
      var tspan = text.text(null).append('tspan').attr('x', x).attr('y', y).attr('dy', dy + 'em');

      while (word = words.pop()) {
        //eslint-disable-line
        line.push(word);
        tspan.text(line.join(' '));

        if (tspan.node().getComputedTextLength() > width) {
          line.pop();
          tspan.text(line.join(' '));
          line = [word];
          tspan = text.append('tspan').attr('x', x).attr('y', y).attr('dy', ++lineNumber * lineHeight + dy + 'em').text(word);
        }
      }
    });
  };

  /* eslint-disable no-loop-func */

  // Settings and Options
  var COMPONENT_NAME$h = 'bullet';

  /**
   * A bullet graph is a variation of a bar graph developed by Stephen Few.
   * Seemingly inspired by the traditional thermometer charts and progress bars found in many
   * dashboards, the bullet graph serves as a replacement for dashboard gauges and meters.
   * @class Bullet
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {array} [settings.dataset.data] The data to use in the chart.
   * @param {array} [settings.dataset.data.tooltip] Tooltip contents for each point.
   * @param {boolean|string} [settings.animate=true] true|false - will do or not do the animation, 'initial' will do only first time the animation.
   * @param {boolean} [settings.redrawOnResize=true] If true, the component will not resize when resizing the page.
   */
  var BULLET_DEFAULTS = {
    dataset: [],
    animate: true,
    redrawOnResize: true
  };

  function Bullet(element, settings) {
    this.settings = utils.mergeSettings(element, settings, BULLET_DEFAULTS);
    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Bullet.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The bullet chart prototype for chaining.
     */
    init: function init() {
      this.width = 0;

      // Do initialization. Build or Events ect
      this.build().handleEvents();

      // Handle initial option
      if (this.settings.animate === 'initial') {
        this.settings.animate = false;
      }

      return this;
    },


    /**
     * Build the Bullet Chart.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    build: function build() {
      var _this = this;

      var chartData = this.settings.dataset[0];
      this.element.addClass('bullet-chart');

      var tooltipInterval = 0;
      var tooltipDataCache = [];
      var tooltipData = chartData.data[0] ? chartData.data[0].tooltip : [];

      // Append the SVG into its parent area.
      var noMarkers = false;
      var parent = this.element.parent();
      var margin = { top: 30, right: 35, bottom: 35, left: 40 };
      var width = parent.width() - margin.left - margin.right;
      var height = parent.height() - margin.top - margin.bottom - 30; // 30 for legend

      height = height < 0 ? 50 : height; // default minimum height

      var svg = d3.select(this.element[0]).append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      function bulletWidth(x) {
        var x0 = x(0);
        return function (d) {
          return Math.abs(x(d) - x0);
        };
      }

      var _loop = function _loop(i) {
        var duration = _this.settings.animate ? 600 : 0;
        var barHeight = 20;
        var self = _this;
        var rowData = chartData.data[i];
        var ranges = rowData.ranges.slice().sort(d3.descending);
        var markers = rowData.markers ? rowData.markers.slice().sort(d3.descending) : [];
        var measures = rowData.measures ? rowData.measures.slice().sort(d3.descending) : [];
        var rangesAsc = rowData.ranges.slice().sort(d3.ascending);
        var markersAsc = rowData.markers ? rowData.markers.slice().sort(d3.ascending) : [];
        var measuresAsc = rowData.measures ? rowData.measures.slice().sort(d3.ascending) : [];

        if (markers.length === 0) {
          markers = measures;
          markersAsc = measuresAsc;
          noMarkers = true;
        }

        var g = svg.append('g').attr('class', 'bullet').attr('transform', 'translate(0, ' + i * (barHeight * 3.5) + ')');

        // Add Title and Subtitle
        var title = g.append('g');

        var text = title.append('text').attr('class', 'title').attr('dy', '-10px').text(function () {
          return rowData.title;
        });

        text.append('tspan').attr('class', 'subtitle').attr('dx', '15px').text(function () {
          return rowData.subtitle;
        });

        var maxAll = Math.max(ranges[0], markers[0], measures[0]);
        var minAll = Math.min(rangesAsc[0], markersAsc[0], measuresAsc[0]);

        minAll = minAll < 0 ? minAll : 0;

        // Compute the new x-scale.
        var x1 = d3.scaleLinear().domain([minAll, maxAll]).range([0, width]).nice();

        // Derive width-scales from the x-scales.
        var w1 = bulletWidth(x1);

        // Update the range rects.
        var range = g.selectAll('rect.range').data(ranges);

        range.enter().append('rect').attr('class', function (d, a) {
          return 'range s' + a;
        }).attr('data-idx', i).attr('width', 0).attr('x', function (d) {
          return x1(d < 0 ? d : 0);
        }).style('fill', function (d, b) {
          if (chartData.barColors) {
            return chartData.barColors[b];
          }
          return '';
        }).attr('height', barHeight).on('click', function () {
          var bar = d3.select(this);
          self.element.trigger('selected', [bar, chartData.data[bar.attr('data-idx')]]);
        }).on('mouseenter', function (d, mouseEnterIdx) {
          var bar = d3.select(this);
          var data = chartData.data[bar.attr('data-idx')];
          var rect = this.getBoundingClientRect();
          var content = '<p>' + d + '</p>';

          var show = function show() {
            var size = charts.tooltipSize(content);
            var x = rect.left + rect.width - size.width / 2;
            var y = rect.top - size.height + $(window).scrollTop() - 5;

            if (content !== '') {
              charts.showTooltip(x, y, content, 'top');
            }
          };

          if (data.tooltip && data.tooltip[mouseEnterIdx]) {
            content = data.tooltip[data.tooltip.length - mouseEnterIdx - 1];
          }

          if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[mouseEnterIdx]) {
            content = '';
            var runInterval = true;
            tooltipInterval = setInterval(function () {
              if (runInterval) {
                runInterval = false;
                tooltipData(function (da) {
                  content = da;
                  tooltipDataCache[i] = da;
                });
              }
              if (content !== '') {
                clearInterval(tooltipInterval);
                show();
              }
            }, 10);
          } else {
            tooltipData = (typeof tooltipData === 'undefined' ? 'undefined' : _typeof(tooltipData)) === 'object' ? '' : tooltipData;
            content = tooltipDataCache[i] || tooltipData || content || '';
            show();
          }
        }).on('mouseleave', function () {
          clearInterval(tooltipInterval);
          charts.hideTooltip();
        }).merge(range).transition().duration(duration).attr('width', w1);

        // Update the measure rects.
        var measure = g.selectAll('rect.measure').data(measures);

        measure.enter().append('rect').attr('class', function (d, k) {
          return 'measure s' + k;
        }).attr('width', 0).attr('height', 3).attr('x', function (d) {
          return x1(d < 0 ? d : 0);
        }).style('fill', function (d, j) {
          if (chartData.lineColors) {
            return chartData.lineColors[j];
          }
          return '';
        }).attr('y', 8.5).merge(measure).transition().duration(duration).attr('width', w1);

        // Update the marker lines.
        var marker = g.selectAll('line.marker').data(markers);

        marker.enter().append('line').attr('class', noMarkers ? 'hidden' : 'marker').attr('x1', 0).attr('x2', 0).style('stroke', function (d, l) {
          if (chartData.markerColors) {
            return chartData.markerColors[l];
          }
          return '';
        }).attr('y1', barHeight / 6).attr('y2', barHeight * 5 / 6).merge(marker).transition().duration(duration).attr('x1', x1).attr('x2', x1).attr('y1', barHeight / 6).attr('y2', barHeight * 5 / 6);

        // Difference
        var diff = (markers[0] > measures[0] ? '-' : '+') + Math.abs(markers[0] - measures[0]);

        if (Math.abs(markers[0] - measures[0]) !== 0) {
          marker.enter().append('text').attr('class', 'inverse').attr('text-anchor', 'middle').attr('y', barHeight / 2 + 4).attr('dx', charts.isRTL ? '-20px' : '20px').attr('x', 0).text(diff).merge(marker).transition().duration(duration).attr('x', function () {
            var total = 0;

            g.selectAll('.measure').each(function (d) {
              var w = w1(d);
              var x = x1(d);

              if (w > total) {
                total = w;
              }

              if (x > total) {
                total = x;
              }
            });

            return charts.isRTL ? -total : total;
          }).style('opacity', 1);
        }

        // Update the tick groups.
        var tick = g.selectAll('g.tick').data(x1.ticks(8));

        // Initialize the ticks with the old scale, x0.
        var tickEnter = tick.enter().append('g').attr('class', 'tick').attr('transform', 'translate(0,0)').style('opacity', 0);

        tickEnter.append('line').attr('y1', barHeight).attr('y2', Math.round(barHeight * 7 / 4.7));

        tickEnter.append('text').attr('text-anchor', 'middle').attr('dy', '1.1em').attr('y', Math.round(barHeight * 7 / 4.7)).attr('class', function (d) {
          return d < 0 ? 'negative-value' : 'positive-value';
        }).text(function (d) {
          return d;
        });

        // Transition the entering ticks to the new scale, x1
        tickEnter.transition().duration(duration).attr('transform', function (d) {
          return 'translate(' + x1(d) + ',0)';
        }).style('opacity', 1);

        if (charts.isRTL && charts.isIE) {
          svg.selectAll('text').attr('transform', 'scale(-1, 1)');
        }
      };

      for (var i = 0; i < chartData.data.length; i++) {
        _loop(i);
      }

      charts.appendTooltip();
      this.element.trigger('rendered');

      return this;
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      this.element.on('updated.' + COMPONENT_NAME$h, function () {
        _this2.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on('resize.' + COMPONENT_NAME$h, function () {
          _this2.handleResize();
        });

        this.element.on('resize.' + COMPONENT_NAME$h, function () {
          _this2.handleResize();
        });
      }

      return this;
    },


    /*
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }
      this.element.empty();

      return this.build();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$h + ' resize.' + COMPONENT_NAME$h);
      $('body').off('resize.' + COMPONENT_NAME$h);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('bullet-chart');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$h);
      $.removeData(this.element[0], 'chart');
    }
  };

  // Other Shared Imports

  // Settings and Options
  var COMPONENT_NAME$i = 'completion-chart';

  /**
  * A completion chart shows completion over a target value. Usually used to show progress as a percentage.
  * @class CompletionChart
  * @param {string} element The plugin element for the constuctor
  * @param {string} [settings] The settings element.
  *
  * @param {array} [settings.dataset.data] The data to use in the chart (See examples)
  * @param {string} [settings.dataset.data.name] - Required object with the title text `{text: 'Available Credit'}`
  * @param {number} [settings.dataset.data.completed] - Required data for the complete section `{text: 'Spent', value: 50000, format: '$,.0f'}`
  * @param {array} [settings.dataset.data.remaining] - Required data for the remaining section `{text: 'Pending', value: 10000, format: '$,.0f'}`
  * @param {array} [settings.dataset.data.total] - Optional data for the total section `{value: 95000, format: '$,.0f'}`
  */

  var COMPLETION_CHART_DEFAULTS = {
    dataset: []
  };

  function CompletionChart(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COMPLETION_CHART_DEFAULTS);
    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  CompletionChart.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The completion chart prototype for chaining.
     */
    init: function init() {
      // Do initialization. Build or Events ect
      this.build().handleEvents();

      return this;
    },


    /**
     * Build the Completion Chart.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    build: function build() {
      var _this = this;

      var chartData = this.settings.dataset[0];

      // Handle Empty Data Set
      if (this.settings.dataset.length === 0) {
        chartData = {};
        chartData.data = [{
          name: { text: Locale ? Locale.translate('NoData') : 'No Data Available' },
          completed: { value: 0 }
        }];
      }

      var dataset = chartData.data[0];
      var isTarget = this.settings.type === 'completion-target';
      var isAchievment = this.settings.type === 'targeted-achievement';

      $(this.element).addClass('completion-chart' + (this.settings.type === 'targeted-achievement' ? ' chart-targeted-achievement' : ''));

      // Set total defaults
      dataset.total = $.extend({}, { value: 100 }, dataset.total);

      // Basic functions
      var isUndefined = function isUndefined(value) {
        return typeof value === 'undefined';
      };

      var fixUndefined = function fixUndefined(value, isNumber) {
        var defaultValue = isNumber ? 0 : '';
        return !isUndefined(value) ? value : defaultValue;
      };

      var toValue = function toValue(percent, ds) {
        ds = ds || dataset;
        return percent / 100 * fixUndefined(ds.total.value, true);
      };

      var toPercent = function toPercent(value, ds) {
        ds = ds || dataset;
        return Math.round(100 * (value / fixUndefined(ds.total.value, true)));
      };

      var localePercent = function localePercent(value) {
        return Locale.formatNumber(value / 100, { style: 'percent', maximumFractionDigits: 0 });
      };

      var format = function format(value, formatterString, ds) {
        if (formatterString === '.0%') {
          return localePercent(toPercent(value, ds));
        }
        return d3.format(formatterString || '')(value);
      };

      var fixPercent = function fixPercent(value, ds) {
        var s = value.toString();
        if (s.indexOf('%') !== -1) {
          return toValue(s.replace(/%/g, ''), ds);
        }
        return value;
      };

      var updateWidth = function updateWidth(elem, value, ds) {
        var percent = toPercent(value, ds);
        percent = percent < 0 ? 0 : percent;
        var w = percent > 100 ? 100 : percent;
        elem[0].style.width = w + '%';

        if (w === 0) {
          elem[0].className += 'is-empty';
        }
      };

      var updateTargetline = function updateTargetline(elem, value) {
        var min = value < 0 ? 0 : value;
        var w = value > 100 ? 100 : min;
        elem[0].style.left = w + '%';
      };

      var setFormat = function setFormat(obj, ds, isPrivate) {
        var value = isPrivate ? obj._value : obj.value; //eslint-disable-line
        return obj && !isUndefined(value) && obj.format ? //eslint-disable-line
        format(fixPercent(value, ds), obj.format, ds) : //eslint-disable-line
        obj ? fixPercent(value, ds) : 0;
      };

      var self = this;

      var setOverlap = function setOverlap() {
        if (isTarget && !isAchievment) {
          setTimeout(function () {
            var remaining = $('.remaining', self.element);
            var total = $('.total', self.element);
            var rect1 = $('.completed .value', self.element)[0].getBoundingClientRect();
            var rect2 = remaining.find('.value')[0].getBoundingClientRect();

            remaining.add(total)[rect1.right > rect2.left - 20 ? 'addClass' : 'removeClass']('overlap');
          }, 500);
        }
      };

      var getSpecColor = function getSpecColor(ds) {
        var specColor = {};
        ds = ds || dataset;

        if (ds.info && !isUndefined(ds.info.color)) {
          if (dataset.info.color.indexOf('#') === 0) {
            specColor.info = true;
          }
        }
        if (ds.completed && !isUndefined(ds.completed.color)) {
          if (ds.completed.color.indexOf('#') === 0) {
            specColor.completed = true;
          }
        }
        if (ds.remaining && !isUndefined(ds.remaining.color)) {
          if (ds.remaining.color.indexOf('#') === 0) {
            specColor.remaining = true;
          }
        }
        if (ds.targetline && !isUndefined(ds.targetline.color)) {
          if (ds.targetline.color.indexOf('#') === 0) {
            specColor.targetline = true;
          }
        }
        return specColor;
      };

      var getTotalText = function getTotalText(ds) {
        var totalText = '';
        var difference = {};

        ds = ds || dataset;

        if (ds.total.difference) {
          difference.value = ds.total.value - ds.completed.value;
          difference.format = dataset.total.format;
        }

        totalText = (!ds.total.textOnly ? setFormat(ds.total.difference ? difference : ds.total) : '') + (ds.total.text || '');

        totalText = isAchievment && ds.remaining ? (!ds.remaining.textOnly ? setFormat(ds.remaining) : '') + (ds.remaining.text || '') : totalText;

        return totalText;
      };

      var percentTextDefault = { show: false, color1: '', color2: 'inverse' };
      var percentText = $.extend({}, percentTextDefault, dataset.percentText);
      var setPercentText = function setPercentText(ds) {
        ds = ds || dataset;
        percentText._value = ds.completed ? ds.completed.value : 0; //eslint-disable-line
        percentText.percent = toPercent(fixUndefined(percentText._value, true), ds); //eslint-disable-line
        percentText.format = '.0%';
        percentText._text = typeof percentText.text !== 'undefined' ? //eslint-disable-line
        percentText.text : typeof percentText.value !== 'undefined' ? //eslint-disable-line
        localePercent(percentText.value) : setFormat(percentText, ds, true);
        percentText.color = percentText[percentText.percent > 55 ? 'color2' : 'color1'];
      };

      var c = void 0; // Cache will after created

      var cacheElements = function cacheElements() {
        c = {
          name: $('.name', _this.element),
          info: {
            value: $('.info .value', _this.element),
            text: $('.info .text', _this.element)
          },
          completed: {
            bar: $('.completed.bar', _this.element),
            value: $('.completed .value', _this.element),
            text: $('.completed .text, .completed-label .text', _this.element)
          },
          remaining: {
            bar: $('.remaining.bar', _this.element),
            value: $('.remaining .value', _this.element),
            text: $('.remaining .text', _this.element)
          },
          targetline: {
            bar: $('.targetline', _this.element),
            value: $('.targetline .value', _this.element),
            text: $('.targetline .text', _this.element)
          },
          total: {
            bar: $('.total.bar', _this.element),
            value: $('.total.value', _this.element)
          },
          percentText: $('.chart-percent-text', _this.element)
        };
      };

      var setJsonData = function setJsonData(ds) {
        ds = ds || dataset;
        c.name.data('jsonData', { name: ds.name });
        c.info.value.add(c.info.text).data('jsonData', { info: ds.info });
        c.completed.bar.add(c.completed.value).add(c.completed.text).data('jsonData', { completed: ds.completed });
        c.remaining.bar.add(c.remaining.value).add(c.remaining.text).data('jsonData', { remaining: ds.remaining });
        c.targetline.bar.add(c.targetline.value).add(c.targetline.text).data('jsonData', { targetline: ds.targetline });
        c.total.bar.add(c.total.value).data('jsonData', { total: ds.total });
        c.percentText.data('jsonData', { percentText: ds.percentText });
      };

      var updateBars = function updateBars(ds) {
        var w = void 0;
        ds = ds || dataset;
        // Update completed bar width
        if (ds.completed) {
          w = fixPercent(ds.completed.value, ds);
          updateWidth(c.completed.bar, w, ds);
        }

        // Update remaining bar width
        if (ds.remaining) {
          w = fixPercent(ds.completed.value, ds) + fixPercent(ds.remaining.value, ds);
          updateWidth(c.remaining.bar, w, ds);
          setOverlap();
        }

        // Update target line bar position
        if (ds.targetline) {
          w = fixPercent(ds.targetline.value, ds);
          updateTargetline(c.targetline.bar, w, ds);
        }
      };

      if (!isUndefined(percentText.color) && percentText.color1 === '') {
        percentText.color1 = percentText.color;
      }

      // Render
      var html = { body: $('<div class="total bar" />') };
      var specColor = getSpecColor();

      if (isTarget || isAchievment) {
        var totalText = getTotalText();

        html.body.addClass('chart-completion-target' + (isAchievment ? ' chart-targeted-achievement' : ''));

        html.label = '<span class="label">\n        <span class="name">\n          ' + (dataset.completed.color && dataset.completed.color === 'error' ? $.createIcon({ icon: 'error', classes: 'icon-error' }) : '') + '\n          ' + fixUndefined(dataset.name.text) + '</span>\n        <span class="l-pull-right total value">' + totalText + '</span>\n      </span>';
      } else {
        html.body.addClass('chart-completion');
        var name = fixUndefined(dataset.name.text);
        var completedColor = fixUndefined(dataset.completed.color);
        var infoColor = fixUndefined(dataset.info.color);
        var bColor = dataset.info.color && !specColor.info ? infoColor : '';
        var infoText = fixUndefined(dataset.info.text);

        if (!specColor.completed) {
          bColor = completedColor;
        }

        var styleColor = '';
        if (dataset.info.color && specColor.info) {
          styleColor = infoColor;
        }

        if (specColor.completed) {
          styleColor = completedColor;
        }

        var styleValue = dataset.info && !isUndefined(dataset.info.value) ? fixUndefined(dataset.info.value) : setFormat(dataset.completed);

        html.label = '<b class="label name">' + name + '</b>\n      <b class="label info ' + bColor + ' colored">\n      <span class="value ' + bColor + '" ' + (styleColor ? 'style="color:' + styleColor : '') + '">' + styleValue + '</span>\n      <span class="text ' + bColor + '" ' + (styleColor ? 'style="color:' + styleColor : '') + '">' + infoText + '</span>\n      </b>';
      }

      if (dataset.remaining) {
        html.remaining = '' + ('' + '<div class="target remaining bar') + (!specColor.remaining ? ' ' + fixUndefined(dataset.remaining.color) : '') + '"' + (specColor.remaining ? ' style="color:' + dataset.remaining.color + ';background-color:' + dataset.remaining.color + ';"' : '') + '">' + (isAchievment ? '' : '<span aria-hidden="true"' + (!isTarget && !isAchievment ? ' class="audible"' : '') + '>' + ('<span class="value' + (!specColor.remaining ? ' ' + fixUndefined(dataset.remaining.color) : '') + '"' + (specColor.remaining ? ' style="color:' + dataset.remaining.color + ';"' : '') + '">' + setFormat(dataset.remaining) + '</span><br />') + ('<span class="text' + (!specColor.remaining ? ' ' + fixUndefined(dataset.remaining.color) : '') + '"' + (specColor.remaining ? ' style="color:' + dataset.remaining.color + ';"' : '') + '">' + fixUndefined(dataset.remaining.text) + '</span>') + '</span>') + '</div>';
      } else {
        html.remaining = '<div class="target remaining bar" style="opacity: 0"></div>';
      }

      if (dataset.completed && isAchievment) {
        setPercentText();
        specColor.percentText = percentText.color.indexOf('#') === 0;

        html.completed = '' + ('' + '<div class="completed bar') + (!specColor.completed ? ' ' + fixUndefined(dataset.completed.color) : '') + '"' + (specColor.completed ? ' style="color:' + dataset.completed.color + ';background-color:' + dataset.completed.color + ';"' : '') + '"></div>' + (percentText.show ? '<div class="chart-percent-text' + (!specColor.percentText && percentText.color !== '' ? ' ' + percentText.color : '') + '"' + (specColor.percentText ? ' style="color:' + percentText.color + ';"' : '') + '>' + percentText._text + '</div>' : '' //eslint-disable-line
        ) + '<span class="completed-label" aria-hidden="true"' + (!isTarget && !isAchievment ? ' class="audible"' : '') + '>' + ('<span class="text">' + fixUndefined(dataset.completed.text) + '</span>') + '</span>';
      }

      if (dataset.completed && !isAchievment) {
        html.completed = '' + ('' + '<div class="completed bar') + (!specColor.completed ? ' ' + fixUndefined(dataset.completed.color) : '') + '"' + (specColor.completed ? ' style="color:' + dataset.completed.color + ';background-color:' + dataset.completed.color + ';"' : '') + '>' + ('<span aria-hidden="true"' + (!isTarget && !isAchievment ? ' class="audible"' : '') + '>') + ('<span class="value' + (!specColor.completed ? ' ' + fixUndefined(dataset.completed.color) : '') + '"' + (specColor.completed ? ' style="color:' + dataset.completed.color + ';"' : '') + '">' + setFormat(dataset.completed) + '</span><br />') + ('<span class="text' + (!specColor.completed ? ' ' + fixUndefined(dataset.completed.color) : '') + '"' + (specColor.completed ? ' style="color:' + dataset.completed.color + ';"' : '') + '">' + fixUndefined(dataset.completed.text) + '</span>') + '</span></div>';
      }

      if (dataset.targetline) {
        html.targetline = '' + ('' + '<div class="target-line targetline bar') + (!specColor.targetline ? ' ' + fixUndefined(dataset.targetline.color) : '') + '"' + (specColor.targetline ? ' style="color:' + dataset.targetline.color + ';background-color:' + dataset.targetline.color + ';"' : '') + '">' + ('<span aria-hidden="true"' + (!isTarget && !isAchievment ? ' class="audible"' : '') + '>') + ('<span class="value' + (!specColor.targetline ? ' ' + fixUndefined(dataset.targetline.color) : '') + '"' + (specColor.targetline ? ' style="color:' + dataset.targetline.color + ';"' : '') + '">' + setFormat(dataset.targetline) + '</span><br />') + ('<span class="text' + (!specColor.targetline ? ' ' + fixUndefined(dataset.targetline.color) : '') + '"' + (specColor.targetline ? ' style="color:' + dataset.targetline.color + ';"' : '') + '">' + fixUndefined(dataset.targetline.text) + '</span>') + '</span>' + '</div>';
      }

      DOM.append(html.body, (html.remaining || '') + (html.completed || '') + (html.targetline || ''), '<div><span><br>');
      DOM.append(this.element, html.label + html.body.prop('outerHTML'), '<div><span><br>');

      cacheElements();
      setJsonData();
      updateBars();

      return this;
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      this.element.on('updated.' + COMPONENT_NAME$i, function () {
        _this2.updated();
      });

      return this;
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings object
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      var type = settings.type || this.settings.type;
      this.settings = settings;
      this.settings.type = type;
      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }
      this.element.empty();

      return this.teardown().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$i);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.removeClass('completion-chart');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$i);
      $.removeData(this.element[0], 'chart');
    }
  };

  /* eslint-disable no-nested-ternary, prefer-arrow-callback */

  // Settings and Options
  var COMPONENT_NAME$j = 'sparkline';

  // The Component Defaults
  var SPARKLINE_DEFAULTS = {
    dataset: [],
    colors: ['#1D5F8A', '#999999', '#bdbdbd', '#d8d8d8'],
    isDots: false,
    isPeakDot: false,
    isMinMax: false,
    isMedianRange: false
  };

  /**
   * Sparklines are a compact way to show trends.
   * @class Sparkline
   * @param {string} element The plugin element for the constuctor
   * @param {string} settings The settings element.
   * @param {array} [settings.dataset] The data to use in the sparklines.
   * @param {array} [settings.colors = ['#1D5F8A', '#999999', '#bdbdbd', '#d8d8d8']] An array of color sequences in hex format fx #1D5F8A,
   * defaulting to the correct standard colors.
   * @param {boolean} [settings.isDots = false] Shows dots on the data points.
   * @param {boolean} [settings.isPeakDot = false] Highlights the top value as peak with a special dot.
   * @param {boolean} [settings.isMinMax  = false] Shows a continuous shading to highlight the min and max values.
   * @param {boolean} [settings.isMedianRange  = false] Adds a median range display.
   */
  function Sparkline(element, settings) {
    this.settings = utils.mergeSettings(element, settings, SPARKLINE_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Sparkline.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The sparkline prototype for chaining.
     */
    init: function init() {
      this.sparklineColors = d3.scaleOrdinal().range(this.settings.colors);

      return this.build().handleEvents();
    },


    /**
     * Build the Sparkline Chart.
     * @private
     * @returns {object} The sparkline prototype for chaining.
     */
    build: function build() {
      // chartData, options
      // Sparkline Chart
      var self = this;
      var tooltipIntervalMedianRange = void 0;
      var tooltipIntervalDots = void 0;
      var tooltipDataCacheMedianRange = [];
      var tooltipDataCacheDots = [];
      var tooltipData = self.settings.tooltip;

      // calculate max and min values in the NLWest data
      var max = 0;
      var min = 0;
      var len = 0;
      var i = void 0;
      var dimensions = this.calculateAspectRatioFit({
        srcWidth: 385,
        srcHeight: 65,
        maxWidth: this.element.width(),
        maxHeight: 600 // container min-height
      });
      var dotsize = dimensions.width > 300 ? 4 : 3;

      var chartData = self.settings.dataset;
      for (i = 0; i < chartData.length; i++) {
        min = d3.min([d3.min(chartData[i].data), min]);
        max = d3.max([d3.max(chartData[i].data), max]);
        len = d3.max([chartData[i].data.length, len]);
      }

      // Make the lines based on the range of values and width
      var p = 10;
      var w = dimensions.width;
      var h = dimensions.height;
      var x = d3.scaleLinear().domain([0, len]).range([p, w - p]);
      var y = d3.scaleLinear().domain([min, max]).range([h - p, p]);
      var line = d3.line().x(function (d, j) {
        return x(j);
      }).y(function (d) {
        return y(d);
      });

      // Add the tooltip dom element
      charts.appendTooltip();

      // Append to the main dom element
      var svg = d3.select(this.element[0]).append('svg').attr('height', h).attr('width', w);

      // Add Median Range
      // https://www.purplemath.com/modules/meanmode.htm
      if (self.settings.isMedianRange) {
        max = d3.max(chartData[0].data);
        min = d3.min(chartData[0].data);

        var minWidth = 10;
        var maxWidth = w - 45;
        var median = d3.median(chartData[0].data);
        var range = max - min;
        var scaleMedianRange = d3.scaleLinear().domain([min, max]).range([0, h]);
        var top = h - scaleMedianRange(median > range ? median : range);
        var bot = h - scaleMedianRange(median < range ? median : range);

        svg.append('g').attr('class', 'medianrange').attr('transform', function () {
          return 'translate(' + minWidth + ',' + top + ')';
        }).append('rect').attr('width', maxWidth).attr('height', bot).style('fill', '#d8d8d8').on('mouseenter', function () {
          var rect = this.getBoundingClientRect();
          var content = '<p class="sparkline-tooltip">' + // eslint-disable-line
          Locale.translate('Median') + '<b>' + median + '</b><br>' + Locale.translate('Range') + '<b>' + range + '</b>' + (self.settings.isPeakDot ? '<br>' + Locale.translate('Peak') + '<b>' + max + '</b>' : '') + '</p>'; // eslint-disable-line

          var show = function show() {
            var size = charts.tooltipSize(content);
            var posX = rect.left + (rect.width - size.width) / 2;
            var posY = rect.top - size.height - 5; // 5 is extra padding

            if (content !== '') {
              charts.showTooltip(posX, posY, content, 'top');
            }
          };

          if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCacheMedianRange[i]) {
            content = '';
            var runInterval = true;
            tooltipIntervalMedianRange = setInterval(function () {
              if (runInterval) {
                runInterval = false;
                tooltipData(function (data) {
                  content = data;
                  tooltipDataCacheMedianRange[i] = data;
                });
              }
              if (content !== '') {
                clearInterval(tooltipIntervalMedianRange);
                show();
              }
            }, 10);
          } else {
            tooltipData = (typeof tooltipData === 'undefined' ? 'undefined' : _typeof(tooltipData)) === 'object' ? '' : tooltipData;
            content = tooltipDataCacheMedianRange[i] || tooltipData || chartData[0].tooltip || content || '';
            show();
          }
        }).on('mouseleave', function () {
          clearInterval(tooltipIntervalMedianRange);
          charts.hideTooltip();
        });
      }

      for (i = 0; i < chartData.length; i++) {
        var set$$1 = chartData[i];
        var g = svg.append('g');

        g.append('path').attr('d', line(set$$1.data)).attr('stroke', self.settings.isMinMax ? '#999999' : this.sparklineColors(i)).attr('class', 'team connected-line');
      }

      // Add Dots (Dots/Peak/MinMAx)
      min = d3.min(chartData[0].data);
      svg.selectAll('.point').data(chartData[0].data).enter().append('circle').attr('r', function (d) {
        return self.settings.isMinMax && max === d || self.settings.isMinMax && min === d ? dotsize + 1 : self.settings.isDots || self.settings.isPeakDot && max === d ? dotsize : 0;
      }).attr('class', function (d) {
        return self.settings.isPeakDot && max === d && !self.settings.isMinMax ? 'point peak' : self.settings.isMinMax && max === d ? 'point max' : self.settings.isMinMax && min === d ? 'point min' : 'point';
      }).style('fill', function (d) {
        return self.settings.isPeakDot && max === d && !self.settings.isMinMax ? '#ffffff' : self.settings.isMinMax && max === d ? '#56932E' : self.settings.isMinMax && min === d ? '#941E1E' : self.sparklineColors(0);
      }).style('stroke', function (d) {
        return self.settings.isPeakDot && max === d && !self.settings.isMinMax ? self.sparklineColors(0) : self.settings.isMinMax && max === d ? 'none' : self.settings.isMinMax && min === d ? 'none' : '#ffffff';
      }).style('cursor', 'pointer').attr('cx', function (d, m) {
        return x(m);
      }).attr('cy', function (d) {
        return y(d);
      }).on('mouseenter', function (d) {
        var rect = this.getBoundingClientRect();
        var content = '<p>' + (chartData[0].name ? chartData[0].name + '<br> ' + (self.settings.isMinMax && max === d ? Locale.translate('Highest') + ': ' : self.settings.isMinMax && min === d ? Locale.translate('Lowest') + ': ' : self.settings.isPeakDot && max === d ? Locale.translate('Peak') + ': ' : '') : '') + '<b>' + d + '</b></p>';

        var show = function show() {
          var size = charts.tooltipSize(content);
          var posX = rect.left - size.width / 2 + 6;
          var posY = rect.top - size.height - 8;

          if (content !== '') {
            charts.showTooltip(posX, posY, content, 'top');
          }
        };

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCacheDots[i]) {
          content = '';
          var runInterval = true;
          tooltipIntervalDots = setInterval(function () {
            if (runInterval) {
              runInterval = false;
              tooltipData(function (data) {
                content = data;
                tooltipDataCacheDots[i] = data;
              });
            }
            if (content !== '') {
              clearInterval(tooltipIntervalDots);
              show();
            }
          }, 10);
        } else {
          tooltipData = (typeof tooltipData === 'undefined' ? 'undefined' : _typeof(tooltipData)) === 'object' ? '' : tooltipData;
          content = tooltipDataCacheDots[i] || tooltipData || chartData[0].tooltip || content || '';
          show();
        }

        d3.select(this).attr('r', self.settings.isMinMax && max === d || self.settings.isMinMax && min === d ? dotsize + 2 : dotsize + 1);
      }).on('mouseleave', function (d) {
        clearInterval(tooltipIntervalDots);
        charts.hideTooltip();
        d3.select(this).attr('r', self.settings.isMinMax && max === d || self.settings.isMinMax && min === d ? dotsize + 1 : dotsize);
      });

      /**
      * Fires when the sparkline is fully renders.
      *
      * @event close
      * @memberof About
      * @property {object} event - The jquery event object
      * @property {object} ui - The svg element.
      */
      this.element.trigger('rendered', svg);
      return this;
    },


    /**
     * Conserve aspect ratio of the orignal region. Useful when shrinking/enlarging
     * @private
     * @param  {object} d the data element with the properties
     * @returns {object} Object with the calulated width and height
     */
    calculateAspectRatioFit: function calculateAspectRatioFit(d) {
      var ratio = Math.min(d.maxWidth / d.srcWidth, d.maxHeight / d.srcHeight);
      return { width: d.srcWidth * ratio, height: d.srcHeight * ratio };
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on('updated.' + COMPONENT_NAME$j, function () {
        _this.updated();
      });

      return this;
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings object
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      var type = settings.type || this.settings.type;
      this.settings = settings;
      this.settings.type = type;
      this.element.empty();

      return this.teardown().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$j);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$j);
      $.removeData(this.element[0], 'chart');
    }
  };

  /* eslint-disable consistent-return */

  // The name of this component
  var COMPONENT_NAME$k = 'emptymessage';

  /**
  * The Empty Message is a message with an icon that can be used when no data is present.
  * @class EmptyMessage
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [settings.title = null] The Main text to show.
  * @param {string} [settings.info = null] Longer paragraph text to show
  * @param {string} [settings.icon = null] The name of the icon to use. See {@link https://design.infor.com/code/ids-enterprise/latest/demo/icons/example-empty-widgets?font=source-sans} for options.
  * @param {boolean} [settings.button = null] The botton text and click event to add.
  * @param {string} [settings.color = 'graphite']  Defaults to 'graphite' but can also be azure. Later may be expanded to all personalization colors.
  */
  var EMPTYMESSAGE_DEFAULTS = {
    title: null,
    info: null,
    icon: null,
    button: null,
    color: 'graphite' // or azure for now until personalization works
  };

  function EmptyMessage(element, settings) {
    this.settings = utils.mergeSettings(element, settings, EMPTYMESSAGE_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Component Methods
  EmptyMessage.prototype = {
    init: function init() {
      this.setup().build();
    },
    setup: function setup() {
      this.element.addClass('empty-message');
      return this;
    },
    build: function build() {
      var opts = this.settings;

      if (opts.icon) {
        $('<div class="empty-icon">\n          <svg class="icon-empty-state is-' + this.settings.color + '" focusable="false" aria-hidden="true" role="presentation">\n            <use xlink:href="#' + opts.icon + '"></use>\n          </svg></div>').appendTo(this.element);
      }

      if (opts.title) {
        // Re-evaluate the text
        if (opts.title === '[NoData]') {
          opts.title = Locale ? Locale.translate('NoData') : 'No Data Available';
        }

        $('<div class="empty-title">' + opts.title + '</div>').appendTo(this.element);
      }

      if (opts.info) {
        $('<div class="empty-info">' + opts.info + '</div>').appendTo(this.element);
      }

      if (opts.button) {
        $('' + ('<div class="empty-actions">' + '<button type="button" class="btn-secondary hide-focus ') + opts.button.cssClass + '" id="' + opts.button.id + '">' + ('<span>' + opts.button.text + '</span>') + '</button>' + '</div>').appendTo(this.element);

        if (opts.button.click) {
          this.element.on('click', opts.button.click);
        }
      }

      return this;
    },


    /**
     * Update the component and optionally apply new settings.
     *
     * @param  {object} settings the settings to update to.
     * @returns {void}
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      this.element.empty();
      this.build();
    },


    /**
     * Teardown - Remove added markup and events
     * @returns {void}
     */
    destroy: function destroy() {
      $.removeData(this.element[0], COMPONENT_NAME$k);
      this.element.empty();
    }
  };

  // Empty Message jQuery wrapper
  $.fn.emptymessage = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$k);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$k, new EmptyMessage(this, settings));
      }
    });
  };

  /* eslint-disable no-nested-ternary, prefer-arrow-callback */

  // Settings and Options
  var COMPONENT_NAME$l = 'line';

  /**
   * A line chart or line graph is a type of chart which displays information as a series of data
   * points called 'markers' connected by straight line segments.
   * @class Line
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   *
   * @param {array} [settings.dataset=[]] The data to use in the line/area/bubble.
   * @param {function|string} [settings.tooltip] A custom tooltip or tooltip renderer function
   * for the whole chart.
   * @param {string} [settings.isArea] Render as an area chart.
   * @param {string} [settings.isBubble=false] Render as a bubble chart.
   * @param {string} [settings.isScatterPlot=false] Render as a Scatter Plot Chart.
  * @param {string} [settings.showLegend=true] If false the label will not be shown.
   * @param {object} [settings.xAxis] A series of options for the xAxis
   * @param {number} [settings.xAxis.rotate] Rotate the elements on the x axis.
   * Recommend -65 deg but this can be tweaked depending on look.
   * @param {object} [settings.yAxis] A series of options for the yAxis
   * @param {object} [settings.xAxis.ticks] Data to control the number of ticks and y axis format.
   * For example `{number: 5, format: ',.1s'}` would show only 5 yaxis points and format the
   * data to show 1K, 1M, 1G ect.. This uses the d3 formatter.
   * @param {function} [settings.xAxis.formatText] A function that passes the text element and a counter.
   * You can return a formatted svg markup element to replace the current element.
   * For example you could use tspans to wrap the strings or color them.
   * @param {object} [settings.yAxis] A series of options for the yAxis
   * @param {function} [settings.yAxis.formatter] A d3 formatter for the yAxis points.
   * @param {boolean} [settings.hideDots=false] If true no dots are shown
   * @param {array} [settings.axisLabels]  Option to a label to one of the four sides. For Example
   * `{left: 'Left axis label', top: 'Top axis label',
   * right: 'Right axis label', bottom: 'Bottom axis label'}`
   * @param {boolean|string} [settings.animate] true|false - will do or not do the animation.
   * 'initial' will do only first time the animation.
   * @param {boolean} [settings.redrawOnResize=true] If true, the component will not resize when resizing the page.
   * @param {object} [settings.dots] Option to customize the dot behavior. You can set the dot size (radius),
   * the size on hover and stroke or even add a custom class.
   * Example `dots: { radius: 3, radiusOnHover: 4, strokeWidth: 0, class: 'custom-dots'}`
   * @param {string} [settings.formatterString] Use d3 format some examples can be found on http://bit.ly/1IKVhHh
   * @param {object} [settings.emptyMessage] An empty message will be displayed when there is no chart data.
   * This accepts an object of the form emptyMessage:
   * `{title: 'No Data Available',
   *  info: 'Make a selection on the list above to see results', icon: 'icon-empty-no-data',
   *  button: {text: 'xxx', click: <function>}
   *  }`
   *  Set this to null for no message or will default to 'No Data Found with an icon.'
   */
  var LINE_DEFAULTS = {
    dataset: [],
    isArea: false,
    isBubble: false,
    isScatterPlot: false,
    showLegend: true,
    hideDots: false,
    animate: true,
    redrawOnResize: true,
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' }
  };

  function Line(element, settings) {
    this.settings = utils.mergeSettings(element, settings, LINE_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Line.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.build().handleEvents();

      // Handle initial option
      if (this.settings.animate === 'initial') {
        this.settings.animate = false;
      }

      /**
      * Fires when the chart is complete done rendering, for customization.
      * @event rendered
      * @memberof Line
      * @param {object} event - The jquery event object
      * @param {array} svg - The svg object.
      */
      this.element.trigger('rendered', [this.svg]);

      return this;
    },


    /**
     * Build the Component.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    build: function build() {
      var self = this;
      var isFormatter = !!this.settings.formatterString;
      var format = function format(value) {
        return isFormatter ? d3.format(self.settings.formatterString)(value) : value;
      };

      this.element.addClass('line-chart' + (self.settings.isBubble ? ' bubble' : ''));
      this.element.addClass('line-chart' + (self.settings.isScatterPlot ? ' scatterplot' : ''));

      // Handle Empty Data Set
      if (self.settings.dataset.length === 0) {
        self.element.emptymessage(self.settings.emptyMessage);
        return this;
      }

      var dots = {
        radius: 5,
        radiusOnHover: 7,
        strokeWidth: 2,
        class: 'dot'
      };

      // Set to zero for animation
      if (self.settings.isBubble) {
        dots.radius = 0;
        dots.radiusOnHover = 0;
        dots.strokeWidth = 0;
      }

      if (self.settings.isScatterPlot) {
        dots.radius = 0;
        dots.strokeWidth = 50;
      }
      $.extend(true, dots, this.settings.dots);

      var isRTL = Locale.isRTL();

      var tooltipInterval = void 0;
      var tooltipDataCache = [];
      var tooltipData = self.settings.tooltip;

      // Config axis labels
      var i = void 0;
      var l = void 0;
      var axisLabels = {};
      var isAxisLabels = { atLeastOne: false };
      var axisArray = ['left', 'top', 'right', 'bottom'];

      if (self.settings.axisLabels) {
        $.extend(true, axisLabels, self.settings.axisLabels);
      }

      if (!$.isEmptyObject(axisLabels)) {
        for (i = 0, l = axisArray.length; i < l; i++) {
          var thisAxis = axisLabels[axisArray[i]];
          if (thisAxis && typeof thisAxis === 'string' && $.trim(thisAxis) !== '') {
            isAxisLabels[axisArray[i]] = true;
            isAxisLabels.atLeastOne = true;
          }
        }
      }

      // Append the SVG in the parent area.
      var longestLabel = '';
      var longestLabelLength = 0;
      var dataset = this.settings.dataset;

      var isAxisXRotate = self.settings.xAxis && self.settings.xAxis.rotate !== undefined; // TODO
      var getMaxes = function getMaxes(d, option) {
        return d3.max(d.data, function (maxData) {
          return option ? maxData.value[option] : maxData.value;
        });
      };

      if (isAxisXRotate) {
        // get the longeset label
        dataset[0].data.map(function (d) {
          //eslint-disable-line
          if (d.name.length > longestLabel.length) {
            longestLabel = d.name;
          }
        });
        longestLabelLength = longestLabel.length;
      }

      var hideDots = this.settings.hideDots;
      var parent = this.element.parent();
      var isCardAction = !!$('.widget-chart-action', parent).length;
      var isViewSmall = parent.width() < 450;
      var margin = {
        top: isAxisLabels.top ? isCardAction ? 15 : 40 : isCardAction ? 5 : 30,
        right: isAxisLabels.right ? isViewSmall ? 45 : 65 : isViewSmall ? 45 : 55,
        bottom: isAxisLabels.bottom ? isAxisXRotate ? 60 : 50 : isAxisXRotate ? longestLabelLength * 5 + 35 : 35,
        left: isAxisLabels.right ? isViewSmall ? 55 : 75 : isViewSmall ? 45 : 65
      };
      var width = parent.width() - margin.left - margin.right;
      var height = parent.height() - margin.top - margin.bottom - 30; // legend

      if (isCardAction) {
        height -= 40;
      }

      self.svg = d3.select(this.element[0]).append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      var names = dataset[0].data.map(function (d) {
        return d.name;
      });

      var valueFormatterString = {};

      if (dataset[0] && dataset[0].valueFormatterString) {
        $.extend(true, valueFormatterString, dataset[0].valueFormatterString);
      }

      var formatValue = function formatValue(s, value) {
        return !$.isEmptyObject(valueFormatterString) && !!s ? d3.format(s)(s === '0.0%' ? value / 100 : value) : value;
      };

      var labels = {
        name: 'Name',
        value: {
          x: 'Value.x',
          y: 'Value.y',
          z: 'Value.z'
        }
      };

      if (dataset[0] && dataset[0].labels) {
        $.extend(true, labels, dataset[0].labels);
      }

      // Calculate the Domain X and Y Ranges
      var maxes = void 0;
      var x = (!!self.settings.xAxis && !!self.settings.xAxis.scale ? self.settings.xAxis.scale : d3.scaleLinear()).range([0, width]);

      var y = d3.scaleLinear().range([height, 0]);
      var z = d3.scaleLinear().range([1, 25]);

      if (self.settings.isBubble) {
        maxes = {
          x: dataset.map(function (d) {
            return getMaxes(d, 'x');
          }),
          y: dataset.map(function (d) {
            return getMaxes(d, 'y');
          }),
          z: dataset.map(function (d) {
            return getMaxes(d, 'z');
          })
        };
      } else if (self.settings.isScatterPlot) {
        maxes = {
          x: dataset.map(function (d) {
            return getMaxes(d, 'x');
          }),
          y: dataset.map(function (d) {
            return getMaxes(d, 'y');
          })
        };
      } else {
        maxes = dataset.map(function (d) {
          return getMaxes(d);
        });
      }

      var entries = d3.max(dataset.map(function (d) {
        return d.data.length;
      })) - 1;
      var xScale = x.domain(!!self.settings.xAxis && !!self.settings.xAxis.domain ? self.settings.xAxis.domain : [0, self.settings.isBubble || self.settings.isScatterPlot ? d3.max(maxes.x) : entries]);

      var yScale = y.domain([0, d3.max(self.settings.isBubble || self.settings.isScatterPlot ? maxes.y : maxes)]).nice();
      var zScale = z.domain([0, d3.max(self.settings.isBubble ? maxes.z : maxes)]).nice();
      var numTicks = entries;
      if (self.settings.xAxis && self.settings.xAxis.ticks) {
        numTicks = self.settings.xAxis.ticks === 'auto' ? Math.max(width / 85, 2) : self.settings.xAxis.ticks;
        if (self.settings.isBubble || self.settings.isScatterPlot && isViewSmall) {
          numTicks = Math.round(entries / 2);
        }
      }

      var xAxis = d3.axisBottom(xScale).ticks(numTicks).tickPadding(10).tickSize(self.settings.isBubble || self.settings.isScatterPlot ? -(height + 10) : 0).tickFormat(function (d, j) {
        if (self.settings.xAxis) {
          if (self.settings.xAxis.formatter) {
            return self.settings.xAxis.formatter(d, j);
          }
          if (self.settings.xAxis.ticks === 'auto') {
            return names[d];
          }
        }
        return self.settings.isBubble || self.settings.isScatterPlot ? d : names[j];
      });

      var yAxis = d3.axisLeft(yScale).ticks(8).tickSize(-(width + 20)).tickPadding(isRTL ? -18 : 20);

      if (self.settings.yAxis && self.settings.yAxis.formatter) {
        yAxis.tickFormat(function (d, k) {
          if (typeof self.settings.yAxis.formatter === 'function') {
            return self.settings.yAxis.formatter(d, k);
          }
          return d;
        });
      }

      if (self.settings.yAxis && self.settings.yAxis.ticks) {
        yAxis.ticks(self.settings.yAxis.ticks.number, self.settings.yAxis.ticks.format);
      }

      // Append The Axis Labels
      if (isAxisLabels.atLeastOne) {
        var axisLabelsGroup = self.svg.append('g').attr('class', 'axis-labels');
        var place = {
          top: 'translate(' + width / 2 + ',' + -10 + ')',
          right: 'translate(' + (width + 28) + ',' + height / 2 + ')rotate(90)',
          bottom: 'translate(' + width / 2 + ',' + (height + 40) + ')',
          left: 'translate(' + -40 + ',' + height / 2 + ')rotate(-90)'
        };

        var placeStyle = {
          top: 'rotate(0deg) scaleX(-1) translate(-' + width / 2 + 'px, ' + -10 + 'px)',
          right: 'rotate(90deg) scaleX(-1) translate(-' + (height / 2 + 5) + 'px, -' + (width + 28) + 'px)',
          bottom: 'rotate(0deg) scaleX(-1) translate(-' + width / 2 + 'px, ' + (height + 40) + 'px)',
          left: 'rotate(90deg) scaleX(-1) translate(-' + (height / 2 - 5) + 'px, ' + 55 + 'px)'
        };

        var addAxis = function addAxis(pos) {
          if (isAxisLabels[pos]) {
            axisLabelsGroup.append('text').attr('class', 'axis-label-' + pos).attr('text-anchor', 'middle').attr('transform', isRTL ? '' : place[pos]).style('font-size', '1.25em').style('transform', isRTL ? placeStyle[pos] : '').text(axisLabels[pos]);
          }
        };

        for (i = 0, l = axisArray.length; i < l; i++) {
          addAxis(axisArray[i]);
        }
      }

      // Append The Axis to the svg
      self.svg.append('g').attr('class', 'x axis').attr('transform', 'translate(0,' + height + ')').call(xAxis);

      self.svg.append('g').attr('class', 'y axis').call(yAxis);

      // Offset the tick inside, uses the fact that the yAxis has 20 added.
      self.svg.selectAll('.tick line').attr('x1', '-10');

      if (self.settings.isBubble || self.settings.isScatterPlot) {
        self.svg.selectAll('.x.axis .tick line, .y.axis .tick line').style('opacity', 0);
        self.svg.select('.x.axis .tick line').attr('x2', '-10').style('opacity', 1);
        self.svg.select('.y.axis .tick line').style('opacity', 1);
      }

      if (isRTL) {
        self.svg.selectAll('text').attr('transform', 'scale(-1, 1)');
        self.svg.selectAll('.y.axis text').style('text-anchor', 'end');
      }

      if (isAxisXRotate) {
        self.svg.selectAll('.x.axis .tick text') // select all the text for the xaxis
        .attr('y', 0).attr('x', function () {
          return -(this.getBBox().width + 10);
        }).attr('dy', '1em').attr('transform', 'rotate(' + self.settings.xAxis.rotate + ')').style('text-anchor', 'start');
      }

      if (self.settings.xAxis && self.settings.xAxis.formatText) {
        self.svg.selectAll('.x.axis .tick text').each(function (m) {
          var elem = d3.select(this);
          var text = d3.select(this).text();
          var markup = self.settings.xAxis.formatText(text, m);
          DOM.html(elem.node(), markup, '<tspan><text><glyph>');
        });
      }

      // Create the line generator
      var line = d3.line().x(function (d, n) {
        if (!!self.settings.xAxis && !!self.settings.xAxis.parser) {
          return xScale(self.settings.xAxis.parser(d, n));
        }
        return xScale(self.settings.isBubble || self.settings.isScatterPlot ? d.value.x : n);
      }).y(function (d) {
        return yScale(self.settings.isBubble || self.settings.isScatterPlot ? d.value.y : d.value);
      });

      // Append the lines
      dataset.forEach(function (d, lineIdx) {
        var lineGroups = self.svg.append('g').attr('data-group-id', lineIdx).attr('class', 'line-group');

        if (self.settings.isArea) {
          var area = d3.area().x(function (dc, p) {
            return xScale(p);
          }).y0(height).y1(function (db) {
            return yScale(self.settings.isBubble || self.settings.isScatterPlot ? db.value.y : db.value);
          });

          lineGroups.append('path').datum(d.data).attr('fill', function () {
            return charts.chartColor(lineIdx, 'line', d);
          }).style('opacity', '.2').attr('class', 'area').attr('d', area);
        }

        var path = lineGroups.append('path').datum(d.data).attr('d', line(d.data)).attr('stroke', function () {
          return self.settings.isBubble || self.settings.isScatterPlot ? '' : charts.chartColor(lineIdx, 'line', d);
        }).attr('stroke-width', 2).attr('fill', 'none').attr('class', 'line').on('click.chart', function () {
          charts.selectElement(d3.select(this.parentNode), self.svg.selectAll('.line-group'), d, self.element);
        });

        // Add animation
        var totalLength = path.node().getTotalLength();
        path.attr('stroke-dasharray', totalLength + ' ' + totalLength).attr('stroke-dashoffset', totalLength).transition().duration(self.settings.animate ? 600 : 0).ease(d3.easeCubic).attr('stroke-dashoffset', 0);

        var handleMouseEnter = function handleMouseEnter(elem, mouseEnterData) {
          var rect = elem.getBoundingClientRect();
          var content = '<p><b>' + mouseEnterData.name + ' </b> ' + format(mouseEnterData.value) + '</p>';

          var show = function show() {
            var size = charts.tooltipSize(content);
            var posX = rect.left - size.width / 2 + 6;
            var posY = rect.top - size.height - 18;

            posX = self.settings.isBubble || self.settings.isScatterPlot ? rect.left + rect.width / 2 - size.width / 2 : posX;

            if (content !== '') {
              charts.showTooltip(posX, posY, content, 'top');
            }
          };

          if (self.settings.isBubble || self.settings.isScatterPlot) {
            content = '<div class="chart-swatch line"><div class="swatch-caption"><span class="indicator-box"></span>\n            <b>' + mouseEnterData.name + '</b></div>';

            for (var key in mouseEnterData) {
              //eslint-disable-line
              if (mouseEnterData.hasOwnProperty(key)) {
                //eslint-disable-line
                if (_typeof(mouseEnterData[key]) !== 'object') {
                  content += '' + ('' + '<div class="swatch-row">' + '<span>') + labels[key] + '</span>' + ('<b>' + d.name + '</b>') + '</div>';
                } else {
                  var obj2 = mouseEnterData[key];
                  for (var key2 in obj2) {
                    //eslint-disable-line
                    if (obj2.hasOwnProperty(key2)) {
                      //eslint-disable-line
                      content += '' + ('' + '<div class="swatch-row">' + '<span class="text-capitalize">') + labels[key][key2] + '</span>' + ('<b>' + formatValue(valueFormatterString[key2], obj2[key2]) + '</b>') + '</div>';
                    }
                  }
                }
              }
            }
            content += '</div>';
          }

          if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
            content = '';
            var runInterval = true;
            tooltipInterval = setInterval(function () {
              if (runInterval) {
                runInterval = false;
                tooltipData(function (data) {
                  content = data;
                  tooltipDataCache[i] = data;
                });
              }
              if (content !== '') {
                clearInterval(tooltipInterval);
                show();
              }
            }, 10);
          } else {
            tooltipData = (typeof tooltipData === 'undefined' ? 'undefined' : _typeof(tooltipData)) === 'object' ? '' : tooltipData;
            content = tooltipDataCache[i] || tooltipData || mouseEnterData.tooltip || d.tooltip || content || '';
            show();

            // Set the colors
            var spans = document.querySelectorAll('#svg-tooltip .swatch-caption span');
            for (var k = 0; k < spans.length; k++) {
              spans[k].style.backgroundColor = charts.chartColor(k, 'line', mouseEnterData);
            }
          }

          // Circle associated with hovered point
          d3.select(this).attr('r', function (df) {
            return self.settings.isBubble ? 2 + zScale(df.value.z) : dots.radiusOnHover;
          });
        };

        if (!hideDots) {
          if (!self.settings.isScatterPlot) {
            lineGroups.selectAll('circle').data(d.data).enter().append('circle').attr('class', dots.class).attr('cx', function (dd, p) {
              if (!!self.settings.xAxis && !!self.settings.xAxis.parser) {
                return xScale(self.settings.xAxis.parser(dd, p));
              }
              return xScale(self.settings.isBubble || self.settings.isScatterPlot ? dd.value.x : p);
            }).attr('cy', function (de) {
              return yScale(self.settings.isBubble || self.settings.isScatterPlot ? 0 : de.value);
            }).attr('r', dots.radius).style('stroke-width', dots.strokeWidth).style('fill', function () {
              return charts.chartColor(lineIdx, 'line', d);
            }).style('opacity', self.settings.isBubble || self.settings.isScatterPlot ? '.7' : '1').on('mouseenter.chart', function (mouseEnterData) {
              handleMouseEnter(this, mouseEnterData);
            }).on('mouseleave.chart', function () {
              clearInterval(tooltipInterval);
              charts.hideTooltip();
              d3.select(this).attr('r', function (dg) {
                return self.settings.isBubble ? zScale(dg.value.z) : dots.radius;
              });
            }).on('click.chart', function (dh) {
              charts.selectElement(d3.select(this.parentNode), self.svg.selectAll('.line-group'), dh, self.element);
            });
          }

          if (self.settings.isScatterPlot) {
            lineGroups.selectAll('.symbol').data(d.data).enter().append('path').attr('class', 'symbol').attr('transform', function (ds) {
              return 'translate(' + xScale(ds.value.x) + ',' + yScale(ds.value.y) + ')';
            }).attr('d', d3.symbol().size(dots.strokeWidth).type(function () {
              return d3.symbols[lineIdx];
            })).style('opacity', 0).style('fill', function () {
              return charts.chartColor(lineIdx, 'line', d);
            }).on('mouseenter.chart', function (mouseEnterData) {
              handleMouseEnter(this, mouseEnterData);
            }).on('mouseleave.chart', function () {
              clearInterval(tooltipInterval);
              charts.hideTooltip();
              d3.select(this).attr('r', function () {
                return dots.radius;
              });
            }).on('click.chart', function (dh) {
              charts.selectElement(d3.select(this.parentNode), self.svg.selectAll('.line-group'), dh, self.element);
            });
          }
          if (self.settings.isBubble) {
            // Add animation
            lineGroups.selectAll('circle').attr('cy', function (di) {
              return yScale(di.value.y);
            }).transition().duration(self.settings.animate ? 750 : 0).ease(d3.easeCubic).attr('r', function (dj) {
              return zScale(dj.value.z);
            });
          }

          if (self.settings.isScatterPlot) {
            // Add animation
            lineGroups.selectAll('.symbol').transition().duration(self.settings.animate ? 750 : 0).ease(d3.easeCubic).style('opacity', 1);
          }
        }
      });

      // Set y-axix tick css class
      self.svg.selectAll('.y.axis .tick').attr('class', function (di) {
        return 'tick' + (di === 0 ? ' tick0' : '');
      });

      var series = dataset.map(function (d) {
        return { color: d.color, name: d.name, selectionObj: self.svg.selectAll('.line-group'), selectionInverse: self.svg.selectAll('.line-group'), data: d };
      });

      if (this.settings.showLegend) {
        charts.addLegend(series, self.settings.isScatterPlot ? 'scatterplot' : 'line', this.settings, this.element);
      }
      charts.appendTooltip();

      charts.setSelected = function (o, isToggle) {
        var selected = 0;
        var equals = utils.equals;
        var selector = void 0;
        var selectorData = void 0;
        var elem = void 0;

        var setSelected = function setSelected(d, i1, d2, i2) {
          if (d2) {
            elem = self.svg.select('[data-group-id="' + i1 + '"]').select('.dot:nth-child(' + (i2 + 2) + ')');
            if (typeof o.groupIndex === 'number' && typeof o.fieldName !== 'undefined' && typeof o.fieldValue !== 'undefined' && o.groupIndex === i1 && o.fieldValue === d2[o.fieldName] || typeof o.index !== 'undefined' && typeof o.groupIndex === 'number' && o.groupIndex === i1 && o.index === i2 || o.elem && $(elem.node()).is(o.elem) || o.data && equals(o.data, d2)) {
              selected++;
              selectorData = d2;
              selector = self.svg.select('[data-group-id="' + i1 + '"]');
            }
          } else {
            elem = self.svg.select('[data-group-id="' + i1 + '"]');
            if (typeof o.groupName !== 'undefined' && typeof o.groupValue !== 'undefined' && o.groupValue === d[o.groupName] || typeof o.groupIndex !== 'undefined' && o.groupIndex === i1 || o.elem && $(elem.node()).is(o.elem) || o.data && equals(o.data, d)) {
              selected++;
              selectorData = d;
              selector = elem;
            }
          }
        };

        dataset.forEach(function (d, i3) {
          if (selected < 1 && d && d.data) {
            d.data.forEach(function (d2, i2) {
              if (selected < 1 && d2) {
                setSelected(d, i3, d2, i2);
              }
            });
            if (selected < 1) {
              setSelected(d, i3);
            }
          }
        });

        if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
          charts.selectElement(selector, self.svg.selectAll('.line-group'), selectorData, self.element);
        }
      };

      this.setInitialSelected();
      this.element.trigger('rendered');
      return this;
    },


    /**
     * Set the initially selected elements
     * @private
     */
    setInitialSelected: function setInitialSelected() {
      var self = this;
      var selected = 0;
      var selector = void 0;
      var selectorData = void 0;

      var setInitialSelected = function setInitialSelected(node, d, selectedIdx) {
        if (node.selected && selected < 1) {
          selected++;
          selector = d3.select(self.svg.selectAll('.line-group').nodes()[selectedIdx]);
          selectorData = d;
        }
      };

      this.settings.dataset.forEach(function (d, setIdx) {
        if (d) {
          setInitialSelected(d, d, setIdx);
        }
      });

      this.settings.dataset.forEach(function (d, setIdx) {
        if (d || d.data) {
          d.data.forEach(function (d2) {
            setInitialSelected(d2, d, setIdx);
          });
        }
      });

      if (selected > 0) {
        charts.selectElement(selector, self.svg.selectAll('.line-group'), selectorData, self.element);
      }
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on('updated.' + COMPONENT_NAME$l, function () {
        _this.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on('resize.' + COMPONENT_NAME$l, function () {
          _this.handleResize();
        });

        this.element.on('resize.' + COMPONENT_NAME$l, function () {
          _this.handleResize();
        });
      }

      return this;
    },


    width: 0,

    /*
     * Get info on the currently selected lines.
     * @returns {object} An object with the matching data and reference to the triggering element.
     */
    getSelected: function getSelected() {
      return charts.selected;
    },


    /*
     * Get info on the currently selected lines.
     */
    setSelected: function setSelected(options, isToggle) {
      var internals = {
        svg: this.svg,
        chartData: this.settings.dataset,
        isStacked: false,
        isGrouped: false,
        isSingle: false
      };
      charts.setSelected(options, isToggle, internals);
    },


    /*
     * Get info on the currently selected lines.
     */
    toggleSelected: function toggleSelected(options) {
      this.setSelected(options, true);
    },


    /*
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      this.element.empty();

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }
      return this.build();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$l);
      $('body').off('resize.' + COMPONENT_NAME$l);
      return this;
    },


    /**
     * Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('line-chart');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$l);
      $.removeData(this.element[0], 'chart');
    }
  };

  /* eslint-disable no-nested-ternary, prefer-arrow-callback */

  // Settings and Options
  var COMPONENT_NAME$m = 'column';

  /**
  * A column chart displays a series as a set of vertical bars that are grouped by category.
  * Column charts are useful for showing data changes over a period of time or for illustrating
  * comparisons among items.
  * @class Column
  * @param {string} element The plugin element for the constuctor
  * @param {string} [settings] The settings element.
  *
  * @param {array} [settings.dataset = []] The data to use in the line/area/bubble.
  * @param {boolean} [settings.isStacked = false] Set to true if its a stacked column chart
  * @param {boolean} [settings.showLegend = true] If false the legend will not be shown.
  * @param {boolean|string} [settings.animate = true] true|false - will do or not do the animation. 'initial' will do only first time the animation.
  * @param {boolean} [settings.redrawOnResize = true] If true, the component will not resize when resizing the page.
  * @param {string} [settings.format = null] The d3 axis format
  * @param {string} [settings.formatterString] Use d3 format some examples can be found on http://bit.ly/1IKVhHh
  * @param {number} [settings.ticks = 9] The number of ticks to show.
  * @param {function} [settings.xAxis.formatText] A function that passes the text element and a counter.
  * You can return a formatted svg markup element to replace the current element.
  * For example you could use tspans to wrap the strings or color them.
  * @param {object} [settings.emptyMessage = { title: 'No Data', info: , icon: 'icon-empty-no-data' }]
  * An empty message will be displayed when there is no chart data. This accepts an object of the form
  * `emptyMessage: {
  *   title: 'No Data Available',
  *   info: 'Make a selection on the list above to see results',
  *   icon: 'icon-empty-no-data',
  *   button: {text: 'xxx', click: <function>
  *   }`
  * Set this to null for no message or will default to 'No Data Found with an icon.'
  */

  var COLUMN_DEFAULTS = {
    dataset: [],
    isStacked: false,
    showLegend: true,
    animate: true,
    format: null,
    redrawOnResize: true,
    ticks: 9,
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' }
  };

  function Column(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COLUMN_DEFAULTS);
    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Column.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.width = 0;

      this.build().handleEvents();

      // Handle initial option
      if (this.settings.animate === 'initial') {
        this.settings.animate = false;
      }

      return this;
    },


    /**
     * Build the Component.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    build: function build() {
      var self = this;
      var isFormatter = !!this.settings.formatterString;
      var format = function format(value) {
        return isFormatter ? d3.format(self.settings.formatterString)(value) : value;
      };

      var datasetStacked = void 0;
      var dataset = this.settings.dataset;
      this.dataset = dataset;

      // Handle Empty Data Set
      if (dataset.length === 0) {
        self.element.emptymessage(self.settings.emptyMessage);
        return this;
      }

      var parent = this.element.parent();
      var isRTL = Locale.isRTL();
      var isPositiveNegative = this.settings.type === 'column-positive-negative' || this.settings.type === 'positive-negative';
      var isSingle = dataset.length === 1;
      this.isSingle = isSingle;
      var isGrouped = !(isSingle || !isSingle && self.settings.isStacked);
      this.isGrouped = isGrouped;

      var margin = {
        top: 40,
        right: 40,
        bottom: isSingle && dataset[0].name === undefined ? self.settings.isStacked ? 20 : 50 : 35,
        left: 45
      };
      var legendHeight = 40;
      var width = parent.width() - margin.left - margin.right - 10;
      var height = parent.height() - margin.top - margin.bottom - (isSingle && dataset[0].name === undefined ? self.settings.isStacked || isPositiveNegative ? legendHeight - 10 : 0 : legendHeight);
      var yMinTarget = void 0;
      var yMaxTarget = void 0;
      var series = void 0;
      var seriesStacked = void 0;
      var pnColors = void 0;
      var pnPatterns = void 0;
      var pnLegends = void 0;
      var pnSeries = void 0;

      var yMin = d3.min(dataset, function (group) {
        return d3.min(group.data, function (d) {
          return d.value;
        });
      });

      var yMax = d3.max(dataset, function (group) {
        //eslint-disable-line
        return d3.max(group.data, function (d) {
          return d.value;
        });
      });

      if (isPositiveNegative) {
        yMinTarget = d3.min(dataset, function (group) {
          return d3.min(group.data, function (d) {
            return d.target;
          });
        });

        yMaxTarget = d3.max(dataset, function (group) {
          return d3.max(group.data, function (d) {
            return d.target;
          });
        });

        yMin = d3.min([yMin, yMinTarget]);
        yMax = d3.max([yMax, yMaxTarget]);

        pnLegends = { target: 'Target', positive: 'Positive', negative: 'Negative' };
        pnColors = { target: 'neutral', positive: 'good', negative: 'error' };
        pnPatterns = {};

        if (dataset[0]) {
          if (dataset[0].colors) {
            $.extend(true, pnColors, dataset[0].colors);
          }
          if (dataset[0].legends) {
            $.extend(true, pnLegends, dataset[0].legends);
          }
          if (dataset[0].patterns) {
            $.extend(true, pnPatterns, dataset[0].patterns);
          }
        }
        // Converting object into array
        pnSeries = [];
        $.each(pnLegends, function (key, val) {
          pnSeries.push({
            name: val,
            color: pnColors[key],
            pattern: pnPatterns[key],
            option: key
          });
        });
      }

      this.element.addClass('column-chart');

      var tooltipInterval = void 0;
      var tooltipDataCache = [];
      var tooltipData = self.settings.tooltip;

      var x0 = d3.scaleBand().range([0, width]).round(true).padding(0.1);

      var x1 = d3.scaleBand();

      var y = d3.scaleLinear().range([height, 0]);

      var xScale = null;
      var yScale = null;

      if (self.settings.isStacked) {
        // Map the Data Sets and Stack them.
        var yStack = { y1: [], y2: [] };
        if (isSingle) {
          datasetStacked = dataset[0].data.map(function (d, i) {
            var y0 = 0;
            if (i === 0) {
              yStack.y1.push(d.value);
              yStack.y2.push(0);
            } else {
              y0 = yStack.y1[0] + yStack.y2[0];
              yStack.y1[0] = d.value;
              yStack.y2[0] = y0;
            }
            return [$.extend({}, d, {
              y0: y0,
              y: d.value,
              x: d.name,
              color: d.color,
              pattern: d.pattern,
              parentName: d.name,
              tooltip: d.tooltip
            })];
          });
        } else {
          datasetStacked = dataset.map(function (d, i) {
            return d.data.map(function (o, i2) {
              var y0 = 0;
              if (i === 0) {
                yStack.y1.push(o.value);
                yStack.y2.push(0);
              } else {
                y0 = yStack.y1[i2] + yStack.y2[i2];
                yStack.y1[i2] = o.value;
                yStack.y2[i2] = y0;
              }
              return $.extend({}, o, {
                y0: y0,
                y: o.value,
                x: o.name,
                color: o.color,
                pattern: o.pattern,
                parentName: d.name,
                tooltip: d.tooltip
              });
            });
          });
        }

        var stack = d3.stack();
        stack(datasetStacked);

        xScale = d3.scaleBand().domain(d3.range(datasetStacked[0].length)).rangeRound([0, width], 0.05);

        if (isSingle && self.settings.isStacked) {
          xScale.paddingInner(0.095);
        }

        yScale = d3.scaleLinear().domain([0, d3.max(datasetStacked, function (d) {
          return d3.max(d, function (d1) {
            return d1.y0 + d1.y;
          });
        })]).range([0, height]);
      }

      // List the values along the x axis
      var xAxisValues = dataset[0].data.map(function (d) {
        return d.name;
      });

      var xAxis = d3.axisBottom(x0).tickSize(0).tickPadding(12);

      var yAxis = d3.axisLeft(y).tickSize(-width).tickPadding(isRTL ? -12 : 12).ticks(self.settings.ticks || 9, d3.format(self.settings.format || 's'));

      if (self.settings.yAxis) {
        if (self.settings.yAxis.formatter) {
          yAxis.tickFormat(function (d, k) {
            if (typeof self.settings.yAxis.formatter === 'function') {
              return self.settings.yAxis.formatter(d, k);
            }
            return d;
          });
        }

        if (self.settings.yAxis.ticks && self.settings.yAxis.ticks.number > 1 && self.settings.yAxis.ticks.format) {
          yAxis.ticks(self.settings.yAxis.ticks.number, self.settings.yAxis.ticks.format);
        }
      }

      var svg = d3.select(this.element[0]).append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      this.svg = svg;

      // Get the Different Names
      var names = dataset.map(function (d) {
        return d.name;
      });

      // Get the Maxes of each series
      var maxesStacked = void 0;
      var maxes = dataset.map(function (d) {
        return d3.max(d.data, function (maxD) {
          return isPositiveNegative ? maxD.target : maxD.value;
        });
      });

      if (self.settings.isStacked) {
        maxesStacked = datasetStacked.map(function (maxesD) {
          return d3.max(maxesD, function (d) {
            return d.y + d.y0;
          });
        });
      }

      if (isSingle) {
        names = dataset[0].data.map(function (d) {
          return d.name;
        });
      }

      // Extra ticks
      if (isPositiveNegative) {
        yMin += yMin / y.ticks().length;
        maxes[0] += maxes[0] / (y.ticks().length / 2);
      }

      // Set series
      (function () {
        if (self.settings.isStacked && isSingle) {
          series = dataset[0].data;
        } else {
          var lm = void 0;
          // Loop backwards to catch and override with found first custom info from top
          for (var i = dataset.length - 1, l = -1; i > l; i--) {
            lm = dataset[i].data.map(function (d) {
              return d;
            });
            $.extend(true, series, lm);
            // Convert back to array from object
            series = $.map(series, function (d) {
              return d;
            });
          }
        }
      })();

      if (self.settings.isStacked && !isSingle) {
        seriesStacked = names.map(function (d, i) {
          return dataset[i];
        });
      }

      x0.domain(self.settings.isStacked ? xAxisValues : names);
      x1.domain(xAxisValues).rangeRound([0, isSingle || self.settings.isStacked ? width : x0.bandwidth()]);
      y.domain([yMin < 0 ? yMin : self.settings.minValue || 0, d3.max(self.settings.isStacked ? maxesStacked : maxes)]).nice();

      if (!isSingle || isSingle && !self.settings.isStacked) {
        svg.append('g').attr('class', 'x axis').attr('transform', 'translate(0,' + (height + (isPositiveNegative ? 10 : 0)) + ')').call(xAxis);
      }

      svg.append('g').attr('class', 'y axis').call(yAxis);

      // Adjust extra(x) space for negative values for RTL
      if (isRTL && yMin < 0) {
        var yMaxLength = 0;
        var tempLength = void 0;

        svg.selectAll('.axis.y text').attr('class', function (d) {
          tempLength = d3.select(this).text().length;
          yMaxLength = tempLength > yMaxLength ? tempLength : yMaxLength;
          return d < 0 ? 'negative-value' : 'positive-value';
        }).attr('x', function (d) {
          return yMaxLength * (d < 0 ? 9 : 5);
        });
      }

      // Make an Array of objects with name + array of all values
      var dataArray = [];
      dataset.forEach(function (d) {
        dataArray.push($.extend({}, d, { values: d.data }));
      });

      if (isSingle) {
        dataArray = [];
        names = dataset[0].data.forEach(function (d) {
          dataArray.push(d);
        });
      }

      var targetBars = void 0;
      var pnBars = void 0;
      var barMaxWidth = 35;
      var barsInGroup = dataArray[0] && dataArray[0].values ? dataArray[0].values.length : 0;
      var isGroupSmaller = width / dataArray.length > barMaxWidth * (barsInGroup + 1);
      var color = function color(colorStr) {
        return charts.chartColor(0, '', { color: colorStr });
      };
      var onEndAllTransition = function onEndAllTransition(transition, callback) {
        var n = void 0;
        if (transition.empty()) {
          callback();
        } else {
          n = transition.size();
          transition.on('end', function () {
            n--;
            if (n === 0) {
              callback();
            }
          });
        }
      };

      var drawBars = function drawBars(isTargetBars) {
        var bars = void 0; //eslint-disable-line
        isTargetBars = isPositiveNegative && isTargetBars;

        // Add the bars - done different depending on if grouped or singlular
        if (isSingle || isPositiveNegative) {
          bars = self.svg.selectAll('rect' + (isTargetBars ? '.target-bar' : '.bar')).data(self.settings.isStacked ? datasetStacked : dataArray).enter().append('rect').attr('class', function (d, i) {
            var classStr = 'bar series-' + i;

            if (isPositiveNegative) {
              classStr = (isTargetBars ? 'target-bar series-' + i : classStr) + (d.value > 0 ? ' positive' : ' negative');
            }
            return classStr;
          }).attr('width', Math.min.apply(null, [x1.bandwidth() - 2, barMaxWidth])).attr('x', function (d) {
            return self.settings.isStacked ? xScale(0) : x1(d.name) + (x1.bandwidth() - barMaxWidth) / 2;
          }).attr('y', function () {
            return y(0) > height ? height : y(0);
          }).attr('height', function () {
            return 0;
          }).attr('mask', function (d) {
            return !isPositiveNegative ? null : isTargetBars ? pnPatterns.target ? 'url(#' + pnPatterns.target + ')' : null : d.value < 0 ? pnPatterns.negative ? 'url(#' + pnPatterns.negative + ')' : null : pnPatterns.positive ? 'url(#' + pnPatterns.positive + ')' : null;
          }).style('fill', function (d) {
            return !isPositiveNegative ? null : color(isTargetBars ? pnColors.target : d.value < 0 ? pnColors.negative : pnColors.positive);
          });

          if (isPositiveNegative) {
            var yTextPadding = 12;
            svg.selectAll(isTargetBars ? '.target-bartext' : '.bartext').data(dataArray).enter().append('text').attr('class', function (d) {
              return (isTargetBars ? 'target-bartext' : 'bartext') + (d.value > 0 ? ' positive' : ' negative');
            }).attr('text-anchor', 'middle').attr('x', function (d) {
              return (x1(d.name) + x1.bandwidth() / 2) * (isRTL ? -1 : 1);
            }).attr('y', function (d) {
              return isTargetBars ? y(d.target) - yTextPadding / 2 : y(d.value > 0 ? 0 : d.value) + yTextPadding;
            }).style('opacity', 0).style('fill', function (d) {
              return isTargetBars ? '' /* color(pnColors.target) */ : d.value < 0 ? color(pnColors.negative) : color(pnColors.positive);
            }).style('font-weight', 'bold').text(function (d) {
              return format(isTargetBars ? d.target : d.value);
            });
          }

          bars.transition().duration(self.settings.animate ? 1000 : 0).call(onEndAllTransition, function () {
            svg.selectAll('.target-bartext, .bartext').transition().duration(self.settings.animate ? 300 : 0).style('opacity', 1);
          }).attr('y', function (d) {
            var r = self.settings.isStacked ? height - yScale(d[0].y) - yScale(d[0].y0) : d.value < 0 ? y(0) : y(d.value);
            return isTargetBars ? y(d.target) : d.value < 0 ? r : r > height - 3 ? height - 2 : r;
          }).attr('height', function (d) {
            var r = void 0;
            if (self.settings.isStacked) {
              r = yScale(d[0].y);
            } else if (d.value < 0) {
              r = height - y(0) - (height - y(d.value));
            } else {
              r = height - y(d.value) - (height - y(0));
            }
            r = d.value < 0 ? r : r < 3 ? 2 : r > height ? height - y(d.value) : r;
            return isTargetBars ? height - y(d.target) - (height - y(0)) : r;
          });
        } else {
          var xValues = svg.selectAll('.x-value').data(self.settings.isStacked ? datasetStacked : dataArray).enter().append('g').attr('class', 'series-group g').attr('data-group-id', function (d, i) {
            return i;
          }).attr('transform', function (d) {
            var x = x0(self.settings.isStacked ? xAxisValues[0] : d.name);
            var bandwidth = x0.bandwidth();
            if (!self.settings.isStacked && isGroupSmaller && bandwidth > barMaxWidth * dataArray.length * 2) {
              x += x0.bandwidth() / 2 / dataArray.length / 2;
            }
            return 'translate(' + x + ',0)';
          });

          bars = xValues.selectAll('rect').data(function (d) {
            return self.settings.isStacked ? d : d.values;
          }).enter().append('rect').attr('class', function (d, i) {
            return 'series-' + i + ' bar';
          }).attr('width', Math.min.apply(null, [x1.bandwidth() - 2, barMaxWidth])).attr('x', function (d, i) {
            var width = Math.min.apply(null, [x1.bandwidth() - 2, barMaxWidth]); //eslint-disable-line
            return self.settings.isStacked ? xScale(i) : x1.bandwidth() / 2 + (width + 2) * i - (dataArray[0].values.length === 1 || dataArray[0].values.length === 5 || dataArray[0].values.length === 4 ? width / 2 : 0);
          }).attr('y', function () {
            return y(0) > height ? height : y(0);
          }).attr('height', function () {
            return 0;
          });

          bars.transition().duration(self.settings.animate ? 600 : 0).attr('y', function (d) {
            var r = self.settings.isStacked ? height - yScale(d.y) - yScale(d.y0) : d.value < 0 ? y(0) : y(d.value);
            return d.value < 0 ? r : r > height - 3 ? height - 2 : r;
          }).attr('height', function (d) {
            var r = void 0;
            if (self.settings.isStacked) {
              r = yScale(d.y);
            } else if (d.value < 0) {
              r = height - y(0) - (height - y(d.value));
            } else {
              r = height - y(d.value) - (height - y(0));
            }
            return d.value < 0 ? r : r < 3 ? 2 : r > height ? height - y(d.value) : r;
          });
        }
        return bars;
      };

      if (isPositiveNegative) {
        targetBars = drawBars(true); // Draw target bars
      }
      var bars = drawBars();

      if (isPositiveNegative) {
        pnBars = d3.selectAll([].concat(toConsumableArray(targetBars.nodes()), toConsumableArray(bars.nodes())));
      }

      if (!isPositiveNegative) {
        // Style the bars and add interactivity
        if (!self.settings.isStacked) {
          bars.style('fill', function (d, i) {
            return isSingle ? charts.chartColor(i, 'column-single', dataset[0].data[i]) : charts.chartColor(i, 'bar', series[i]);
          }).attr('mask', function (d, i) {
            return isSingle ? dataset[0].data[i].pattern ? 'url(#' + dataset[0].data[i].pattern + ')' : null : series[i].pattern ? 'url(#' + series[i].pattern + ')' : null;
          });
        } else if (self.settings.isStacked && !isSingle) {
          bars.style('fill', function () {
            var thisGroup = d3.select(this.parentNode).attr('data-group-id');
            return charts.chartColor(thisGroup, 'bar', dataset[thisGroup]);
          }).attr('mask', function () {
            var thisGroup = d3.select(this.parentNode).attr('data-group-id');
            return dataset[thisGroup].pattern ? 'url(#' + dataset[thisGroup].pattern + ')' : null;
          });
        } else if (self.settings.isStacked && isSingle) {
          bars.style('fill', function (d, i) {
            return charts.chartColor(i, 'bar', d[0]);
          }).attr('mask', function (d) {
            return d[0].pattern ? 'url(#' + d[0].pattern + ')' : null;
          });
        }
      }

      $.extend(charts.settings, {
        svg: svg,
        chartType: 'Column',
        isSingle: isSingle,
        isGrouped: isGrouped,
        isStacked: self.settings.isStacked
      });

      (isPositiveNegative ? pnBars : bars).on('mouseenter', function (d, i) {
        var x = void 0;
        var y = void 0; //eslint-disable-line
        var j = void 0;
        var l = void 0;
        var hexColor = void 0;
        var size = void 0;
        var isTooltipBottom = void 0;
        var maxBarsForTopTooltip = 6;
        var thisShape = this;
        var shape = $(this);
        var content = '';
        var ePageY = d3.event.pageY;

        var setPattern = function setPattern(pattern, hexColor) {
          //eslint-disable-line
          return !pattern || !hexColor ? '' : '' + ('<svg width="12" height="12">' + '<rect style="fill: ') + hexColor + '" mask="url(#' + pattern + ')" height="12" width="12" />' + '</svg>';
        };

        var show = function show(isTooltipBottom) {
          //eslint-disable-line
          size = charts.tooltipSize(content);
          x = shape[0].getBoundingClientRect().left - size.width / 2 + shape.attr('width') / 2;

          if (self.settings.isStacked) {
            y = shape[0].getBoundingClientRect().top - size.height - 10;
          } else {
            y = ePageY - charts.tooltip.outerHeight() - 25;
            if (dataset.length > 1) {
              x = thisShape.parentNode.getBoundingClientRect().left - size.width / 2 + thisShape.parentNode.getBoundingClientRect().width / 2;
              if (isTooltipBottom) {
                y += charts.tooltip.outerHeight() + 50;
                if (y > thisShape.parentNode.getBoundingClientRect().bottom + 10) {
                  y = thisShape.parentNode.getBoundingClientRect().bottom + 10;
                }
              } else {
                y = thisShape.parentNode.getBoundingClientRect().top - charts.tooltip.outerHeight() + 25;
              }
            }
          }

          if (content !== '') {
            charts.showTooltip(x, y, content, isTooltipBottom ? 'bottom' : 'top');
          }
        };

        // Stacked
        if (self.settings.isStacked) {
          if (isSingle) {
            content = '<p><b>' + format(d[0].value) + '</b> ' + d[0].name + '</p>';
          } else {
            content = '' + ('' + '<div class="chart-swatch">' + '<div class="swatch-caption"><b>') + datasetStacked[0][i].name + '</b></div>';
            for (j = datasetStacked.length - 1, l = 0; j >= l; j--) {
              hexColor = charts.chartColor(j, 'bar', dataset[j]);
              content += '' + ('' + '<div class="swatch-row">' + '<div style="background-color:') + (dataset[j].pattern ? 'transparent' : hexColor) + ';">' + setPattern(dataset[j].pattern, hexColor) + '</div>' + ('<span>' + datasetStacked[j][i].parentName + '</span><b>' + format(datasetStacked[j][i].value) + '</b>') + '</div>';
            }
            content += '</div>';
          }
          size = charts.tooltipSize(content);
          x = shape[0].getBoundingClientRect().left - size.width / 2 + shape.attr('width') / 2;
          y = shape[0].getBoundingClientRect().top - size.height - 10;
        } else {
          // Not Stacked
          if (isPositiveNegative) {
            content = '' + ('' + '<div class="chart-swatch">' + '<div class="swatch-caption"><b>') + d.name + '</b></div>' + '<div class="swatch-row">' + ('<div style="background-color:' + (pnPatterns.target ? 'transparent' : color(pnColors.target)) + ';">' + setPattern(pnPatterns.target, color(pnColors.target)) + '</div>') + ('<span>' + pnLegends.target + '</span><b>' + format(d.target) + '</b>') + '</div>' + '<div class="swatch-row">' + ('<div style="background-color:' + (d.value < 0 ? pnPatterns.negative ? 'transparent' : color(pnColors.negative) : pnPatterns.positive ? 'transparent' : color(pnColors.positive)) + ';">' + (d.value < 0 ? setPattern(pnPatterns.negative, color(pnColors.negative)) : setPattern(pnPatterns.positive, color(pnColors.positive))) + '</div>') + ('<span>' + pnLegends[d.value < 0 ? 'negative' : 'positive'] + '</span><b>' + format(d.value) + '</b>') + '</div>' + '</div>';
          } else if (dataset.length === 1) {
            content = '<p><b>' + format(d.value) + '</b> ' + d.name + '</p>';
          } else {
            var data = d3.select(this.parentNode).datum().values;

            content = '<div class="chart-swatch">';
            for (j = 0, l = data.length; j < l; j++) {
              hexColor = charts.chartColor(j, 'bar', series[j]);
              content += '' + ('' + '<div class="swatch-row">' + '<div style="background-color:') + (series[j].pattern ? 'transparent' : hexColor) + ';">' + setPattern(series[j].pattern, hexColor) + '</div>' + ('<span>' + data[j].name + '</span><b>' + format(data[j].value) + '</b>') + '</div>';
            }
            content += '</div>';
            isTooltipBottom = data.length > maxBarsForTopTooltip;
          }

          size = charts.tooltipSize(content);
          x = shape[0].getBoundingClientRect().left - size.width / 2 + shape.attr('width') / 2;
          y = ePageY - charts.tooltip.outerHeight() - 25;
          if (dataset.length > 1) {
            x = this.parentNode.getBoundingClientRect().left - size.width / 2 + this.parentNode.getBoundingClientRect().width / 2;
            y = this.parentNode.getBoundingClientRect().top - charts.tooltip.outerHeight() + 25;
          }
        }

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
          content = '';
          var runInterval = true;
          tooltipInterval = setInterval(function () {
            if (runInterval) {
              runInterval = false;
              tooltipData(function (data) {
                content = data;
                tooltipDataCache[i] = data;
              });
            }

            if (content !== '') {
              clearInterval(tooltipInterval);
              show();
            }
          }, 10);
        } else {
          content = tooltipDataCache[i] || tooltipData || content || '';
          if (d.tooltip) {
            var val = d.tooltip.replace('{{value}}', format(d.value));
            content = '<p>' + val + '</p>';
          }
          show(isTooltipBottom);
        }
      })

      // Mouseleave
      .on('mouseleave', function () {
        clearInterval(tooltipInterval);
        charts.hideTooltip();
      })

      // Click
      .on('click', function (d, i, clickedLegend) {
        var isTargetBar = this && d3.select(this).classed('target-bar');
        var isSelected = this && d3.select(this).classed('is-selected');
        var thisGroupId = parseInt(d3.select(this.parentNode).attr('data-group-id'), 10);

        // Set isSelected to false if even 1 bar is selected
        if (isTargetBar) {
          var allBars = d3.selectAll('.bar').nodes();
          var len = allBars.length;

          for (var j = 0; j < len; j++) {
            var bar = allBars[j];

            if (d3.select(bar).classed('is-selected')) {
              isSelected = false;
              break;
            }
          }
        }

        charts.setSelectedElement({
          task: isSelected ? 'unselected' : 'selected',
          container: self.element,
          selector: this,
          isTrigger: !isSelected,
          isTargetBar: isTargetBar,
          triggerGroup: isGrouped,
          d: d,
          i: i,
          type: self.settings.type,
          dataset: self.dataset,
          isSingle: self.isSingle,
          isGrouped: self.isGrouped,
          isStacked: self.settings.isStacked,
          svg: self.svg,
          clickedLegend: clickedLegend === true
        });

        if (isSelected) {
          self.element.triggerHandler('selected', [d3.select(this).nodes(), {}, isGrouped ? thisGroupId : i]);
        }
      })

      // Contextmenu
      .on('contextmenu', function (d) {
        charts.triggerContextMenu(self.element, d3.select(this).nodes()[0], d);
      });

      // Add Legend
      self.settings.isGrouped = isGrouped;
      self.settings.isSingle = isSingle;
      self.settings.isStacked = self.settings.isStacked;
      self.settings.svg = this.svg;

      if (self.settings.showLegend) {
        if (isSingle && dataset[0].name) {
          charts.addLegend(dataset, 'column-single', self.settings, self.element);
        } else if (isPositiveNegative) {
          charts.addLegend(pnSeries, self.settings.type, self.settings, self.element);
        } else if (self.settings.isStacked && isSingle) {
          charts.addLegend(series, self.settings.type, self.settings, self.element);
        } else if (!isSingle) {
          charts.addLegend(self.settings.isStacked ? seriesStacked : series, self.settings.type, self.settings, self.element);
        }
      }

      if (self.settings.xAxis && self.settings.xAxis.formatText) {
        self.svg.selectAll('.x.axis .tick text').each(function (m) {
          var elem = d3.select(this);
          var text = d3.select(this).text();
          var markup = self.settings.xAxis.formatText(text, m);

          DOM.html(elem.node(), markup, '<tspan>');
        });
      }

      if (charts.isRTL && charts.isIE) {
        svg.selectAll('text').attr('transform', 'scale(-1, 1)');
        svg.selectAll('.y.axis text').style('text-anchor', 'start');

        if (isPositiveNegative) {
          svg.selectAll('.negative-value').style('text-anchor', 'end');
        }
      }

      // Set y-axix tick css class
      svg.selectAll('.y.axis .tick').attr('class', function (d) {
        return 'tick' + (d === 0 ? ' tick0' : '');
      });

      // Add Tooltips and legend
      charts.appendTooltip();

      // See if any labels overlap and use shorter */
      // [applyAltLabels] - function(svg, dataArray, elem, selector, isNoEclipse)
      if (charts.labelsColide(svg)) {
        charts.applyAltLabels(svg, dataArray, 'shortName');
      }

      if (charts.labelsColide(svg)) {
        charts.applyAltLabels(svg, dataArray, 'abbrName');
      }

      if (charts.labelsColide(svg)) {
        charts.applyAltLabels(svg, dataArray, null, null, true);

        // Adjust extra(x) space with short name for RTL
        if (isPositiveNegative) {
          svg.selectAll('.target-bartext, .bartext').attr('x', function () {
            return +d3.select(this).attr('x') - (isRTL ? -6 : 6);
          });
        }
      }

      charts.setSelected = function (o, isToggle) {
        var selected = 0;
        var equals = utils.equals;
        var legendsNode = svg.node().parentNode.nextSibling;
        var legends = d3.select(legendsNode);
        var isLegends = legends.node() && legends.classed('chart-legend');
        var barIndex = void 0;
        var selector = void 0;
        var isStackedGroup = void 0;
        var xGroup = void 0;

        var setSelectedBar = function setSelectedBar(g, gIdx) {
          var isGroup = !!g;
          g = isGroup ? d3.select(g) : svg;
          gIdx = typeof gIdx !== 'undefined' ? gIdx : 0;
          g.selectAll('.bar').each(function (d, i) {
            if (!d) {
              return;
            }
            if (selected < 1) {
              if (typeof o.fieldName !== 'undefined' && typeof o.fieldValue !== 'undefined' && o.fieldValue === (isSingle && self.settings.isStacked ? d[0][o.fieldName] : d[o.fieldName]) || //eslint-disable-line
              typeof o.index !== 'undefined' && o.index === i || o.data && equals(o.data, dataset[gIdx].data[i]) || o.elem && $(this).is(o.elem)) {
                selected++;
                selector = d3.select(this);
                barIndex = i;
                if (isGroup && !self.settings.isStacked) {
                  isStackedGroup = true;
                }
              }
            }
          });
        };

        var setSelectedGroup = function setSelectedGroup() {
          var groups = svg.selectAll('.series-group');
          if (groups.nodes().length) {
            groups.each(function (d, i) {
              setSelectedBar(this, i);
            });
          }
        };

        if (isGrouped || self.settings.isStacked && !isSingle && !isGrouped) {
          dataset.forEach(function (d, i) {
            if (selected < 1) {
              xGroup = $(svg.select('[data-group-id="' + i + '"]').node());
              if (typeof o.groupName !== 'undefined' && typeof o.groupValue !== 'undefined' && o.groupValue === d[o.groupName] || typeof o.groupIndex !== 'undefined' && o.groupIndex === i || o.data && equals(o.data, d) || o.elem && xGroup.is(o.elem)) {
                if (typeof o.fieldName === 'undefined' && typeof o.fieldValue === 'undefined' && typeof o.index === 'undefined') {
                  selected++;
                  selector = svg.select('[data-group-id="' + i + '"]').select('.bar');
                  barIndex = i;
                  if (self.settings.isStacked && !isGrouped) {
                    isStackedGroup = true;
                  }
                }
              }
            }
          });
          if (selected < 1) {
            setSelectedGroup();
          }
        } else {
          setSelectedBar();
        }

        if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
          if (isStackedGroup) {
            if (isLegends) {
              $(legends.selectAll('.chart-legend-item')[0][barIndex]).trigger('click.chart');
            }
          } else {
            selector.on('click').call(selector.node(), selector.datum(), barIndex);
          }
        }
      };

      this.setInitialSelected();
      this.element.trigger('rendered');
      return this;
    },


    /**
     * Set the initially selected elements
     * @private
     */
    setInitialSelected: function setInitialSelected() {
      var selected = 0;
      var self = this;
      var legendsNode = self.svg.node().parentNode.nextSibling;
      var legends = d3.select(legendsNode);
      var isLegends = legends.node() && legends.classed('chart-legend');
      var barIndex = void 0;
      var selector = void 0;
      var isStackedGroup = void 0;

      var setSelectedBar = function setSelectedBar(g) {
        g = g ? d3.select(g) : self.svg;
        g.selectAll('.bar').each(function (d, i) {
          if (!d) {
            return;
          }
          if ((self.isSingle && self.settings.isStacked ? d[0].selected : d.selected) && selected < 1) {
            selected++;
            selector = d3.select(this);
            barIndex = i;
          }
        });
      };

      var setSelectedGroup = function setSelectedGroup() {
        var groups = self.svg.selectAll('.series-group');
        if (groups.nodes().length) {
          groups.each(function () {
            setSelectedBar(this);
          });
        }
      };

      if (self.isGrouped || self.settings.isStacked && !self.isSingle && !self.isGrouped) {
        self.dataset.forEach(function (d, i) {
          if (d.selected && selected < 1) {
            selected++;
            selector = self.svg.select('[data-group-id="' + i + '"]').select('.bar');
            barIndex = i;
            if (self.settings.isStacked && !self.isSingle && !self.isGrouped) {
              isStackedGroup = true;
            }
          }
        });
        if (selected < 1) {
          setSelectedGroup();
        }
      } else {
        setSelectedBar();
      }

      if (selected > 0) {
        if (isStackedGroup) {
          if (isLegends) {
            $(legends.selectAll('.chart-legend-item')[0][barIndex]).trigger('click.chart');
          }
        } else {
          selector.on('click').call(selector.node(), selector.datum(), barIndex);
        }
      }
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on('updated.' + COMPONENT_NAME$m, function () {
        _this.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on('resize.' + COMPONENT_NAME$m, function () {
          _this.handleResize();
        });

        this.element.on('resize.' + COMPONENT_NAME$m, function () {
          _this.handleResize();
        });
      }

      return this;
    },


    /*
     * Get info on the currently selected lines.
     * @returns {object} An object with the matching data and reference to the triggering element.
     */
    getSelected: function getSelected() {
      return charts.selected;
    },


    /*
     * Get info on the currently selected lines.
     */
    setSelected: function setSelected(options, isToggle) {
      var internals = {
        svg: this.svg,
        chartData: this.settings.dataset,
        isStacked: false,
        isGrouped: false,
        isSingle: false
      };
      charts.setSelected(options, isToggle, internals);
    },


    /*
     * Get info on the currently selected lines.
     */
    toggleSelected: function toggleSelected(options) {
      this.setSelected(options, true);
    },


    /*
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }
      this.element.empty();

      return this.build();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$m);
      $('body').off('resize.' + COMPONENT_NAME$m);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('column-chart');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$m);
      $.removeData(this.element[0], 'chart');
    }
  };

  // Other Shared Imports

  // Settings and Options
  var COMPONENT_NAME$n = 'bar';

  /**
   * A bar chart or bar graph is a chart or graph that presents categorical data with rectangular bars
   * with heights or lengths proportional to the values that they represent. This is adapated from
   * http://jsfiddle.net/datashaman/rBfy5/2/
   * @class Bar
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {array} [settings.dataset=[]] The data to use in the line/area/bubble.
   * @param {boolean} [settings.isStacked=true] Default is a single or stacked chart.
   * @param {boolean} [settings.isNormalized=false] If true its a 100% bar chart
   * @param {boolean} [settings.isGrouped=false] If true its a grouped bar chart
   * @param {boolean} [settings.showLegend=true] If false the legend will not be shown.
   * @param {boolean|string} [settings.animate=true] true|false - will do or not do the animation, 'initial' will do only first time the animation.
   * @param {boolean} [settings.redrawOnResize=true] If true, the component will not resize when resizing the page.
   * @param {string} [settings.formatterString] Use d3 format some examples can be found on http://bit.ly/1IKVhHh
   * @param {string} [settings.format=true] The d3 axis format
   * @param {string} [settings.tooltip=null] A tooltip for the whole chart
   * @param {boolean} [settings.useLogScale=false] If true log scale is enabled.
   * @param {object} [settings.ticks=null] Settings for the chart ticks. Can set ticks: {format: d3Format, number: n}
   * @param {boolean} [settings.showLines=true] Show the in the axis lines or not.
   * @param {number} [settings.labelFactor=1.27] How far out than the outer circle should the labels be placed, this
   * may be useful to adjust for some labels.
   * @param {number} [settings.wrapWidth=60] The number of pixels after which a label needs to be given a new line.
   * You may want to change this based on label data.
   * @param {object} [settings.emptyMessage={
   *  title: (Locale ? Locale.translate('NoData') : 'No Data Available'),
   *   info: '',
   *  icon: 'icon-empty-no-data' }]
   * An empty message will be displayed when there is no chart data. This accepts an object of the form emptyMessage:
   * `{title: 'No Data Available',
   *  info: 'Make a selection on the list above to see results'
   *  icon: 'icon-empty-no-data',
   *  button: {text: 'xxx', click: <function>}  }`
   * Set this to null for no message or will default to 'No Data Found with an icon.'
   */
  var BAR_DEFAULTS = {
    dataset: [],
    isStacked: true,
    isNormalized: false,
    isGrouped: false,
    showLegend: true,
    animate: true,
    format: null,
    redrawOnResize: true,
    tooltip: null,
    useLogScale: false,
    ticks: null,
    showLines: true,
    labelFactor: 1.27,
    wrapWidth: 60,
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' }
  };

  function Bar(element, settings) {
    this.settings = utils.mergeSettings(element, settings, BAR_DEFAULTS);
    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Bar.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.width = 0;
      this.build().handleEvents();

      // Handle initial option
      if (this.settings.animate === 'initial') {
        this.settings.animate = false;
      }

      /**
      * Fires when the chart is complete done rendering, for customization.
      * @event rendered
      * @memberof Bar
      * @param {object} event - The jquery event object
      * @param {array} svg - The svg object.
      */
      this.element.trigger('rendered', [this.svg]);
      return this;
    },


    /**
     * Build the Component.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    build: function build() {
      var self = this;
      var isRTL = Locale.isRTL();
      var isFormatter = !!this.settings.formatterString;
      var format = function format(value) {
        return isFormatter ? d3.format(self.settings.formatterString)(value) : value;
      };

      var maxTextWidth = void 0;
      var yMap = void 0;
      var legendMap = void 0;
      var gindex = void 0;
      var totalBarsInGroup = void 0;
      var totalGroupArea = void 0;
      var totalHeight = void 0;
      var gap = void 0;
      var barHeight = void 0;

      var tooltipInterval = void 0;
      var tooltipDataCache = [];
      var tooltipData = self.settings.tooltip;

      var maxBarHeight = 30;
      var legendHeight = 30;
      var gapBetweenGroups = 0.6; // Makes it one bar in height (barHeight * 0.5)
      var isViewSmall = this.element.parent().width() < 450;
      var dataset = this.settings.dataset;

      var margins = {
        top: 20,
        left: 30,
        right: 30,
        bottom: dataset.length === 1 ? 5 : 30
      };

      this.element.addClass('bar-chart');
      if (this.settings.isGrouped) {
        this.element.addClass('bar-chart-grouped');
      }

      if (this.settings.isStacked) {
        this.element.addClass('bar-chart-stacked');
      }

      // Handle Empty Data Set
      if (dataset.length === 0) {
        self.element.emptymessage(self.settings.emptyMessage);
        return this;
      }

      // const width = parseInt(this.element.parent().width(), 10) - margins.left - margins.right;
      var height = parseInt(this.element.parent().height(), 10) - margins.top - margins.bottom - legendHeight; // influences the bar width

      // Get the Legend Series'
      var series = dataset.map(function (d) {
        //eslint-disable-line
        return { name: d.name, color: d.color, pattern: d.pattern };
      });

      // Map the Data Sets and Stack them.
      var yStack = { y1: [], y2: [] };
      dataset = dataset.map(function (d, i) {
        //eslint-disable-line
        return d.data.map(function (o, i2) {
          //eslint-disable-line
          var y0 = 0;
          if (i === 0) {
            yStack.y1.push(o.value);
            yStack.y2.push(0);
          } else {
            y0 = yStack.y1[i2] + yStack.y2[i2];
            yStack.y1[i2] = o.value;
            yStack.y2[i2] = y0;
          }
          return $.extend({}, o, { //eslint-disable-line
            y0: y0,
            y: o.value,
            x: o.name,
            color: o.color,
            pattern: o.pattern
          });
        });
      });

      // Calculate max text width
      maxTextWidth = 0;
      dataset = dataset.map(function (group, i) {
        // eslint-disable-line
        if (!self.settings.isStacked) {
          if (series[i]) {
            maxTextWidth = series[i].name.length > maxTextWidth ? series[i].name.length : maxTextWidth;
          }
        }
        return group.map(function (d) {
          // eslint-disable-line
          if (self.settings.isStacked) {
            maxTextWidth = d.x.length > maxTextWidth ? d.x.length : maxTextWidth;
          }

          // Invert the x and y values, and y0 becomes x0
          return $.extend({}, d, {
            x: d.y,
            y: d.x,
            x0: d.y0,
            color: d.color,
            pattern: d.pattern
          });
        });
      });

      var h = parseInt(this.element.parent().height(), 10) - margins.bottom - (self.settings.isStacked ? 0 : legendHeight / 2);
      var w = parseInt(this.element.parent().width(), 10) - margins.left;
      var textWidth = margins.left + maxTextWidth * 6;

      self.svg = d3.select(this.element[0]).append('svg').attr('width', w).attr('height', h).append('g').attr('class', 'group').attr('transform', 'translate(' + textWidth + ',' + margins.top + ')');

      var xMin = d3.min(dataset, function (group) {
        //eslint-disable-line
        return d3.min(group, function (d) {
          //eslint-disable-line
          return self.settings.isStacked ? d.x + d.x0 : d.x;
        });
      });

      var xMax = d3.max(dataset, function (group) {
        //eslint-disable-line
        return d3.max(group, function (d) {
          //eslint-disable-line
          return self.settings.isStacked ? d.x + d.x0 : d.x;
        });
      });

      if (self.settings.isStacked && self.settings.isNormalized) {
        var gMax = [];
        // get the max for each array group
        dataset.forEach(function (d) {
          //eslint-disable-line
          d.forEach(function (d, i) {
            //eslint-disable-line
            gMax[i] = (gMax[i] === undefined ? 0 : gMax[i]) + d.x;
          });
        });

        // Normalize Each Group
        dataset.forEach(function (d) {
          //eslint-disable-line
          d.forEach(function (d, i) {
            //eslint-disable-line
            var xDif = gMax[i] / 100;
            d.x /= xDif;
            d.x0 /= xDif;
          });
        });
        xMax = 100;
      }

      // Width of the bar minus the margin
      var barWith = w - textWidth - margins.left;
      var xScale = void 0;

      if (self.settings.useLogScale) {
        xScale = d3.scaleLog().domain([xMin > 0 ? xMin : 1, xMax]).range([1, barWith]).nice();
      } else {
        xScale = d3.scaleLinear().domain([xMin < 0 ? xMin : 0, xMax]).range([0, barWith]).nice();
      }

      if (self.settings.isStacked) {
        yMap = dataset[0].map(function (d) {
          return d.y;
        });

        barHeight = 0.32;
      } else {
        yMap = series.map(function (d) {
          return d.name;
        });

        (function () {
          var i = void 0;
          var l = void 0;
          var lm = void 0;
          // Loop backwards to catch and override with found first custom info from top
          for (i = dataset.length - 1, l = -1; i > l; i--) {
            lm = dataset[i].map(function (d) {
              return d;
            });
            $.extend(true, legendMap, lm);
            // Convert back to array from object
            legendMap = $.map(legendMap, function (d) {
              return d;
            });
          }
        })();

        gindex = 0;
        totalBarsInGroup = legendMap.length;
        totalGroupArea = height / yMap.length;
        barHeight = totalGroupArea / totalBarsInGroup;
        totalHeight = totalBarsInGroup > 1 ? totalGroupArea - barHeight * gapBetweenGroups : maxBarHeight;
        gap = totalGroupArea - totalHeight;
        maxBarHeight = totalHeight / totalBarsInGroup;
        barHeight = 0;
      }

      var yScale = d3.scaleBand().domain(yMap).rangeRound([0, height]).padding(barHeight, barHeight); // TODO

      var xAxis = d3.axisBottom().scale(xScale).tickSize(-height); //  .orient('middle') ??

      if (isViewSmall) {
        xAxis.ticks(textWidth < 100 ? 5 : 3);
      }

      if (self.settings.isStacked && self.settings.isNormalized) {
        xAxis.tickFormat(function (d) {
          return d + '%';
        });
      }

      if (self.settings.useLogScale) {
        xAxis.ticks(10, ',.1s');

        if (self.settings.showLines === false) {
          xAxis.tickSize(0);
        }
      }

      if (self.settings.ticks) {
        xAxis.ticks(self.settings.ticks.number, self.settings.ticks.format);
      }

      var yAxis = d3.axisLeft().scale(yScale).tickPadding(15).tickSize(0);

      self.svg.append('g').attr('class', 'axis x').attr('transform', 'translate(0,' + height + ')').call(xAxis);

      self.svg.append('g').attr('class', 'axis y').call(yAxis);

      var groups = self.svg.selectAll('g.group').data(dataset).enter().append('g').attr('class', 'series-group').attr('data-group-id', function (d, i) {
        return i;
      });

      self.settings.isGrouped = self.svg.selectAll('.series-group').nodes().length > 1 && !self.settings.isStacked;
      self.settings.isSingle = self.svg.selectAll('.series-group').nodes().length === 1 && self.settings.isStacked;

      groups.selectAll('rect').data(function (d, i) {
        d.forEach(function (d3) {
          d3.index = i;

          if (!self.settings.isStacked) {
            d3.gindex = gindex++;
          }
        });
        return d;
      }).enter().append('rect').attr('class', function (d, i) {
        return 'bar series-' + i;
      }).style('fill', function (d, i) {
        return self.settings.isStacked ? // eslint-disable-line
        series.length === 1 ? charts.chartColor(i, 'bar-single', d) : // eslint-disable-line
        charts.chartColor(d.index, 'bar', series[d.index]) : // eslint-disable-line
        charts.chartColor(i, 'bar', legendMap[i]);
      }) // eslint-disable-line
      .attr('mask', function (d, i) {
        if (dataset.length === 1 && dataset[0][i].pattern) {
          return 'url(#' + dataset[0][i].pattern + ')';
        } else if (self.settings.isStacked && series[d.index].pattern) {
          return 'url(#' + series[d.index].pattern + ')';
        } else if (!self.settings.isStacked && legendMap[i].pattern) {
          return 'url(#' + legendMap[i].pattern + ')';
        }
        return '';
      }).attr('x', function (d) {
        if (self.settings.useLogScale) {
          return 0;
        }
        return self.settings.isStacked && !self.settings.isSingle ? xScale(d.x0) : xScale(0);
      }).attr('y', function (d) {
        return self.settings.isStacked ? yScale(d.y) : (totalGroupArea - totalHeight) / 2 + d.gindex * maxBarHeight + d.index * gap;
      }).attr('height', function () {
        return self.settings.isStacked ? yScale.bandwidth() : maxBarHeight;
      }).attr('width', 0) // Animated in later
      .on('mouseenter', function (d, i) {
        var j = void 0;
        var l = void 0;
        var hexColor = void 0;
        var total = 0;
        var totals = [];
        var content = '';
        var data = d3.select(this.parentNode).datum();
        var mid = Math.round(data.length / 2);
        var shape = d3.select(this);
        var setPattern = function setPattern(pattern, hexColor2) {
          return !pattern || !hexColor2 ? '' : '<svg width="12" height="12"><rect mask="url(#' + pattern + ')" height="12" width="12" /></svg>';
        };

        var show = function show(xPosS, yPosS, isTooltipBottom) {
          var size = charts.tooltipSize(content);
          var x = xPosS + parseFloat(shape.attr('width')) / 2 - size.width / 2;
          var y = isTooltipBottom ? yPosS : yPosS - size.height - 13;

          if (content !== '') {
            charts.showTooltip(x, y, content, isTooltipBottom ? 'bottom' : 'top');
          }
        };

        if (dataset.length === 1) {
          content = '<p><b>' + d.y + ' </b>' + d.x + '</p>';
        } else {
          content = '<div class="chart-swatch">';

          if (self.settings.isStacked) {
            for (j = 0, l = dataset.length; j < l; j++) {
              total = 0;
              hexColor = charts.chartColor(j, 'bar', series[j]);
              for (var k = 0, kl = dataset.length; k < kl; k++) {
                total += dataset[k][i].x;
                totals[k] = dataset[k][i].x;
              }
              content += '<div class="swatch-row">\n                  <div class="swatch-color">' + setPattern(series[j].pattern, hexColor) + '</div>\n                  <span>' + series[j].name + '</span>\n                  <b> ' + (isFormatter ? format(totals[j]) : Math.round(totals[j] / total * 100) + '%') + ' </b>\n                </div>';
            }
          } else {
            if (mid > 1) {
              shape = d3.select(this.parentNode).select('.series-' + mid);
            }
            for (j = 0, l = data.length; j < l; j++) {
              hexColor = charts.chartColor(j, 'bar', legendMap[j]);
              content += '<div class="swatch-row">\n                    <div class="swatch-color">' + setPattern(legendMap[j].pattern, hexColor) + '</div>\n                  <span>' + data[j].name + '</span><b>' + format(data[j].value) + '</b>\n                </div>';
            }
          }
          content += '</div>';
        }

        if (total > 0) {
          content = '<span class="chart-tooltip-total"><b>' + total + '</b> ' + Locale.translate('Total') + '</span>' + content;
        }

        var yPosS = shape.nodes()[0].getBoundingClientRect().top + $(window).scrollTop();
        var xPosS = shape.nodes()[0].getBoundingClientRect().left + $(window).scrollLeft();

        var maxBarsForTopTooltip = 6;
        var isTooltipBottom = !self.settings.isStacked && data.length > maxBarsForTopTooltip;

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
          content = '';
          var runInterval = true;
          tooltipInterval = setInterval(function () {
            if (runInterval) {
              runInterval = false;
              tooltipData(function (data2) {
                content = data2;
                tooltipDataCache[i] = data2;
              });
            }
            if (content !== '') {
              clearInterval(tooltipInterval);
              show(xPosS, yPosS, isTooltipBottom);
            }
          }, 10);
        } else {
          content = tooltipDataCache[i] || tooltipData || d.tooltip || content || '';
          show(xPosS, yPosS, isTooltipBottom);

          // set inline colors
          if (self.settings.isStacked) {
            for (j = 0, l = dataset.length; j < l; j++) {
              hexColor = charts.chartColor(j, 'bar', series[j]);

              var row = $('#svg-tooltip').find('.swatch-row').eq(j);
              if (!series[j].pattern) {
                row.find('div').css('background-color', hexColor);
              }
              row.find('rect').css('fill', hexColor);
            }
          } else {
            for (j = 0, l = data.length; j < l; j++) {
              hexColor = charts.chartColor(j, 'bar', legendMap[j]);

              var _row = $('#svg-tooltip').find('.swatch-row').eq(j);
              if (!legendMap[j].pattern) {
                _row.find('div').css('background-color', hexColor);
              }
              _row.find('rect').css('fill', hexColor);
            }
          }
        }
      }).on('mouseleave', function () {
        clearInterval(tooltipInterval);
        charts.hideTooltip();
      }).on('click', function (d, i) {
        var isSelected = this && d3.select(this).classed('is-selected');
        var thisGroupId = parseInt(d3.select(this.parentNode).attr('data-group-id'), 10);

        charts.setSelectedElement({
          task: isSelected ? 'unselected' : 'selected',
          container: self.element,
          selector: this,
          isTrigger: !isSelected,
          triggerGroup: self.settings.isGrouped,
          d: d,
          i: i,
          type: self.settings.type,
          dataset: dataset,
          isSingle: self.isSingular,
          isGrouped: self.settings.isGrouped,
          isStacked: self.settings.isStacked,
          svg: self.svg,
          clickedLegend: self.settings.clickedLegend
        });

        if (isSelected) {
          self.element.triggerHandler('selected', [d3.select(this).nodes(), {}, i]);
        }
      });

      // Adjust the labels
      self.svg.selectAll('.axis.y text').attr('x', function () {
        return isRTL ? 15 : -15;
      });
      self.svg.selectAll('.axis.x text').attr('class', function (d) {
        return d < 0 ? 'negative-value' : 'positive-value';
      });

      if (isRTL && (charts.isIE || charts.isIEEdge)) {
        self.svg.selectAll('text').attr('transform', 'scale(-1, 1)');
        self.svg.selectAll('.y.axis text').style('text-anchor', 'start');
      }

      if (isViewSmall && self.settings.useLogScale) {
        var ticks = d3.selectAll('.x .tick text');
        var foundMid = false;

        // At small breakpoint hide the last ones
        ticks.attr('class', function (d, i) {
          var middleTick = Math.round(ticks.size() / 2);

          if (i >= middleTick && !foundMid && d.toString().startsWith('1')) {
            foundMid = true;
            middleTick = d;
          }

          if (i !== 0 && i !== ticks.size() - 1 && (self.settings.useLogScale ? d !== middleTick : i !== middleTick)) {
            d3.select(this).remove();
          }
        });
      }

      // Set x-axix tick css class
      self.svg.selectAll('.x.axis .tick').attr('class', function (d) {
        return 'tick' + (d === 0 ? ' tick0' : '');
      });

      // Animate the Bars In
      self.svg.selectAll('.bar').transition().duration(self.settings.animate ? 600 : 0).attr('width', function (d) {
        var scale = xScale(d.x);
        var scale0 = xScale(0);

        if (isNaN(scale) || !math.isFinite(scale)) {
          scale = 0;
        }

        if (isNaN(scale0) || !math.isFinite(scale0)) {
          scale0 = 0;
        }

        return Math.abs(scale - scale0);
      }).attr('x', function (d) {
        if (self.settings.useLogScale) {
          return 0;
        }
        return self.settings.isStacked && !self.settings.isSingle ? xScale(d.x0) : //eslint-disable-line
        d.x < 0 ? xScale(d.x) : xScale(0);
      });

      self.settings.svg = self.svg;

      // Add Legends
      if (self.settings.showLegend) {
        charts.addLegend(self.settings.isStacked ? series : legendMap, self.settings.type, self.settings, this.element);
        // charts.addLegend(self.settings.isStacked ? series : legendMap);
      }
      charts.appendTooltip();

      this.setInitialSelected();
      this.element.trigger('rendered');
      return this;
    },


    /**
     * Set the initially selected elements
     * @private
     */
    setInitialSelected: function setInitialSelected() {
      var selected = 0;
      var self = this;
      var legendsNode = self.svg.node().parentNode.nextSibling;
      var legends = d3.select(legendsNode);
      var isLegends = legends.node() && legends.classed('chart-legend');
      var barIndex = void 0;
      var selector = void 0;
      var isStackedGroup = void 0;

      var setSelectedBar = function setSelectedBar(g) {
        g = g ? d3.select(g) : self.svg;
        g.selectAll('.bar').each(function (d, i) {
          if (!d) {
            return;
          }
          if (d.selected && selected < 1) {
            selected++;
            selector = d3.select(this);
            barIndex = i;
          }
        });
      };

      var setSelectedGroup = function setSelectedGroup() {
        var groups = self.svg.selectAll('.series-group');
        if (groups.nodes().length) {
          // eslint-disable-line
          groups.each(function () {
            setSelectedBar(this);
          });
        }
      };

      if (self.settings.isGrouped || self.settings.isStacked && !self.settings.isSingle) {
        self.settings.dataset.forEach(function (d, i) {
          if (d.selected && selected < 1) {
            selected++;
            selector = self.svg.select('[data-group-id="' + i + '"]').select('.bar');
            barIndex = i;
            if (self.settings.isStacked && !self.settings.isGrouped) {
              isStackedGroup = true;
            }
          }
        });
        if (selected < 1) {
          setSelectedGroup();
        }
      } else {
        setSelectedBar();
      }

      if (selected > 0) {
        if (isStackedGroup) {
          if (isLegends) {
            $(legends.selectAll('.chart-legend-item')[0][barIndex]).trigger('click.chart');
          }
        } else {
          selector.on('click').call(selector.node(), selector.datum(), barIndex);
        }
      }
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on('updated.' + COMPONENT_NAME$n, function () {
        _this.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on('resize.' + COMPONENT_NAME$n, function () {
          _this.handleResize();
        });

        this.element.on('resize.' + COMPONENT_NAME$n, function () {
          _this.handleResize();
        });
      }

      return this;
    },


    /*
     * Get info on the currently selected lines.
     * @returns {object} An object with the matching data and reference to the triggering element.
     */
    getSelected: function getSelected() {
      return charts.selected;
    },


    /*
     * Get info on the currently selected lines.
     */
    setSelected: function setSelected(options, isToggle) {
      var internals = {
        svg: this.svg,
        chartData: this.settings.dataset,
        isStacked: this.settingsisStacked,
        isGrouped: this.settings.isGrouped,
        isSingle: this.settings.isSingle
      };
      charts.setSelected(options, isToggle, internals);
    },


    /*
     * Get info on the currently selected lines.
     */
    toggleSelected: function toggleSelected(options) {
      this.setSelected(options, true);
    },


    /*
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }
      this.element.empty();

      return this.build().element.trigger('rendered', [this.svg]);
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$n);
      $('body').off('resize.' + COMPONENT_NAME$n);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('bar-chart');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$n);
      $.removeData(this.element[0], 'chart');
    }
  };

  /* eslint-disable no-nested-ternary, prefer-arrow-callback */

  // Settings and Options
  var COMPONENT_NAME$o = 'pie';

  /**
   * A pie chart (or a circle chart) is a circular statistical graphic which is divided
    into slices to illustrate numerical proportion. In a pie chart, the arc length of each slice is proportional to the quantity it represents.
   * @class Pie
   * @constructor
   *
   * @param {jquery[]|htmlelement} element The plugin element for the constuctor
   * @param {object} [settings] The component settings.
   * @param {array} [settings.dataset] The data to use in the line/area/bubble.
   * @param {boolean} [settings.isDonut=false] If true it renders as a donut chart.
   * @param {boolean} [settings.redrawOnResize=true] If true, the component will not resize when resizing the page. There is tooltip values provided.
    It will not be shown. If you still want lines at the lower breakpoint you can set this to true
   * @param {boolean} [settings.hideCenterLabel=false] If false the center label will not be shown.
   * @param {boolean} [settings.showLines=true] If false connector lines wont be shown
   * @param {boolean} [settings.showLinesMobile=false] This defaults to false, when false and under 450px the lines
   * @param {object} [settings.lines] A setting that controls the line values and format.
   * @param {string} [settings.line.show='value'] Controls the line value, this can be value, label or percent or custom function.
   * @param {string} [settings.line.formatter='.0f'] The d3.formatter string.
   * @param {boolean} [settings.showLegend=true] If false the legend will not be shown.
   * @param {boolean} [settings.showMobile=false] If true the chart is better formed to fit in a single widget.
   * @param {string} [settings.legendPlacement='right'] Where to locate the legend. This can be bottom or right at the moment.
   * @param {object} [settings.legend] A setting that controls the legend values and format.
   * @param {string} [settings.legend.show='label (percent)'] Controls what is visible
    in the legend, this can be value, value (percent), label or percent or your own custom function.
   * @param {string} [settings.legend.formatter='.0f'] The d3.formatter string.
   * @param {boolean} [settings.showTooltips=true] If false now tooltips will be shown
   * @param {object} [settings.tooltip] A setting that controls the tooltip values and format.
   * @param {string} [settings.tooltip.show='label (value)'] Controls what is visible in
    the tooltip, this can be value, label or percent or custom function.
   * @param {string} [settings.tooltip.formatter='.0f'] The d3.formatter string.
   * @param {object} [settings.emptyMessage] An empty message will be displayed when there is no chart data.
   * This accepts an object of the form emptyMessage:
   * `{title: 'No Data Available',
   *  info: 'Make a selection on the list above to see results', icon: 'icon-empty-no-data',
   *  button: {text: 'xxx', click: <function>}
   *  }`
   *  Set this to null for no message or will default to 'No Data Found with an icon.'
   */

  var PIE_DEFAULTS = {
    dataset: [],
    isDonut: false,
    redrawOnResize: true,
    hideCenterLabel: false,
    showLines: true,
    showLinesMobile: false,
    lines: {
      show: 'value', // value, label or percent or custom function
      formatter: '.0f'
    },
    showLegend: true,
    legendPlacement: 'right', // Can be bottom or right
    legend: {
      show: 'label (percent)', // value, label, label (percent) or percent or custom function
      formatter: '.0f'
    },
    showTooltips: true,
    tooltip: {
      show: 'label (value)', // value, label, label (value) or percent or custom function
      formatter: '.0f'
    },
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' }
  };

  function Pie(element, settings) {
    this.settings = utils.mergeSettings(element, settings, PIE_DEFAULTS);
    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Pie.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.width = 0;
      this.isFirefox = Environment.browser.name === 'firefox';

      // Handle Empty Data Set
      if (this.settings.dataset.length === 0) {
        this.element.emptymessage(this.settings.emptyMessage);
        return this;
      }

      this.build().handleEvents();

      /**
       * Fires when the chart is complete done rendering, for customization.
       * @event rendered
       * @memberof Pie
       * @property {object} event - The jquery event object
       * @property {object} svg - The svg object.
       */
      this.element.trigger('rendered', [this.svg]);

      return this;
    },


    /**
     * Build the Component.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    build: function build() {
      var self = this;

      self.svg = d3.select(this.element[0]).append('svg');

      self.mainGroup = self.svg.append('g');

      self.mainGroup.append('g').attr('class', 'slices');
      self.mainGroup.append('g').attr('class', 'labels');
      self.mainGroup.append('g').attr('class', 'lines');
      this.element.addClass('chart-pie');

      if (this.settings.showMobile) {
        this.settings.legendPlacement = 'bottom';
      }

      if (self.settings.legendPlacement) {
        this.element.addClass('has-' + self.settings.legendPlacement + '-legend');
      }

      var w = parseInt(this.element.width(), 10);
      var h = parseInt(this.element.height(), 10);

      var dims = {
        height: h,
        width: w
      };

      if (self.settings.legendPlacement === 'right') {
        dims.width = w * 0.75;
      }

      if (this.settings.showMobile) {
        dims.height = h * 0.80; // make some more room for the legend
        this.element.addClass('is-mobile');
      }

      dims.radius = Math.min(dims.width, dims.height) / 2;
      self.dims = dims;

      self.pie = d3.pie().sort(null).value(function (d) {
        return d.value;
      });

      self.arc = d3.arc().outerRadius(dims.radius * 0.75).innerRadius(self.settings.isDonut ? dims.radius * 0.5 : 0);

      // Influences the label position
      self.outerArc = d3.arc().innerRadius(dims.radius * 0.75).outerRadius(dims.radius * 0.75 + 20);

      self.svg.attr('width', self.settings.legendPlacement === 'right' ? '75%' : '100%').attr('height', self.settings.showMobile ? '80%' : '100%');

      self.mainGroup.attr('transform', 'translate(' + dims.width / 2 + ',' + dims.height / 2 + ')');

      // move the origin of the group's coordinate space to the center of the SVG element
      dims.center = { x: dims.width / 2, y: dims.height / 2 };

      self.key = function (d) {
        return d.data.name;
      };
      var isEmpty = !self.settings.dataset || self.settings.dataset.length === 0;
      this.chartData = !isEmpty ? self.settings.dataset[0].data : [];
      this.sum = d3.sum(this.chartData, function (d) {
        return d.value;
      });

      // Calculate the percentages
      var values = this.chartData.map(function (d) {
        return d.value / self.sum * 100;
      });
      var rounded = this.roundLargestRemainer(values);

      this.chartData = this.chartData.map(function (d, i) {
        d.percent = d.value / self.sum;
        d.percentRound = rounded[i];
        return d;
      });

      var sum = 0;
      this.chartData.map(function (d) {
        // eslint-disable-line
        sum += d.percentRound;
      });

      // Handle zero sum or empty pies
      if (isEmpty || sum === 0 || isNaN(sum)) {
        this.chartData.push({ data: {}, color: '#BDBDBD', name: 'Empty-Pie', value: 100, percent: 1, percentRound: 100 });
      }

      self.updateData(self.chartData);
      if (self.settings.showTooltips) {
        charts.appendTooltip('is-pie');
      }

      if (this.settings.showLegend) {
        var series = self.chartData.map(function (d) {
          var name = charts.formatToSettings(d, self.settings.legend);

          if (self.settings.legendFormatter) {
            name = d.name + ' (' + d3.format(self.settings.legendFormatter)(d.value) + ')';
          }

          if (d.name === 'Empty-Pie') {
            name = '';
          }
          return { name: name, display: 'twocolumn', placement: self.settings.legendPlacement, color: d.color };
        });

        this.settings.svg = self.svg;
        charts.addLegend(series, 'pie', this.settings, this.element);
      }

      this.setInitialSelected();
      this.addCenterLabel();
      this.element.trigger('rendered');
      return this;
    },


    /**
     * Randomize the data for testing.
     * @private
     * @param  {boolean} toZero Set them all to zero value.
     * @returns {void}
     */
    randomize: function randomize(toZero) {
      var self = this;
      this.chartData = this.chartData.map(function (d) {
        d.value = toZero ? 0 : Math.random();
        return d;
      });

      this.sum = d3.sum(this.chartData, function (d) {
        return d.value;
      });
      var values = this.chartData.map(function (d) {
        return d.value / self.sum * 100;
      });
      var rounded = this.roundLargestRemainer(values);

      this.chartData = this.chartData.map(function (d, i) {
        d.percent = d.value / self.sum;
        d.percentRound = rounded[i];
        return d;
      });

      return this.chartData;
    },


    /**
     * Add the center label for donut chart.
     * @private
     * @returns {void}
     */
    addCenterLabel: function addCenterLabel() {
      var self = this;

      if (self.settings.isDonut && !self.settings.hideCenterLabel) {
        var centerLabel = self.settings.dataset[0].centerLabel;
        var arcs = self.svg.selectAll('.slices');

        arcs.append('text').attr('dy', '.35em').style('text-anchor', 'middle').attr('class', 'chart-donut-text').html(centerLabel);

        // FIX: IE does not render .html
        // http://stackoverflow.com/questions/13962294/dynamic-styling-of-svg-text
        if (charts.isIE && !charts.isIEEdge) {
          if (utils.isHTML(centerLabel)) {
            var text = arcs.select('.chart-donut-text');
            var tmp = document.createElement('text');

            tmp.innerHTML = centerLabel;

            var nodes = Array.prototype.slice.call(tmp.childNodes);
            nodes.forEach(function (node) {
              text.append('tspan').attr('style', node.getAttribute && node.getAttribute('style')).attr('x', node.getAttribute && node.getAttribute('x')).attr('dy', node.getAttribute && node.getAttribute('dy')).text(node.textContent);
            });
          } else {
            arcs.select('.chart-donut-text').text(centerLabel);
          }
        }
      }
    },


    /**
     * Update the chart with a new dataset
     * @param  {object} data The data to use.
     * @returns {void}
     */
    updateData: function updateData(data) {
      // Pie Slices
      var self = this;
      var tooltipInterval = void 0;
      var isEmpty = !self.settings.dataset || self.settings.dataset.length === 0;
      var slice = self.svg.select('.slices').selectAll('path.slice').data(self.pie(data), self.key);

      var getOffset = function getOffset(node) {
        var body = document.body;
        var rect = void 0;

        // Fix: With firefox `getBoundingClientRect` not working if node is hidden
        if (self.isFirefox && self.settings.dotSize === 0) {
          var dot = d3.select(node);
          dot.attr('r', 2);
          rect = node.getBoundingClientRect();
          dot.attr('r', self.settings.dotSize);
        } else {
          rect = node.getBoundingClientRect();
        }
        return {
          top: rect.top + body.scrollTop,
          left: rect.left + body.scrollLeft
        };
      };

      self.isRTL = Locale.isRTL();

      slice.enter().insert('path').style('fill', function (d, i) {
        return charts.chartColor(i, 'pie', d.data);
      }).attr('class', 'slice').on('contextmenu', function (d) {
        // Handle Right Click Menu
        charts.triggerContextMenu(self.element, d3.select(this).select('path').nodes()[0], d);
      }).on('click', function (d, i) {
        clearTimeout(tooltipInterval);
        // Handle Click to select
        var isSelected = this && d3.select(this).classed('is-selected');

        // Make unselected
        charts.setSelectedElement({
          task: isSelected ? 'unselected' : 'selected',
          container: self.element,
          selector: isSelected ? '.chart-container .is-selected' : this,
          isTrigger: !isSelected,
          d: d.data,
          i: i,
          type: self.settings.type,
          dataset: self.settings.dataset,
          svg: self.svg
        });

        if (isSelected) {
          /**
           * Fires when arc/slice is selected.
           * @event selected
           * @memberof Pie
           * @property {object} event - The jquery event object
           * @property {object} selected arc/slice.
           * @property {object} data of selected arc/slice.
           * @property {number} index of selected arc/slice.
           */
          self.element.triggerHandler('selected', [d3.select(this).nodes(), {}, i]);
        }
      }).on('mouseenter', function (d, i) {
        if (!self.settings.showTooltips) {
          return;
        }
        // See where to position
        var dot = self.svg.selectAll('circle').nodes()[i];
        var offset = getOffset(dot);

        // See where we want the arrow
        var rads = self.midAngle(d);

        // https://www.wyzant.com/resources/lessons/math/trigonometry/unit-circle
        var isTop = rads <= Math.PI / 4 && rads >= 0 || rads > 7 * Math.PI / 4;
        var isRight = rads <= 3 * Math.PI / 4 && rads >= Math.PI / 4;
        var isBottom = rads <= 5 * Math.PI / 4 && rads >= 3 * Math.PI / 4;
        var isLeft = rads <= 7 * Math.PI / 4 && rads >= 5 * Math.PI / 4;

        // Build the content
        var content = '';
        var show = function show() {
          if (content === '') {
            return;
          }

          var size = charts.tooltipSize(content);
          var x = offset.left;
          var y = offset.top;
          var padding = 5;

          if (isTop) {
            x -= size.width / 2;
            y -= size.height - padding;
            charts.showTooltip(x, y, content, 'top');
          }
          if (isRight) {
            y -= size.height / 2;
            charts.showTooltip(x, y, content, 'right');
          }
          if (isBottom) {
            x -= size.width / 2;
            // y -= padding;
            charts.showTooltip(x, y, content, 'bottom');
          }
          if (isLeft) {
            x -= size.width - padding;
            y -= size.height / 2;
            charts.showTooltip(x, y, content, 'left');
          }
        };

        var value = charts.formatToSettings(d, self.settings.tooltip);
        content = d.data.tooltip || value;
        content = content.replace('{{percent}}', d.data.percentRound + '%');
        content = content.replace('{{value}}', d.value);
        content = content.replace('%percent%', d.data.percentRound + '%');
        content = content.replace('%value%', d.value);

        if (content.indexOf('<b>') === -1) {
          content = content.replace('(', '<b>');
          content = content.replace(')', '</b>');
        }

        // Debounce it a bit
        if (tooltipInterval != null) {
          clearTimeout(tooltipInterval);
        }

        tooltipInterval = setTimeout(function () {
          show();
        }, 300);
      }).on('mouseleave', function () {
        clearTimeout(tooltipInterval);
        charts.hideTooltip();
      }).merge(slice).transition().duration(self.settings.animationSpeed).attrTween('d', function (d) {
        this.current = this.current || d;
        var interpolate = d3.interpolate(this.current, d);
        this.current = interpolate(0);
        return function (t) {
          return self.arc(interpolate(t));
        };
      });

      slice.exit().remove();

      if (isEmpty) {
        return;
      }

      var isMobile = self.element.parent().width() < 520;
      var shouldShow = self.settings.showLines;

      if (!self.settings.showLinesMobile && shouldShow) {
        shouldShow = !isMobile;
      }

      self.settings.dotSize = shouldShow ? 2 : 0;

      // Text Labels
      if (shouldShow) {
        var padding = 20;
        var text = self.svg.select('.labels').selectAll('text').data(self.pie(data), self.key);

        text.enter().append('text').attr('dy', '.35em').text(function (d) {
          return charts.formatToSettings(d, self.settings.lines);
        }).merge(text).transition().duration(self.settings.animationSpeed).attrTween('transform', function (d) {
          this.current = this.current || d;
          var interpolate = d3.interpolate(this.current, d);
          this.current = interpolate(0);
          return function (t) {
            var d2 = interpolate(t);
            var pos = self.outerArc.centroid(d2);
            pos[0] = self.dims.radius * (self.midAngle(d2) < Math.PI ? 1 : -1);
            pos[0] -= self.midAngle(d2) < Math.PI ? padding : -padding;
            return 'translate(' + pos + ')';
          };
        }).styleTween('text-anchor', function (d) {
          this.current = this.current || d;
          var interpolate = d3.interpolate(this.current, d);
          this.current = interpolate(0);
          return function (t) {
            var d2 = interpolate(t);

            if (self.isRTL) {
              return self.midAngle(d2) > Math.PI ? 'start' : 'end';
            }

            return self.midAngle(d2) < Math.PI ? 'start' : 'end';
          };
        });

        text.exit().remove();

        // Slice to text poly lines
        var polyline = self.svg.select('.lines').selectAll('polyline').data(self.pie(data), self.key);

        polyline.enter().append('polyline').merge(polyline).transition().duration(self.settings.animationSpeed).attrTween('points', function (d) {
          this.current = this.current || d;
          var interpolate = d3.interpolate(this.current, d);
          this.current = interpolate(0);
          return function (t) {
            var d2 = interpolate(t);
            var pos = self.outerArc.centroid(d2);
            pos[0] = self.dims.radius * 0.85 * (self.midAngle(d2) < Math.PI ? 1 : -1);
            return [self.outerArc.centroid(d2), self.outerArc.centroid(d2), pos];
          };
        });

        polyline.exit().remove();
      }

      var dots = self.svg.select('.lines').selectAll('circle').data(self.pie(data), self.key);

      dots.enter().append('circle').attr('class', 'circles').attr('r', self.settings.dotSize).merge(dots).transition().duration(self.settings.animationSpeed).attrTween('transform', function (d) {
        this.current = this.current || d;
        var interpolate = d3.interpolate(this.current, d);
        this.current = interpolate(0);
        return function (t) {
          var d2 = interpolate(t);
          return 'translate(' + self.outerArc.centroid(d2) + ' )';
        };
      });

      dots.exit().remove();
    },


    /**
     * Set the initially selected elements
     * @private
     * @returns {void}
     */
    setInitialSelected: function setInitialSelected() {
      var selected = 0;
      var selector = void 0;

      this.svg.selectAll('.slice').each(function (d, i) {
        if (!d || !d.data) {
          return;
        }

        if (d.data.selected && selected < 1) {
          selected++;
          selector = d3.select(this);
          selector.on('click').call(selector.node(), selector.datum(), i);
        }
      });
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on('updated.' + COMPONENT_NAME$o, function () {
        _this.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on('resize.' + COMPONENT_NAME$o, function () {
          _this.handleResize();
        });

        this.element.on('resize.' + COMPONENT_NAME$o, function () {
          _this.handleResize();
        });
      }

      return this;
    },


    /**
     * Get info on the currently selected lines.
     * @private
     * @returns {object} An object with the matching data and reference to the triggering element.
     */
    getSelected: function getSelected() {
      return charts.selected;
    },


    /**
     * Get info on the currently selected lines.
     * @private
     * @param {object} o The selection data object
     * @param {boolean} isToggle If true toggle the current state.
     */
    setSelected: function setSelected(o, isToggle) {
      var self = this;
      var selector = void 0;
      var arcIndex = void 0;
      var selected = 0;
      var equals = utils.equals;

      this.svg.selectAll('.slice').each(function (d, i) {
        if (!d || !d.data) {
          return;
        }

        if (selected < 1) {
          if (typeof o.fieldName !== 'undefined' && typeof o.fieldValue !== 'undefined' && o.fieldValue === d.data[o.fieldName] || typeof o.index !== 'undefined' && o.index === i || o.data && equals(o.data, self.chartData[i].data) || o.elem && $(this).is(o.elem)) {
            selected++;
            selector = d3.select(this);
            arcIndex = i;
          }
        }
      });

      if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
        selector.on('click').call(selector.node(), selector.datum(), arcIndex);
      }
    },


    /**
     * Get info on the currently selected lines.
     * @param {object} options The selected info object.
     * @returns {void}
     */
    toggleSelected: function toggleSelected(options) {
      this.setSelected(options, true);
    },


    /**
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      this.element.empty();

      return this.build().element.trigger('rendered', [this.svg]);
    },


    /**
     * Handle updated settings and values.
     * @private
     * @param  {array} values A list of values
     * @returns {array} The values rounded to 100
     */
    roundLargestRemainer: function roundLargestRemainer(values) {
      var sum = 0;
      var count = 0;
      var dVala = 0;
      var dValb = 0;
      var order = [];

      // Round everything down
      for (var i = 0; i < values.length; i++) {
        sum += parseInt(values[i], 10);
        order[i] = i;
      }

      // Getting the difference in sum and 100
      var diff = 100 - sum;

      // Distributing the difference by adding 1 to items in decreasing order of their decimal parts
      order.sort(function (a, b) {
        dVala = values[a] - parseInt(values[a], 10);
        dValb = values[b] - parseInt(values[b], 10);
        return dValb - dVala;
      });

      values.sort(function (a, b) {
        dVala = a - parseInt(a, 10);
        dValb = b - parseInt(b, 10);
        return dValb - dVala;
      });

      for (var j = 0; j < values.length; j++) {
        count = j;
        if (count < diff) {
          values[j] = parseInt(values[j], 10) + 1;
        } else {
          values[j] = parseInt(values[j], 10);
        }
      }

      // Set back the order
      var unsorted = [];
      for (var _i = 0; _i < values.length; _i++) {
        unsorted[order[_i]] = values[_i];
      }
      return unsorted;
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$o);
      $('body').off('resize.' + COMPONENT_NAME$o);
      return this;
    },


    /**
     * Calculate the middle angle.
     * @private
     * @param  {object} d The d3 data.
     * @returns {boolean} The mid angule
     */
    midAngle: function midAngle(d) {
      return d.startAngle + (d.endAngle - d.startAngle) / 2;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('pie-chart');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$o);
      $.removeData(this.element[0], 'chart');
    }
  };

  // Shared Imports

  // Settings and Options
  var COMPONENT_NAME$p = 'radar';

  // Default Radar Options
  var RADAR_DEFAULTS = {
    dataset: [],
    redrawOnResize: true,
    margin: { top: 50, right: 0, bottom: 50, left: 0 },
    levels: 4,
    maxValue: 0,
    labelFactor: 1.27,
    wrapWidth: 60,
    opacityArea: 0.2,
    dotRadius: 3,
    opacityCircles: 0,
    strokeWidth: 1,
    roundStrokes: true,
    showCrosslines: true,
    showAxisLabels: true,
    colors: charts.colorRange,
    showTooltips: true,
    tooltip: {
      show: 'value', // value, label, label (value) or percent or custom function
      formatter: '.0%' // or .0% ?
    },
    axisFormatter: '.0%',
    showLegend: true,
    legendPlacement: 'right',
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' }
  };

  /**
   * A radar chart is a graphical method of displaying multivariate data in the form of a
   * two-dimensional chart of three or more quantitative variables represented on axes starting
   * from the same poin
   * @class Radar
   * @param {string} element The plugin element for the constuctor
   * @param {string} settings The settings element.
   * @param {array} settings.dataset The data to use in the radar
   * @param {boolean} [settings.redrawOnResize = true] If false, the component will not resize when resizing the page.
   * @param {object} [settings.margin] The margins of the SVG, you may want to adjust
   * depending on text location.
   * @param {number} [settings.levels = 4] How many levels or inner circles should there be drawn.
   * @param {number} [settings.maxValue = 0] What is the value that the biggest circle will represent
   * @param {number} [settings.labelFactor = 1.27] How far out than the outer circle should the labels be placed,
   * this may be useful to adjust for some charts.
   * @param {number} [settings.wrapWidth = 60] The number of pixels after which a label needs to be
   * given a new line. You may want to change this based on label data.
   * @param {boolean} [settings.showCrosslines = true] Set to false to hide the cross line axes.
   * @param {boolean} [settings.showAxisLabels = true] Set to false to hide percent labels.
   * @param {number} [settings.opacityArea = 0.2] The opacity value of the blobs. This is set to the correct Infor Style.
   * @param {number} [settings.dotRadius = 3] The size of the colored circles of each blog. Set to zero to remove dots.
   * @param {number} [settings.opacityCircles  = 0]The opacity of the circles of each blob 0 or .1 are good values.
   * This is set to the correct Infor Style.
   * @param {number} [settings.strokeWidth = 1] The width of the stroke around each blob.
   * This is set to the correct Infor Style.
   * @param {boolean} [settings.roundStrokes = true] If true the area and stroke will follow a
   * round path (cardinal-closed).
   * @param {boolean} [settings.showCrosslines = true]  If false the axis lines will not be shown in the diagonals.
   * @param {boolean} [settings.showAxisLabels = true]  If false the axis labels will not be shown.
   * @param {string} [settings.axisFormatter = '.0%'] D3 formatter to use on the axis labels
   * @param {array} [settings.colors] An array of colors to use.
   * @param {boolean} [settings.showTooltips = true] If false no tooltips will be shown.
   * @param {object} [settings.tooltip] A setting that controls the tooltip values and format.
   * @param {string} [settings.tooltip.show = 'value'] Controls what is visible in the tooltip, this can be value, label
   * or percent or custom function.
   * @param {object} [settings.tooltip.formatter = '.0%'] The d3.formatter string.
   * @param {boolean} [settings.showLegend = true] If false the legend will not be shown.
   * @param {string} [settings.legendPlacement = 'right'] Where to locate the legend. This can be bottom or right at
   * the moment.
   * @param {object} [settings.emptyMessage] An empty message will be displayed when there is no chart data.
   * This accepts an object of the form emptyMessage:
   * `{title: 'No Data Available',
   *  info: 'Make a selection on the list above to see results', icon: 'icon-empty-no-data',
   *  button: {text: 'xxx', click: <function>}
   *  }`
   *  Set this to null for no message or will default to 'No Data Found with an icon.'
   */
  function Radar(element, settings) {
    this.settings = utils.mergeSettings(element, settings, RADAR_DEFAULTS);
    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Radar.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.width = 0;

      this.build().handleEvents();

      /**
      * Fires when the chart is complete done rendering, for customization.
      * @event rendered
      * @memberof Radar
      * @property {object} event - The jquery event object
      * @property {array} svg - The svg object.
      */
      this.element.trigger('rendered', [this.svg]);

      return this;
    },


    /**
     * Build the Component.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    build: function build() {
      this.updateData(this.settings.dataset);
      this.setInitialSelected();
      return this;
    },


    /**
     * Update the chart with a new dataset
     * @param  {object} data The data to use.
     */
    updateData: function updateData(data) {
      var self = this;
      var settings = self.settings;
      var dims = {
        // Width of the circle
        w: parseInt(this.element.parent().width(), 10),
        // Height of the circle && 60px on top and bottom for labels
        h: parseInt(this.element.parent().height() - 115, 10)
      };

      if (settings.legendPlacement === 'right') {
        dims.w *= 0.75;
      }
      this.element.addClass('chart-radar');

      // Handle Empty Data Set
      if (data.length === 0) {
        self.element.emptymessage(self.settings.emptyMessage);
        return;
      }

      var tooltipInterval = void 0;
      var colors = d3.scaleOrdinal(self.settings.colors);

      // If the supplied maxValue is smaller than the actual one, replace by the max in the data
      var maxValue = Math.max(settings.maxValue, d3.max(data, function (i) {
        return d3.max(i.data.map(function (o) {
          return o.value;
        }));
      })); //eslint-disable-line

      var allAxis = data[0].data.map(function (i) {
        return i.name;
      }); // Map the names to the axis
      var total = allAxis.length; // The number of different axes
      var radius = Math.min(dims.w / 2, dims.h / 2); // Radius of the outermost circle
      var angleSlice = Math.PI * 2 / total; // The width in radians of each 'slice'

      // Create the Scale for the radius
      var rScale = d3.scaleLinear().range([0, radius]).domain([0, maxValue]);

      // Create the container SVG and parent g
      // Remove whatever chart with the same id/class was present before
      var elem = this.element[0];
      d3.select(elem).select('svg').remove();

      // Initiate the radar chart SVG
      var svg = d3.select(elem).append('svg').attr('width', dims.w + settings.margin.left + settings.margin.right).attr('height', dims.h + settings.margin.top + settings.margin.bottom).attr('class', 'chart-radar');

      this.svg = svg; // Pointer for selection states

      // Append a g element
      var g = svg.append('g').attr('transform', 'translate(' + (dims.w / 2 + settings.margin.left) + ',' + (dims.h / 2 + settings.margin.top) + ')');

      // Filter for the outside glow effect
      if (settings.opacityCircles > 0) {
        var filter = g.append('defs').append('filter').attr('id', 'glow');
        filter.append('feGaussianBlur').attr('stdDeviation', '2.5').attr('result', 'coloredBlur');
        var feMerge = filter.append('feMerge');
        feMerge.append('feMergeNode').attr('in', 'coloredBlur');
        feMerge.append('feMergeNode').attr('in', 'SourceGraphic');
      }

      // Draw the Circular grid

      // Wrapper for the grid & axes
      var axisGrid = g.append('g').attr('class', 'chart-radar-axis-wrapper');

      // Draw the background circles
      axisGrid.selectAll('.levels').data(d3.range(1, settings.levels + 1).reverse()).enter().append('circle').attr('class', 'chart-radar-grid-circle').attr('r', function (d) {
        return radius / settings.levels * d;
      }).style('fill-opacity', settings.opacityCircles).style('filter', settings.opacityCircles > 0 ? 'url(#glow)' : '');

      // Text indicating at what % each level is
      if (this.settings.showAxisLabels) {
        axisGrid.selectAll('.axis-label').data(d3.range(1, settings.levels + 1).reverse()).enter().append('text').attr('class', 'axis-label').attr('x', 4).attr('y', function (d) {
          return -d * radius / settings.levels;
        }).attr('dy', '0.4em').style('font-size', '10px').attr('fill', '#737373').text(function (d) {
          var text = '';
          var roundedVal = Math.round(maxValue * 10) / 10;

          if (settings.axisFormatter.indexOf('%') > -1) {
            text = d3.format(settings.axisFormatter)(roundedVal * d / settings.levels);
          } else {
            text = d3.format(settings.axisFormatter)(d / settings.levels);
          }

          return text;
        });
      }

      // Draw the axes

      // Create the straight lines radiating outward from the center
      var axis = axisGrid.selectAll('.axis').data(allAxis).enter().append('g').attr('class', 'axis');

      // Append the cross lines
      if (this.settings.showCrosslines) {
        axis.append('line').attr('x1', 0).attr('y1', 0).attr('x2', function (d, i) {
          return rScale(maxValue * 1.05) * Math.cos(angleSlice * i - Math.PI / 2);
        }).attr('y2', function (d, i) {
          return rScale(maxValue * 1.05) * Math.sin(angleSlice * i - Math.PI / 2);
        }).attr('class', 'chart-radar-crossline').style('stroke-width', '1px');
      }

      // Append the labels at each axis
      axis.append('text').attr('class', 'legend').style('font-size', '12px').attr('text-anchor', 'middle').attr('dy', '0.35em').attr('x', function (d, i) {
        return rScale(maxValue * settings.labelFactor) * Math.cos(angleSlice * i - Math.PI / 2);
      }).attr('y', function (d, i) {
        return rScale(maxValue * settings.labelFactor) * Math.sin(angleSlice * i - Math.PI / 2);
      }).text(function (d) {
        return d;
      }).call(charts.wrap, settings.wrapWidth, settings.labelFactor);

      // Draw the radar chart blobs

      // The radial line function
      var radarLine = d3.lineRadial().curve(d3.curveBasisClosed).radius(function (d) {
        return rScale(d.value);
      }).angle(function (d, i) {
        return i * angleSlice;
      });

      if (settings.roundStrokes) {
        radarLine.curve(d3.curveCardinalClosed);
      }

      // Create a wrapper for the blobs
      var blobWrapper = g.selectAll('.radarWrapper').data(data.map(function (i) {
        return i.data;
      })).enter().append('g').attr('class', 'chart-radar-wrapper');

      // Append the backgrounds
      blobWrapper.append('path').attr('class', 'chart-radar-area').attr('d', function (d) {
        return radarLine(d);
      }).style('fill', function (d, i) {
        return colors(i);
      }).style('fill-opacity', settings.opacityArea).on('click', function (d, i) {
        // Handle Click to select
        clearTimeout(tooltipInterval);

        var selectElem = d3.select(this);
        var isSelected = selectElem.classed('is-selected');
        svg.selectAll('.is-selected').classed('is-selected', false);
        svg.selectAll('.is-not-selected').classed('is-not-selected', false);

        if (!isSelected) {
          svg.selectAll('.chart-radar-area').classed('is-not-selected', true);
          selectElem.classed('is-selected', true).classed('is-not-selected', false);
          selectElem.style('fill-opacity', self.settings.opacityArea);
        }

        var triggerData = {
          elem: selectElem.nodes(),
          data: d,
          index: i
        };

        /**
        * Fires when the chart is complete done rendering, for customization.
        * @event selected
        * @memberof Radar
        * @property {object} data - The data element attached
        * @property {HTMLElement} elem - The dom element
        * @property {number} index - The index for this blob.
        */

        /**
        * Fires when the chart is complete done rendering, for customization.
        * @event deselected
        * @memberof Radar
        * @property {object} data - The data element attached
        * @property {HTMLElement} elem - The dom element
        * @property {number} index - The index for this blob.
        */
        self.element.triggerHandler(isSelected ? 'deselected' : 'selected', triggerData);

        charts.selected = !isSelected ? triggerData : [];
      });

      // Create the outlines
      blobWrapper.append('path').attr('class', 'chart-radar-stroke').attr('d', function (d) {
        return radarLine(d);
      }).style('stroke-width', settings.strokeWidth + 'px').style('stroke', function (d, i) {
        return colors(i);
      }).style('fill', 'none').style('filter', settings.opacityCircles > 0 ? 'url(#glow)' : '');

      // Append the circles
      blobWrapper.selectAll('.chart-radar-circle').data(function (d) {
        return d;
      }).enter().append('circle').attr('class', 'chart-radar-circle').attr('r', settings.dotRadius).attr('cx', function (d, i) {
        return rScale(d.value) * Math.cos(angleSlice * i - Math.PI / 2);
      }).attr('cy', function (d, i) {
        return rScale(d.value) * Math.sin(angleSlice * i - Math.PI / 2);
      }).style('fill', function () {
        return colors($(this.parentNode).index() - 1);
      }).style('fill-opacity', 0.6);

      // Wrapper for the invisible circles on top
      var blobCircleWrapper = g.selectAll('.radar-circle-wrapper').data(data.map(function (i) {
        return i.data;
      })).enter().append('g').attr('class', 'radar-circle-wrapper');

      // Append a set of invisible circles on top for the mouseover pop-up
      blobCircleWrapper.selectAll('.radar-invisible-circle').data(function (d) {
        return d;
      }).enter().append('circle').attr('class', 'radar-invisible-circle').attr('r', settings.dotRadius * 1.5).attr('cx', function (d, i) {
        return rScale(d.value) * Math.cos(angleSlice * i - Math.PI / 2);
      }).attr('cy', function (d, i) {
        return rScale(d.value) * Math.sin(angleSlice * i - Math.PI / 2);
      }).style('fill', 'none').style('pointer-events', 'all').on('mouseenter', function (d) {
        if (!settings.showTooltips) {
          return;
        }

        var offset = $(this).offset();
        var content = charts.formatToSettings(d, self.settings.tooltip);

        if (content.indexOf('<b>') === -1) {
          content = content.replace('(', '<b>');
          content = content.replace(')', '</b>');
        }

        var size = charts.tooltipSize(content);
        var x = offset.left;
        var y = offset.top;
        var padding = 6;
        x -= size.width / 2 - padding;
        y -= size.height + padding;

        // Debounce it a bit
        if (tooltipInterval != null) {
          clearTimeout(tooltipInterval);
        }

        tooltipInterval = setTimeout(function () {
          charts.showTooltip(x, y, content, 'top');
        }, 300);
      }).on('mouseleave', function () {
        clearTimeout(tooltipInterval);
        charts.hideTooltip();
      });

      // Add tooltip object
      if (settings.showTooltips) {
        charts.appendTooltip('is-pie');
      }

      if (settings.showLegend) {
        if (settings.legendPlacement) {
          this.element.addClass('has-' + settings.legendPlacement + '-legend');
        }

        var series = self.settings.dataset.map(function (d, i) {
          return {
            name: d.name,
            display: 'twocolumn',
            placement: self.settings.legendPlacement,
            color: colors(i)
          };
        });

        this.settings.svg = self.svg;
        charts.addLegend(series, 'pie', this.settings, this.element);
      }
    },


    /**
     * Set the initially selected elements
     * @private
     */
    setInitialSelected: function setInitialSelected() {},


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on('updated.' + COMPONENT_NAME$p, function () {
        _this.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on('resize.' + COMPONENT_NAME$p, function () {
          _this.handleResize();
        });

        this.element.on('resize.' + COMPONENT_NAME$p, function () {
          _this.handleResize();
        });
      }

      return this;
    },


    /**
     * Get info on the currently selected lines.
     * @returns {object} An object with the matching data and reference to the triggering element.
     */
    getSelected: function getSelected() {
      return charts.selected;
    },


    /**
     * Get info on the currently selected lines.
     * @param {object} o The selection data object
     * @param {boolean} isToggle If true toggle the current state.
     */
    setSelected: function setSelected(o, isToggle) {
      var selector = void 0;
      var arcIndex = void 0;
      var selected = 0;
      var self = this;

      this.svg.selectAll('.chart-radar-area').each(function (d, i) {
        var set = self.settings.dataset[i];
        if (!set || !set.data) {
          return;
        }

        if (selected < 1) {
          if (typeof o.fieldName !== 'undefined' && typeof o.fieldValue !== 'undefined' && o.fieldValue === set[o.fieldName] || typeof o.index !== 'undefined' && o.index === i || o.elem && $(this).is(o.elem)) {
            selected++;
            selector = d3.select(this);
            arcIndex = i;
          }
        }
      });

      if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
        selector.on('click').call(selector.node(), selector.datum(), arcIndex);
      }
    },


    /**
     * Get info on the currently selected lines.
     * @param {object} options The selected info object.
     */
    toggleSelected: function toggleSelected(options) {
      this.setSelected(options, true);
    },


    /**
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (settings && settings.dataset) {
        this.element.find('.chart-legend').remove();
        this.settings.dataset = settings.dataset;
        this.updateData(this.settings.dataset);
        return this;
      }

      this.element.empty();
      return this.build();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$p);
      $('body').off('resize.' + COMPONENT_NAME$p);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('radar-chart');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$p);
      $.removeData(this.element[0], 'radar');
    }
  };

  /*
  * jQuery Component Wrapper for Charts. It maps the singlular components
  * to the previous versions single jquery wrapper.
  * @param  {object} settings The settings to apply.
  * @returns {object} The jquery object for chaining.
  */
  $.fn.chart = function (settings) {
    var instance = null;
    this.empty(); // allow changing chart type

    switch (settings.type) {
      case 'targeted-achievement':
      case 'completion':
      case 'completion-target':
        {
          instance = this.data(settings.type);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var chartComponent = new CompletionChart(this, settings);
          this.data(COMPONENT_NAME$i, chartComponent);
          this.data('chart', chartComponent); // Compatibility
          this.data(settings.type, chartComponent); // Compatibility
          break;
        }
      case 'bullet':
        {
          instance = this.data(COMPONENT_NAME$h);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent = new Bullet(this, settings);
          this.data(COMPONENT_NAME$h, _chartComponent);
          this.data('chart', _chartComponent); // Compatibility
          break;
        }
      case 'radar':
        {
          instance = this.data(COMPONENT_NAME$p);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent2 = new Radar(this, settings);
          this.data(COMPONENT_NAME$p, _chartComponent2);
          this.data('chart', _chartComponent2); // Compatibility
          break;
        }
      case 'sparkline':
        {
          instance = this.data(COMPONENT_NAME$j);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent3 = new Sparkline(this, settings);
          this.data(COMPONENT_NAME$j, _chartComponent3);
          this.data('chart', _chartComponent3); // Compatibility
          break;
        }
      case 'sparkline-dots':
        {
          settings.isDots = true;
          instance = this.data(COMPONENT_NAME$j);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent4 = new Sparkline(this, settings);
          this.data(COMPONENT_NAME$j, _chartComponent4);
          this.data('chart', _chartComponent4); // Compatibility
          break;
        }
      case 'sparkline-peak':
        {
          settings.isPeakDot = true;
          instance = this.data(COMPONENT_NAME$j);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent5 = new Sparkline(this, settings);
          this.data(COMPONENT_NAME$j, _chartComponent5);
          this.data('chart', _chartComponent5); // Compatibility
          break;
        }
      case 'sparkline-dots-n-peak':
        {
          settings.isPeakDot = true;
          settings.isDots = true;
          instance = this.data(COMPONENT_NAME$j);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent6 = new Sparkline(this, settings);
          this.data(COMPONENT_NAME$j, _chartComponent6);
          this.data('chart', _chartComponent6); // Compatibility
          break;
        }
      case 'sparkline-minmax':
        {
          settings.isMinMax = true;
          instance = this.data(COMPONENT_NAME$j);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent7 = new Sparkline(this, settings);
          this.data(COMPONENT_NAME$j, _chartComponent7);
          this.data('chart', _chartComponent7); // Compatibility
          break;
        }
      case 'sparkline-medianrange':
        {
          settings.isMedianRange = true;
          instance = this.data(COMPONENT_NAME$j);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent8 = new Sparkline(this, settings);
          this.data(COMPONENT_NAME$j, _chartComponent8);
          this.data('chart', _chartComponent8); // Compatibility
          break;
        }
      case 'sparkline-medianrange-n-peak':
        {
          settings.isMedianRange = true;
          settings.isPeakDot = true;
          instance = this.data(COMPONENT_NAME$j);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent9 = new Sparkline(this, settings);
          this.data(COMPONENT_NAME$j, _chartComponent9);
          this.data('chart', _chartComponent9); // Compatibility
          break;
        }
      case 'line':
        {
          instance = this.data(COMPONENT_NAME$l);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent10 = new Line(this, settings);
          this.data(COMPONENT_NAME$l, _chartComponent10);
          this.data('chart', _chartComponent10); // Compatibility
          break;
        }
      case 'area':
        {
          settings.isArea = true;
          instance = this.data(COMPONENT_NAME$l);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent11 = new Line(this, settings);
          this.data(COMPONENT_NAME$l, _chartComponent11);
          this.data('chart', _chartComponent11); // Compatibility
          break;
        }
      case 'bubble':
        {
          settings.isBubble = true;
          instance = this.data(COMPONENT_NAME$l);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent12 = new Line(this, settings);
          this.data(COMPONENT_NAME$l, _chartComponent12);
          this.data('chart', _chartComponent12); // Compatibility
          break;
        }
      case 'scatterplot':
        {
          settings.isScatterPlot = true;
          instance = this.data(COMPONENT_NAME$l);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent13 = new Line(this, settings);
          this.data(COMPONENT_NAME$l, _chartComponent13);
          this.data('chart', _chartComponent13); // Compatibility
          break;
        }
      case 'column':
      case 'column-grouped':
      case 'positive-negative':
      case 'column-positive-negative':
        {
          instance = this.data(COMPONENT_NAME$m);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent14 = new Column(this, settings);
          this.data(COMPONENT_NAME$m, _chartComponent14);
          this.data('chart', _chartComponent14); // Compatibility
          break;
        }
      case 'column-stacked':
        {
          settings.isStacked = true;
          instance = this.data(COMPONENT_NAME$m);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent15 = new Column(this, settings);
          this.data(COMPONENT_NAME$m, _chartComponent15);
          this.data('chart', _chartComponent15); // Compatibility
          break;
        }
      case 'bar':
        {
          settings.isStacked = true;
          instance = this.data(COMPONENT_NAME$n);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent16 = new Bar(this, settings);
          this.data(COMPONENT_NAME$n, _chartComponent16);
          this.data('chart', _chartComponent16); // Compatibility
          break;
        }
      case 'bar-stacked':
        {
          settings.isStacked = true;
          instance = this.data(COMPONENT_NAME$n);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent17 = new Bar(this, settings);
          this.data(COMPONENT_NAME$n, _chartComponent17);
          this.data('chart', _chartComponent17); // Compatibility
          break;
        }
      case 'bar-normalized':
        {
          settings.isNormalized = true;
          instance = this.data(COMPONENT_NAME$n);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent18 = new Bar(this, settings);
          this.data(COMPONENT_NAME$n, _chartComponent18);
          this.data('chart', _chartComponent18); // Compatibility
          break;
        }
      case 'bar-grouped':
        {
          settings.isStacked = false;
          settings.isGrouped = true;
          instance = this.data(COMPONENT_NAME$n);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent19 = new Bar(this, settings);
          this.data(COMPONENT_NAME$n, _chartComponent19);
          this.data('chart', _chartComponent19); // Compatibility
          break;
        }
      case 'pie':
        {
          instance = this.data(COMPONENT_NAME$o);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent20 = new Pie(this, settings);
          this.data(COMPONENT_NAME$o, _chartComponent20);
          this.data('chart', _chartComponent20); // Compatibility
          break;
        }
      case 'donut':
        {
          settings.isDonut = true;
          instance = this.data(COMPONENT_NAME$o);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent21 = new Pie(this, settings);
          this.data(COMPONENT_NAME$o, _chartComponent21);
          this.data('chart', _chartComponent21); // Compatibility
          break;
        }
      default:
        instance = null;
    }

    return this;
  };

  // Settings and Options
  var COMPONENT_NAME$q = 'monthview';

  var COMPONENT_NAME_DEFAULTS = {
    month: new Date().getMonth(),
    year: new Date().getFullYear(),
    activeDate: null,
    activeDateIslamic: null,
    isPopup: false,
    headerStyle: 'full',
    disable: {
      dates: [],
      minDate: '',
      maxDate: '',
      dayOfWeek: [],
      isEnable: false,
      restrictMonths: false
    },
    legend: [{ name: 'Public Holiday', color: '#76B051', dates: [] }, { name: 'Weekends', color: '#EFA836', dayOfWeek: [] }],
    hideDays: false,
    showMonthYearPicker: false,
    advanceMonths: 5,
    range: {
      useRange: false, // true - if datepicker using range dates
      start: '', // Start date '03/05/2018'
      end: '', // End date '03/21/2018'
      separator: ' - ', // separator string between two dates
      minDays: 0, // Minimum days
      maxDays: 0, // Maximum days
      selectForward: false, // Only in forward direction
      selectBackward: false, // Only in backward direction
      includeDisabled: false // if true range will include disable dates in it
    },
    selectable: true,
    onSelected: null
  };

  /**
   * MonthView - Renders a Month calendar
   * @class MonthView
   * @param {string} element The plugin element for the constuctor
   * @param {object} [settings] The settings element.
   * @param {number} [settings.month] The month to show.
   * @param {number} [settings.year] The year to show.
   * @param {number} [settings.activeDate] The date to highlight as selected/today.
   * @param {number} [settings.activeDateIslamic] The date to highlight as selected/today (as an array for islamic)
   * @param {number} [settings.isPopup] Is it in a popup (datepicker using it)
   * @param {number} [settings.headerStyle] Configure the header, this can be 'simple' or 'full'. Full adds a picker and today link.
   * @param {object} [settings.disable] Disable dates in various ways.
   * For example `{minDate: 'M/d/yyyy', maxDate: 'M/d/yyyy'}`. Dates should be in format M/d/yyyy
   * or be a Date() object or string that can be converted to a date with new Date().
   * @param {array} [settings.disable.dates] Disable specific dates.
   * Example `{dates: ['12/31/2018', '01/01/2019'}`.
   * @param {string|date} [settings.disable.minDate] Disable up to a minimum date.
   * Example `{minDate: '12/31/2016'}`.
   * @param {string|date} [settings.disable.maxDate] Disable up to a maximum date.
   * Example `{minDate: '12/31/2019'}`.
   * @param {array} [settings.disable.dayOfWeek] Disable a specific of days of the week 0-6.
   * Example `{dayOfWeek: [0,6]}`.
   * @param {boolean} [settings.disable.isEnable=false] Inverse the disable settings.
   * If true all the disable settings will be enabled and the rest will be disabled.
   * So you can inverse the settings.
   * @param {boolean} [settings.disable.retrictMonths=false] Restrict month selections on datepicker.
   * It requires minDate and maxDate for the feature to activate.
   * For example if you have more non specific dates to disable then enable ect.
   * @param {object} [settings.range] Range between two dates with various options.
   * @param {boolean} [settings.range.useRange=false] Use range of two dates options.
   * @param {string|date} [settings.range.start] Start date in range.
   * @param {string|date} [settings.range.end] End date in range.
   * @param {string} [settings.range.separator=' - '] Visual separator between two dates.
   * @param {number} [settings.range.minDays=0] Minimum days to be in range.
   * @param {number} [settings.range.maxDays=0] Maximum days to be in range.
   * @param {boolean} [settings.range.selectForward=false] Range only in forward direction.
   * @param {boolean} [settings.range.selectBackward=false] Range only in backward direction.
   * @param {boolean} [settings.range.includeDisabled=false] Include disable dates in range of dates.
   * @param {boolean} [settings.hideDays=false] If true the days portion of the calendar will be hidden. Usefull for Month/Year only formats.
   * @param {boolean} [settings.showMonthYearPicker=false] If true the month and year will render as dropdowns.
   * @param {number} [settings.advanceMonths=5] The number of months in each direction to show in
   *  the dropdown for months (when initially opening)
   * @param {array} [settings.legend]  Legend Build up
   * for example `[{name: 'Public Holiday', color: '#76B051', dates: []},
   * {name: 'Weekends', color: '#EFA836', dayOfWeek: []}]`
   * @param {boolean} [settings.selectable=false] If true the month days can be clicked to select
   * @param {boolean} [settings.onSelected=false] Call back that fires when a month day is clicked.
   */
  function MonthView(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COMPONENT_NAME_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  MonthView.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    init: function init() {
      // Do initialization. Build or Events ect
      return this.build().handleEvents();
    },


    /**
     * Add any needed markup to the component.
     * @private
     * @returns {object} The Calendar prototype, useful for chaining.
     */
    build: function build() {
      // Calendar Html in Popups
      this.prevButton = '' + ('<button type="button" class="btn-icon prev">\n        ' + $.createIcon('caret-left') + '\n        <span>' + Locale.translate('PreviousMonth') + '</span>\n      </button>');
      this.nextButton = '' + ('<button type="button" class="btn-icon next">\n        ' + $.createIcon('caret-right') + '\n        <span>' + Locale.translate('NextMonth') + '</span>\n      </button>');

      this.header = $('' + ('<div class="monthview-header">\n        <span class="month">november</span>\n        <span class="year">2015</span>\n        ' + (Locale.isRTL() ? this.nextButton + this.prevButton : this.prevButton + this.nextButton) + '\n      </div>'));
      this.table = $('<table class="monthview-table" aria-label="' + Locale.translate('Calendar') + '" role="application"></table>');
      this.dayNames = $('' + '<thead>\n        <tr>\n          <th>SU</th>\n          <th>MO</th>\n          <th>TU</th>\n          <th>WE</th>\n          <th>TH</th>\n          <th>FR</th>\n          <th>SA</th>\n        </tr>\n      </thead>').appendTo(this.table);
      this.days = $('' + '<tbody>\n        <tr>\n          <td class="alternate">26</td>\n          <td class="alternate">27</td>\n          <td class="alternate">28</td>\n          <td class="alternate">29</td>\n          <td class="alternate" >30</td>\n          <td class="alternate">31</td>\n          <td>1</td>\n        </tr><tr>\n          <td>2</td>\n          <td>3</td>\n          <td>4</td>\n          <td>5</td>\n          <td>6</td>\n          <td>7</td>\n          <td>8</td>\n        </tr><tr>\n          <td>9</td>\n          <td>10</td>\n          <td>11</td>\n          <td>12</td>\n          <td>13</td>\n          <td>14</td>\n          <td>15</td>\n        </tr><tr>\n          <td>16</td>\n          <td>17</td>\n          <td>18</td>\n          <td>19</td>\n          <td class="is-today">20</td>\n          <td>21</td>\n          <td>22</td>\n        </tr><tr>\n          <td>23</td>\n          <td>24</td>\n          <td>25</td>\n          <td>26</td>\n          <td>27</td>\n          <td>28</td>\n          <td class="alternate">1</td>\n        </tr><tr>\n          <td class="alternate">2</td>\n          <td class="alternate">3</td>\n          <td class="alternate">4</td>\n          <td class="alternate">5</td>\n          <td class="alternate">6</td>\n          <td class="alternate">7</td>\n          <td class="alternate">8</td>\n        </tr>\n      </tbody>').appendTo(this.table);

      if (this.settings.hideDays) {
        this.table = '';
      }

      // Reconfigure the header
      if (this.settings.headerStyle === 'full') {
        this.header = $('' + ('<div class="monthview-header full">\n          ' + (Locale.isRTL() ? this.nextButton + this.prevButton : this.prevButton + this.nextButton) + '\n          <span class="monthview-datepicker">\n            <label for="monthview-datepicker-field" class="label audible">' + Locale.translate('Today') + '</label>\n            <input id="monthview-datepicker-field" readonly data-init="false" class="datepicker" name="monthview-datepicker-field" type="text"/>\n          </span>\n          <a class="hyperlink today" href="#">' + Locale.translate('Today') + '</a>\n        </div>'));
        this.monthPicker = this.header.find('#monthview-datepicker-field');
        this.todayLink = this.header.find('.hyperlink.today');
      }

      this.showMonth(this.settings.month, this.settings.year);
      this.calendar = this.element.addClass('monthview').append(this.header, this.table);
      if (!this.settings.isPopup) {
        this.element.addClass('is-fullsize');
      }

      // Add Legend
      this.addLegend();

      if (this.settings.disable.restrictMonths && this.settings.disable.minDate && this.settings.disable.maxDate) {
        this.validatePrevNext('start');
      }

      if (this.settings.headerStyle === 'full') {
        this.monthPicker.datepicker({
          autoSize: true,
          dateFormat: Locale.calendar().dateFormat.year,
          showMonthYearPicker: true,
          hideButtons: true
        });
        this.header.find('button, a').hideFocus();
      }

      return this;
    },


    /**
     * Set current calendar
     * @private
     * @returns {void}
     */
    setCurrentCalendar: function setCurrentCalendar() {
      if (this.settings.calendarName) {
        this.currentCalendar = Locale.getCalendar(this.settings.calendarName) || Locale.calendar();
      } else {
        this.currentCalendar = Locale.calendar();
      }
      this.isIslamic = this.currentCalendar.name === 'islamic-umalqura';
      this.conversions = this.currentCalendar.conversions;
    },


    /**
     * Update the calendar to show the given month and year
     * @param {number} month The zero based month to display
     * @param {number} year The year to display
     * @returns {void}
     */
    showMonth: function showMonth(month, year) {
      var self = this;
      var now = new Date();

      now.setHours(0);
      now.setMinutes(0);
      now.setSeconds(0);

      var elementDate = this.settings.activeDate && this.settings.activeDate.getDate() ? this.settings.activeDate : now;

      this.setCurrentCalendar();

      if (this.isIslamic) {
        if (!this.settings.activeDateIslamic) {
          var gregorianDate = new Date();
          this.todayDateIslamic = this.conversions.fromGregorian(gregorianDate);
          this.settings.activeDateIslamic = [];
          this.settings.activeDateIslamic[0] = this.todayDateIslamic[0];
          this.settings.activeDateIslamic[1] = this.todayDateIslamic[1];
          this.settings.activeDateIslamic[2] = this.todayDateIslamic[2];
          year = this.settings.activeDateIslamic[0];
          month = this.settings.activeDateIslamic[1];
        }
        elementDate = this.conversions.fromGregorian(now);
      }

      if (year.toString().length < 4) {
        year = new Date().getFullYear();
      }

      if (month === 12) {
        year++;
        month = 0;
        this.currentMonth = month;
        this.currentYear = year;
      }

      if (month < 0) {
        year--;
        month = 11;
        this.currentMonth = month;
        this.currentYear = year;
      }

      var days = this.currentCalendar.days.narrow;
      days = days || this.currentCalendar.days.abbreviated;

      if (!this.settings.isPopup) {
        days = this.currentCalendar.days.abbreviated;
      }
      var monthName = this.currentCalendar.months.wide[month];

      this.currentMonth = month;
      this.currentYear = year;

      // Set the Days of the week
      var firstDayofWeek = this.currentCalendar.firstDayofWeek || 0;
      this.dayNames.find('th').each(function (i) {
        $(this).text(days[(i + firstDayofWeek) % 7]);
      });

      // Localize Month Name
      this.yearFirst = this.currentCalendar.dateFormat.year && this.currentCalendar.dateFormat.year.substr(1, 1) === 'y';
      this.header.find('.month').attr('data-month', month).text(xssUtils.stripTags(monthName) + ' ');
      this.header.find('.year').text(' ' + year);

      if (this.yearFirst && !this.isIslamic && !Locale.isRTL()) {
        elementDate.setFullYear(year);
        var translation = Locale.formatDate(elementDate, { date: 'year' });
        var justYear = translation.split(' ')[0];

        this.header.find('.year').text(justYear + ' ');
        this.header.find('.year').insertBefore(this.header.find('.month'));
      }

      if (this.settings.headerStyle === 'full' && this.monthPicker) {
        this.monthPicker.val(Locale.formatDate(new Date(year, month, 1), { date: 'year' }));
        if (this.monthPicker.data('datepicker')) {
          this.monthPicker.data('datepicker').setSize();
        }
      }

      this.appendMonthYearPicker(month, year);

      // Adjust days of the week
      // lead days
      var firstDayOfMonth = this.firstDayOfMonth(year, month);
      var leadDays = (firstDayOfMonth - (this.currentCalendar.firstDayofWeek || 0) + 7) % 7;
      var lastMonthDays = this.daysInMonth(year, month + (this.isIslamic ? 1 : 0));
      var thisMonthDays = this.daysInMonth(year, month + (this.isIslamic ? 0 : 1));
      var nextMonthDayCnt = 1;
      var dayCnt = 1;
      var exYear = void 0;
      var exMonth = void 0;
      var exDay = void 0;

      var s = this.settings;
      this.dayMap = [];
      this.days.find('td').each(function (i) {
        var th = $(this).removeClass('alternate prev-month next-month is-selected range is-today');
        th.removeAttr('aria-selected');

        if (i < leadDays) {
          exDay = lastMonthDays - leadDays + 1 + i;
          exMonth = month === 0 ? 11 : month - 1;
          exYear = month === 0 ? year - 1 : year;

          self.setDisabled(th, exYear, exMonth, exDay);
          self.setLegendColor(th, exYear, exMonth, exDay);
          self.dayMap.push({ key: stringUtils.padDate(exYear, exMonth, exDay), elem: th });
          th.addClass('alternate prev-month').html('<span class="day-container"><span aria-hidden="true" class="day-text">' + xssUtils.stripTags(exDay) + '</span></span>');
          th.data('key', stringUtils.padDate(exYear, exMonth, exDay));
        }

        if (i >= leadDays && dayCnt <= thisMonthDays) {
          self.dayMap.push({ key: stringUtils.padDate(year, month, dayCnt), elem: th });
          th.html('<span class="day-container"><span aria-hidden="true" class="day-text">' + xssUtils.stripTags(dayCnt) + '</span></span>');
          th.data('key', stringUtils.padDate(year, month, dayCnt));

          // Add Selected Class to Selected Date
          if (self.isIslamic) {
            if (year === elementDate[0] && month === elementDate[1] && dayCnt === elementDate[2]) {
              th.addClass('is-selected' + (s.range.useRange ? ' range' : '')).attr('aria-selected', 'true');
            }
          } else {
            var tHours = elementDate.getHours();
            var tMinutes = elementDate.getMinutes();
            var tSeconds = self.isSeconds ? elementDate.getSeconds() : 0;

            if (new Date(year, month, dayCnt).setHours(tHours, tMinutes, tSeconds, 0) === elementDate.setHours(tHours, tMinutes, tSeconds, 0)) {
              th.addClass('is-selected' + (s.range.useRange ? ' range' : '')).attr('aria-selected', 'true');
            }
          }

          if (dayCnt === self.todayDay && self.currentMonth === self.todayMonth && self.currentYear === self.todayYear) {
            th.addClass('is-today');
          }

          th.attr('aria-label', Locale.formatDate(new Date(self.currentYear, self.currentMonth, dayCnt), { date: 'full' }));

          self.setDisabled(th, year, month, dayCnt);
          self.setLegendColor(th, year, month, dayCnt);

          th.attr('role', 'link');
          dayCnt++;
          return;
        }

        if (dayCnt >= thisMonthDays + 1) {
          exDay = nextMonthDayCnt;
          exMonth = month === 11 ? 0 : month + 1;
          exYear = month === 11 ? year + 1 : year;

          self.dayMap.push({ key: stringUtils.padDate(exYear, exMonth, exDay), elem: th });
          self.setDisabled(th, exYear, exMonth, exDay);
          self.setLegendColor(th, exYear, exMonth, exDay);

          th.addClass('alternate next-month').html('<span class="day-container"><span aria-hidden="true" class="day-text">' + nextMonthDayCnt + '</span></span>');
          th.data('key', stringUtils.padDate(exYear, exMonth, exDay));
          nextMonthDayCnt++;
        }
      });

      // Hide 6th Row if all disabled
      var row = this.days.find('tr').eq(5);
      if (row.find('td.alternate').length === 7) {
        row.hide();
      } else {
        row.show();
      }

      /**
      * Fires as the calendar popup is opened.
      * @event monthrendered
      * @memberof MonthView
      * @property {object} event - The jquery event object
      * @property {object} args - The event arguments
      * @property {number} args.year - The rendered year
      * @property {object} args.elem - The DOM object
      * @property {object} args.api - The MonthView api
      */
      this.element.trigger('monthrendered', { year: year, month: month, elem: this.element, api: this });
    },


    /**
     * Append month year picker
     * @private
     * @param {number} month The month to show in the picker
     * @param {number} year The year to show in the picker
     * @returns {void}
     */
    appendMonthYearPicker: function appendMonthYearPicker(month, year) {
      var self = this;

      if (!this.settings.showMonthYearPicker) {
        return;
      }

      this.header.addClass('is-monthyear');

      var monthDropdown = '' + ('<label for="month-dropdown" class="audible">\n        ' + Locale.translate('Month') + '\n      </label>\n      <select id="month-dropdown" class="dropdown">');

      var wideMonths = this.currentCalendar.months.wide;
      // eslint-disable-next-line
      wideMonths.map(function (monthMap, i) {
        monthDropdown += '<option ' + (i === month ? ' selected ' : '') + ' value="' + i + '">' + monthMap + '</option>';
      });
      monthDropdown += '</select>';

      var monthSpan = this.header.find('.month').empty().append(monthDropdown);
      monthSpan.find('select.dropdown').dropdown().off('change.monthview').on('change.monthview', function () {
        var elem = $(this);
        self.currentMonth = parseInt(elem.val(), 10);
        self.showMonth(self.currentMonth, self.currentYear);
      });

      var yearDropdown = '' + ('<label for="year-dropdown" class="audible">\n        ' + Locale.translate('Year') + '\n      </label>\n      <select id="year-dropdown" class="dropdown year">');

      var years = [];

      for (var i = this.settings.advanceMonths; i >= 1; i--) {
        years.push(parseInt(year, 10) - i);
      }
      years.push(year);
      for (var j = 1; j <= this.settings.advanceMonths; j++) {
        years.push(parseInt(year, 10) + j);
      }

      // eslint-disable-next-line
      years.map(function (yearMap) {
        yearDropdown += '<option ' + (year === yearMap ? ' selected ' : '') + ' value="' + yearMap + '">' + yearMap + '</option>';
      });
      yearDropdown += '</select>';

      var yearSpan = this.header.find('.year').empty().append(yearDropdown);
      yearSpan.find('select.dropdown').dropdown().off('change.datepicker').on('change.datepicker', function () {
        var elem = $(this);
        self.currentYear = parseInt(elem.val(), 10);
        self.showMonth(self.currentMonth, self.currentYear, true);
      });

      if (this.yearFirst) {
        yearSpan.find('.dropdown-wrapper').css('left', '0');
        monthSpan.find('.dropdown-wrapper').css('left', '10px');
      }
    },


    /**
     * Find first day of the week for a given month
     * @private
     * @param {number} year The year to use with the month
     * @param {number} month The month to find the first day for
     * @returns {number} day
     */
    firstDayOfMonth: function firstDayOfMonth(year, month) {
      if (this.isIslamic) {
        var firstDay = this.conversions.toGregorian(year, month, 1);
        return firstDay === null ? 1 : firstDay.getDay();
      }
      return new Date(year, month, 1).getDay();
    },


    /**
     * Find the date of the Month (29, 30, 31 ect)
     * @private
     * @param {number} year The year to use with the month
     * @param {number} month The month to find the days in month for
     * @returns {number} date
     */
    daysInMonth: function daysInMonth(year, month) {
      if (this.isIslamic) {
        var monthLengthBitmap = this.conversions.yearInfo[this.islamicYearIndex(year)][0];
        var monthDayCount = 0;
        for (var M = 0; M <= month; M++) {
          // eslint-disable-next-line
          monthDayCount = 29 + (monthLengthBitmap & 1);
          if (M === month) {
            return monthDayCount;
          }
          // eslint-disable-next-line
          monthLengthBitmap = monthLengthBitmap >> 1;
        }
        return 0;
      }
      return new Date(year, month, 0).getDate();
    },


    /**
     * Get the islamic year index
     * @private
     * @param {number} islamicYear Year to test.
     * @returns {number} index
     */
    islamicYearIndex: function islamicYearIndex(islamicYear) {
      var yearIdx = islamicYear - 1318;
      if (yearIdx < 0 || yearIdx >= this.conversions.yearInfo.length) {
        return 0; // for an out-of-range year, simply returns 0
      }
      return yearIdx;
    },


    /**
     * Set disable Date
     * @private
     * @param {object} elem Node element to set.
     * @param {string} year to check.
     * @param {string} month to check.
     * @param {string} date to check.
     * @returns {void}
     */
    setDisabled: function setDisabled(elem, year, month, date) {
      var s = this.settings;
      var dateIsDisabled = this.isDateDisabled(year, month, date);
      elem.removeClass('is-disabled').removeAttr('aria-disabled');

      if (dateIsDisabled && !s.disable.isEnable || !dateIsDisabled && s.disable.isEnable) {
        elem.addClass('is-disabled').attr('aria-disabled', 'true').removeClass('is-selected range').removeAttr('aria-selected');
      }
    },


    /**
     * Check through the options to see if the date is disabled
     * @private
     * @param {string} year to check.
     * @param {string} month to check.
     * @param {string} date to check.
     * @returns {boolean} true if the date is disabled
     */
    isDateDisabled: function isDateDisabled(year, month, date) {
      var s = this.settings;
      var min = new Date(s.disable.minDate).setHours(0, 0, 0, 0);
      var max = new Date(s.disable.maxDate).setHours(0, 0, 0, 0);
      var d2 = new Date(year, month, date);

      // dayOfWeek
      if (s.disable.dayOfWeek.indexOf(d2.getDay()) !== -1) {
        return true;
      }

      d2 = d2.setHours(0, 0, 0, 0);

      // min and max
      if (d2 <= min || d2 >= max) {
        return true;
      }

      // dates
      if (s.disable.dates.length && typeof s.disable.dates === 'string') {
        s.disable.dates = [s.disable.dates];
      }

      for (var i = 0, l = s.disable.dates.length; i < l; i++) {
        var d = new Date(s.disable.dates[i]);
        if (d2 === d.setHours(0, 0, 0, 0)) {
          return true;
        }
      }

      return false;
    },


    /**
     * Get array of dates between two dates
     * @private
     * @param {object} startDate .
     * @param {object} endDate .
     * @param {boolean} includeDisabled .
     * @returns {array} dates between two dates
     */
    getDateRange: function getDateRange(startDate, endDate, includeDisabled) {
      var dates = [];
      var current = new Date(startDate);

      includeDisabled = typeof includeDisabled !== 'undefined' ? includeDisabled : this.settings.range.includeDisabled;

      while (endDate.getTime() >= current.getTime()) {
        if (includeDisabled || !includeDisabled && !this.isDateDisabled(current.getFullYear(), current.getMonth(), current.getDate())) {
          dates.push(new Date(current));
        }
        current.setDate(current.getDate() + 1);
      }
      return dates;
    },


    /**
     * Set Color for the Legend settings
     * @private
     * @param {object} elem to set.
     * @param {string} year to check.
     * @param {string} month to check.
     * @param {string} date to check.
     * @returns {void}
     */
    setLegendColor: function setLegendColor(elem, year, month, date) {
      if (!this.settings.showLegend || !elem[0]) {
        return;
      }

      var hex = this.getLegendColor(year, month, date);
      var self = this;

      elem[0].style.backgroundColor = '';
      elem.off('mouseenter.legend mouseleave.legend');

      if (hex) {
        // set color on elem at .3 of provided color as per design
        elem.addClass('is-colored');
        elem[0].style.backgroundColor = this.hexToRgba(hex, 0.3);

        var normalColor = self.hexToRgba(hex, 0.3);
        var hoverColor = self.hexToRgba(hex, 0.7);

        // handle hover states
        elem.on('mouseenter.legend', function () {
          var thisElem = $(this);
          thisElem[0].style.backgroundColor = hoverColor;
          thisElem.find('span')[0].style.backgroundColor = 'transparent';
        }).on('mouseleave.legend', function () {
          var thisElem = $(this);
          thisElem[0].style.backgroundColor = normalColor;
          thisElem.find('span')[0].style.backgroundColor = '';
        });
      }
    },


    /**
     * Process Color Options to get the date color
     * @private
     * @param {string} year .
     * @param {string} month .
     * @param {string} date .
     * @returns {string} date color
     */
    /* eslint-disable consistent-return */
    getLegendColor: function getLegendColor(year, month, date) {
      var s = this.settings;
      if (!s.showLegend) {
        return;
      }

      var checkDate = new Date(year, month, date);
      var checkHours = checkDate.setHours(0, 0, 0, 0);

      for (var i = 0; i < s.legend.length; i++) {
        var series = s.legend[i];

        // Check Day of week
        if (series.dayOfWeek && series.dayOfWeek.indexOf(checkDate.getDay()) !== -1) {
          return series.color;
        }

        // Check for dates that match
        if (series.dates) {
          for (var j = 0; j < series.dates.length; j++) {
            var d = new Date(series.dates[j]);
            if (checkHours === d.setHours(0, 0, 0, 0)) {
              return series.color;
            }
          }
        }
      }

      return '';
    },

    /* eslint-enable consistent-return */

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.on('updated.' + COMPONENT_NAME$q, function () {
        self.updated();
      });

      // Change Month Events
      this.header.off('click.datepicker').on('click.datepicker', 'button', function () {
        var isNext = $(this).is('.next');
        var range = {};

        if (self.settings.disable.restrictMonths && self.settings.disable.minDate && self.settings.disable.maxDate) {
          self.validatePrevNext(isNext);
        }

        if (self.settings.range.useRange) {
          if (isNext) {
            range.date = new Date(self.currentYear, self.currentMonth + 1, self.element.find('.next-month:visible').length + 1);
          } else {
            range.date = new Date(self.currentYear, self.currentMonth, 1);
            range.date.setDate(range.date.getDate() - (self.days.find('.prev-month:visible').length + 1));
          }
        }

        self.showMonth(self.currentMonth + (isNext ? 1 : -1), self.currentYear);

        if (self.settings.range.useRange) {
          range.formatedDate = Locale.formatDate(range.date, { date: 'full' });
          range.cell = self.days.find('[aria-label="' + range.formatedDate + '"]');
          self.setRangeOnCell(self.settings.range.second ? false : range.cell);
        }
      });

      if (self.settings.range.useRange) {
        this.header.off('mouseover.datepicker').on('mouseover.datepicker', 'button', function () {
          if (self.settings.range.extra) {
            self.setRangeOnCell($(this).is('.next') ? self.settings.range.extra.maxCell : self.settings.range.extra.minCell);
          }
        }).off('focus.datepicker').on('focus.datepicker', 'button:not(.hide-focus)', function () {
          if (self.settings.range.extra) {
            self.setRangeOnCell($(this).is('.next') ? self.settings.range.extra.maxCell : self.settings.range.extra.minCell);
          }
        });

        this.days.off('mouseover.datepicker').on('mouseover.datepicker', 'td', function () {
          self.setRangeOnCell(this);
        });
      }

      if (self.settings.headerStyle === 'full' && this.monthPicker) {
        this.monthPicker.off('change.monthview').on('change.monthview', function () {
          var picker = $(this).data('datepicker');
          if (self.isIslamic) {
            self.showMonth(picker.currentIslamicDate[1], picker.currentIslamicDate[0]);
            return;
          }
          var currentDate = picker.currentDate;
          self.showMonth(currentDate.getMonth(), currentDate.getFullYear());
        });

        this.todayLink.off('click.monthview').on('click.monthview', function () {
          self.showTodaysMonth();
        });
      }

      // Allow dates to be selected
      if (self.settings.selectable) {
        self.element.addClass('is-selectable').off('click.monthview-day').on('click.monthview-day', 'td', function (e) {
          var node = e.currentTarget;
          var data = $(e.currentTarget).data();
          var key = data.key;

          var args = {
            node: node,
            key: key,
            day: parseInt(key.substr(6, 2), 10),
            month: parseInt(key.substr(4, 2), 10),
            year: parseInt(key.substr(0, 4), 10)
          };

          self.element.trigger('selected', args);
          if (self.settings.onSelected) {
            self.settings.onSelected(node, args);
          }

          self.element.find('td.is-selected').removeClass('is-selected');
          $(node).addClass('is-selected');
        });
      }

      return this;
    },


    /**
     * Move the monthview to the month that has today in it.
     */
    showTodaysMonth: function showTodaysMonth() {
      var todayDate = new Date();

      if (this.isIslamic) {
        var islamicDateParts = this.conversions.fromGregorian(todayDate);
        this.showMonth(islamicDateParts[1], islamicDateParts[0]);
        return;
      }

      this.showMonth(todayDate.getMonth(), todayDate.getFullYear());

      if (this.settings.selectable) {
        this.element.find('td.is-selected').trigger('click.monthview-day');
      }
    },


    /**
     * Validate the Previous and Next Button availability.
     * @private
     * @param {string | boolean} isNext to validate the current selected.
     */
    validatePrevNext: function validatePrevNext(isNext) {
      var self = this;

      var currMonth = self.currentMonth;
      if (isNext !== 'start') {
        currMonth = isNext ? self.currentMonth + 1 : self.currentMonth - 1;
      }

      var minDate = new Date(self.settings.disable.minDate);
      var maxDate = new Date(self.settings.disable.maxDate);

      if (minDate.getFullYear() >= self.currentYear && self.currentYear <= maxDate.getFullYear()) {
        if (minDate.getMonth() === currMonth) {
          this.element.find('.prev').prop('disabled', true);
        } else {
          this.element.find('.prev').prop('disabled', false);
        }

        if (currMonth >= maxDate.getMonth()) {
          this.element.find('.next').prop('disabled', true);
        } else {
          this.element.find('.next').prop('disabled', false);
        }
      } else {
        this.element.find('.prev').prop('disabled', false);
        this.element.find('.next').prop('disabled', false);
      }
    },


    /**
     * Add a Legend below the table
     * @private
     * @returns {void}
     */
    addLegend: function addLegend() {
      var s = this.settings;
      if (!s.showLegend) {
        return;
      }

      // Remove Legend
      if (this.legend && this.legend.length) {
        this.legend.remove();
      }

      this.legend = $('<div class="monthview-legend"></div>');

      for (var i = 0; i < s.legend.length; i++) {
        var series = s.legend[i];
        var item = '' + ('<div class="monthview-legend-item">\n          <span class="monthview-legend-swatch" style="background-color: ' + this.hexToRgba(series.color, 0.3) + '"></span>\n          <span class="monthview-legend-text">' + series.name + '</span>\n        </div>');

        this.legend.append(item);
      }
      this.table.after(this.legend);
    },


    /**
     * Convert the provided hex to an RGBA for states
     * This may be later moved into a colors file along with getLuminousColorShade
     * @private
     * @param {string} hex to set.
     * @param {string} opacity to check.
     * @returns {string} converted rgba
     */
    hexToRgba: function hexToRgba(hex, opacity) {
      var c = void 0;
      if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
        c = hex.substring(1).split('');

        if (c.length === 3) {
          c = [c[0], c[0], c[1], c[1], c[2], c[2]];
        }

        c = '0x' + c.join('');
        // eslint-disable-next-line
        return 'rgba(' + [c >> 16 & 255, c >> 8 & 255, c & 255].join(',') + ',' + opacity.toString() + ')';
      }
      return '';
    },


    /**
     * Set range on given cell -or- current month/year.
     * @private
     * @param {object} cell to set range.
     * @returns {void}
     */
    setRangeOnCell: function setRangeOnCell(cell) {
      var self = this;
      var s = this.settings;

      if (s.range.useRange && s.range.first && !s.range.second) {
        var first = s.range.first;
        var extra = s.range.extra;
        var len = extra.cellLength - 1;
        var firstCell = first.rowIdx + first.cellIdx + len * first.rowIdx;
        cell = $(cell); // First date selected cell element

        if (cell.length && !cell.is('.is-disabled, .is-selected')) {
          var row = cell.closest('tr');
          var cellIdx = cell.index();
          var rowIdx = row.index();
          var thisCell = rowIdx + cellIdx + len * rowIdx;
          var d = self.getCellDate(cell);
          var cellDate = new Date(d.year, d.month, d.day);
          var max = this.getDifferenceToDate(s.range.first.date, s.range.maxDays);

          self.days.find('td:visible').each(function (i) {
            var thisTd = $(this);
            if (cellDate > s.range.first.date && !s.range.selectBackward && (!s.range.maxDays || s.range.maxDays > 0 && cellDate.getTime() <= max.aftertime) && (i > firstCell && i <= thisCell || cellDate > extra.max && i <= thisCell)) {
              thisTd.addClass('range-next');
            } else if (cellDate < s.range.first.date && !s.range.selectForward && (!s.range.maxDays || s.range.maxDays > 0 && cellDate.getTime() >= max.beforetime) && (i < firstCell && i >= thisCell || cellDate < extra.min && i >= thisCell)) {
              thisTd.addClass('range-prev');
            } else {
              thisTd.removeClass('range-next range-prev');
            }
          });
        } else if (!cell.length) {
          self.days.find('td').removeClass('range-next range-prev');
        }
      }
      if (!cell && s.range.second) {
        self.setRangeSelected();
      }
    },


    /**
     * Get difference to given date
     * @private
     * @param {object} date .
     * @param {number} days .
     * @param {boolean} includeDisabled .
     * @returns {object} before/after difference to given date
     */
    getDifferenceToDate: function getDifferenceToDate(date, days, includeDisabled) {
      var _this = this;

      var difference = {};
      var move = function move(d, daystomove, isNext) {
        d = new Date(d);
        while (daystomove > 0) {
          d.setDate(d.getDate() + (isNext ? 1 : -1));
          if (includeDisabled || !includeDisabled && !_this.isDateDisabled(d.getFullYear(), d.getMonth(), d.getDate())) {
            daystomove--;
            difference[isNext ? 'after' : 'before'] = new Date(d);
          }
        }
        if (isNext && difference.after) {
          difference.aftertime = difference.after.getTime();
        } else if (difference.before) {
          difference.beforetime = difference.before.getTime();
        }
      };
      includeDisabled = typeof includeDisabled !== 'undefined' ? includeDisabled : this.settings.range.includeDisabled;
      move(date, days); // previous
      move(date, days, true); // next
      return difference;
    },


    /**
     * Set range selected value
     * @private
     * @returns {void}
     */
    setRangeSelected: function setRangeSelected() {
      var self = this;
      var s = this.settings;
      var dateObj = function dateObj(d) {
        return new Date(d.year, d.month, d.day);
      };

      if (s.range.useRange && s.range.second && s.range.second.date && this.days && this.days.length) {
        this.days.find('td').removeClass('range range-next range-prev range-selection end-date is-selected');
        this.days.find('td:visible').each(function () {
          var cell = $(this);
          var isDisabled = cell.is('.is-disabled') && !s.range.includeDisabled;
          var includeDisabled = cell.is('.is-disabled') && s.range.includeDisabled;
          var includeDisableClass = includeDisabled ? ' include-disabled' : '';
          var getTime = function getTime(d) {
            d = new Date(d);
            d.setHours(0, 0, 0);
            return d.getTime();
          };
          var date = getTime(dateObj(self.getCellDate(cell)));
          var d1 = getTime(s.range.first.date);
          var d2 = getTime(s.range.second.date);

          if ((date === d1 || date === d2) && !isDisabled) {
            cell.addClass('is-selected' + includeDisableClass + (d1 !== d2 ? ' range-selection' + (date === d2 ? ' end-date' : '') : ''));
          } else if (date > d1 && date < d2 && !isDisabled) {
            cell.addClass('range-selection' + includeDisableClass);
          }
        });
      }
    },


    /**
     * Get date from given cell.
     * @private
     * @param {object} cell to get date.
     * @returns {object} as: year, month, day
     */
    getCellDate: function getCellDate(cell) {
      var s = this.settings;
      var day = parseInt(cell.text(), 10);
      var month = parseInt(this.header.find('.month').attr('data-month'), 10);
      var year = parseInt(this.header.find('.year').text(), 10);

      if (s.showMonthYearPicker) {
        year = parseInt(this.header.find('.year select').val(), 10);
        month = parseInt(this.header.find('.month select').val(), 10);
      }

      if (cell.hasClass('prev-month')) {
        if (month === 0) {
          month = 11;
          year--;
        } else {
          month--;
        }
      } else if (cell.hasClass('next-month')) {
        if (month === 11) {
          month = 0;
          year++;
        } else {
          month++;
        }
      }

      return { year: year, month: month, day: day };
    },


    /**
     * Handle updated settings and values.
     * @returns {object} [description]
     */
    updated: function updated() {
      return this.destroy().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.header.off();
      this.days.off();
      this.element.off('updated.' + COMPONENT_NAME$q);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @private
     * @returns {object} The prototype.
     */
    destroy: function destroy() {
      this.teardown();
      this.element.empty();
      $.removeData(this.element[0], COMPONENT_NAME$q);
      return this;
    }
  };

  // Settings and Options
  var COMPONENT_NAME$r = 'calendar';

  var COMPONENT_NAME_DEFAULTS$1 = {
    eventTypes: [{ id: 'example', label: 'Example', color: 'emerald07', checked: true, click: function click() {} }],
    events: [],
    month: new Date().getMonth(),
    year: new Date().getFullYear(),
    showViewChanger: true,
    onRenderMonth: null,
    template: null
  };

  /**
   * Calendar - Full eventing calendar.
   * @class Calendar
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {array} [settings.eventTypes] An array of objects with data for the event types.
   * @param {array} [settings.events] An array of objects with data for the events.
   * @param {array} [settings.month] Initial month to show.
   * @param {array} [settings.year] Initial year to show.
   * @param {boolean} [settings.showViewChanger] If false the dropdown to change views will not be shown.
   * @param {function} [settings.onRenderMonth] Fires when a month is rendered, allowing you to pass back events or event types to show.
   * @param {function} [settings.onSelected] Fires when a month day is clicked. Allowing you to do something.
   * @param {string} [settings.template] The ID of the template used for the events. This template will be used for editing events.
   */
  function Calendar(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COMPONENT_NAME_DEFAULTS$1);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Calendar.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @returns {object} The Component prototype, useful for chaining.
     */
    init: function init() {
      // Do initialization. Build or Events ect
      return this.build().handleEvents();
    },


    /**
     * Add any needed markup to the component.
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    build: function build() {
      this.renderEventTypes().renderMonthView().renderViewChanger();
      return this;
    },


    /**
     * Render the eventType Section
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    renderEventTypes: function renderEventTypes() {
      this.eventTypeContainer = document.querySelector('.calendar-event-types');
      if (!this.eventTypeContainer) {
        return false;
      }

      var eventTypeMarkup = '';
      for (var i = 0; i < this.settings.eventTypes.length; i++) {
        var eventType = this.settings.eventTypes[i];
        eventTypeMarkup += '<input type="checkbox" class="checkbox ' + eventType.color + '07" name="' + eventType.id + '" id="' + eventType.id + '" checked="' + (eventType.checked ? 'true' : 'false') + '" ' + (eventType.disabled ? 'disabled="true"' : '') + ' />\n        <label for="' + eventType.id + '" class="checkbox-label">' + eventType.label + '</label><br/>';
      }
      this.eventTypeContainer.innerHTML = eventTypeMarkup;
      this.element.initialize();
      return this;
    },


    /**
     * Render the monthview calendar
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    renderMonthView: function renderMonthView() {
      this.monthViewContainer = document.querySelector('.calendar .calendar-monthview');

      this.monthView = new MonthView(this.monthViewContainer, {
        onRenderMonth: this.settings.onRenderMonth,
        onSelected: this.settings.onSelected,
        selectable: true,
        month: this.settings.month,
        year: this.settings.year
      });
      this.monthViewHeader = document.querySelector('.calendar .monthview-header');
      this.renderEvents();
      return this;
    },


    /**
     * Render the dropdown to change views.
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    renderViewChanger: function renderViewChanger() {
      if (!this.settings.showViewChanger) {
        return this;
      }
      var viewChangerHtml = '<label for="calendar-view-changer" class="label audible">' + Locale.translate('ChangeView') + '</label>\n      <select id="calendar-view-changer" name="calendar-view-changer" class="dropdown">\n        <option value="month" selected>' + Locale.translate('Month') + '</option>\n        <option value="week" disabled>' + Locale.translate('Week') + '</option>\n        <option value="day" disabled>' + Locale.translate('Day') + '</option>\n        <option value="schedule" disabled>' + Locale.translate('Schedule') + '</option>\n      </select>\n    </div>';
      $(this.monthViewHeader).append(viewChangerHtml);
      this.viewChangerHtml = $('#calendar-view-changer');
      this.viewChangerHtml.dropdown();
      return this;
    },


    /**
     * Render or re-render the events details section, using on the readonly or default eventTemplate
     * @param {string} eventId The event id
     * @private
     */
    renderEventDetails: function renderEventDetails(eventId) {
      if ((typeof Tmpl === 'undefined' ? 'undefined' : _typeof(Tmpl)) !== 'object' || !this.settings.template || !this.settings.events) {
        return;
      }

      // Find the event data
      var eventData = this.settings.events.filter(function (event) {
        return event.id === eventId;
      });
      if (!eventData) {
        return;
      }

      this.eventDetailsContainer = document.querySelector('.calendar-event-details');

      // create a copy of the template
      if (this.settings.template instanceof $) {
        this.settings.template = '' + this.settings.template.html();
      } else if (typeof this.settings.template === 'string') {
        // If a string doesn't contain HTML elments,
        // assume it's an element ID string and attempt to select with jQuery
        if (!stringUtils.containsHTML(this.settings.template)) {
          this.settings.template = $('#' + this.settings.template).html();
        }
      }

      var event = eventData[0];
      event.color = this.getEventTypeColor(event.type);
      event.startsLong = Locale.formatDate(event.starts, { date: 'long' });
      event.endsLong = Locale.formatDate(event.ends, { date: 'long' });
      event.typeLabel = this.getEventTypeLabel(event.type);

      var renderedTmpl = Tmpl.compile(this.settings.template, { event: event });
      this.eventDetailsContainer.innerHTML = renderedTmpl;
    },


    /**
     * Clear all contents from the event details area.
     * @private
     */
    clearEventDetails: function clearEventDetails() {
      this.eventDetailsContainer = document.querySelector('.calendar-event-details');
      if (this.eventDetailsContainer) {
        this.eventDetailsContainer.innerHTML = '';
      }
    },


    /**
     * Get the currently unchecked filter types
     * @returns {array} The active types.
     * @private
     */
    filterEventTypes: function filterEventTypes() {
      var checkboxes = this.eventTypeContainer.querySelectorAll('.checkbox');
      var types = [];

      for (var i = 0; i < checkboxes.length; i++) {
        var input = checkboxes[i];
        if (!input.checked) {
          types.push(input.getAttribute('id'));
        }
      }
      return types;
    },


    /**
     * Render/ReRender the events attached to the settings.
     * @param {boolean} isCallback Will be set to true when a callback occurs
     * @returns {object} The Calendar prototype, useful for chaining.
     */
    renderEvents: function renderEvents(isCallback) {
      var _this = this;

      if (this.settings.onRenderMonth && !isCallback) {
        this.callOnRenderMonth();
        return this;
      }

      var self = this;
      var filters = this.filterEventTypes();

      this.visibleEvents = [];
      this.removeAllEvents();

      var _loop = function _loop(i) {
        var event = _this.settings.events[i];
        if (filters.indexOf(event.type) > -1) {
          return 'continue';
        }

        // Check for events starting on this day , or only on this day.
        var startDate = new Date(event.starts);
        var startKey = stringUtils.padDate(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());

        // Check for events extending onto this day
        var endDate = new Date(event.ends);
        var endKey = stringUtils.padDate(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());

        var days = self.monthView.dayMap.filter(function (day) {
          return day.key >= startKey && day.key <= endKey;
        });

        // Event is only on this day
        if (days.length === 1) {
          var color = self.getEventTypeColor(event.type);
          self.appendEvent(days[0].elem[0], event, color, 'event-day-start-end');
        }

        // Event extends multiple days
        if (days.length > 1) {
          var _color = self.getEventTypeColor(event.type);
          for (var l = 0; l < days.length; l++) {
            var cssClass = l === 0 ? 'event-day-start' : 'event-day-span';

            if (days.length - 1 === l) {
              cssClass = 'event-day-end';
            }
            self.appendEvent(days[l].elem[0], event, _color, cssClass);
          }
        }
      };

      for (var i = 0; i < this.settings.events.length; i++) {
        var _ret = _loop(i);

        if (_ret === 'continue') continue;
      }

      return this;
    },


    /**
     * Remove all events from the month.
     */
    removeAllEvents: function removeAllEvents() {
      this.monthViewContainer.querySelectorAll('.calendar-event-more').forEach(function (e) {
        return e.parentNode.removeChild(e);
      });
      this.monthViewContainer.querySelectorAll('.calendar-event').forEach(function (e) {
        return e.parentNode.removeChild(e);
      });
    },


    /**
     * Add the ui event to the container.
     * @param {object} container The container to append to
     * @param {object} event The event data object.
     * @param {string} color The color to shade
     * @param {string} type Type of event, can be event-day-start, event-day-start-end, event-day-span, event-day-end
     * @returns {object} The Calendar prototype, useful for chaining.
     */
    appendEvent: function appendEvent(container, event, color, type) {
      var node = void 0;
      var eventCnt = container.querySelectorAll('.calendar-event').length;

      if (eventCnt >= 2) {
        var moreSpan = container.querySelector('.calendar-event-more');
        var moreText = Locale.translate('More').replace('...', '');
        if (!moreSpan) {
          node = document.createElement('span');
          node.classList.add('calendar-event-more');
          node.innerHTML = '+ 1 ' + moreText;
          node.setAttribute('data-count', 1);
          container.querySelector('.day-container').appendChild(node);
        } else {
          var cnt = moreSpan.getAttribute('data-count');
          cnt++;
          moreSpan.setAttribute('data-count', cnt);
          moreSpan.innerHTML = '+ ' + cnt + ' ' + moreText;
        }

        this.visibleEvents.push({ id: event.id, type: event.type, elem: node });
        return this;
      }

      node = document.createElement('a');
      node.classList.add('calendar-event', color, type);
      node.setAttribute('data-id', event.id);

      node.innerHTML = '<div class="calendar-event-content">\n      ' + (event.icon ? '<span class="calendar-event-icon"><svg class="icon" focusable="false" aria-hidden="true" role="presentation" data-status="' + event.status + '"><use xlink:href="#' + event.icon + '"></use></svg></span>' : '') + '\n      <span class="calendar-event-title">' + (event.shortSubject || event.subject) + '</span>\n    </div>';
      container.querySelector('.day-container').appendChild(node);

      // Show the full text if cut off
      if (!event.shortSubject) {
        node.setAttribute('title', event.subject);
        $(node).tooltip({
          beforeShow: function beforeShow(response, ui) {
            var title = ui[0].querySelector('.calendar-event-title');
            var icon = ui[0].querySelector('.calendar-event-icon');
            var iconStatus = icon ? icon.querySelector('.icon').getAttribute('data-status') : '';

            if (title.offsetWidth > ui[0].scrollWidth - (icon ? icon.offsetWidth : 0)) {
              response('' + title.innerText + (iconStatus ? ' (' + Locale.translate(iconStatus, false) + ')' : ''));
              return;
            }
            response(false);
          }
        });
      }

      this.visibleEvents.push({ id: event.id, type: event.type, elem: node });
      return this;
    },


    /**
     * Find the matching type and get the color.
     * @param {object} id The eventType id to find.
     * @param {object} event The event data object.
     * @returns {object} The Calendar prototype, useful for chaining.
     */
    getEventTypeColor: function getEventTypeColor(id) {
      var color = 'azure';
      if (!id) {
        return color;
      }

      var eventInfo = this.settings.eventTypes.filter(function (eventType) {
        return eventType.id === id;
      });
      if (eventInfo.length === 1) {
        color = eventInfo[0].color || 'azure';
      }
      return color;
    },


    /**
     * Find the matching type and get the color.
     * @param {object} id The eventType id to find.
     * @param {object} event The event data object.
     * @returns {object} The Calendar prototype, useful for chaining.
     */
    getEventTypeLabel: function getEventTypeLabel(id) {
      var type = '';
      if (!id) {
        return type;
      }

      var eventInfo = this.settings.eventTypes.filter(function (eventType) {
        return eventType.id === id;
      });
      if (eventInfo.length === 1) {
        type = eventInfo[0].label;
      }
      return type;
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      this.element.on('updated.' + COMPONENT_NAME$r, function () {
        _this2.updated();
      });

      this.element.on('monthrendered.' + COMPONENT_NAME$r, function () {
        _this2.renderEvents();
      });

      this.element.on('change.' + COMPONENT_NAME$r, '.checkbox', function () {
        _this2.renderEvents(true);
      });

      $(this.monthViewContainer).on('selected.' + COMPONENT_NAME$r, function (e, args) {
        var dayEl = args.node;
        var dayEvents = dayEl.querySelectorAll('.calendar-event');

        if (!dayEvents || dayEvents.length === 0) {
          _this2.clearEventDetails();
          return;
        }

        for (var i = 0; i < dayEvents.length; i++) {
          _this2.renderEventDetails(dayEvents[i].getAttribute('data-id'));
        }
      });

      return this;
    },


    /**
     * Handle updated settings and values.
     * @private
     */
    callOnRenderMonth: function callOnRenderMonth() {
      var self = this;

      function response(events, eventTypes) {
        if (eventTypes && eventTypes.length > 0) {
          self.settings.eventTypes = eventTypes;
          self.renderEventTypes();
        }
        if (events && events.length > 0) {
          self.settings.events = events;
          self.renderEvents(true);
        }
      }
      this.settings.onRenderMonth(this.element, response);
    },


    /**
     * Handle updated settings and values.
     * @returns {object} [description]
     */
    updated: function updated() {
      return this.teardown().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$r);
      this.element.off('monthrendered.' + COMPONENT_NAME$r);
      this.element.off('change.' + COMPONENT_NAME$r);
      $(this.monthViewContainer).off();

      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @private
     */
    destroy: function destroy() {
      if (this.eventTypeContainer) {
        this.eventTypeContainer.innerHTML = '';
      }
      if (this.monthViewContainer) {
        this.monthViewContainer.innerHTML = '';
      }
      if (this.eventDetailsContainer) {
        this.eventDetailsContainer.innerHTML = '';
      }
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$r);
    }
  };

  /**
   * jQuery Component Wrapper for Calendar
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.calendar = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$r);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$r, new Calendar(this, settings));
      }
    });
  };

  // Default Settings
  var COMPONENT_NAME$s = 'circlepager';

  /**
   * The Circle Pager Displays content in a sliding carousel and has paging buttons.
   * @class CirclePager
   * @constructor
   *
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {Integer} [settings.slidesToShow=1] The number of slides to show in one view / pane
   * @param {Integer} [settings.startingSlide] First showing slide/group, an 0-based integer
   * @param {boolean} [settings.loop=false] Setting loop: true will loop back after next/previous reached to end
   */
  var CIRCLEPAGER_DEFAULTS = {
    slidesToShow: 1,
    startingSlide: null,
    loop: false
  };

  function CirclePager(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, CIRCLEPAGER_DEFAULTS);
    this.init();
  }

  // CirclePager Methods
  CirclePager.prototype = {
    init: function init() {
      this.setElements();

      if (this.slides.length) {
        this.createControls();
        this.handleEvents();
        this.showCollapsedView();
        this.initActiveSlide();
      }
    },


    /**
     * Set elements
     * @private
     * @returns {void}
     */
    setElements: function setElements() {
      var s = this.settings;

      this.container = $('.slides', this.element);
      this.slidesJQ = $('.slide', this.element);
      this.slidesToShow = s.slidesToShow;
      this.slides = [];

      for (var i = 0, l = this.slidesJQ.length; i < l; i++) {
        this.slides.push({ node: $(this.slidesJQ[i]) });
      }

      this.activeIndex = s.startingSlide !== null && s.startingSlide > -1 && s.startingSlide < this.slides.length ? s.startingSlide : 0;
    },


    /**
     * Create controls
     * @private
     * @returns {void}
     */
    createControls: function createControls() {
      var len = this.slides.length;
      var html = '<div class="controls">';
      var htmlContent = '';
      var numOfButtons = 0;
      var slide = void 0;
      var temp = void 0;
      var href = void 0;
      var text = void 0;
      var buttonText = void 0;
      var last = void 0;
      var lastIndex = void 0;
      var isSingle = void 0;
      var isDisabled = void 0;

      for (var i = 0, l = len; i < l; i += this.slidesToShow) {
        temp = '';
        numOfButtons++;
        isSingle = this.slidesToShow === 1 || len - i === 1;
        text = Locale.translate(isSingle ? 'SlideOf' : 'SlidesOf');
        // Keep href in english language only
        href = isSingle ? '#slide {0} of {1}' : '#slides {0} and {1} of {2}';

        // Collect as much bullets need to present
        for (var g = 0; g < this.slidesToShow && i + g < len; g++) {
          temp += i + g + 1 + ', ';
        }
        text = text.replace(isSingle ? '{1}' : '{2}', len);
        href = href.replace(isSingle ? '{1}' : '{2}', len);
        temp = temp.slice(0, -2);
        lastIndex = temp.lastIndexOf(',');
        last = temp.substr(lastIndex + 2);

        // Controls for single slide in view
        if (isSingle) {
          isDisabled = '';
          slide = this.slides[i].node;

          // Set disabled
          if (slide.is('.is-disabled, [disabled]') && !slide.is('[disabled="false"]')) {
            isDisabled = ' disabled tabindex="-1"';
            this.slides[i].isDisabled = true;
          }

          // Set default starting slide
          if (slide.is('.active') && this.settings.startingSlide === null && isDisabled === '') {
            this.activeIndex = i;
          }

          // Use custom text if supplied
          buttonText = slide.attr('data-button-text');
          text = buttonText && buttonText.length ? buttonText : text.replace('{0}', temp);

          href = href.replace('{0}', temp);
        } else {
          // Controls for multiple slides in view
          temp = temp.substr(0, lastIndex);
          text = text.replace('{1}', last).replace('{0}', temp);
          href = href.replace('{1}', last).replace('{0}', temp);
        }

        href = href.toLowerCase().replace(/[\s,--]+/g, '-');

        htmlContent += '<a href="' + href + '" class="control-button hyperlink hide-focus"' + isDisabled + '><span class="audible">' + text + '</span></a>';
      }

      html += htmlContent + '</div>';

      // Previous/Next buttons
      this.isBulletsNav = this.element.width() > numOfButtons * 29;
      var previousButton = $('.btn-previous', this.element);
      var nextButton = $('.btn-next', this.element);
      if (!this.isBulletsNav) {
        if (!previousButton.length) {
          html += '' + ('<button class="btn-previous" type="button">\n            ' + $.createIcon('left-arrow') + '\n            <span class="audible"> ' + Locale.translate('Previous') + '</span>\n          </button>');
        }
        if (!nextButton.length) {
          html += '' + ('<button class="btn-next" type="button">\n            ' + $.createIcon('right-arrow') + '\n            <span class="audible">' + Locale.translate('Next') + '</span>\n          </button>');
        }
      } else {
        previousButton.add(nextButton).remove();
      }

      if (this.activeIndex > 0 && this.activeIndex > numOfButtons - 1) {
        this.activeIndex = numOfButtons - 1;
      }

      if (numOfButtons > 1) {
        this.element.append(html);
      }
    },


    /**
     * Check if given element is visible in container
     * @private
     * @param {object} element to check.
     * @returns {boolean} -1 if not in container
     */
    isVisibleInContainer: function isVisibleInContainer(element) {
      if (element && element[0]) {
        var eRect = element[0].getBoundingClientRect();
        var cRect = this.element[0].getBoundingClientRect();

        return eRect.left > cRect.left && eRect.left < cRect.left + cRect.width && eRect.top > cRect.top && eRect.top < cRect.top + cRect.height;
      }
      return -1;
    },


    /**
     * Update number of slides to show in view
     * @private
     * @param {object} numOfSlides to show.
     * @returns {object} this api
     */
    updateSlidesToShow: function updateSlidesToShow(numOfSlides) {
      if (!this.isActive) {
        return;
      }
      this.settings.slidesToShow = numOfSlides || 1;
      this.updated();
      return this; // eslint-disable-line
    },


    /**
     * Make sure max number of slides to show in view
     * @private
     * @param {object} numOfSlides to show.
     * @returns {void}
     */
    responsiveSlidesToShow: function responsiveSlidesToShow(numOfSlides) {
      var _this = this;

      if (!this.isActive) {
        return;
      }

      this.slidesToShow = numOfSlides || this.settings.slidesToShow;
      this.unbind().slidesJQ.css('width', '');
      if (this.slides.length) {
        setTimeout(function () {
          _this.createControls();
          _this.handleEvents();
          _this.showCollapsedView();
          _this.initActiveSlide();
        }, 0);
      }
    },


    /**
     * Show a slide to First Slide
     * @private
     * @param {string} index  The index of the slide to show (0 based)
     * @returns {void}
     */
    show: function show(index) {
      if (!this.isActive) {
        return;
      }
      index = typeof index !== 'undefined' ? index : this.activeIndex;
      this.activeIndex = index;

      var left = index > 0 ? (Locale.isRTL() ? '' : '-') + index * 100 + '%' : 0;
      this.controlButtons.removeClass('is-active').eq(index).addClass('is-active');
      this.container[0].style.left = left;

      // Make sure bullets navigation do not overflow
      if (!this.isBulletsNav) {
        this.element.addClass('is-bullets-nav-hidden');
        this.controlButtons.find('span').addClass('audible').end().eq(index).find('span').removeClass('audible');
      } else {
        this.element.removeClass('is-bullets-nav-hidden');
        this.controlButtons.find('span').addClass('audible');
      }

      // Set focus
      if (this.isFocus && this.isBulletsNav) {
        this.isFocus = false;
        this.controlButtons.eq(index).focus();
      }
    },


    /**
     * Move to First Slide
     * @private
     * @returns {void}
     */
    first: function first() {
      this.show(0);
    },


    /**
     * Move to Last Slide
     * @private
     * @returns {void}
     */
    last: function last() {
      this.show(Math.round(this.slides.length / this.slidesToShow) - 1);
    },


    /**
     * Move to Previous Slide
     * @private
     * @returns {void}
     */
    prev: function prev() {
      var _this2 = this;

      // eslint-disable-line
      var prev = void 0;

      if (this.activeIndex > 0) {
        prev = this.activeIndex - 1;
      } else {
        prev = this.settings.loop ? Math.round(this.slides.length / this.slidesToShow) - 1 : 0;
      }

      if (this.slides[prev].isDisabled) {
        setTimeout(function () {
          _this2.prev();
        }, 0);
        this.activeIndex = prev;
        return false;
      }
      this.show(prev);
    },


    /**
    * Move to Next Slide
    * @private
    * @returns {void}
    */
    next: function next() {
      var _this3 = this;

      // eslint-disable-line
      var next = void 0;
      if (this.activeIndex >= Math.round(this.slides.length / this.slidesToShow) - 1) {
        next = this.settings.loop ? 0 : this.activeIndex;
      } else {
        next = this.activeIndex + 1;
      }

      if (this.slides[next].isDisabled) {
        setTimeout(function () {
          _this3.next();
        }, 0);
        this.activeIndex = next;
        return false;
      }
      this.show(next);
    },


    /**
    * Make active
    * @private
    * @returns {void}
    */
    showCollapsedView: function showCollapsedView() {
      this.isActive = true;
      this.element.addClass('is-active');
      this.container[0].style.width = 100 * this.slides.length + '%';
      if (this.settings.slidesToShow > 1 && this.slidesJQ.eq(0).width() * this.slidesToShow > this.element.width()) {
        this.responsiveSlidesToShow(this.slidesToShow - 1);
        return;
      }
      for (var i = 0, l = this.slidesJQ.length; i < l; i++) {
        this.slidesJQ[i].style.width = 100 / this.slidesToShow / this.slides.length + '%';
      }
      this.show();
    },


    /**
    * Make un-active
    * @private
    * @returns {void}
    */
    showExpandedView: function showExpandedView() {
      this.isActive = false;
      this.element.removeClass('is-active');
      this.element[0].style.width = '';
      this.container[0].style.width = '';
      this.container[0].style.left = '';
    },


    /**
    * Initialize active slide
    * @private
    * @returns {void}
    */
    initActiveSlide: function initActiveSlide() {
      // eslint-disable-line
      if (this.slides[this.activeIndex].isDisabled) {
        this.next();
        return false;
      }
      this.show();
      this.slidesJQ.addClass('is-visible');
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      $('body').off('resize.circlepager');
      this.element.off('focus.circlepager keydown.circlepager', '*');
      this.controlButtons.off('click.circlepager keydown.circlepager');
      $('.btn-previous, .btn-next', this.element).off('click.circlepager');
      $('.controls', this.element).remove();
      this.showExpandedView();
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, CIRCLEPAGER_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$s);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this4 = this;

      var self = this;

      // Previous button
      $('.btn-previous', this.element).on('click.circlepager', function (e) {
        _this4.prev();
        e.stopImmediatePropagation();
      });

      // Next button
      $('.btn-next', this.element).on('click.circlepager', function (e) {
        _this4.next();
        e.stopImmediatePropagation();
      });

      this.controlButtons = $('.control-button', this.element);

      var _loop = function _loop(i, l) {
        var btn = $(_this4.controlButtons[i]);
        btn.hideFocus();

        // Handle clicks for bottom bullet links
        btn.on('click.circlepager', function (e) {
          e.preventDefault();
          if (_this4.slides[i].isDisabled) {
            return;
          }
          _this4.show(i);
        });
      };

      for (var i = 0, l = this.controlButtons.length; i < l; i++) {
        _loop(i, l);
      }

      // Handle keyboard events

      // Prevent hidden slide's content to be get focused
      // on focusable elements in slides content
      this.element.on('focus.circlepager', '*', function (e) {
        // eslint-disable-line
        var handled = false;
        if (!self.isVisibleInContainer($(this))) {
          var canfocus = self.element.find(':focusable');
          for (var i = 0, l = canfocus.length; i < l; i++) {
            if (self.isVisibleInContainer(canfocus.eq(i))) {
              canfocus.eq(i).focus();
              handled = true;
              break;
            }
          }
        }
        e.stopPropagation();
        if (handled) {
          return false;
        }
      });
      // Keydown on focusable elements in slides content to
      // prevent hidden slide's content to be get focused
      this.element.on('keydown.circlepager', '*', function (e) {
        // eslint-disable-line
        var handled = false;
        var key = e.which || e.keyCode || e.charCode || 0;
        var canfocus = $(':focusable');
        var index = canfocus.index(this);

        if (key === 9) {
          // tab
          // Using shift key with tab (going backwards)
          if (e.shiftKey) {
            for (var i = index - 1; i >= 0; i--) {
              if (self.element.has(canfocus.eq(i)).length < 1 || self.isVisibleInContainer(canfocus.eq(i))) {
                canfocus.eq(i).focus();
                handled = true;
                break;
              }
            }
          } else if (!self.isVisibleInContainer(canfocus.eq(index + 1))) {
            // Using only tab key (going forward)
            self.controlButtons.first().focus();
            handled = true;
          }
        }
        e.stopPropagation();
        if (handled) {
          return false;
        }
      });

      // Control buttons
      this.controlButtons.on('keydown.circlepager', function (e) {
        // eslint-disable-line
        var handled = false;
        var key = e.which || e.keyCode || e.charCode || 0;
        var isRTL = Locale.isRTL();

        // Left and Right arrow keys
        if ([37, 39].indexOf(key) !== -1) {
          self.isFocus = true; // Move focus
          if (e.altKey) {
            // [Alt + Left/Right arrow] to move to the first or last
            if (key === 37 && !isRTL || key === 39 && isRTL) {
              self.first();
            } else {
              self.last();
            }
          } else {
            // Left and Right arrow keys to navigate
            if (!isRTL && key === 37 || isRTL && key === 39) {
              self.prev();
            } else {
              self.next();
            }
            handled = true;
          }
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      });

      // Set max number of slides can view on resize
      $('body').on('resize.circlepager', function () {
        self.responsiveSlidesToShow();
      });
    }
  };

  /**
   * jQuery Component Wrapper for CirclePager
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.circlepager = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$s);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$s, new CirclePager(this, settings));
      }
    });
  };

  // Default Settings
  var COMPONENT_NAME$t = 'colorpicker';

  /**
   * The ColorPicker Component is a trigger field with a listing colors that can be selected.
   * @class ColorPicker
   * @param {jQuery[]|HTMLElement} element The plugin element for the constuctor
   * @param {object} [settings] The settings element.
   * @param {object} [settings.themes={}] Themes available for ColorPicker
   * @param {array} [settings.colors=[]] An array of objects of the form. {label: 'Azure', number: '01', value: 'CBEBF4'}
   * that can be used to populate the color grid.
   * @param {boolean} [settings.showLabel=false]  Show the label if true vs the hex value if false.
   * @param {boolean} [settings.editable=true]  If false, the field is readonly and transparent. I.E. The value
   * cannot be typed only editable by selecting.
   * @param {boolean} [settings.uppercase=true] If false, lower case hex is allowed. If true upper case hex is allowed.
   * If showLabel is true this setting is ignored.
   * @param {boolean} [settings.colorOnly=false] If true the field will be shrunk to only show the color portion.
   * @param {boolean} [settings.clearable=true] If true will add clearable option.
   * @param {string} [settings.clearableText] The text to show in tooltip.
   */
  var COLORPICKER_DEFAULTS = {
    // Theme key: MUST match with theme file name (ie: [filename: 'light-theme.css' -> 'light-theme'])

    // BORDERS
    // Use (,) commas to separate themes or single entry for border as:
    // colors[{label: 'Slate', number: '01', value: 'F0F0F0',
    // border: 'light-theme, high-contrast-theme'}]
    // and assign which swatch theborder should apply ['all' or 'matched-only']
    // themes: { 'high-contrast-theme': {'border': 'all'} }

    // CHECKMARKS
    // checkmark: {'one': [1, 2], 'two': [3, 10]}
    // will add class as "checkmark-{key}", where current colors number is in range
    // [{value[0]} to {value[1]}]
    // will add class "checkmark-one", where current colors number is in range [1 to 3]
    // and will add class "checkmark-two", where current colors number is in range [3 to 10]
    themes: {
      light: { border: 'matched-only', checkmark: { one: [1, 2], two: [3, 10] } },
      dark: { border: 'matched-only', checkmark: { one: [1, 2], two: [3, 10] } },
      'high-contrast': { border: 'all', checkmark: { one: [1, 3], two: [4, 10] } }
    },
    colors: [{ label: 'Slate', number: '10', value: '1a1a1a' }, { label: 'Slate', number: '09', value: '292929' }, { label: 'Slate', number: '08', value: '383838', border: 'dark' }, { label: 'Slate', number: '07', value: '454545', border: 'dark' }, { label: 'Slate', number: '06', value: '5C5C5C' }, { label: 'Slate', number: '05', value: '737373' }, { label: 'Slate', number: '04', value: '999999' }, { label: 'Slate', number: '03', value: 'BDBDBD' }, { label: 'Slate', number: '02', value: 'D8D8D8' }, { label: 'Slate', number: '01', value: 'F0F0F0', border: 'light, high-contrast' }, { label: 'Amber', number: '10', value: 'D66221' }, { label: 'Amber', number: '09', value: 'DE7223' }, { label: 'Amber', number: '08', value: 'E68425' }, { label: 'Amber', number: '07', value: 'EB9728' }, { label: 'Amber', number: '06', value: 'EFAA30' }, { label: 'Amber', number: '05', value: 'F2BC41' }, { label: 'Amber', number: '04', value: 'F4C951' }, { label: 'Amber', number: '03', value: 'F7D475' }, { label: 'Amber', number: '02', value: 'F8E09C' }, { label: 'Amber', number: '01', value: 'FBE9BF' }, { label: 'Ruby', number: '10', value: '880E0E' }, { label: 'Ruby', number: '09', value: '941E1E' }, { label: 'Ruby', number: '08', value: 'A13030' }, { label: 'Ruby', number: '07', value: 'AD4242' }, { label: 'Ruby', number: '06', value: 'B94E4E' }, { label: 'Ruby', number: '05', value: 'C65F5F' }, { label: 'Ruby', number: '04', value: 'D26D6D' }, { label: 'Ruby', number: '03', value: 'DE8181' }, { label: 'Ruby', number: '02', value: 'EB9D9D' }, { label: 'Ruby', number: '01', value: 'F4BCBC' }, { label: 'Turquoise', number: '10', value: '0E5B52' }, { label: 'Turquoise', number: '09', value: '206B62' }, { label: 'Turquoise', number: '08', value: '317C73' }, { label: 'Turquoise', number: '07', value: '448D83' }, { label: 'Turquoise', number: '06', value: '579E95' }, { label: 'Turquoise', number: '05', value: '69ADA3' }, { label: 'Turquoise', number: '04', value: '7BBFB5' }, { label: 'Turquoise', number: '03', value: '8ED1C6' }, { label: 'Turquoise', number: '02', value: 'A9E1D6' }, { label: 'Turquoise', number: '01', value: 'C0EDE3' }, { label: 'Emerald', number: '10', value: '397514' }, { label: 'Emerald', number: '09', value: '44831F' }, { label: 'Emerald', number: '08', value: '56932E' }, { label: 'Emerald', number: '07', value: '66A140' }, { label: 'Emerald', number: '06', value: '76B051' }, { label: 'Emerald', number: '05', value: '89BF65' }, { label: 'Emerald', number: '04', value: '9CCE7C' }, { label: 'Emerald', number: '03', value: 'AFDC91' }, { label: 'Emerald', number: '02', value: 'C3E8AC' }, { label: 'Emerald', number: '01', value: 'D5F6C0' }, { label: 'Amethyst', number: '10', value: '4B2A5E' }, { label: 'Amethyst', number: '09', value: '5A3A6F' }, { label: 'Amethyst', number: '08', value: '6C4B81' }, { label: 'Amethyst', number: '07', value: '7D5F92' }, { label: 'Amethyst', number: '06', value: '8E72A4' }, { label: 'Amethyst', number: '05', value: 'A189B8' }, { label: 'Amethyst', number: '04', value: 'B59ECA' }, { label: 'Amethyst', number: '03', value: 'C7B4DB' }, { label: 'Amethyst', number: '02', value: 'DACCEC' }, { label: 'Amethyst', number: '01', value: 'EDE3FC' }, { label: 'Azure', number: '10', value: '133C59' }, { label: 'Azure', number: '09', value: '134D71' }, { label: 'Azure', number: '08', value: '1D5F8A' }, { label: 'Azure', number: '07', value: '2876A8' }, { label: 'Azure', number: '06', value: '368AC0' }, { label: 'Azure', number: '05', value: '4EA0D1' }, { label: 'Azure', number: '04', value: '69B5DD' }, { label: 'Azure', number: '03', value: '8DC9E6' }, { label: 'Azure', number: '02', value: 'ADD8EB' }],
    placeIn: null, // null|'editor'
    showLabel: false,
    editable: true,
    uppercase: true,
    colorOnly: false,
    clearable: true,
    clearableText: null
  };

  function ColorPicker(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COLORPICKER_DEFAULTS);

    // Merge Settings does deep copy we want to replace here
    if (settings && settings.colors) {
      this.settings.colors = settings.colors;
    }

    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  ColorPicker.prototype = {
    init: function init() {
      this.isIe = Environment.browser.name === 'ie';
      this.isIeEdge = Environment.browser.name === 'edge';
      this.isIe11 = this.isIe && Environment.browser.version === '11';
      this.inlineLabel = this.element.closest('label');
      this.inlineLabelText = this.inlineLabel.find('.label-text');
      this.isInlineLabel = this.element.parent().is('.inline');

      // Set default clearable text
      if (!this.settings.clearableText) {
        this.settings.clearableText = Locale ? Locale.translate('None') : 'None';
      }

      this.build();
      this.handleEvents();
      this.setCustomWidth();
    },


    // Add the extra markup
    build: function build() {
      this.isEditor = this.settings.placeIn === 'editor';
      var colorpicker = this.element;
      var initialValue = this.isEditor ? this.element.attr('data-value') : this.element.val();
      var classList = 'swatch' + (!initialValue || $.trim(initialValue) === '' ? ' is-empty' : '');

      if (!this.isEditor) {
        // Add Button
        if (this.isInlineLabel) {
          this.inlineLabel.addClass('colorpicker-container');
        } else {
          this.container = $('<span class="colorpicker-container"></span>');
          colorpicker.wrap(this.container);
        }

        this.container = colorpicker.parent();
        this.swatch = $('<span class="' + classList + '"></span>').prependTo(this.container);

        // Add Masking to show the #.
        // Remove the mask if using the "showLabel" setting
        if (!this.settings.showLabel) {
          var pattern = ['#', /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/];

          colorpicker.mask({ pattern: pattern });
        } else {
          var maskAPI = colorpicker.data('mask');
          if (maskAPI && typeof maskAPI.destroy === 'function') {
            maskAPI.destroy();
          }
        }
      }

      this.icon = $.createIconElement('dropdown').appendTo(this.isEditor ? this.element : this.container);
      this.icon.wrap('<span class="trigger"></span>');

      // Handle initial values
      if (initialValue) {
        this.setColor(initialValue);
      }

      if (this.element.is(':disabled')) {
        this.disable();
      }

      if (this.element.prop('readonly')) {
        this.readonly();
      }

      if (!this.settings.editable) {
        this.readonly();
      }

      if (this.settings.colorOnly) {
        this.element.parent().addClass('color-only');
      }

      this.addAria();
    },


    /**
    * Get the hex value based on a label. Does not handle duplicates.
    * @param {string} label  The label to search for in the color labels.
    * @returns {void}
    */
    getHexFromLabel: function getHexFromLabel(label) {
      for (var i = 0; i < this.settings.colors.length; i++) {
        var data = this.settings.colors[i];
        var translated = Locale.translate(data.label, true);

        if (label === data.label + data.number || label === translated + data.number) {
          var hex = data.value;
          if (hex.substr(0, 1) !== '#') {
            hex = '#' + hex;
          }

          return hex;
        }
      }
      return '';
    },


    /**
    * Get the label value based on a hex. Does not handle duplicates.
    * Can pass with or without the #
    *
    * @param {string} hex The hex to search for in the color set.
    * @returns {void}
    */
    getLabelFromHex: function getLabelFromHex(hex) {
      if (!hex) {
        return '';
      }

      for (var i = 0; i < this.settings.colors.length; i++) {
        var data = this.settings.colors[i];

        if (hex.replace('#', '') === data.value.replace('#', '')) {
          return this.translateColorLabel(data.label) + data.number;
        }
      }

      return '';
    },


    /**
    * Set custom width.
    * @private
    * @returns {void}
    */
    setCustomWidth: function setCustomWidth() {
      if (this.element[0].style && this.element[0].style.width) {
        var w = parseInt(this.element[0].style.width, 10);
        this.container.css({ width: w });
        this.element.css({ width: w - 2 - this.swatch.width() });
      }
    },

    /**
    * Get the currently set hex value.
    * @returns {string} A string containing the hex
    */
    getHexValue: function getHexValue() {
      return this.element.attr('value');
    },


    /**
    * Get the currently set label value.
    * @returns {string} A string containing the hex
    */
    getLabelValue: function getLabelValue() {
      return this.settings.showLabel ? this.element.val() : this.getLabelFromHex(this.element.val());
    },


    /**
    * Add the necessary aria for accessibility.
    * @private
    * @returns {void}
    */
    addAria: function addAria() {
      this.element.attr({
        role: 'combobox',
        'aria-autocomplete': 'list'
      });

      $('label[for="' + this.element.attr('id') + '"]').append('<span class="audible">' + Locale.translate('UseArrow') + '</span>');
    },


    /**
    * Toggle / Open the List of Colors
    * @returns {void}
    */
    toggleList: function toggleList() {
      var _this = this;

      var menu = $('#colorpicker-menu');

      if (this.element.is(':disabled') || this.element.prop('readonly') && this.settings.editable) {
        return;
      }

      if (menu.length && this.isPickerOpen) {
        return;
      }

      // Append Color Menu
      menu = this.updateColorMenu();

      var popupmenuOpts = {
        ariaListbox: true,
        menuId: 'colorpicker-menu',
        trigger: 'immediate',
        attachToBody: true,
        placementOpts: {
          containerOffsetX: 10,
          containerOffsetY: 10,
          parentXAlignment: Locale.isRTL() ? 'right' : 'left',
          strategies: ['flip', 'nudge', 'shrink']
        },
        offset: {
          x: 0,
          y: 10
        }
      };

      // Show Menu
      this.element.popupmenu(popupmenuOpts).on('open.colorpicker', function () {
        _this.element.parent().addClass('is-open');
        _this.isPickerOpen = true;
      }).on('close.colorpicker', function () {
        menu.on('destroy.colorpicker', function () {
          _this.element.off('open.colorpicker selected.colorpicker close.colorpicker');
          _this.menu.off('destroy.colorpicker').remove();
        });

        _this.element.parent().removeClass('is-open');
        _this.isPickerOpen = false;

        _this.element.trigger('listclosed', 'select');
      }).on('selected.colorpicker', function (e, item) {
        if (!_this.isEditor) {
          _this.setColor(item.data('value'), item.data('label'));
        }
        _this.element.focus();
        _this.element.trigger('change');
      });

      // Append Buttons
      this.menu = $('#colorpicker-menu');

      setTimeout(function () {
        _this.menu.find('.is-selected').focus();
      }, 1);
    },


    /**
    * Set the visible color in the field
    * @param {string} hex The hex value to use (can have the # or not).
    * @param {string} label The text to display
    * @returns {void}
    */
    setColor: function setColor(hex, label) {
      hex = hex || '';
      var s = this.settings;
      var colorHex = hex;
      var colorLabel = label;

      // Make sure there is always a hash
      if (hex.substr(0, 1) !== '#' && hex !== '') {
        colorHex = '#' + colorHex;
      }

      var isValidHex = /(^#[0-9a-fA-F]{6}$)|(^#[0-9a-fA-F]{3}$)/i.test(colorHex);

      // Simply return out if hex isn't valid
      if (s.showLabel && label === s.clearableText) {
        this.setValueOnField({ hex: colorHex, label: s.clearableText, isEmpty: true });
        return;
      } else if (!isValidHex) {
        if (!s.showLabel) {
          colorHex = colorHex !== '#' ? colorHex : '';
          this.setValueOnField({ hex: colorHex, invalid: true });
          return;
        }
        colorLabel = hex.replace('#', '');
        colorHex = this.getHexFromLabel(colorLabel);
      }

      if (!colorLabel) {
        colorLabel = this.getLabelFromHex(colorHex);
      }

      this.setValueOnField({ hex: colorHex, label: colorLabel });
    },


    /**
     * Set the value on the field
     * @private
     * @param {object} [o] Options
     * @param {string} [o.hex] The hex value to use
     * @param {string} [o.label] The text to display
     * @param {boolean} [o.isEmpty] if true will set empty value for all
     * @param {boolean} [o.invalid] if true will set empty value for swatch only
     * @returns {void}
     */
    setValueOnField: function setValueOnField(o) {
      var s = this.settings;
      var targetAttr = this.isEditor ? 'data-value' : 'value';
      var hex = '';

      if (!o.isEmpty && typeof o.hex === 'string') {
        hex = s.uppercase ? o.hex.toUpperCase() : o.hex.toLowerCase();
      }

      if (this.swatch) {
        if (o.isEmpty || o.invalid) {
          this.swatch.addClass(o.isEmpty ? 'is-empty' : 'is-invalid');
          this.swatch[0].style.backgroundColor = '';
        } else {
          this.swatch.removeClass('is-empty is-invalid');
          this.swatch[0].style.backgroundColor = hex;
        }
      }

      this.element[0].value = s.showLabel ? o.label : hex;
      this.element[0].setAttribute(targetAttr, hex);
      this.element[0].setAttribute('aria-describedby', o.label || '');
    },


    /**
     * @private
     * @param {string} colorText the original text color
     * @returns {string} the translated text color
     */
    translateColorLabel: function translateColorLabel(colorText) {
      if (!colorText) {
        return '';
      }
      var translatedText = Locale.translate(colorText, true);
      return typeof translatedText === 'string' ? Locale.translate(colorText, true) : colorText;
    },


    /**
     * Refresh and Append the Color Menu
     * @private
     * @returns {jQuery} the menu to be appended
     */
    updateColorMenu: function updateColorMenu() {
      var _this2 = this;

      var s = this.settings;
      var isMenu = !!$('#colorpicker-menu').length;
      var menu = $('<ul id="colorpicker-menu" class="popupmenu colorpicker"></ul>');
      var activeTheme = personalization.currentTheme;
      var isBorderAll = s.themes[activeTheme].border === 'all';
      var checkThemes = s.themes[activeTheme].checkmark;
      var checkmarkClass = '';

      var _loop = function _loop(i, l) {
        var li = $('<li></li>');
        var a = $('<a href="#"><span class="swatch"></span></a>').appendTo(li);
        var colorText = (_this2.translateColorLabel(s.colors[i].label) || s.colors[i].label) + (s.colors[i].number || '');
        var colorNum = parseInt(s.colors[i].number, 10);
        var regexp = new RegExp('\\b' + activeTheme + '\\b');
        var colorValue = s.colors[i].value;
        var isBorder = false;
        var elemValue = _this2.isEditor ? _this2.element.attr('data-value') : _this2.element.val();

        if (s.showLabel && !_this2.isEditor) {
          elemValue = _this2.getHexFromLabel(elemValue);
        }

        // Set border to this swatch
        if (isBorderAll || regexp.test(s.colors[i].border)) {
          isBorder = true;
        }

        if (elemValue && ('' + elemValue).toLowerCase().replace('#', '') === ('' + colorValue).toLowerCase()) {
          // Set checkmark color class
          if (checkThemes) {
            /* eslint-disable no-loop-func */
            $.each(checkThemes, function (k, v) {
              // checkmark: {'one': [1, 2], 'two': [3, 10]}
              // will add class "checkmark-one", where current colors number is in range [1 to 3]
              // and will add class "checkmark-two", where current colors number is in range [3 to 10]
              if (colorNum >= v[0] && colorNum <= v[1]) {
                checkmarkClass = ' checkmark-' + k;
              }
            });
            /* eslint-disable no-loop-func */
          }
          a.addClass('is-selected' + checkmarkClass);
        }

        colorValue = s.uppercase ? colorValue.toUpperCase() : colorValue.toLowerCase();
        var swatch = a.find('.swatch');
        if (swatch[0]) {
          swatch[0].style.backgroundColor = '#' + colorValue;
        }
        swatch.addClass(isBorder ? 'is-border' : '');
        a.data('label', colorText).data('value', colorValue).attr('title', colorText + ' #' + colorValue).tooltip();

        if (!isMenu) {
          menu.append(li);
        }
      };

      for (var i = 0, l = s.colors.length; i < l; i++) {
        _loop(i, l);
      }

      if (!isMenu) {
        // Add clearable swatch to popupmenu
        if (s.clearable) {
          var _li = $('<li></li>');
          var _a = $('<a href="#" title="' + s.clearableText + '"><span class="swatch is-empty' + (isBorderAll ? ' is-border' : '') + '"></span></a>').appendTo(_li);
          _a.data('label', s.clearableText).data('value', '').tooltip();
          menu.append(_li);
        } else {
          var _li2 = $('<li></li>');
          $('<a href="#" title="Azure01 #C8E9F4"><span class="swatch" style="background-color: rgb(173 ,216, 235);"></span></a>').appendTo(_li2).tooltip();
          menu.append(_li2);
        }

        $('body').append(menu);
      }

      return menu;
    },


    /**
    * Change the color picker from enabled to disabled.
    * @returns {void}
    */
    enable: function enable() {
      this.element.prop('disabled', false);
      this.element.prop('readonly', false);
      this.element.parent().removeClass('is-disabled is-readonly');
    },


    /**
    * Make the color picker disabled
    * @returns {void}
    */
    disable: function disable() {
      this.element.prop('disabled', true);
      this.element.parent().addClass('is-disabled');
    },


    /**
    * Make the color picker readonly
    * @returns {void}
    */
    readonly: function readonly() {
      this.enable();
      this.element.prop('readonly', true);
      this.element.parent().addClass('is-readonly');

      if (!this.settings.editable) {
        this.element.parent().addClass('is-not-editable');
      }
    },


    /**
    * Returns true if the color picker is disabled.
    * @returns {void}
    */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
    * Gets the decimal as a rgb value so it can be shown in the editor
    * @private
    * @param {string} n Decimal value to convert to rgb.
    * @returns {void}
    */
    decimal2rgb: function decimal2rgb(n) {
      if (typeof n !== 'number') {
        return n;
      }

      /* eslint-disable no-bitwise */
      return 'rgb(' + (n & 0xFF) + ', ' + ((n & 0xFF00) >> 8) + ', ' + ((n & 0xFF0000) >> 16) + ')';
      /* eslint-disable no-console */
    },
    rgb2hex: function rgb2hex(rgb) {
      if (!rgb || rgb.search('rgb') === -1) {
        return rgb;
      } else if (rgb === 'rgba(0, 0, 0, 0)') {
        return 'transparent';
      }

      var hex = function hex(x) {
        return ('0' + parseInt(x, 10).toString(16)).slice(-2);
      };

      var newRgb = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+))?\)$/);
      return '#' + hex(newRgb[1]) + hex(newRgb[2]) + hex(newRgb[3]);
    },


    /**
    * Update the component and optionally apply new settings.
    *
    * @param  {object} settings the settings to update to.
    * @returns {object} The plugin api for chaining.
    */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      return this.destroy().init();
    },
    teardown: function teardown() {
      this.element.off('keypress.colorpicker keyup.colorpicker blur.colorpicker openlist.colorpicker change.colorpicker paste.colorpicker');
      this.swatch.off('click.colorpicker');
      this.swatch.remove();
      this.container.find('.trigger').remove();
      var input = this.container.find('.colorpicker');

      if (input.data('mask')) {
        input.data('mask').destroy();
      }

      input.unwrap();
      input.removeAttr('data-mask role aria-autocomplete');
    },


    /**
    * Detach events and restore DOM to default.
    * @returns {object} The plugin api (this).
    */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$t);
      return this;
    },


    /**
    * Detach events and restore DOM to default.
    * @private
    * @returns {void}
    */
    handleEvents: function handleEvents() {
      var _this3 = this;

      var elem = this.element;
      var elemParent = elem.parent();
      var originalVal = void 0;

      this.icon.parent().on('click.colorpicker', function () {
        _this3.toggleList();
      });

      elem.on('focus.colorpicker', function () {
        originalVal = elem.val();
        elemParent.addClass('is-focused');
      }).on('blur.colorpicker', function () {
        elemParent.removeClass('is-focused');

        // Fix: Force to change event
        // IE-Edge not firing `change event` after updated input-s values
        if (_this3.isIeEdge && !elem.is('.is-open') && originalVal !== elem.val()) {
          elem.triggerHandler('change');
        }
      }).on('openlist.colorpicker', function () {
        _this3.toggleList();
      });

      var eventStr = 'blur.colorpicker paste.colorpicker change.colorpicker';
      eventStr += this.isIe11 ? 'keypress.colorpicker' : 'keyup.colorpicker';
      elem.on(eventStr, function () {
        var val = _this3.isEditor ? elem.attr('data-value') : elem.val();
        if (_this3.settings.showLabel) {
          _this3.setColor(elem.attr('value'), val);
          return;
        }
        _this3.setColor(val);
      });

      // Handle Key Down to open
      elem.on('keydown.colorpicker', function (e) {
        if (e.keyCode === 38 || e.keyCode === 40) {
          _this3.toggleList();
        }
      });
    }
  };

  /**
   * jQuery Component Wrapper for Colorpicker
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.colorpicker = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$t);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$t, new ColorPicker(this, settings));
      }
    });
  };

  var COMPONENT_NAME$u = 'expandablearea';

  /**
  * An expandable pane / area.
  * @class ExpandableArea
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  * @param {string} [settings.trigger = null]  Id of some other button to use as a trigger
  * @param {string} [settings.bottomBorder = false]  Change the border to bottom vs top (for some cases)
  */
  var EXPANDABLEAREA_DEFAULTS = {
    trigger: null,
    bottomBorder: false
  };

  function ExpandableArea(element, settings) {
    this.settings = utils.mergeSettings(element, settings, EXPANDABLEAREA_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Expandable Area API
  ExpandableArea.prototype = {

    /**
    * Initialize the Expandable area
    * @private
    */
    init: function init() {
      this.setup().build().handleEvents();
    },


    /**
    * Setup internal variables.
    * @private
    * @returns {object} The Api for chaining.
    */
    setup: function setup() {
      this.id = this.element.attr('id');
      if (!this.id || this.id === undefined) {
        this.id = 'expandable-area-' + $('body').find('.expandable-area').index(this.element);
      }

      this.header = this.settings.trigger ? this.element : this.element.children('.expandable-header');
      this.footer = this.element.children('.expandable-footer');
      this.content = this.element.children('.expandable-pane');

      this.isCard = this.element.is('.card, .widget');
      return this;
    },


    /**
    * Add markup to build up the component.
    * @private
    * @returns {object} The Api for chaining.
    */
    build: function build() {
      var _this = this;

      var expanded = this.element.hasClass('is-expanded');

      this.header.attr({
        'aria-expanded': '' + expanded,
        'aria-controls': this.id + '-content',
        id: this.id + '-header'
      });
      this.content.attr({
        id: this.id + '-content'
      });

      // Add the link and footer if not there already.
      // If we're using an expandable card,
      if (!this.isCard && !this.footer.length && !this.settings.trigger) {
        this.footer = $('<div class="expandable-footer"></div>').appendTo(this.element);
      }

      function getExpander(instance, useHeaderExpander) {
        var expander = void 0;

        if (useHeaderExpander === true) {
          // Use icon-based expander in the header
          expander = instance.header.find('expandable-expander');
          if (!expander.length) {
            expander = $('' + ('<a href="#" target="_self" class="btn-expander">' + '<svg class="chevron icon" focusable="false" aria-hidden="true" role="presenation">' + '<use xlink:href="#icon-caret-down"></use>' + '</svg>' + '<span class="audible">') + Locale.translate('ShowMore') + '</span>' + '</a>').appendTo(instance.header);
          }

          return expander;
        }

        // Use the text-based expander button in the footer
        expander = instance.footer.find('.expandable-expander');
        if (!expander.length) {
          expander = $('' + ('<a href="#" target="_self" class="expandable-expander hyperlink">' + '<span data-translated="true">') + Locale.translate('ShowMore') + '</span>' + '</a>').prependTo(instance.footer);
        }
        return expander;
      }

      this.expander = getExpander(this, this.isCard);
      this.expander.attr('href', '#').hideFocus();

      if (this.expander.length === 0) {
        this.expander = $('#' + this.settings.trigger);
      }

      // Change the borer to the bottom vs top
      if (this.settings.bottomBorder) {
        this.element.addClass('has-bottom-border');
      }

      // Initialized in expanded mode.
      if (expanded) {
        this.content.addClass('no-transition');
        this.element.one('afterexpand.expandable-area', function () {
          _this.content.removeClass('no-transition');
        });
        this.open();
      }

      if (!expanded) {
        this.content.addClass('no-transition');
        this.element.one('aftercollapse.expandable-area', function () {
          _this.content.removeClass('no-transition');
        });
        this.close();
      }

      return this;
    },


    /**
    * Return if the expandable area is current disable or not.
    * @returns {boolean} True or False depending on the disabled status.
    */
    isDisabled: function isDisabled() {
      return this.element.hasClass('is-disabled');
    },


    /**
    * Add Keyboard Support.
    * @private
    * @param  {object} e The event we are handling.
    * @returns {void}
    */
    handleKeys: function handleKeys(e) {
      if (this.isDisabled()) {
        return null;
      }

      var key = e.which;

      if (key === 13 || key === 32) {
        // Enter/Spacebar
        e.preventDefault();
        this.toggleExpanded();
        return false;
      }

      return null;
    },


    /**
    * Toggle focus classes on focus.
    * @private
    * @returns {void}
    */
    handleFocus: function handleFocus() {
      if (this.isDisabled()) {
        return;
      }

      this.header.addClass('is-focused');
    },


    /**
    * Toggle blur classes on blur.
    * @private
    * @returns {void}
    */
    handleBlur: function handleBlur() {
      if (this.isDisabled()) {
        return;
      }

      this.header.removeClass('is-focused');
    },


    /**
    * Returns expanded status about the current expandable area
    * @returns {boolean} True of alse depending on current expanded status.
    */
    isExpanded: function isExpanded() {
      return this.element.is('.is-expanded');
    },


    /**
    * Toggle current expansion state.
    */
    toggleExpanded: function toggleExpanded() {
      // if (this.header.attr('aria-expanded') === 'true') {
      if (this.isExpanded()) {
        this.close();
      } else {
        this.open();
      }
    },


    /**
    * Open the pane if closed.
    */
    open: function open() {
      var _this2 = this;

      /**
       * Fires after a row is added via the api.
      * @event beforeexpand
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */
      var canExpand = this.element.triggerHandler('beforeexpand', [this.element]);

      if (canExpand === false) {
        return;
      }

      this.element.addClass('is-expanded');
      this.header.attr('aria-expanded', 'true');
      this.expander.addClass('active');

      /**
       * Fires after a row is added via the api.
      * @event expand
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */
      this.element.triggerHandler('expand', [this.element]);

      this.expander.find('span[data-translated="true"]').text(Locale.translate('ShowLess') ? Locale.translate('ShowLess') : 'Show Less');

      if (this.isCard) {
        this.expander.find('.icon').addClass('active');
      }

      if (this.content[0]) {
        this.content[0].style.display = 'block';
      }

      /**
       * Fires after a row is added via the api.
      * @event afterexpand
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */
      this.content.one('animateopencomplete', function () {
        _this2.element.triggerHandler('afterexpand', [_this2.element]);
      }).animateOpen();
    },


    /**
    * Close the pane if open.
    */
    close: function close() {
      var _this3 = this;

      /**
      * Fires after a row is added via the api.
      * @event beforecollapse
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */
      var canCollapse = this.element.triggerHandler('beforecollapse', [this.element]);

      if (canCollapse === false) {
        return;
      }

      this.expander.removeClass('active');
      /**
      * Fires after a row is added via the api.
      * @event collapse
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */
      this.element.triggerHandler('collapse', [this.element]);
      this.expander.find('span[data-translated="true"]').text(Locale.translate('ShowMore') ? Locale.translate('ShowMore') : 'Show More');

      if (this.isCard) {
        this.expander.find('.icon').removeClass('active');
      }

      /**
      * Fires after a row is added via the api.
      * @event aftercollapse
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */
      this.content.one('animateclosedcomplete', function () {
        _this3.element.removeClass('is-expanded');
        _this3.header.attr('aria-expanded', 'false');
        _this3.element.triggerHandler('aftercollapse', [_this3.element]);
        _this3.content[0].style.display = 'none';
      }).animateClosed();
    },


    /**
    * Disable the expandable area from being closable.
    * @returns {void}
    */
    disable: function disable() {
      this.element.addClass('is-disabled');
    },


    /**
    * Enable the expandable area to allow close.
    * @returns {void}
    */
    enable: function enable() {
      this.element.removeClass('is-disabled');
    },


    /**
    * Destroy by removing markup and canceling events.
    * @returns {void}
    */
    destroy: function destroy() {
      this.header.children('a').off();
      this.header.off();
      this.header.removeAttr('aria-controls').removeAttr('aria-expanded').removeAttr('id');
      this.content.removeAttr('id').removeClass('no-transition');
      $.removeData(this.element[0], COMPONENT_NAME$u);
    },


    /**
     * Update the component and optionally apply new settings.
     * @param  {object} settings the settings to update to.
     * @returns {object} The plugin api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      return this;
    },


    /**
    * Attach event handlers.
    * @private
    * @returns {object} The Api for chaining.
    */
    handleEvents: function handleEvents() {
      var self = this;
      this.expander.on('click.expandablearea', function (e) {
        if (!self.isDisabled()) {
          e.preventDefault();
          self.toggleExpanded();
        }
      });

      this.header.on('keydown.expandablearea', function (e) {
        self.handleKeys(e);
      }).on('focus.expandablearea', function (e) {
        self.handleFocus(e);
      }).on('blur.expandablearea', function (e) {
        self.handleBlur(e);
      });

      return this;
    }
  };

  $.fn.expandablearea = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$u);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$u, new ExpandableArea(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$v = 'compositeform';

  /**
  * CompositeForm is a specialized responsive form component.
  * @class CompositeForm
  * @constructor
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [settings.breakpoint = 'phone-to-tablet'] Defines the breakpoint at which the composite form will change into its responsive mode
  * @param {string} [settings.trigger = null] Expandable area trigger selector. Passed to expandable area.
  * @param {string} [settings.expandedText = Locale.translate('ShowLess')] Text to use for the expand button (Default localized)
  * @param {string} [settings.collapsedText = Locale.translate('ShowMore')] Text to use for the collapse button (Default localized)
  */
  var COMPOSITEFORM_DEFAULTS = {
    breakpoint: 'phone-to-tablet',
    trigger: null,
    expandedText: Locale.translate('ShowLess'),
    collapsedText: Locale.translate('ShowMore')
  };

  function CompositeForm(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COMPOSITEFORM_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Component API
  CompositeForm.prototype = {

    /**
    * Initialize the component
    * @private
    * @returns {object} The component api for chaining.
    */
    init: function init() {
      return this.build().handleEvents();
    },


    /**
    * Adds markup to the control and stores references to some sub-elements
    * @private
    * @returns {object} The component api for chaining.
    */
    build: function build() {
      var componentClassList = this.element[0].classList;
      if (!componentClassList.contains('composite-form')) {
        componentClassList.add('composite-form');
      }

      // Get expandable area reference, if applicable
      var expandableArea = this.element.find('.expandable-area');
      if (expandableArea.length) {
        this.hasSummary = true;
        this.expandableArea = expandableArea;
        this.expandableAreaAPI = this.expandableArea.data('expandablearea');
        if (!this.expandableAreaAPI) {
          this.expandableArea.expandablearea({ trigger: this.settings.trigger });
          this.expandableAreaAPI = this.expandableArea.data('expandablearea');
        }

        // Get expandable trigger
        this.expander = this.expandableAreaAPI.expander;
        this.setExpanderText(this.settings.expandedText);
      } else {
        this.hasSummary = false;
      }

      // Check size and append class, if necessary
      this.checkResponsive();

      return this;
    },


    /**
     * Sets up event handlers for this control and its sub-elements
     * @param {string} expanderText - the text content
     * @returns {undefined}
     */
    handleEvents: function handleEvents() {
      var self = this;

      $('body').off('resize.' + COMPONENT_NAME$v).on('resize.' + COMPONENT_NAME$v, function (e) {
        self.checkResponsive(e);
      });

      this.element.on('updated.' + COMPONENT_NAME$v, function () {
        self.updated();
      });

      function changeExpanderText() {
        var isExpanded = self.expandableAreaAPI.isExpanded();
        self.setExpanderText(self.settings[isExpanded ? 'expandedText' : 'collapsedText']);
      }

      if (this.hasSummary) {
        this.expandableArea.on('expand.' + COMPONENT_NAME$v, changeExpanderText).on('collapse.' + COMPONENT_NAME$v, changeExpanderText);
      }

      return this;
    },


    /**
     * Checks if we've passed the breakpoint for switching into Responsive mode.
     * @returns {undefined}
     */
    checkResponsive: function checkResponsive() {
      var cl = this.element[0].classList;

      if (breakpoints.isBelow(this.settings.breakpoint)) {
        cl.add('is-in-responsive-mode');
      } else {
        cl.remove('is-in-responsive-mode');
        if (this.isSideOriented() && !this.expandableAreaAPI.isExpanded()) {
          this.expandableAreaAPI.open();
        }
      }
    },


    /**
     * Sets the text content of the Composite Form's Expandable Area Expander.
     * @param {string} expanderText - the text content
     * @returns {undefined}
     */
    setExpanderText: function setExpanderText(expanderText) {
      if (!this.hasSummary) {
        return;
      }

      if (!(expanderText instanceof String) || !expanderText.length) {
        return;
      }

      var textSpan = this.expander.find('span');
      if (!textSpan) {
        textSpan = this.expander;
      }
      textSpan.text(expanderText);
    },


    /**
     * Determines if this component is configured for "on-side" orientation of the Summary area.
     * @returns {boolean} If the component is currently side oriented.
     */
    isSideOriented: function isSideOriented() {
      return this.element[0].classList.contains('on-side');
    },


    /**
     * Re-invokes the Composite Form
     * @returns {object} The component API for chaining.
     */
    updated: function updated() {
      return this.teardown().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The component API for chaining.
     */
    teardown: function teardown() {
      $('body').off('resize.' + COMPONENT_NAME$v);
      this.element.off('updated.' + COMPONENT_NAME$v);

      if (this.hasSummary) {
        this.expandableArea.off('expand.' + COMPONENT_NAME$v + ' collapse.' + COMPONENT_NAME$v);
      }

      return this;
    },


    /**
     * Destroys the component instance by removing it from its associated element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$v);
    }
  };

  /**
   * jQuery Component Wrapper for Composite Form
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.compositeform = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$v);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$v, new CompositeForm(this, settings));
      }
    });
  };

  var COMPONENT_NAME$w = 'contextualactionpanel';

  /**
  * A more complex modal for complex in page interactions.
  * @class ContextualActionPanel
  * @param {string} element The component element.
  * @param {string} settings The component settings.
  * @param {string} [settings.id = `contextual-action-modal-cnt`]
  * The id to use for the CAP, or defaults to generated.
  * @param {array} [settings.buttons = null] A list of buttons that will sit in the toolbar's Buttonset area.
  * @param {string} [settings.title = 'Contextual Action Panel'] String that sits in the toolbar's title field.
  * @param {content} [settings.content = null] Pass content through to CAP.
  * @param {boolean} [settings.initializeContent = true] Initialize content before opening with defaults.
  * @param {string} [settings.trigger = 'click'] Can be 'click' or 'immediate'.
  * @param {boolean} [settings.centerTitle = false] If true the title will be centered.
  * @param {boolean} [settings.useFlexToolbar] If true the new flex toolbar will be used (For CAP)
  */
  var CONTEXTUALACTIONPANEL_DEFAULTS = {
    id: 'contextual-action-modal-' + (parseInt($('.modal').length, 10) + 1),
    buttons: null,
    title: 'Contextual Action Panel', //
    content: null, //
    initializeContent: true, // initialize content before opening
    trigger: 'click',
    showCloseButton: false,
    centerTitle: false
  };

  function ContextualActionPanel(element, settings) {
    this.settings = utils.mergeSettings(element, settings, CONTEXTUALACTIONPANEL_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  ContextualActionPanel.prototype = {

    /**
    * Initialize the CAP.
    * @private
    */
    init: function init() {
      this.setup().build().handleEvents();
    },


    /**
    * Setup internal variables.
    * @private
    * @returns {object} The Api for chaining.
    */
    setup: function setup() {
      this.panel = this.element.next('.contextual-action-panel');

      // Handle case with popup triggered from a menu
      if (this.element.closest('.popupmenu').length === 1) {
        this.panel = this.element.closest('.popupmenu').next('.contextual-action-panel');
      }

      if (this.panel[0]) {
        this.panel[0].style.display = 'none';
      }
      this.panel.addClass('is-animating');
      return this;
    },


    /**
    * Add markup to build up the component.
    * @private
    * @returns {object} The Api for chaining.
    */
    build: function build() {
      var self = this;

      // Build the Content
      if (this.panel.length === 0) {
        if (this.settings.content instanceof jQuery) {
          if (this.settings.content.is('.contextual-action-panel')) {
            this.panel = this.settings.content;
          } else {
            this.settings.content.wrap('<div class="contextual-action-panel"></div>');
            this.panel = this.settings.content.parent();
          }

          this.panel.addClass('modal').appendTo('body');

          if (this.settings.content.is('iframe')) {
            this.settings.content.ready(function () {
              self.completeBuild();
              self.settings.content.show();
            });
            return self;
          }
          this.settings.content.show();
        } else {
          this.panel = $('<div class="contextual-action-panel">' + this.settings.content + '</div>').appendTo('body');
          this.panel.addClass('modal').attr('id', this.settings.id);
        }
      }

      this.completeBuild();
      return this;
    },


    /**
    * Finalize build up/
    * @private
    * @returns {object} The Api for chaining.
    */
    completeBuild: function completeBuild() {
      var children = void 0;
      var isIframe = false;
      var contents = void 0;
      var hasSearchfield = false;
      var predefined = true;

      // Invoke Icons
      this.panel.find('svg').icon();

      // Get a reference to `.modal-content`
      var modalContent = this.panel.find('.modal-content');
      if (modalContent.length === 0) {
        children = this.panel.children();
        if (children.is('iframe')) {
          contents = children.contents();
          this.toolbar = contents.find('.toolbar, .flex-toolbar');
          isIframe = true;
        }

        if (!isIframe) {
          children.wrapAll('<div class="modal-content"></div>').wrapAll('<div class="modal-body"></div>');
          this.panel.addClass('modal');
        }
      }

      // Build/reference the header
      var modalHeader = this.panel.find('.modal-header');
      if (modalHeader.length === 0) {
        modalHeader = $('<div class="modal-header"></div>');
        modalHeader.insertBefore(this.panel.find('.modal-body'));
      }
      this.header = modalHeader;

      // Detect existence of buttonset for later
      var buttonset = this.panel.find('.toolbar .buttonset, .flex-toolbar .buttonset');

      // Build/reference the CAP header toolbar
      if (!this.toolbar) {
        this.toolbar = this.panel.find('.toolbar, .flex-toolbar');
      }
      if (!this.toolbar.length) {
        predefined = false;
        if (this.settings.buttons) {
          this.settings.buttons.forEach(function (button) {
            if (button.type === 'input') {
              hasSearchfield = true;
            }
          });
        }

        if (this.settings.title && this.settings.centerTitle) {
          var toolbarSearchfieldSection = hasSearchfield ? '<div class="toolbar-section search"></div>' : '';
          var toolbarHTML = '<div class="flex-toolbar">\n          <div class="toolbar-section static"></div>\n          <div class="toolbar-section title center-text">\n            <h2>' + this.settings.title + '</h2>\n          </div>\n          ' + toolbarSearchfieldSection + '\n          <div class="toolbar-section buttonset static"></div>\n        </div>';

          this.toolbar = $(toolbarHTML);
        } else if (!buttonset.length) {
          var toolbarCSSClass = this.settings.useFlexToolbar ? 'flex-toolbar' : 'toolbar';
          var toolbarTitleSection = this.settings.useFlexToolbar ? '<div class="toolbar-section title"><h2>' + this.settings.title + '</h2></div>' : '';
          var toolbarButtonsetCSSClass = this.settings.useFlexToolbar ? 'toolbar-section buttonset' : 'buttonset';
          var toolbarButtonsetSection = '<div class="' + toolbarButtonsetCSSClass + '"></div>';
          var _toolbarSearchfieldSection = this.settings.useFlexToolbar && hasSearchfield ? '<div class="toolbar-section search"></div>' : '';
          var _toolbarHTML = '<div class="' + toolbarCSSClass + '">\n          ' + toolbarTitleSection + '\n          ' + _toolbarSearchfieldSection + '\n          ' + toolbarButtonsetSection + '\n        </div>';

          var toolbar = $(_toolbarHTML);
          toolbar.appendTo(this.panel.find('.modal-header'));
          this.toolbar = toolbar;
          buttonset = toolbar.children('.buttonset');
        }
      }
      this.toolbar.appendTo(this.header);

      // Only add certain elements if a Toolbar was generated with JS-options
      // and not by HTML markup.
      if (!predefined) {
        if (!buttonset || !buttonset.length && !this.settings.centerTitle) {
          buttonset = $('<div class="toolbar-section buttonset"></div>');
          buttonset.appendTo(this.toolbar);
        }

        var toolbarTitle = this.toolbar.find('.title');
        if (!toolbarTitle.length) {
          var centerTextCSS = this.settings.centerTitle ? ' center-text' : '';
          toolbarTitle = $('\n          <div class="toolbar-section title' + centerTextCSS + '">\n            <h2>' + this.settings.title + '</h2>\n          </div>\n        ');

          if (buttonset) {
            toolbarTitle.insertBefore(buttonset);
          } else {
            this.toolbar.prepend(toolbarTitle);
          }
        }

        if (!toolbarTitle.length) {
          toolbarTitle = $('\n          <div class="title">\n            ' + this.settings.title + '\n          </div>\n        ');
          this.toolbar.prepend(toolbarTitle);
        }
      }

      // Move to the body element to break stacking context issues.
      if (!isIframe) {
        this.panel.detach().appendTo('body');
      }

      this.element.attr('data-modal', this.settings.id);
      if (!this.panel.attr('id')) {
        this.panel.attr('id', this.settings.id);
      }

      this.panel.modal({
        buttons: this.settings.buttons,
        centerTitle: this.settings.centerTitle,
        useFlexToolbar: this.settings.useFlexToolbar,
        trigger: this.settings.trigger ? this.settings.trigger : 'click'
      });

      this.buttons = this.panel.find('.buttonset').children('button');

      this.closeButton = this.panel.find('.modal-header').find('.btn-close, [name="close"], button.close-button');
      if (!predefined && this.settings.showCloseButton && !this.closeButton.length) {
        this.closeButton = $('\n        <button class="btn-close" type="button">\n          <svg class="icon icon-close" focusable="false" aria-hidden="true" role="presentation">\n            <use xlink:href="#icon-close"></use>\n          </svg>\n          <span>Close</span>\n        </button>\n      ');

        if (!this.settings.useFlexToolbar) {
          var CAPToolbarButton = $('<div class="close-button"></div>').append(this.closeButton);
          this.header.append(CAPToolbarButton);
        } else {
          var standaloneSection = $('<div class="toolbar-section static"></div>').append(this.closeButton);
          var more = this.toolbar.find('.toolbar-section.more');
          standaloneSection.after(more.length ? more : buttonset);
        }
      }

      if (this.closeButton.length) {
        this.toolbar.addClass('has-close-button');
      }

      if (this.toolbar.is('.toolbar')) {
        this.toolbar.toolbar();
      }
      if (this.toolbar.is('.flex-toolbar')) {
        this.toolbar.toolbarflex();
      }

      utils.fixSVGIcons(this.element);
      return this;
    },


    /**
    * Attach event handlers.
    * @private
    * @returns {object} The Api for chaining.
    */
    handleEvents: function handleEvents() {
      var self = this;

      // Convenience method that takes an event from the Modal control's panel element,
      // and triggers any listeners that may be looking at the Contextual Action Panel's
      // trigger instead.
      function passEvent(e) {
        self.element.triggerHandler(e.type);
      }

      this.panel.addClass('is-animating').on('open.contextualactionpanel', function (e) {
        passEvent(e);
        self.panel.removeClass('is-animating');
      }).on('beforeclose.contextualactionpanel', function () {
        self.panel.addClass('is-animating');
      }).on('close.contextualactionpanel', function (e) {
        passEvent(e);
      }).on('beforeopen.contextualactionpanel', function (e) {
        if (self.settings.initializeContent) {
          $(this).initialize();
        }
        passEvent(e);
      }).on('afteropen.contextualactionpanel', function () {
        if (self.toolbar) {
          self.toolbar.trigger('recalculate-buttons');
        }

        // Select the proper element on the toolbar
        if (self.toolbar.length) {
          var selected = self.toolbar.find('.buttonset > .is-selected');
          if (!selected.length) {
            selected = self.toolbar.find('.buttonset > *:first-child');
            if (selected.is('.searchfield-wrapper')) {
              selected = selected.children('.searchfield');
            }
          }
          if (!selected.length && self.toolbar.is('.flex-toolbar')) {
            selected = self.toolbar.find('button').first();
            selected.focus();
            return;
          }
          var toolbarData = self.toolbar.data('toolbar');
          if (toolbarData) {
            toolbarData.setActiveButton(selected, true);
          }
        }

        // Focus the first focusable element inside the Contextual Panel's Body
        self.panel.find('.modal-body-wrapper').find(':focusable').first().focus();
        utils.fixSVGIcons(self.panel);
      }).on('beforedestroy.contextualactionpanel', function () {
        self.teardown();
      });

      if (self.closeButton && self.closeButton.length) {
        self.closeButton.on('click.contextualactionpanel', function () {
          self.handleToolbarSelected();
        });
      }

      return this;
    },


    /**
    * Toolbar select event handler.
    * @private
    * @returns {void}
    */
    handleToolbarSelected: function handleToolbarSelected() {
      this.close();
    },


    /**
    * Detach events and restore markup.
    * @private
    * @returns {void}
    */
    teardown: function teardown() {
      var self = this;
      var buttonset = self.toolbar.children('.buttonset');

      this.panel.off('open.contextualactionpanel close.contextualactionpanel ' + 'beforeopen.contextualactionpanel afterclose.contextualactionpanel');

      buttonset.children('*:not(.searchfield)').off('click.contextualactionpanel');

      var menuButtons = buttonset.children('.btn-menu');
      menuButtons.each(function () {
        var popup = $(this).data('popupmenu');
        if (popup) {
          popup.destroy();
        }
      });

      if (self.header) {
        self.header.remove();
      }

      var children = self.panel.find('.modal-body').children();
      children.first().unwrap().unwrap();

      self.element.removeAttr('data-modal');

      if (self.closeButton && self.closeButton.length) {
        self.closeButton.off('click.contextualactionpanel');
        delete self.closeButton;
      }

      // Trigger an afterclose event on the Contextual Action Panel's trigger element
      // (different from the panel, which is already removed).
      self.element.trigger('afterteardown');
    },


    /**
    * Close the Contextual Action Panel if open and call destroy.
    * @returns {void}
    */
    close: function close() {
      var destroy = void 0;
      if (this.settings.trigger === 'immediate') {
        destroy = true;
      }
      if (this.panel.data('modal')) {
        this.panel.data('modal').close(destroy);
      }
    },


    /**
    * Add a disabled attribute to the main component element.
    * @returns {void}
    */
    disable: function disable() {
      this.element.prop('disabled', true);
      if (this.panel.hasClass('is-visible')) {
        this.close();
      }
    },


    /**
    * Remove disabled attribute from the main component element.
    * @returns {void}
    */
    enable: function enable() {
      this.element.prop('disabled', false);
    },


    /**
     * Update the component and optionally apply new settings.
     *
     * @param  {object} settings the settings to update to.
     * @returns {object} The plugin api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      return this;
    },


    /**
    * Destroy and remove added markup and events
    * @returns {void}
    */
    destroy: function destroy() {
      this.teardown();
      this.panel.data('modal').destroy();
      $.removeData(this.element[0], COMPONENT_NAME$w);
    }
  };

  /**
   * jQuery Component Wrapper for Contextual Action Panel
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.contextualactionpanel = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$w);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$w, new ContextualActionPanel(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$x = 'tooltip';

  /**
   * Tooltip and Popover Control
   * @class Tooltip
   * @constructor
   *
   * @param {htmlelement|jquery[]} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string|function} [settings.content] Takes title attribute or feed content. Can be a string or jQuery markup.
   * @param {object} [settings.offset={top: 10, left: 10}] How much room to leave.
   * @param {string} [settings.placement='top'] Supports 'top'|'bottom'|'right'|'offset'.
   * @param {string} [settings.trigger='hover'] Supports click and immediate and hover (and maybe in future focus).
   * @param {string} [settings.title] Title for Infor Tips.
   * @param {string} [settings.beforeShow] Call back for ajax tooltip.
   * @param {string} [settings.popover] force it to be a popover (no content).
   * @param {string} [settings.closebutton] Show X close button next to title in popover.
   * @param {boolean} [settings.isError=false] Add error classes.
   * @param {boolean} [settings.isErrorColor=false] Add error color only not description.
   * @param {string} [settings.tooltipElement] ID selector for an alternate element to use to contain the tooltip classes.
   * @param {object} [settings.parentElement] jQuery-wrapped element that gets.
    passed to the 'place' behavior as the element to place the tooltip against.
   * @param {boolean} [settings.keepOpen=false] Forces the tooltip to stay open in situations where it would normally close.
   * @param {string} [settings.extraClass] Extra css class.
   * @param {object} [settings.placementOpt] Placement options.
   * @param {string} [settings.maxWidth] Toolip max width.
  * @param {boolean} [settings.initializeContent] Init the content in the tooltip.
   */

  var TOOLTIP_DEFAULTS = {
    content: null,
    offset: { top: 10, left: 10 },
    placement: 'top',
    trigger: 'hover',
    title: null,
    beforeShow: null,
    popover: null,
    closebutton: null,
    isError: false,
    isErrorColor: false,
    tooltipElement: null,
    parentElement: null,
    keepOpen: false,
    extraClass: null,
    placementOpts: {},
    maxWidth: null,
    initializeContent: true
  };

  function Tooltip(element, settings) {
    this.settings = utils.mergeSettings(element, settings, TOOLTIP_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  Tooltip.prototype = {

    /**
     * Initializes the component
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup();
      this.appendTooltip();

      // Initial Content Setting.
      // Don't do this if we're using an "immediate" trigger because _setContent()_ is handled at
      // display time in that case.
      var shouldRender = this.settings.trigger !== 'immediate';
      if (shouldRender) {
        this.setContent(this.settings.content, true);
      }

      this.handleEvents();
    },


    /**
     * Builds internal references
     * @private
     * @returns {void}
     */
    setup: function setup() {
      // "this.activeElement" is the target element that the Tooltip will display itself against
      this.activeElement = this.settings.parentElement instanceof $ && this.settings.parentElement.length ? this.settings.parentElement : this.element;

      this.descriptionId = $('.tooltip-description').length + 1;
      this.description = this.element.parent().find('.tooltip-description');
      if (!this.description.length && this.settings.isError) {
        this.description = $('<span id="tooltip-description-' + this.descriptionId + '" class="tooltip-description audible"></span>').insertAfter(this.element);
      }

      if (this.element.is('.dropdown, .multiselect')) {
        this.activeElement = this.element.nextAll('.dropdown-wrapper:first').find('>.dropdown');
      }

      var titleAttr = this.element.attr('title');
      if (!this.settings.popover && titleAttr && titleAttr.length || !this.settings.popover && this.settings.title) {
        this.settings.content = this.settings.title ? this.settings.title : titleAttr;
        this.element.removeAttr('title');
      }

      if (this.settings.trigger === 'hover') {
        this.element.addClass('longpress-target');
      }

      this.isPopover = this.settings.content !== null && _typeof(this.settings.content) === 'object' || this.settings.popover === true;

      this.settings.closebutton = !!(this.settings.closebutton || this.element.data('closebutton'));

      if (this.element.data('extraClass') && this.element.data('extraClass').length) {
        this.settings.extraClass = this.element.data('extraClass');
      }

      this.isRTL = Locale.isRTL();
    },


    /**
     * Adds ARIA attributes on some elements for better accessiblity.
     * @private
     * @returns {void}
     */
    addAria: function addAria() {
      if (!this.content) {
        return;
      }

      this.description.text(this.content);
      this.content = this.addClassToLinks(this.content, 'links-clickable');

      if (!this.isPopover) {
        this.element.removeAttr('title').attr('aria-describedby', this.description.attr('id'));
      }

      if (this.isPopover && this.settings.trigger === 'click') {
        this.element.attr('aria-haspopup', true);
      }
    },


    /**
     * @param {jquery[]|string} content HTML or String-based content.
     * @param {string} [thisClass] optional, additional CSS class that gets appeneded to any anchor tags inside of the content.
     * @returns {string} the appended content
     */
    addClassToLinks: function addClassToLinks(content, thisClass) {
      var isjQuery = content instanceof $ && content.length > 0;
      if (isjQuery) {
        return content;
      }

      var d = $('<div/>').html(content);
      $('a', d).addClass(thisClass);
      return d.html();
    },


    /**
     * Gets a reference to the element being used for the tooltip and positions it in the correct spot on the page.
     * @private
     * @returns {void}
     */
    appendTooltip: function appendTooltip() {
      this.tooltip = this.settings.tooltipElement ? $(this.settings.tooltipElement) : $('#tooltip');
      if (!this.tooltip.length) {
        var name = this.settings.tooltipElement ? this.settings.tooltipElement.substring(1, this.settings.tooltipElement.length) : 'tooltip';
        this.tooltip = $('<div class="' + (this.isPopover ? 'popover' : 'tooltip') + ' bottom is-hidden" role="tooltip" id="' + name + '"><div class="arrow"></div><div class="tooltip-content"></div></div>');
      }

      this.tooltip.place({
        container: this.scrollparent,
        parent: this.activeElement,
        placement: this.settings.placement,
        strategy: 'flip'
      });

      this.setTargetContainer();
    },


    /**
     * Sets up all event listeners for this component
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var self = this;
      var delay = 400;
      var timer = void 0;

      if (this.settings.trigger === 'hover' && !this.settings.isError) {
        (this.element.is('.dropdown, .multiselect') ? this.activeElement : this.element).on('mouseenter.' + COMPONENT_NAME$x, function () {
          timer = setTimeout(function () {
            self.show();
          }, delay);
        }).on('mouseleave.' + COMPONENT_NAME$x + ' click.' + COMPONENT_NAME$x, function () {
          clearTimeout(timer);
          setTimeout(function () {
            self.hide();
          }, delay);
        }).on('longpress.' + COMPONENT_NAME$x, function () {
          self.show();
        }).on('updated.' + COMPONENT_NAME$x, function () {
          self.updated();
        });
      }

      function toggleTooltipDisplay() {
        if (!self.tooltip.hasClass('is-hidden')) {
          self.hide();
        } else {
          self.show();
        }
      }

      if (this.settings.trigger === 'click') {
        this.element.on('click.' + COMPONENT_NAME$x, function () {
          toggleTooltipDisplay();
        });
      }

      if (this.settings.trigger === 'immediate') {
        timer = setTimeout(function () {
          toggleTooltipDisplay();
        }, 1);
      }

      var isFocusable = this.settings.trigger === 'focus';
      if (isFocusable) {
        this.element.on('focus.' + COMPONENT_NAME$x, function () {
          self.show();
        }).on('blur.' + COMPONENT_NAME$x, function () {
          if (!self.settings.keepOpen) {
            self.hide();
          }
        });
      }

      // Close the popup/tooltip on orientation changes (but not when keyboard is open)
      $(window).on('orientationchange.' + COMPONENT_NAME$x, function () {
        // Match every time.
        if (self.tooltip.hasClass('is-hidden')) {
          return;
        }
        self.close();
      }, false);
    },


    /**
     * Sets the content used inside the Tooltip element.
     * @private
     * @param {jquery[]|string|function} content incoming content to be set
     * @param {boolean} dontRender causes the tooltip to prevent a visual refresh
      after changing its content, meaning it will keep the previous content visible until this tooltip is closed or manually re-drawn.
     * @returns {boolean} whether or not the render was successful
     */
    setContent: function setContent(content, dontRender) {
      var self = this;
      var settingsContent = this.settings.content;
      var noIncomingContent = content === undefined || content === null;
      var noSettingsContent = settingsContent === undefined || settingsContent === null;

      function doRender() {
        if (dontRender === true) {
          return;
        }
        self.addAria();
        self.render();
      }

      // If all sources of content are undefined, just return false and don't show anything.
      if (noIncomingContent && noSettingsContent) {
        return false;
      }

      // If the settingsContent type is a function, we need to re-run that function
      // to update the content.
      // NOTE: If you need to use a function to generate content, understand that the
      //  tooltip/popover will not cache your content for future reuse.  It will ALWAYS
      //  override incoming content.
      if (typeof settingsContent === 'function') {
        content = settingsContent;
      }

      // Use the pre-set content if we have no incoming content
      if (noIncomingContent) {
        content = settingsContent;
      }

      // If the incoming/preset content is exactly the same as the stored content,
      // don't continue with this step. Deep object comparison for jQuery objects
      // is done further down the chain.
      if (content === this.content) {
        doRender();
        return true;
      }

      // jQuery-wrapped elements don't get manipulated.
      // Simply store the reference, render, and return.
      if (content instanceof $ && content.length) {
        this.content = content.addClass('hidden');
        doRender();
        return true;
      }

      // Handle setting of content based on its Object type.
      // If type isn't handled, the tooltip will not display.
      if (typeof content === 'string') {
        if (!content.length) {
          return false;
        }

        // Could be a translation definition
        content = Locale.translate(content, true) || content;

        // Could be an ID attribute.
        // If it matches an element already on the page, grab that element's content
        // and store the reference only.
        if (content.indexOf('#') === 0) {
          var contentCheck = $('' + content);
          if (contentCheck.length) {
            this.content = contentCheck;
            doRender();
            return true;
          }
          return false;
        }

        // functions
      } else if (typeof content === 'function') {
        var callbackResult = content.call(this.element);
        if (!callbackResult || typeof callbackResult !== 'string' || !callbackResult.length) {
          return false;
        }
        content = callbackResult;

        // if type isn't handled, return false
      } else {
        return false;
      }

      // Store an internal copy of the processed content
      this.content = xssUtils.sanitizeHTML(content);

      // Wrap tooltip content in <p> tags if there isn't already one present.
      // Only happens for non-jQuery markup.
      this.content = '<p>' + this.content + '</p>';

      doRender();
      return true;
    },


    /**
     * Renders internal content either as a Tooltip or Popover.
     * @private
     * @returns {void}
     */
    render: function render() {
      if (this.isPopover) {
        return this.renderPopover();
      }
      return this.renderTooltip();
    },


    /**
     * Renders internal content as a Tooltip.
     * @private
     * @returns {void}
     */
    renderTooltip: function renderTooltip() {
      var titleArea = this.tooltip[0].querySelectorAll('.tooltip-title')[0];
      var contentArea = this.tooltip[0].querySelectorAll('.tooltip-content')[0];
      var extraClass = this.settings.extraClass;
      var content = this.content;
      var tooltip = this.tooltip[0];
      var classes = 'tooltip is-hidden';

      if (extraClass) {
        classes += ' ' + extraClass;
      }
      tooltip.setAttribute('class', classes);

      if (titleArea) {
        titleArea.style.display = 'none';
      }

      if (!contentArea.previousElementSibling.classList.contains('arrow')) {
        contentArea.insertAdjacentHTML('beforebegin', '<div class="arrow"></div>');
      }

      var tooltipHTML = typeof this.content === 'string' ? content : content[0].innerHTML;
      DOM.html(contentArea, tooltipHTML, '<div><p><span><ul><li><a><abbr><b><i><kbd><small><strong><sub><svg><use><br>');
    },


    /**
     * Renders internal content as a Tooltip.
     * @private
     * @returns {void}
     */
    renderPopover: function renderPopover() {
      var self = this;
      var extraClass = this.settings.extraClass;
      var contentArea = this.tooltip.find('.tooltip-content');
      var title = this.tooltip[0].querySelector('.tooltip-title');
      var content = this.content;
      var classes = 'popover is-hidden';

      if (extraClass) {
        classes += ' ' + extraClass;
      }

      this.tooltip[0].setAttribute('class', classes);

      if (typeof content === 'string') {
        content = $(content);
        contentArea.html(content);
        contentArea.find('.hidden').removeClass('hidden');
      } else {
        contentArea.html(content);
      }

      var popoverWidth = contentArea.width();

      if (!this.settings.placementOpts) {
        this.settings.placementOpts = {};
      }

      if (!this.settings.placementOpts.parent) {
        this.settings.placementOpts.parent = this.element;
      }

      content[0].classList.remove('hidden');
      contentArea[0].firstElementChild.classList.remove('hidden');

      var parentWidth = this.settings.placementOpts.parent.width();

      if (Locale.isRTL()) {
        this.settings.placementOpts.parentXAlignment = parentWidth > popoverWidth ? 'left' : 'right';
      } else {
        this.settings.placementOpts.parentXAlignment = parentWidth > popoverWidth ? 'right' : 'left';
      }

      if (this.settings.title !== null) {
        if (!title) {
          var titleFrag = document.createDocumentFragment();
          title = document.createElement('div');
          DOM.html(title, this.settings.title, '*');
          title.classList.add('tooltip-title');
          titleFrag.appendChild(title);
          this.tooltip[0].insertBefore(titleFrag, this.tooltip[0].firstChild);
        } else {
          title.style.display = '';
          title.childNodes[0].nodeValue = this.settings.title;
        }
      } else if (title) {
        title.style.display = 'none';
      }

      if (this.settings.closebutton && title && !title.firstElementChild) {
        var closeBtnX = $('<button type="button" class="btn-icon l-pull-right btn-close">' + $.createIcon({ classes: ['icon-close'], icon: 'close' }) + '<span>Close</span>' + '</button>').on('click', function () {
          self.hide();
        });

        title.appendChild(closeBtnX[0]);
      }

      if (this.settings.initializeContent) {
        content.initialize();
      }
    },


    /**
     * Alias for _show()_.
     * @private
     * @returns {void}
     */
    open: function open() {
      return this.show();
    },


    /**
     * Causes the tooltip to become shown
     * @param {object} newSettings an object containing changed settings that will be
     *  applied to the Tooltip/Popover before it's displayed.
     * @param {boolean} ajaxReturn causes an AJAX-powered Tooltip/Popover not to refresh.
     */
    show: function show(newSettings, ajaxReturn) {
      var self = this;
      this.isInPopup = false;

      if (newSettings) {
        this.settings = utils.mergeSettings(this.element[0], newSettings, this.settings);
      }

      if (this.settings.beforeShow && !ajaxReturn) {
        var response = function response(content) {
          if (typeof content === 'boolean' && !content) {
            return;
          }
          self.content = content;
          self.show({ content: content }, true);
        };

        if (typeof this.settings.beforeShow === 'string') {
          window[this.settings.beforeShow](response, this.element);
          return;
        }

        this.settings.beforeShow(response, this.element);
        return;
      }

      var okToShow = true;

      okToShow = this.setContent(this.content);
      if (okToShow === false) {
        return;
      }

      /**
       * Fires before show the tooltip.
       *
       * @event beforeshow
       * @memberof Tooltip
       * @property {object} event - The jquery event object
       * @property {object} tooltip - instance
       */
      okToShow = this.element.triggerHandler('beforeshow', [this.tooltip]);
      if (okToShow === false) {
        return;
      }

      this.tooltip[0].removeAttribute('style');
      this.tooltip[0].classList.add(this.settings.placement);

      if (this.settings.isError || this.settings.isErrorColor) {
        this.tooltip[0].classList.add('is-error');
      }

      this.position();
      utils.fixSVGIcons(this.tooltip);
      /**
       * Fires on show the tooltip.
       *
       * @event show
       * @memberof Tooltip
       * @property {object} event - The jquery event object
       * @property {object} tooltip - instance
       */
      this.element.trigger('show', [this.tooltip]);

      var mouseUpEventName = Environment.features.touch ? 'touchend' : 'mouseup';

      setTimeout(function () {
        $(document).on(mouseUpEventName + '.' + COMPONENT_NAME$x, function (e) {
          var target = $(e.target);

          if (self.settings.isError || self.settings.trigger === 'focus') {
            return;
          }

          if (target.is(self.element) && target.is('svg.icon')) {
            return;
          }

          if ($('#editor-popup').length && $('#colorpicker-menu').length) {
            return;
          }

          if (target.closest('.popover').length === 0 && target.closest('.dropdown-list').length === 0) {
            self.hide(e);
          }
        }).on('keydown.' + COMPONENT_NAME$x, function (e) {
          if (e.which === 27 || self.settings.isError) {
            self.hide();
          }
        });

        if (self.settings.isError && !self.element.is(':visible, .dropdown') && self.element.is('[aria-describedby]')) {
          self.hide();
        }

        if (window.orientation === undefined) {
          $('body').on('resize.' + COMPONENT_NAME$x, function () {
            self.hide();
          });
        }

        // Hide on Page scroll
        $('body').on('scroll.' + COMPONENT_NAME$x, function () {
          self.hide();
        });

        self.element.closest('.modal-body-wrapper').on('scroll.tooltip', function () {
          self.hide();
        });

        self.element.closest('.scrollable').on('scroll.tooltip', function () {
          self.hide();
        });

        self.element.closest('.datagrid-body').on('scroll.tooltip', function () {
          self.hide();
        });

        // Click to close
        if (self.settings.isError) {
          self.tooltip.on('click.' + COMPONENT_NAME$x, function () {
            self.hide();
          });
        }
        /**
         * Fires after show the tooltip.
         *
         * @event aftershow
         * @memberof Tooltip
         * @property {object} event - The jquery event object
         * @property {object} tooltip - instance
         */
        self.element.trigger('aftershow', [self.tooltip]);
      }, 400);
    },


    /**
     * Places the tooltip element itself in the correct DOM element.
     * If the current element is inside a scrollable container, the tooltip element
     *  goes as high as possible in the DOM structure.
     * @returns {void}
     */
    setTargetContainer: function setTargetContainer() {
      var targetContainer = $('body');

      // adjust the tooltip if the element is being scrolled inside a scrollable DIV
      this.scrollparent = this.element.closest('.page-container.scrollable');
      if (this.scrollparent.length) {
        targetContainer = this.scrollparent;
      }

      if (this.settings.parentElement) {
        targetContainer = this.settings.parentElement;
      }

      // this.tooltip.detach().appendTo(targetContainer);
      targetContainer[0].appendChild(this.tooltip[0]);
    },


    /**
     * Placement behavior's "afterplace" handler.
     * DO NOT USE FOR ADDITIONAL POSITIONING.
     * @private
     * @param {jquery.event} e custom `afterPlace` event
     * @param {placementobject} placementObj object containing placement settings
     * @returns {void}
     */
    handleAfterPlace: function handleAfterPlace(e, placementObj) {
      this.tooltip.data('place').setArrowPosition(e, placementObj, this.tooltip);
      this.tooltip.triggerHandler('tooltipafterplace', [placementObj]);
    },


    /**
     * Resets the current position of the tooltip.
     * @returns {this} component instance
     */
    position: function position() {
      this.setTargetContainer();
      this.tooltip[0].classList.remove('is-hidden');

      var self = this;
      var distance = this.isPopover ? 20 : 10;
      var tooltipPlacementOpts = this.settings.placementOpts || {};
      var opts = $.extend({}, {
        x: 0,
        y: distance,
        container: this.scrollparent,
        containerOffsetX: tooltipPlacementOpts.containerOffsetX || this.settings.offset.left,
        containerOffsetY: tooltipPlacementOpts.containerOffsetY || this.settings.offset.top,
        parent: tooltipPlacementOpts.parent || this.activeElement,
        placement: tooltipPlacementOpts.placement || this.settings.placement,
        strategies: ['flip', 'nudge']
      }, tooltipPlacementOpts);

      if (opts.placement === 'left' || opts.placement === 'right') {
        opts.x = distance;
        opts.y = 0;
      }

      this.tooltip.one('afterplace.tooltip', function (e, placementObj) {
        self.handleAfterPlace(e, placementObj);
      });

      // Tool tip may be cleaned up on a modal or CAP
      if (this.tooltip.data('place')) {
        this.tooltip.data('place').place(opts);
      } else {
        this.tooltip.place(opts);
        this.tooltip.data('place').place(opts);
      }
      return this;
    },


    /**
     * Alias for _hide()_ that works with the global _closeChildren()_ method.
     * @private
     * @returns {void}
     */
    close: function close() {
      return this.hide();
    },


    /**
     * Hides the Tooltip/Popover
     * @returns {void}
     */
    hide: function hide() {
      if (this.settings.keepOpen) {
        return;
      }

      if (this.isInPopup) {
        this.settings.content.addClass('hidden');
        return;
      }

      this.tooltip[0].classList.add('is-hidden');
      this.tooltip[0].style.left = '';
      this.tooltip[0].style.top = '';
      this.tooltip.find('.arrow').removeAttr('style');

      this.detachOpenEvents();

      if ($('.popover').not('.is-hidden').length === 0) {
        $(document).off('mouseup.tooltip keydown.tooltip');
        $('body').off('resize.tooltip');
      }

      /**
       * Fires when hide the tooltip.
       *
       * @event hide
       * @memberof Tooltip
       * @property {object} event - The jquery event object
       * @property {object} tooltip - instance
       */
      this.element.trigger('hide', [this.tooltip]);
    },


    /**
     * Causes the tooltip to store updated settings and re-render itself.
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      var self = this;
      if (self.settings.trigger === 'immediate') {
        setTimeout(function () {
          self.show();
        }, 100);
      } else {
        self.setContent();
      }

      return this;
    },


    /**
     * Removes any events which would cause the tooltip/popover to re-open.
     * @private
     * @returns {void}
     */
    detachOpenEvents: function detachOpenEvents() {
      this.tooltip.off('click.' + COMPONENT_NAME$x);

      $(document).off(['keydown.' + COMPONENT_NAME$x, 'mouseup.' + COMPONENT_NAME$x, 'touchend.' + COMPONENT_NAME$x].join(' '));

      $('body').off(['resize.' + COMPONENT_NAME$x, 'scroll.' + COMPONENT_NAME$x].join(' '));

      this.element.closest('.modal-body-wrapper').off('scroll.' + COMPONENT_NAME$x);
      this.element.closest('.scrollable').off('scroll.' + COMPONENT_NAME$x);
      this.element.closest('.datagrid-body').off('scroll.' + COMPONENT_NAME$x);
    },


    /**
     * Tears down this component instance, removing all internal flags and unbinding events.
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.description.remove();
      this.descriptionId = undefined;
      this.activeElement = undefined;

      this.element.removeAttr('aria-describedby').removeAttr('aria-haspopup');
      if (!this.tooltip.hasClass('is-hidden')) {
        this.hide();
      }

      if (this.tooltip && this.tooltip.data('place')) {
        this.tooltip.data('place').destroy();
      }

      this.element.off(['mouseenter.' + COMPONENT_NAME$x, 'mouseleave.' + COMPONENT_NAME$x, 'longpress.' + COMPONENT_NAME$x, 'click.' + COMPONENT_NAME$x, 'updated.' + COMPONENT_NAME$x, 'focus.' + COMPONENT_NAME$x, 'blur.' + COMPONENT_NAME$x].join(' '));

      this.detachOpenEvents();

      $(window).off('orientationchange.' + COMPONENT_NAME$x);

      return this;
    },


    /**
     * Destroys this component instance
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$x);
    }
  };

  /**
   * jQuery Component Wrapper for Tooltip/Popover
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.tooltip = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$x);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$x, new Tooltip(this, settings));
      }
    });
  };

  // The Tooltip Component and Popover Component use the same prototype with different settings.
  // Simply setup the Popover to be the same thing as the Tooltip.
  $.fn.popover = $.fn.tooltip;

  // Name of this component.
  var COMPONENT_NAME$y = 'dropdown';

  // Dropdown Settings and Options
  var moveSelectedOpts = ['none', 'all', 'group'];
  var reloadSourceStyles = ['none', 'open', 'typeahead'];

  /**
  * The Dropdown allows users to select from a list. Like an Html Select.
  * @class Dropdown
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {boolean} [settings.closeOnSelect = true]  When an option is selected, the list will close if set to "true".  List stays open if "false".
  * @param {string} [settings.cssClass = null]  Append an optional css class to dropdown-list
  * @param {string} [settings.filterMode = 'contains']  Search mode to use between 'startsWith' and 'contains', false will not allow client side filter
  * @param {boolean} [settings.noSearch = false]  If true, disables the ability of the user to enter text
  * in the Search Input field in the open combo box
  * @param {boolean} [settings.showEmptyGroupHeaders = false]  If true, displays optgroup headers in the list
  * even if no selectable options are present underneath.
  * @param {boolean} [settings.source]  A function that can do an ajax call.
  * @param {boolean} [settings.sourceArguments = {}]  If a source method is defined, this flexible object can be
  * passed into the source method, and augmented with parameters specific to the implementation.
  * @param {boolean|string} [settings.reload = 'none']  Determines how a Dropdown list will repopulate its contents, when operating via AJAX.
  * @param {boolean} [settings.reloadSourceOnOpen = false]  If set to true, will always perform an ajax call
  * whenever the list is opened.  If false, the first AJAX call's results are cached.
  * @param {boolean} [settings.empty = false]  Initialize Empty Value
  * @param {boolean} [settings.delay = 300]  Typing buffer delay in ms
  * @param {number} [settings.maxWidth = null] If set the width of the dropdown is limited to this pixel width.
  * Fx 300 for the 300 px size fields. Default is size of the largest data.
  * @param {object} [settings.placementOpts = null]  Gets passed to this control's Place behavior
  * @param {function} [settings.onKeyDown = null]  Allows you to hook into the onKeyDown. If you do you can access the keydown event data. And optionally return false to cancel the keyDown action.
  */
  var DROPDOWN_DEFAULTS = {
    closeOnSelect: true,
    cssClass: null,
    filterMode: 'contains',
    maxSelected: undefined, // (multiselect) sets a limit on the number of items that can be selected
    moveSelected: 'none',
    moveSelectedToTop: undefined,
    multiple: false, // Turns the dropdown into a multiple selection box
    noSearch: false,
    showEmptyGroupHeaders: false,
    showSelectAll: false, // (Multiselect) shows an item the top of the list labeled "select all".
    source: undefined,
    sourceArguments: {},
    reload: reloadSourceStyles[0],
    empty: false,
    delay: 300,
    maxWidth: null,
    placementOpts: null,
    onKeyDown: null
  };

  function Dropdown(element, settings) {
    this.settings = utils.mergeSettings(element, settings, DROPDOWN_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Actual DropDown Code
  Dropdown.prototype = {

    /**
     * @returns {array|string} currently-selected options
     */
    get value() {
      var reload = this.settings.reload;
      var multiple = this.settings.multiple;

      if (reload === 'typeahead') {
        if (multiple) {
          return this.selectedValues;
        }
        return this.element.val();
      }

      var result = [];
      var options = this.element[0].options;
      var opt = void 0;

      for (var i = 0; i < options.length; i++) {
        opt = options[i];
        if (opt.selected) {
          result.push(opt.value || opt.text);
        }
      }

      if (!multiple && result.length === 1) {
        return result[0];
      }
      return result;
    },

    /**
     * Initialize the dropdown.
     * @private
     * @returns {object} The api for chaining
     */
    init: function init() {
      var orgId = this.element.attr('id');
      orgId = orgId ? xssUtils.stripTags(orgId) : '';

      this.inlineLabel = this.element.closest('label');
      this.inlineLabelText = this.inlineLabel.find('.label-text');
      this.isInlineLabel = this.element.parent().is('.inline');

      this.timer = null;
      this.filterTerm = '';

      if (!orgId) {
        orgId = utils.uniqueId(this.element, 'dropdown');
        DOM.setAttribute(this.element[0], 'id', orgId);
        DOM.setAttribute(this.element.parent().find('label').first()[0], 'for', orgId);
      }

      if (Environment.os.name === 'ios' || Environment.os.name === 'android') {
        this.settings.noSearch = true;
      }

      // convert <select> tag's size css classes for the pseudo element
      var elemClassList = this.element[0].classList;
      if (elemClassList.length === 0) {
        this.element[0].classList = 'dropdown';
      }
      var pseudoClassString = elemClassList.contains('dropdown-xs') ? 'dropdown input-xs' : //eslint-disable-line
      elemClassList.contains('dropdown-sm') ? 'dropdown input-sm' : //eslint-disable-line
      elemClassList.contains('dropdown-lg') ? 'dropdown input-lg' : 'dropdown'; //eslint-disable-line

      // Detect Inline Styles
      var style = this.element.attr('style');
      this.isHidden = style && style.indexOf('display: none') >= 0;

      // Build the wrapper if it doesn't exist
      var baseElement = this.isInlineLabel ? this.inlineLabel : this.element;
      this.wrapper = baseElement.next('.dropdown-wrapper');
      this.isWrapped = this.wrapper.length > 0;

      if (!this.isWrapped) {
        this.wrapper = $('<div class="dropdown-wrapper"></div>').insertAfter(baseElement);
      }

      if (this.isWrapped) {
        this.pseudoElem = this.wrapper.find('.' + pseudoClassString);
        this.trigger = this.wrapper.find('.trigger');
      } else {
        this.pseudoElem = $('div#' + orgId + '-shdo');
      }

      if (elemClassList.contains('text-align-reverse')) {
        pseudoClassString += ' text-align-reverse';
      } else if (elemClassList.contains('text-align-center')) {
        pseudoClassString += ' text-align-center';
      }

      // Build sub-elements if they don't exist
      this.label = $('label[for="' + orgId + '"]');

      if (!this.pseudoElem.length) {
        this.pseudoElem = $('<div class="' + pseudoClassString + '">');
      } else {
        this.pseudoElem[0].setAttribute('class', pseudoClassString);
      }

      if (!this.isWrapped) {
        this.pseudoElem.append($('<span></span>'));
      }
      var toExclude = ['data-validate'];
      var attributes = DOM.getAttributes(this.element[0]);
      var attributesToCopy = this.getDataAttributes(attributes, toExclude);

      this.pseudoElem.attr(attributesToCopy.obj).attr({
        role: 'combobox',
        'aria-autocomplete': 'list',
        'aria-controls': 'dropdown-list',
        'aria-readonly': 'true',
        'aria-expanded': 'false',
        'aria-label': this.label.text()
      });

      // Pass disabled/readonly from the original element, if applicable
      // "disabled" is a stronger setting than "readonly" - should take precedent.
      function handleStates(self) {
        var disabled = self.element.prop('disabled');
        var readonly = self.element.prop('readonly');

        if (disabled) {
          return self.disable();
        }

        if (readonly) {
          return self.readonly();
        }

        return self.enable();
      }
      handleStates(this);

      if (!this.isWrapped) {
        this.wrapper.append(this.pseudoElem, this.trigger);
      }

      // Check for and add the icon
      this.icon = this.wrapper.find('.icon');
      if (!this.icon.length) {
        this.icon = $.createIconElement('dropdown');
        this.wrapper.append(this.icon);
      }

      // Setup the incoming options that can be set as properties/attributes
      if (this.element.prop('multiple') && !this.settings.multiple) {
        this.settings.multiple = true;
      }
      if (this.settings.multiple && !this.element.prop('multiple')) {
        this.element.prop('multiple', true);
      }

      // Add the internal hash for typeahead filtering, if applicable
      if (this.settings.reload === 'typeahead') {
        this.selectedValues = [];
      } else {
        delete this.selectedValues;
      }

      var dataSource = this.element.attr('data-source');
      if (dataSource && dataSource !== 'source') {
        this.settings.source = dataSource;
      }
      var dataMaxselected = this.element.attr('data-maxselected');
      if (dataMaxselected && !isNaN(dataMaxselected)) {
        //eslint-disable-line
        this.settings.maxSelected = parseInt(dataMaxselected, 10);
      }

      // TODO: deprecate "moveSelectedToTop" in favor of "moveSelected"
      // _getMoveSelectedSetting()_ converts the old setting to the new text type.
      function getMoveSelectedSetting(incomingSetting, useText) {
        switch (incomingSetting) {
          case useText ? 'true' : true:
            return 'all';
          case useText ? 'false' : false:
            return 'none';
          default:
            if (moveSelectedOpts.indexOf(incomingSetting) > -1) {
              return incomingSetting;
            }
            return 'none';
        }
      }

      // Backwards compatibility for deprecated "moveSelectedToTop" setting.
      if (this.settings.moveSelectedToTop !== undefined) {
        this.settings.moveSelected = this.settings.moveSelectedToTop;
      }

      var dataMoveSelected = this.element.attr('data-move-selected');
      if (dataMoveSelected) {
        this.settings.moveSelected = getMoveSelectedSetting(dataMoveSelected, true);
      } else {
        this.settings.moveSelected = getMoveSelectedSetting(this.settings.moveSelected);
      }

      // Backwards compatibility with `settings.reloadSourceOnOpen`
      if (this.settings.reloadSourceOnOpen) {
        this.settings.reload = 'open';
        delete this.settings.reloadSourceOnOpen;
      }

      var dataCloseOnSelect = this.element.attr('data-close-on-select');
      if (dataCloseOnSelect && !this.settings.closeOnSelect) {
        this.settings.closeOnSelect = dataCloseOnSelect === 'true';
      }
      var dataNoSearch = this.element.attr('data-no-search');
      if (dataNoSearch && !this.settings.noSearch) {
        this.settings.noSearch = dataNoSearch === 'true';
      }

      // Persist sizing defintions
      var sizingStrings = ['-xs', '-sm', '-mm', '-md', '-lg'];
      var classString = this.element.attr('class');
      var s = null;

      for (var i = 0; i < sizingStrings.length; i++) {
        s = sizingStrings[i];
        if (classString.match(s)) {
          this.pseudoElem.addClass('dropdown' + s);
        }
      }

      // Cached dataset (from AJAX, if applicable)
      this.dataset = [];

      this.listfilter = new ListFilter({
        filterMode: this.settings.filterMode
      });

      this.setListIcon();
      this.setDisplayedValues();
      this.setInitial();
      this.setWidth();

      this.tooltipApi = null;
      if (this.pseudoElem.find('span').width() >= this.pseudoElem.width()) {
        this.setTooltip();
      }

      this.element.triggerHandler('rendered');

      return this.handleEvents();
    },


    /**
     * Used for preventing menus from popping open/closed when they shouldn't.
     * Gets around the need for timeouts everywhere
     * @private
     * @returns {boolean} If the timeout should be cancelled.
      */
    inputTimer: function inputTimer() {
      if (this.inputTimeout) {
        return false;
      }

      var self = this;

      this.inputTimeout = setTimeout(function () {
        clearTimeout(self.inputTimeout);
        self.inputTimeout = null;
      }, 100);

      return true;
    },


    /**
     * Set Width on the field
     * @private
     */
    setWidth: function setWidth() {
      var style = this.element[0].style;

      if (style.width) {
        this.pseudoElem[0].style.width = style.width;
      }
      if (style.position === 'absolute') {
        this.pseudoElem[0].style.position = 'absolute';
        this.pseudoElem[0].style.left = style.left;
        this.pseudoElem[0].style.top = style.top;
        this.pseudoElem[0].style.bottom = style.bottom;
        this.pseudoElem[0].style.right = style.right;
      }
    },


    /**
     * Set list item icon
     * @private
     * @param  {object} listIconItem The icon info to use on the list.
     */
    setItemIcon: function setItemIcon(listIconItem) {
      var self = this;
      var specColor = null;

      if (!listIconItem.icon) {
        listIconItem.isIcon = false;
        listIconItem.html = '';
        self.listIcon.items.push(listIconItem);
        return;
      }

      // Set icon properties
      if (_typeof(listIconItem.icon) === 'object') {
        listIconItem.obj = listIconItem.icon;
        listIconItem.icon = listIconItem.icon.icon;

        // Color
        if (listIconItem.obj.color) {
          specColor = listIconItem.obj.color.indexOf('#') === 0;
          if (specColor) {
            listIconItem.specColor = listIconItem.obj.color;
          } else {
            listIconItem.classList = ' ' + listIconItem.obj.color;
          }
        } else if (listIconItem.obj.class) {
          specColor = listIconItem.obj.class.indexOf('#') === 0;
          if (specColor) {
            listIconItem.specColor = listIconItem.obj.class;
          } else {
            listIconItem.classList = ' ' + listIconItem.obj.class;
          }
        }

        // Color Over
        if (listIconItem.obj.colorOver) {
          specColor = listIconItem.obj.colorOver.indexOf('#') === 0;
          if (specColor) {
            listIconItem.specColorOver = listIconItem.obj.colorOver;
          } else {
            listIconItem.classListOver = ' ' + listIconItem.obj.colorOver;
          }
        } else if (listIconItem.obj.classOver) {
          specColor = listIconItem.obj.classOver.indexOf('#') === 0;
          if (specColor) {
            listIconItem.specColorOver = listIconItem.obj.classOver;
          } else {
            listIconItem.classListOver = ' ' + listIconItem.obj.classOver;
          }
        }
      }

      // Set flags
      listIconItem.isIcon = listIconItem.icon && listIconItem.icon.length;

      if (listIconItem.classList && listIconItem.classList.length) {
        listIconItem.isClassList = true;
      }
      if (listIconItem.classListOver && listIconItem.classListOver.length) {
        listIconItem.isClassListOver = true;
      }

      // Build icon
      listIconItem.html = $.createIcon({
        icon: listIconItem.isIcon ? listIconItem.icon : '',
        class: 'listoption-icon' + (listIconItem.isClassList ? ' ' + listIconItem.classList : '')
      });

      self.listIcon.items.push(listIconItem);
    },


    /**
     * Set all icons on the list.
     * @private
     */
    setListIcon: function setListIcon() {
      var self = this;
      var hasIcons = self.settings.multiple ? false : self.element.find('[data-icon]').length > 0;
      var opts = hasIcons ? this.element.find('option') : [];

      self.listIcon = { hasIcons: hasIcons, items: [] };

      if (hasIcons) {
        var count = 0;

        opts.each(function (i) {
          var iconAttr = $(this).attr('data-icon');
          var icon = null;

          if (typeof iconAttr !== 'string' || !iconAttr.length) {
            return;
          }

          if (iconAttr.indexOf('{') !== 0) {
            icon = iconAttr;
          } else {
            icon = $.fn.parseOptions(this, 'data-icon');
          }
          self.setItemIcon({ html: '', icon: icon });

          if (self.listIcon.items[i] && self.listIcon.items[i].isIcon) {
            count++;
          }
        });

        hasIcons = count > 0;
      }

      if (hasIcons) {
        self.pseudoElem.prepend($.createIcon({ icon: '', class: 'listoption-icon' }));
        self.listIcon.pseudoElemIcon = self.pseudoElem.find('> .listoption-icon');
        self.listIcon.idx = -1;
      }

      self.listIcon.hasIcons = hasIcons;
    },


    /**
     * Triggers tooltip in multiselect
     */
    setTooltip: function setTooltip() {
      var opts = this.element.find('option:selected');
      var optText = this.getOptionText(opts);
      this.tooltipApi = this.pseudoElem.find('span').tooltip({
        content: optText,
        trigger: 'hover'
      });
    },


    /**
     * Set over color for list item icon,
     * if run without pram {target}, it will make on only
     * @private
     * @param  {object} target The dom target.
     */
    setItemIconOverColor: function setItemIconOverColor(target) {
      var self = this;
      if (self.listIcon.hasIcons) {
        var targetIcon = target ? target.find('.listoption-icon') : null;
        self.list.find('li').each(function (i) {
          var li = $(this);
          var icon = li.find('.listoption-icon');
          var iconRef = self.listIcon.items[i];

          if (!iconRef) {
            return;
          }

          // make it on
          if (li.is('.is-focused')) {
            if (iconRef.isClassListOver) {
              icon.removeClass(iconRef.classListOver).addClass(iconRef.classList);
            }
          }
          // make it over
          if (targetIcon && li.is(target)) {
            if (iconRef.isClassListOver) {
              targetIcon.removeClass(iconRef.classList);
              targetIcon.addClass(iconRef.classListOver);
            }
          }
        });
      }
    },


    /**
     * Update the icon.
     * @private
     * @param {object} opt The dom target.
     */
    updateItemIcon: function updateItemIcon(opt) {
      var self = this;
      if (self.listIcon.hasIcons) {
        var target = self.listIcon.pseudoElemIcon;
        var i = opt.index();
        var idx = self.listIcon.idx;
        var iconRef = self.listIcon.items[i];
        var icon = iconRef && iconRef.isIcon ? iconRef.icon : '';

        // Return out if this item has no icon
        if (!iconRef) {
          return;
        }

        // Reset class and color
        if (idx > -1) {
          var iconAtIndex = self.listIcon.items[idx];
          if (iconAtIndex) {
            target.removeClass(iconAtIndex.classList + ' ' + iconAtIndex.classListOver);
            target[0].style.fill = '';
          }
        }

        // Update new stuff
        self.listIcon.idx = i;
        target.changeIcon(icon);
        if (iconRef.isClassList) {
          target.addClass(iconRef.classList);
        }
      }
    },


    /**
     * Update the visible list object.
     * @param {string} [term = undefined] an optional search term that will cause highlighting of text
     * @private
     */
    updateList: function updateList(term) {
      var self = this;
      var isMobile = self.isMobile();
      var listExists = self.list !== undefined && self.list !== null && self.list.length > 0;
      var listContents = '';
      var ulContents = '';
      var upTopOpts = 0;
      var hasOptGroups = this.element.find('optgroup').length;
      var reverseText = '';
      var isMultiselect = this.settings.multiple === true;
      var moveSelected = '' + this.settings.moveSelected;
      var showSelectAll = this.settings.showSelectAll === true;

      if (this.element[0].classList.contains('text-align-reverse')) {
        reverseText = ' text-align-reverse';
      } else if (this.element[0].classList.contains('text-align-center')) {
        reverseText = ' text-align-center';
      }

      if (!listExists) {
        listContents = '<div class="dropdown-list' + reverseText + (isMobile ? ' mobile' : '') + (this.settings.multiple ? ' multiple' : '') + '" id="dropdown-list" role="application" ' + (this.settings.multiple ? 'aria-multiselectable="true"' : '') + '>' + ('<label for="dropdown-search" class="audible">' + Locale.translate('Search') + '</label>') + ('<input type="text" class="dropdown-search' + reverseText + '" role="combobox" aria-expanded="true" id="dropdown-search" aria-autocomplete="list">') + ('<span class="trigger">' + (isMobile ? $.createIcon({ icon: 'close', classes: ['close'] }) : $.createIcon('dropdown')) + '<span class="audible">' + (isMobile ? Locale.translate('Close') : Locale.translate('Collapse')) + '</span>') + '</span>' + '<ul role="listbox">';
      }

      // Get a current list of <option> elements
      // If none are available, simply return out
      var opts = this.element.find('option');
      var groups = this.element.find('optgroup');
      var selectedFilterMethod = ':selected';
      var groupsSelectedOpts = [];

      // For typeahead reloading, the <option> tags are not used for determining what's already
      // selected.  Use the internal storage of selected values instead.
      if (this.settings.reload === 'typeahead') {
        selectedFilterMethod = function selectedFilterMethod(i, opt) {
          if (!self.selectedValues) {
            return false;
          }
          return self.selectedValues.indexOf(opt.value) > -1;
        };
      }

      var selectedOpts = opts.filter(selectedFilterMethod);

      // Re-inforce typeahead-reloaded options' `selected` properties
      if (this.settings.reload === 'typeahead') {
        selectedOpts.prop('selected', true);
      }

      function buildLiHeader(textContent) {
        return '<li role="presentation" class="group-label" focusable="false">\n        ' + textContent + '\n      </li>';
      }

      function buildLiOption(option, index) {
        var liMarkup = '';
        var text = option.innerHTML;
        var attributes = DOM.getAttributes(option);
        var value = attributes.getNamedItem('value');
        var title = attributes.getNamedItem('title');
        var hasTitle = title ? '" title="' + title.value + '"' : '';
        var badge = attributes.getNamedItem('data-badge');
        var badgeColor = attributes.getNamedItem('data-badge-color');
        var badgeHtml = '';
        var isSelected = option.selected ? ' is-selected' : '';
        var isDisabled = option.disabled ? ' is-disabled' : '';
        var liCssClasses = option.className ? ' ' + option.className.value : '';
        var aCssClasses = liCssClasses.indexOf('clear') > -1 ? ' class="clear-selection"' : '';
        var tabIndex = ' tabIndex="' + (index && index === 0 ? 0 : -1) + '"';
        var toExclude = ['data-badge', 'data-badge-color', 'data-val', 'data-icon'];
        var copiedDataAttrs = ' ' + self.getDataAttributes(attributes, toExclude).str;
        var trueValue = (value && 'value' in value ? value.value : text).replace(/"/g, '/quot/');
        var iconHtml = '';

        if (self.listIcon.hasIcons && self.listIcon.items[index]) {
          iconHtml = self.listIcon.items[index].html;
        }

        if (badge) {
          badgeHtml = '<span class="badge ' + (badgeColor ? badgeColor.value : 'azure07') + '">' + badge.value + '</span>';
        }

        if (liCssClasses.indexOf('clear') > -1 && text === '') {
          text = Locale.translate('ClearSelection');
        }

        // Highlight search term
        if (term && term.length > 0) {
          var exp = self.getSearchRegex(term);
          text = text.replace(exp, '<i>$1</i>').trim();
        }

        liMarkup += '<li class="dropdown-option' + isSelected + isDisabled + liCssClasses + '" data-val="' + trueValue + '" ' + copiedDataAttrs + tabIndex + hasTitle + ' role="presentation">\n        <a id="list-option-' + index + '" href="#" ' + aCssClasses + ' role="option">' + iconHtml + text + badgeHtml + '</a></li>';

        return liMarkup;
      }

      // In multiselect scenarios, shows an option at the top of the list that will
      // select all available options if checked.
      if (isMultiselect && showSelectAll) {
        var allSelected = opts.not('[disabled], .hidden').length === selectedOpts.not('[disabled], .hidden').length;

        ulContents += '<li role="presentation" class="dropdown-select-all-list-item' + (allSelected ? ' is-selected' : '') + '">' + ('<a role="option" href="#" id="dropdown-select-all-anchor" class="dropdown-select-all-anchor">' + Locale.translate('SelectAll') + '</a>') + '</li>';
      }

      // Move selected options in each group to just underneath their corresponding group headers.
      if (moveSelected === 'group') {
        // If no optgroups exist, change to "all" and skip this part.
        if (!groups || !groups.length) {
          moveSelected = 'all';
        } else {
          // Break apart selectedOpts into groups.
          // These selected items are applied when the header is generated.
          groups.each(function (i, g) {
            var els = selectedOpts.filter(function () {
              return $.contains(g, this);
            });
            groupsSelectedOpts.push(els);
          });
        }
      }

      // Move all selected options to the top of the list if the setting is true.
      // Also adds a group heading if other option groups are found in the <select> element.
      if (moveSelected === 'all') {
        opts = opts.not(selectedOpts);

        // Show a "selected" header if there are selected options
        if (selectedOpts.length > 0) {
          ulContents += buildLiHeader(Locale.translate('Selected') + ' ' + (self.isInlineLabel ? self.inlineLabelText.text() : this.label.text()));
        }

        selectedOpts.each(function (i) {
          ulContents += buildLiOption(this, i);
          upTopOpts++;
        });

        // Only show the "all" header beneath the selected options if there
        // are no other optgroups present
        if (!hasOptGroups && opts.length > 0) {
          ulContents += buildLiHeader(Locale.translate('All') + ' ' + (self.isInlineLabel ? self.inlineLabelText.text() : this.label.text()));
        }
      }

      opts.each(function (i) {
        var count = i + upTopOpts;
        var option = $(this);
        var parent = option.parent();
        var optgroupIsNotDrawn = void 0;
        var optgroupIndex = void 0;

        // Add Group Header if this is an <optgroup>
        // Remove the group header from the queue.
        if (parent.is('optgroup') && groups.length) {
          optgroupIndex = parent.index();
          optgroupIsNotDrawn = groups.index(parent) > -1;

          if (optgroupIsNotDrawn) {
            groups = groups.not(parent);
            ulContents += buildLiHeader('' + parent.attr('label'));

            // Add all selected items for this group
            if (moveSelected === 'group') {
              groupsSelectedOpts[optgroupIndex].each(function (j) {
                ulContents += buildLiOption(this, j);
                upTopOpts++;
              });
            }
          }
        }

        if (moveSelected !== 'none' && option.is(':selected')) {
          return;
        }

        ulContents += buildLiOption(this, count);
      });

      // Render the new list contents to the page.
      // Build the entire thing and set references if this is the first opening.
      // Otherwise, simply replace the elements inside the <ul>.
      if (!listExists) {
        listContents += ulContents + '</ul>' + '</div>';

        // Append markup to the DOM
        this.list = $(listContents);

        // Get references
        this.listUl = this.list.find('ul');
        this.searchInput = this.list.find('#dropdown-search');
      } else {
        this.listUl.html(ulContents);
      }

      if (this.listIcon.hasIcons) {
        this.list.addClass('has-icons');
        this.listIcon.pseudoElemIcon.clone().appendTo(this.list);
      }

      if (hasOptGroups) {
        this.listUl.addClass('has-groups');
      }

      if ($.fn.tooltip) {
        this.listUl.find('[title]').addClass('has-tooltip').tooltip();
      }

      this.position();

      if (this.isOpen()) {
        this.highlightOption(this.listUl.find('li:visible:not(.separator):not(.group-label):not(.is-disabled)').first());
      }
    },


    /**
     * Sets the displayed value of the Pseudo-Element based on currently-selected options.
     * @private
     */
    setDisplayedValues: function setDisplayedValues() {
      var opts = this.element.find('option:selected');
      var text = this.getOptionText(opts);

      if (opts.hasClass('clear')) {
        text = '';
      }

      if (this.settings.empty && opts.length === 0) {
        this.pseudoElem.find('span').text('');
        return;
      }

      // Displays the text on the pseudo-element
      var maxlength = this.element.attr('maxlength');
      if (maxlength) {
        text = text.substr(0, maxlength);
      }
      text = text.trim();
      this.pseudoElem.find('span').text(text);

      // Set the "previousActiveDescendant" to the first of the items
      this.previousActiveDescendant = opts.first().val();

      this.updateItemIcon(opts);
      this.setBadge(opts);
    },


    /**
     * Copy classes from the two objects
     * @private
     * @param  {object} from The from element
     * @param  {object} to  The to element
     * @param  {string} prop The property to set
     */
    copyClass: function copyClass(from, to, prop) {
      if (from.hasClass(prop)) {
        to.addClass(prop);
      }
    },


    /**
     * Copy initial stuff from the drop down to the pseudo element.
     * @private
     */
    setInitial: function setInitial() {
      if (this.element.is(':disabled')) {
        this.disable();
      }
      if (this.element.is('[readonly]')) {
        this.readonly();
      }
      if (this.isHidden) {
        this.pseudoElem.hide().prev('label').hide();
        this.pseudoElem.next('svg').hide();
      }

      // set placeholder text on pseudoElem span element
      if (this.element.attr('placeholder')) {
        this.pseudoElem.find('span').attr('data-placeholder-text', this.element.attr('placeholder'));
      }
    },


    /**
     * Figure out which keys to ignore on typehead.
     * @private
     * @param  {element} input The input element.
     * @param  {object} e  The event.
     * @returns {boolean} False if the key should be ignored.
     */
    ignoreKeys: function ignoreKeys(input, e) {
      var charCode = e.which;

      // Needed for browsers that use keypress events to manipulate the window.
      if (e.altKey && (charCode === 38 || charCode === 40)) {
        e.stopPropagation();
        e.preventDefault();
        return false;
      }

      if (input.is(':disabled') || input.hasClass('is-readonly')) {
        return; // eslint-disable-line
      }

      if (e.ctrlKey) {
        if (this.settings.onKeyDown) {
          var ret = this.settings.onKeyDown(e);
          if (ret === false) {
            e.stopPropagation();
            e.preventDefault();
            return false;
          }
        }
      }

      return true;
    },


    /**
     * Handle events while search is focus'd
     * @private
     * @returns {void}
     */
    handleSearchEvents: function handleSearchEvents() {
      var _this = this;

      if (this.settings.noSearch) {
        this.searchInput.prop('readonly', true);
      }

      // Used to determine how spacebar should function.
      // False means space will select/deselect.  True means
      // Space will add a space inside the search input.
      if (!this.filterTerm) {
        this.searchKeyMode = false;
      }

      this.searchInput.on('keydown.' + COMPONENT_NAME$y, function (e) {
        var searchInput = $(_this);
        if (!_this.ignoreKeys(searchInput, e)) {
          return false;
        }

        return _this.handleKeyDown(searchInput, e);
      }).on('input.' + COMPONENT_NAME$y, function (e) {
        _this.isFiltering = true;
        _this.handleAutoComplete(e);
      });
    },


    /**
     * Filter the list elements by term.
     * @private
     * @param  {string} term The search term
     */
    filterList: function filterList(term) {
      var typeahead = false;
      // 'typeahead' reloading skips client-side filtering in favor of server-side
      if (this.settings.source && this.settings.reload === 'typeahead') {
        typeahead = true;
        this.callSource();
      }

      var self = this;
      var selected = false;
      var list = $('.dropdown-option', this.listUl);
      var headers = $('.group-label', this.listUl);
      var hasIcons = false;
      var results = void 0;

      if (!list.length || !this.list || this.list && !this.list.length) {
        return;
      }

      if (!term) {
        term = '';
      }

      if (!typeahead && term && term.length) {
        results = this.listfilter.filter(list, term);
      } else {
        results = list;
      }

      this.list.addClass('search-mode');
      this.list.find('.trigger').find('.icon').attr('class', 'icon search').changeIcon('search');
      this.searchInput.removeAttr('aria-activedescendant');

      this.unhighlightOptions();

      if (!results || !results.length && !term) {
        this.resetList();
        return;
      }

      results.removeClass('hidden');
      list.not(results).add(headers).addClass('hidden');
      list.filter(results).each(function (i) {
        var li = $(this);
        li.attr('tabindex', i === 0 ? '0' : '-1');

        if (!selected) {
          self.highlightOption(li);
          selected = true;
        }

        // Highlight Term
        var exp = self.getSearchRegex(term);
        var text = li.text().replace(exp, '<i>$1</i>').trim();
        var icon = li.children('a').find('svg').length !== 0 ? new XMLSerializer().serializeToString(li.children('a').find('svg')[0]) : '';

        if (icon) {
          hasIcons = true;
        }

        li.children('a').html(icon + text);
      });

      headers.each(function () {
        var children = $(this).nextUntil('.group-label, .selector').not('.hidden');
        if (self.settings.showEmptyGroupHeaders || children.length) {
          $(this).removeClass('hidden');
        }
      });

      term = '';
      this.position();

      if (hasIcons && this.list.find('svg').length > 2) {
        this.list.find('svg').last().changeIcon('icon-empty-circle');
      }
    },


    /**
     * Removes filtering from an open Dropdown list and turns off "search mode"
     * @private
     */
    resetList: function resetList() {
      // 'typeahead' reloading skips client-side filtering in favor of server-side
      if (this.settings.source && this.settings.reload === 'typeahead') {
        this.filterTerm = '';
        this.searchKeyMode = false;
        this.callSource(null, true);
        return;
      }

      if (!this.list || this.list && !this.list.length) {
        return;
      }

      this.list.removeClass('search-mode');
      var lis = this.listUl.find('li');
      var hasIcons = false;
      lis.removeAttr('style').each(function () {
        var a = $(this).children('a');
        var li = $(this);

        var text = a.text();
        var icon = li.children('a').find('svg').length !== 0 ? new XMLSerializer().serializeToString(li.children('a').find('svg')[0]) : '';

        if (icon) {
          hasIcons = true;
        }

        a.html(icon + text);
      });

      // Adjust height / top position
      if (this.list.hasClass('is-ontop')) {
        this.list[0].style.top = this.pseudoElem.offset().top - this.list.height() + this.pseudoElem.outerHeight() - 2 + 'px';
      }

      if (this.settings.multiple) {
        this.updateList();
      }

      lis.removeClass('hidden');
      this.position();

      if (hasIcons && this.list.find('svg').length > 2) {
        this.list.find('svg').last().changeIcon('icon-empty-circle');
      }

      if (this.list.find('svg').length === 2) {
        this.list.find('svg').last().remove();
      }
    },


    /**
     * Select the blank item (if present)
     * @private
     */
    selectBlank: function selectBlank() {
      var blank = this.element.find('option').filter(function () {
        return !this.value || $.trim(this.value).length === 0;
      });

      if (!blank.length) {
        return;
      }

      // TODO: Refactor this in v4.9.0 to call `selectOption` instead.  Can't currently
      // do that because `selectOption` depends on the list being open.
      blank[0].selected = true;
      blank[0].setAttribute('selected', true);
      this.element.triggerHandler('updated');
      this.element.triggerHandler('change');
    },


    /**
     * Handle the key down event actions.
     * @private
     * @param  {object} input The dom element.
     * @param  {object} e The event element.
     * @returns {boolean} Returns the event in some situations.
     */
    handleKeyDown: function handleKeyDown(input, e) {
      var selectedIndex = this.element[0].selectedIndex || -1;
      var options = this.element[0].options;
      var key = e.which;
      var self = this;
      var excludes = 'li:visible:not(.separator):not(.group-label):not(.is-disabled)';
      var next = void 0;

      if (this.isLoading()) {
        return;
      }

      if (self.settings.onKeyDown) {
        var ret = self.settings.onKeyDown(e);
        if (ret === false) {
          e.stopPropagation();
          e.preventDefault();
          return false; //eslint-disable-line
        }
      }

      if (self.isOpen()) {
        options = this.listUl.find(excludes);
        selectedIndex = -1;
        $(options).each(function (index) {
          if ($(this).is('.is-focused')) {
            selectedIndex = index;
          }
        });
      }

      switch (key) {//eslint-disable-line
        case 37: // backspace
        case 8: // del & backspace
        case 46:
          {
            // del
            if (!self.isOpen()) {
              self.selectBlank();
              // Prevent Backspace from returning to the previous page.
              e.stopPropagation();
              e.preventDefault();
              return false; //eslint-disable-line
            }
            break;
          }
        case 9:
          {
            // tab - save the current selection
            // If "search mode" is currently off, Tab should turn this mode on and place focus back
            // into the SearchInput.
            // If search mode is on, Tab should 'select' the currently highlighted
            // option in the list, update the SearchInput and close the list.
            if (self.isOpen()) {
              self.closeList('tab');
              this.activate();
            }
            // allow tab to propagate otherwise
            return true; //eslint-disable-line
          }
        case 27:
          {
            // Esc - Close the Combo and Do not change value
            if (self.isOpen()) {
              // Close the option list
              self.element.closest('.modal.is-visible').data('listclosed', true);
              var tdContainer = self.pseudoElem ? self.pseudoElem.parents('td') : null;
              self.closeList('cancel');
              self.activate();

              if (tdContainer) {
                tdContainer.focus();
              }

              e.stopPropagation();
              return false; //eslint-disable-line
            }
            // Allow Esc to propagate if the menu was closed, since some other Controls
            // that rely on dropdown may need to trigger routines when the Esc key is pressed.
            break;
          }
        case 32: // Spacebar
        case 13:
          {
            // enter
            if (self.isOpen()) {
              if (key === 32 && self.searchKeyMode === true) {
                break;
              }

              e.preventDefault();

              if (options.length && selectedIndex > -1) {
                self.selectOption($(options[selectedIndex])); // store the current selection
              }

              if (self.settings.closeOnSelect) {
                self.closeList('select'); // Close the option list
                self.activate();
              }
            }
            e.stopPropagation();
            return false; //eslint-disable-line
          }
        case 38:
          {
            // up
            if (e.shiftKey) {
              return;
            }
            this.searchKeyMode = false;

            if (selectedIndex > 0) {
              next = $(options[selectedIndex - 1]);
              this.highlightOption(next);
              self.setItemIconOverColor(next);
              // NOTE: Do not also remove the ".is-selected" class here!
              // It's not the same as ".is-focused"!
              // Talk to ed coyle if you need to know why.
              next.parent().find('.is-focused').removeClass('is-focused');
              next.addClass('is-focused');
            }

            e.stopPropagation();
            e.preventDefault();
            return false; //eslint-disable-line
          }
        case 40:
          {
            // down
            if (e.shiftKey) {
              return;
            }
            this.searchKeyMode = false;

            if (selectedIndex < options.length - 1) {
              next = $(options[selectedIndex + 1]);
              this.highlightOption(next);
              self.setItemIconOverColor(next);
              // NOTE: Do not also remove the ".is-selected" class here!
              //  It's not the same as ".is-focused"!
              // Talk to ed coyle if you need to know why.
              next.parent().find('.is-focused').removeClass('is-focused');
              next.addClass('is-focused');
            }

            e.stopPropagation();
            e.preventDefault();
            return false; //eslint-disable-line
          }
        case 35:
          {
            // end
            this.searchKeyMode = false;

            var last = $(options[options.length - 1]);
            this.highlightOption(last);

            e.stopPropagation();
            return false; //eslint-disable-line
          }
        case 36:
          {
            // home
            this.searchKeyMode = false;

            var first = $(options[0]);
            this.highlightOption(first);

            e.stopPropagation();
            return false; //eslint-disable-line
          }
      }

      if (!self.isOpen() && !self.isControl(key) && !this.settings.source && !this.settings.noSearch) {
        // Make this into Auto Complete
        self.isFiltering = true;
        self.filterTerm = $.actualChar(e);

        if (self.searchInput && self.searchInput.length) {
          self.searchInput.val($.actualChar(e));
        }
        self.toggleList();
      }

      this.searchKeyMode = true;
      if (self.searchInput) {
        self.searchInput.attr('aria-activedescendant', '');
      }
      return true; // eslint-disable-line
    },


    /**
     * @private
     * @param {jQuery.Event} e incoming keydown event
     * @returns {boolean} whether or not the keydown event is allowed to continue
     */
    handlePseudoElemKeydown: function handlePseudoElemKeydown(e) {
      var target = $(e.target);
      var key = e.key;

      // "Esc" is used by IE11
      var isEscapeKey = key === 'Esc' || key === 'Escape';

      // Control Keydowns are ignored
      var controlKeys = ['Alt', 'Shift', 'Control', 'Meta'];
      if (controlKeys.indexOf(key) > -1) {
        return false;
      }

      if (!this.ignoreKeys(target, e)) {
        return false;
      }

      // Down arrow opens the list.
      // Down/Up are for IE/Edge.
      // ArrowDown/ArrowUp are for all others.
      var openKeys = ['ArrowDown', 'ArrowUp', 'Down', 'Up', 'Enter', 'Spacebar', ' '];
      if (openKeys.indexOf(key) > -1) {
        if (!this.isOpen()) {
          this.open();
        }

        // TODO: refactor this out so that `handleKeyDown` is no longer necessary.
        // This is necessary here because in `noSearch` mode, there is no actionable searchInput.
        if (this.settings.noSearch && !e.ctrlKey) {
          this.handleKeyDown(target, e);
        }

        return false;
      }

      // Mac OSX: "backspace" delete key
      // Everything else: DEL key (numpad, control keys)
      var isOSX = Environment.os.name === 'Mac OS X';
      if (!isOSX && key === 'Delete' || isOSX && key === 'Backspace') {
        this.selectBlank();

        // Stop the backspace key from navigating back a page
        if (key === 'Backspace') {
          e.stopPropagation();
          e.preventDefault();
        }
        return true;
      }

      // In nosearch mode, bypass the typeahead autocomplete and pass keydown events
      // along to the list elements
      if (this.settings.noSearch && isEscapeKey) {
        if (this.isOpen()) {
          return this.handleKeyDown(target, e);
        }
      }

      // Allow some keys to pass through with no changes in functionality
      if (isEscapeKey || key === 'Tab') {
        return true;
      }

      // handle `onKeyDown` callback
      if (this.settings.onKeyDown) {
        var ret = this.settings.onKeyDown(e);
        if (ret === false) {
          e.stopPropagation();
          e.preventDefault();
          return false; //eslint-disable-line
        }
      }

      this.handleAutoComplete(e);
      return true;
    },


    /**
     * Handle the typeahead.
     * @private
     * @param {object} e The event object
     */
    handleAutoComplete: function handleAutoComplete(e) {
      var _this2 = this;

      if (this.isLoading()) {
        return;
      }

      var self = this;
      if (this.timer) {
        clearTimeout(this.timer);
      }

      if (e.type === 'input') {
        this.filterTerm = this.searchInput.val();
      } else {
        this.filterTerm += $.actualChar(e);
        if (e.key !== this.filterTerm && e.key.toLowerCase() === this.filterTerm) {
          this.filterTerm = e.key;
        }
      }

      // if called by `open()`, runs in the context of this Dropdown's API
      function filter() {
        if (self.filterTerm === '') {
          self.resetList();
        } else {
          self.filterList(self.filterTerm.toLowerCase());
        }
      }

      this.timer = setTimeout(function () {
        if (self.settings.noSearch) {
          self.selectStartsWith(self.filterTerm);
          return;
        }

        _this2.searchKeyMode = true;
        if (!self.isOpen()) {
          self.open(filter);
          return;
        }

        filter();
      }, self.settings.delay);
    },


    /**
     * Determine if the key is a control key
     * @private
     * @param  {number} keycode The keycode to check.
     * @returns {boolean} true if the key is a control key.
     */
    isControl: function isControl(keycode) {
      var valid = keycode > 7 && keycode < 48 || // control chars
      keycode > 90 && keycode < 94 || // windows keys
      keycode > 111 && keycode < 146; // function keys

      return valid;
    },


    /**
     * Focus the input element. Since the select is hidden this is needed over normal focus()
     * @private
     * @param  {boolean} [useSearchInput] If true the search is used.
     * @param {boolean} [noFocus] if true, does not attempt to focus the input
     * @returns {void}
     */
    activate: function activate(useSearchInput) {
      var self = this;
      var input = this.pseudoElem;

      if (useSearchInput || self.isMobile()) {
        input = this.searchInput;
      }

      if (useSearchInput && (input.hasClass('is-readonly') || input.prop('readonly') === true)) {
        return;
      }

      function selectText() {
        if (self.isMobile() || self.filterTerm) {
          return;
        }

        if (input[0].setSelectionRange) {
          input[0].setSelectionRange(0, input[0].value.length); // scroll to left
        } else if (input[0].tagName === 'INPUT') {
          // using Search Input instead of Pseudo Div
          input[0].select();
        }
      }

      selectText();

      // Set focus back to the element
      if (Environment.browser.isIE10() || Environment.browser.isIE11()) {
        setTimeout(function () {
          input[0].focus();
        }, 0);
      } else {
        input[0].focus();
      }
    },


    /**
     * @private
     * @param {string} term incoming search term
     * @returns {RegExp} a valid regex object used to filter search results
     */
    getSearchRegex: function getSearchRegex(term) {
      var regex = void 0;

      try {
        regex = new RegExp('(' + term + ')', 'i');
      } catch (e) {
        // create a "matches all" regex if we can't create a regex from the search term
        regex = /[\s\S]*/i;
      }

      return regex;
    },


    /**
     * Retrieves a string containing all text for currently selected options.
     * @private
     * @param  {array} opts The current option elements.
     * @returns {string} The selection options in a string  delimited by commas.
     */
    getOptionText: function getOptionText(opts) {
      var text = '';

      if (!opts) {
        opts = this.element.find('option:selected');
      }

      opts.each(function () {
        if (text.length > 0) {
          text += ', ';
        }
        text += $(this).text().trim();
      });

      return text;
    },


    /**
     * Open the dropdown list of options
     * @param {function} callback additional items that can be run after the opening process completes
     * @returns {void}
     */
    open: function open(callback) {
      var self = this;

      if (!this.inputTimer()) {
        return;
      }

      if (this.element.is(':disabled') || this.pseudoElem.hasClass('is-disabled') || this.pseudoElem.hasClass('is-readonly')) {
        return;
      }

      function completeOpen() {
        self.updateList();
        self.openList();

        if (callback && typeof callback === 'function') {
          callback.call(this);
        }
      }

      if (!self.callSource(completeOpen)) {
        completeOpen();
      }
    },


    /**
     * Popup the list of options for selection.
     * @private
     */
    openList: function openList() {
      var current = this.previousActiveDescendant ? this.list.find('.dropdown-option[data-val="' + this.previousActiveDescendant.replace(/"/g, '/quot/') + '"]') : this.list.find('.is-selected');
      var self = this;
      var threshold = 10;
      var isEmpty = true;
      var pos = void 0;

      this.touchPrevented = false;

      if (current.length > 0) {
        isEmpty = true;
      }

      if (Environment.os.name === 'ios') {
        $('head').triggerHandler('disable-zoom');
      }

      // Close any other drop downs.
      $('select').each(function () {
        var data = $(this).data();
        if (data.dropdown) {
          data.dropdown.closeList('cancel');
        }
      });

      // Close any open popup menus
      var otherMenus = $('.popupmenu.is-open').filter(function () {
        return $(this).parents('.popupmenu').length === 0;
      }); // close others.

      otherMenus.each(function () {
        var trigger = $(this).data('trigger');
        if (!trigger || !trigger.length) {
          return;
        }

        var api = $(this).data('trigger').data('popupmenu');
        if (api && typeof api.close === 'function') {
          api.close();
        }
      });

      if (!this.isOpen()) {
        this.list.appendTo('body');
      }
      this.list.show();

      // Persist the "short" input field
      var isShort = this.element.closest('.field-short').length === 1;

      this.list.addClass(isShort ? 'dropdown-short' : '');

      this.pseudoElem.attr('aria-expanded', 'true').addClass('is-open');

      this.pseudoElem.attr('aria-label', this.label.text());
      this.searchInput.attr('aria-activedescendant', current.children('a').attr('id'));

      // In a grid cell
      this.isInGrid = this.pseudoElem.closest('.datagrid-row').length === 1;
      if (this.pseudoElem.parent().hasClass('is-inline')) {
        this.isInGrid = false;
      }

      if (this.isInGrid) {
        var rowHeight = this.pseudoElem.closest('.datagrid').attr('class').replace('datagrid', '');
        this.list.addClass('datagrid-dropdown-list ' + rowHeight);
      }

      if (this.pseudoElem.closest('.datagrid-filter-wrapper').length === 1) {
        this.list.addClass('datagrid-filter-dropdown');
      }

      var cssClass = this.settings.cssClass;
      if (cssClass && typeof cssClass === 'string') {
        this.list.addClass(cssClass);
      }

      this.position();

      // Limit the width
      if (this.settings.maxWidth) {
        this.list.css('max-width', this.settings.maxWidth + 'px');
      }

      // Set the contents of the search input.
      // If we've got a stored typeahead
      if (this.filterTerm) {
        this.searchInput.val(this.filterTerm);
      } else {
        this.searchInput.val(this.pseudoElem.find('span').text().trim());
      }

      var noScroll = this.settings.multiple;
      this.highlightOption(current, noScroll);
      if (this.settings.multiple && this.listUl.find('.is-selected').length > 0) {
        this.highlightOption(this.listUl.find('.dropdown-option').eq(0));
        setTimeout(function () {
          self.listUl.scrollTop(0);
        }, 0);
      }

      if (!this.settings.multiple && !isEmpty) {
        this.searchInput.val(current.find('a').text());
      }

      this.handleSearchEvents();
      this.activate(true); // Focus the Search Input

      /**
      *  Fires as the dropdown list is opened.
      *
      * @event listopened
      * @memberof Dropdown
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */
      this.element.trigger('listopened');

      if (this.isMobile()) {
        // iOS-specific keypress event that listens for when you click the "done" button
        self.searchInput.on('keypress.dropdown', function (e) {
          if (e.which === 13) {
            self.closeList('select');
          }
        });
      }

      self.list.removeClass('dropdown-tall').on('touchend.list click.list', 'li', function (e) {
        if (self.touchPrevented) {
          return;
        }

        var itemSelected = self.selectListItem($(this));
        e.preventDefault();
        if (!itemSelected) {
          return;
        }
        e.stopPropagation();
      }).on('mouseenter.list', 'li', function () {
        self.highlightOption($(this), true);
      });

      // Some list-closing events are on a timer to prevent immediate list close
      // There would be several things to check with a setTimeout, so this is done with a CSS
      // class to keep things a bit cleaner
      setTimeout(function () {
        self.list.addClass('is-closable');
      }, 100);

      // Is the jQuery Element a component of the current Dropdown list?
      function isDropdownElement(target) {
        return target.closest('.dropdown, .multiselect').length > 0 || target.closest('.dropdown-list').length > 0 || self.touchmove === true;
      }

      // Triggered when the user scrolls the page.
      // Ignores Scrolling on Mobile, and will not close the list if accessing an item within the list
      function scrollDocument(e) {
        var focus = $('*:focus'); // dont close on timepicker arrow down and up
        if (self.touchPrevented || isDropdownElement($(e.target)) || focus.is('.timepicker')) {
          return;
        }
        self.closeList('cancel');
      }

      // Triggered when the user clicks anywhere in the document
      // Will not close the list if the clicked target is anywhere inside the dropdown list.

      function clickDocument(e) {
        var target = $(e.target);
        if (self.touchPrevented || isDropdownElement(target) && !target.is('.icon')) {
          e.preventDefault();

          self.touchPrevented = false;
          return;
        }

        self.closeList('cancel');
      }

      function touchStartCallback(e) {
        self.touchPrevented = false;

        pos = {
          x: e.originalEvent.touches[0].pageX,
          y: e.originalEvent.touches[0].pageY
        };

        $(document).on('touchmove.dropdown', function (evt) {
          var newPos = {
            x: evt.originalEvent.touches[0].pageX,
            y: evt.originalEvent.touches[0].pageY
          };

          if (newPos.x >= pos.x + threshold || newPos.x <= pos.x - threshold || newPos.y >= pos.y + threshold || newPos.y <= pos.y - threshold) {
            self.touchPrevented = true;
          }
        });
      }

      function touchEndCallback(e) {
        //eslint-disable-line
        $(document).off('touchmove.dropdown');
        e.preventDefault();

        if (self.touchPrevented) {
          e.stopPropagation();
          return false;
        }

        clickDocument(e);
      }

      // Need to detect whether or not scrolling is happening on a touch-capable device
      // The dropdown list should not close on mobile if scrolling is occuring, but should close
      // if the user is simply tapping outside the list.
      $(document).on('touchstart.dropdown', touchStartCallback).on('touchend.dropdown touchcancel.dropdown', touchEndCallback).on('click.dropdown', clickDocument);

      var modalScroll = $('.modal.is-visible .modal-body-wrapper');
      var parentScroll = self.element.closest('.scrollable').length ? self.element.closest('.scrollable') : $(document);
      parentScroll = self.element.closest('.scrollable-y').length ? self.element.closest('.scrollable-y') : parentScroll;
      parentScroll = modalScroll.length ? modalScroll : parentScroll;
      parentScroll.on('scroll.dropdown', scrollDocument);

      $('body').on('resize.dropdown', function () {
        self.position();

        // in desktop environments, close the list on viewport resize
        if (window.orientation === undefined) {
          self.closeList('cancel');
        }
      });

      // In mobile environments, close the list on an orientation change.
      // Don't do this on mobile against a resize because of the software keyboard's potential
      // to cause a "resize" event to fire.
      if (window.orientation !== undefined) {
        $(window).on('orientationchange.dropdown', function () {
          self.closeList('cancel');
        });
      }

      if (Environment.os.name === 'ios') {
        $('head').triggerHandler('enable-zoom');
      }
    },


    /**
     * Set size and positioning of the list
     * @private
     */
    position: function position() {
      var self = this;
      var positionOpts = {
        parentXAlignment: 'left',
        placement: 'bottom',
        strategies: ['flip', 'shrink-y']
      };

      function dropdownAfterPlaceCallback(e, placementObj) {
        // Turn upside-down if flipped to the top of the pseudoElem
        if (placementObj.wasFlipped === true) {
          self.list.addClass('is-ontop');
          self.listUl.prependTo(self.list);
        }

        // Set the <UL> height to 100% of the `.dropdown-list` minus the size of the search input
        var ulHeight = parseInt(window.getComputedStyle(self.listUl[0]).height, 10);
        var listHeight = parseInt(window.getComputedStyle(self.list[0]).height, 10);
        var searchInputHeight = $(this).hasClass('dropdown-short') ? 24 : 34;

        if (ulHeight + searchInputHeight > listHeight) {
          self.listUl[0].style.height = listHeight - searchInputHeight + 'px';
        }

        return placementObj;
      }

      // Reset styles that may have been appended to the list
      this.list[0].removeAttribute('style');
      this.listUl[0].removeAttribute('style');

      var parentElement = this.pseudoElem;
      if (this.isInGrid) {
        parentElement = this.element.closest('.datagrid-cell-wrapper');
      }

      // If the list would end up being wider parent,
      // use the list's width instead of the parent's width
      var parentElementStyle = window.getComputedStyle(parentElement[0]);
      var parentElementBorderWidth = parseInt(parentElementStyle.borderLeftWidth, 10) * 2;
      var parentElementWidth = Math.round(parseInt(parentElement[0].clientWidth, 10) + parentElementBorderWidth);

      // Temporarily shrink the value of the search input, and compare the size of the list to
      // the parent element.
      this.searchInput[0].style.cssText = 'width: ' + parentElementWidth + 'px !important';
      var listDefaultWidth = Math.round(this.list.width());
      var useParentWidth = listDefaultWidth <= parentElementWidth;
      this.searchInput[0].style.width = '';

      // Add parent info to positionOpts
      positionOpts.parent = parentElement;
      positionOpts.useParentWidth = useParentWidth;

      // use negative height of the pseudoElem to get the Dropdown list to overlap the input.
      var isRetina = window.devicePixelRatio > 1;
      var isChrome = Environment.browser.name === 'chrome';

      positionOpts.y = -(parseInt(parentElement[0].clientHeight, 10) + parseInt(parentElementStyle.borderTopWidth, 10) + parseInt(parentElementStyle.borderBottomWidth, 10) - (!isChrome && isRetina ? 1 : 0));
      positionOpts.x = 0;
      if (self.settings.placementOpts && self.settings.placementOpts.x) {
        positionOpts.x = self.settings.placementOpts.x;
      }

      this.list.one('afterplace.dropdown', dropdownAfterPlaceCallback).place(positionOpts);
      this.list.data('place').place(positionOpts);
    },


    /**
     * @param {jQuery[]} target a jQuery-wrapped <option> or <li> tag representing an option.
     * @returns {boolean} whether or not the item was successfully selected.
     */
    selectListItem: function selectListItem(target) {
      var ddOption = target.closest('li');

      if (ddOption.length) {
        target = ddOption;
      }

      if (target.is('.separator, .group-label')) {
        return false;
      }

      if (target.is('.dropdown-select-all-anchor')) {
        target = target.parent();
      }

      // If this is the Select All option, select/deselect all.
      if (this.settings.multiple && target[0].classList.contains('dropdown-select-all-list-item')) {
        var doSelectAll = !target[0].classList.contains('is-selected');
        target[0].classList[doSelectAll ? 'add' : 'remove']('is-selected');
        this.selectAll(doSelectAll);
        return true; //eslint-disable-line
      }

      var val = target.attr('data-val').replace(/"/g, '/quot/');
      var cur = this.element.find('option[value="' + val + '"]');
      // Try matching the option's text if 'cur' comes back empty or overpopulated.
      // Supports options that don't have a 'value' attribute
      // And also some special &quote handling
      if (cur.length === 0 || cur.length > 1) {
        cur = this.element.find('option').filter(function () {
          var elem = $(this);
          var attr = elem.attr('value');
          return elem.text() === val || attr && attr.replace(/"/g, '/quot/') === val;
        });
      }

      if (cur.is(':disabled')) {
        return false; //eslint-disable-line
      }

      this.selectOption(cur);

      if (this.settings.closeOnSelect) {
        this.closeList('select');
      }

      if (this.isMobile()) {
        return true; //eslint-disable-line
      }

      this.activate(!this.settings.closeOnSelect);

      // Check/uncheck select all depending on no. of selected items
      if (this.settings.showSelectAll) {
        var opts = this.element.find('option');
        var selectedOpts = opts.filter(':selected');

        if (opts.length > selectedOpts.length) {
          this.list.find('.dropdown-select-all-list-item').removeClass('is-selected');
        } else {
          this.list.find('.dropdown-select-all-list-item').addClass('is-selected');
        }
      }

      return true; //eslint-disable-line
    },


    /**
    * Close the list of options if open.
    * @returns {void}
    */
    close: function close() {
      return this.closeList('cancel'); // See "js/lifecycle.js"
    },


    /**
     * Close the list of options if open.
     * @private
     * @param  {string} [action] The action that trigger the closing (cancel fx) this
     * is passed to the events.
     * @returns {void}
     */
    closeList: function closeList(action) {
      //  Also see "js/lifecycle.js" alias that works with the global "closeChildren" method.
      if (!this.list || !this.list.is(':visible') || !this.isListClosable()) {
        return;
      }

      if (!this.inputTimer()) {
        return;
      }

      if (this.touchmove) {
        this.touchmove = false;
      }

      // Rendering-related resets
      this.filterTerm = '';
      this.searchKeyMode = false;
      this.setDisplayedValues();

      this.searchInput.off(['input.' + COMPONENT_NAME$y, 'keydown.' + COMPONENT_NAME$y].join(' '));

      // Destroy any tooltip items
      this.listUl.find('.has-tooltip').each(function () {
        var api = $(this).data('tooltip');
        if (api) {
          api.destroy();
        }
      });

      this.list.off(['click.' + COMPONENT_NAME$y, 'touchmove.' + COMPONENT_NAME$y, 'touchend.' + COMPONENT_NAME$y, 'touchcancel.' + COMPONENT_NAME$y, 'mousewheel.' + COMPONENT_NAME$y, 'mouseenter.' + COMPONENT_NAME$y].join(' ')).remove();

      this.pseudoElem.removeClass('is-open').attr('aria-expanded', 'false');

      this.searchInput.removeAttr('aria-activedescendant');

      $(document).off(['click.' + COMPONENT_NAME$y, 'scroll.' + COMPONENT_NAME$y, 'touchmove.' + COMPONENT_NAME$y, 'touchend.' + COMPONENT_NAME$y, 'touchcancel.' + COMPONENT_NAME$y].join(' '));

      $('body').off('resize.dropdown');
      $(window).off('orientationchange.dropdown');

      /**
      * Fires as the dropdown list is closed
      *
      * @event listclosed
      * @memberof Dropdown
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */
      this.element.trigger('listclosed', action);
      this.activate();
      this.list = null;
      this.searchInput = null;
      this.listUl = null;
    },


    /**
    * Scroll to a particular option and make it in view.
    * @private
    * @param  {object} current The option element to scroll to.
    * @returns {void}
    */
    scrollToOption: function scrollToOption(current) {
      var self = this;
      if (!current) {
        return;
      }
      if (current.length === 0) {
        return;
      }
      // scroll to the currently selected option
      self.listUl.scrollTop(0);
      self.listUl.scrollTop(current.offset().top - self.listUl.offset().top - self.listUl.scrollTop() - 40);
    },


    /**
    * Blur and Close List
    * @private
    * @returns {void}
    */
    handleBlur: function handleBlur() {
      var self = this;

      /*
      if (this.isOpen()) {
        this.timer = setTimeout(() => {
          self.closeList('cancel');
        }, 40);
      }
      */

      self.closeList('cancel');

      return true;
    },


    /*
    * Function that is used to chekc if the field is loading from an ajax call.
    * @returns {void} Returns true if the field is attempting to load via AJAX.
    */
    isLoading: function isLoading() {
      return this.element.is('.is-loading') && this.element.is('.is-blocked');
    },


    /**
     * Return true/false depending on if the list is open.
     * @returns {boolean} The current state (open = true).
     */
    isOpen: function isOpen() {
      return !!this.pseudoElem.hasClass('is-open');
    },


    /**
     * Toggle the current state of the list between open and closed.
     * @private
     */
    toggle: function toggle() {
      this.toggleList();
    },


    /**
     * Toggle the current state of the list between open and closed.
     * @deprecated
     * @private
     */
    toggleList: function toggleList() {
      if (this.isOpen() || this.isLoading()) {
        this.closeList('cancel');
        return;
      }
      this.open();
    },


    /**
     * Highlight the option that is being typed.
     * @private
     * @param {object} listOption The option element
     * @param {boolean} noScroll If true will scroll to the option
     */
    highlightOption: function highlightOption(listOption, noScroll) {
      //eslint-disable-line
      if (!listOption) {
        return;
      }

      if (listOption.length === 0) {
        listOption = this.list.find('.dropdown-option').eq(0);
      }

      if (listOption.is('.separator, .group-label')) {
        return;
      }

      // Get corresponding option from the list
      var option = this.element.find('option[value="' + listOption.attr('data-val') + '"]');

      if (option.hasClass('.is-disabled') || option.is(':disabled')) {
        return; //eslint-disable-line
      }

      if (!this.isOpen()) {
        return;
      }

      this.setItemIconOverColor();
      this.list.find('.is-focused').removeClass('is-focused').attr({ tabindex: '-1' });
      if (!option.hasClass('clear')) {
        this.setItemIconOverColor(listOption);
        listOption.addClass('is-focused').attr({ tabindex: '0' });
      }

      // Set activedescendent for new option
      // this.pseudoElem.attr('aria-activedescendant', listOption.attr('id'));
      this.searchInput.attr('aria-activedescendant', listOption.children('a').attr('id'));

      if (!noScroll || noScroll === false || noScroll === undefined) {
        this.scrollToOption(listOption);
      }
    },


    /**
     * Un Highlight the option that is being typed.
     * @private
     * @param  {object} listOptions The option element
     * @param  {boolean} noScroll If true will scroll to the option
     */
    unhighlightOptions: function unhighlightOptions(listOptions, noScroll) {
      if (!listOptions || !listOptions.length) {
        listOptions = this.list.find('.is-selected');
      }
      this.setItemIconOverColor();
      listOptions.removeClass('is-focused').attr({ tabindex: '-1' });

      this.searchInput.removeAttr('aria-activedescendant');

      if (!noScroll || noScroll === false || noScroll === undefined) {
        this.scrollToOption(listOptions.first());
      }
    },


    /**
     * Toggle all selection for items.
     * @private
     * @param {boolean} doSelectAll true to select and false will clear selection for all items.
     * @returns {void}
     */
    selectAll: function selectAll(doSelectAll) {
      var selector = {
        options: 'option:not(.is-disabled):not(:disabled)',
        items: 'li.dropdown-option:not(.separator):not(.group-label):not(.is-disabled)'
      };
      var options = [].slice.call(this.element[0].querySelectorAll(selector.options));
      var items = [].slice.call(this.listUl[0].querySelectorAll(selector.items));
      var last = options[options.length - 1];
      var text = '';

      if (doSelectAll) {
        // Select all
        items.forEach(function (node) {
          return node.classList.add('is-selected');
        });
        options.forEach(function (node) {
          node.selected = true;
          node.setAttribute('selected', true);
        });

        text = this.getOptionText($(options));
        var maxlength = this.element[0].getAttribute('maxlength');
        if (maxlength) {
          text = text.substr(0, maxlength);
        }
      } else {
        // Clear all
        items.forEach(function (node) {
          return node.classList.remove('is-selected');
        });
        options.forEach(function (node) {
          node.selected = false;
          node.setAttribute('selected', true);
        });
      }
      this.previousActiveDescendant = last.value || '';

      this.pseudoElem[0].querySelector('span').textContent = text;
      this.searchInput[0].value = text;
      this.updateItemIcon(last);

      if (this.list[0].classList.contains('search-mode')) {
        this.resetList();
      }
      this.activate(true);
      this.setBadge(last);

      this.element.trigger('change').triggerHandler('selected');
    },


    /**
     * Convenience method for running _selectOption()_ on a set of list options.
     * Accepts an array or jQuery selector containing valid list options and selects/deselects them.
     * @private
     * @param {object} options incoming options
     * @param {boolean} noTrigger if true, causes the 'selected' and 'change' events
     * not to fire on each list item.
     */
    selectOptions: function selectOptions(options, noTrigger) {
      // Use a jQuery selector if the incoming options are inside an array
      if (Array.isArray(options)) {
        options = $(options);
      }

      var self = this;
      options.each(function () {
        self.selectOption($(this), noTrigger);
      });

      self.element.trigger('change').triggerHandler('selected');
    },


    /**
     * Select an option and conditionally trigger events.
     * Accepts an array or jQuery selector containing valid list options and selects/deselects them.
     * @private
     * @param {object} option - the incoming li option
     * @param {boolean} noTrigger - if true, causes the 'selected' and 'change' events not to
     * fire on the list item.
     */
    selectOption: function selectOption(option, noTrigger) {
      if (!option || !option.length) {
        return;
      }
      var li = void 0;

      if (option.is('li')) {
        li = option;
        option = this.element.find('option[value="' + option.attr('data-val') + '"]');

        // Try matching the option's text if 'cur' comes back empty.
        // Supports options that don't have a 'value' attribute.
        if (option.length === 0) {
          option = this.element.find('option').filter(function () {
            return $(this).text() === li.attr('data-val');
          });
        }
      }

      var value = option.val();
      if (!option) {
        return;
      }

      if (!li && typeof value === 'string') {
        value = value.replace(/"/g, '/quot/');
        li = this.listUl.find('li[data-val="' + value + '"]');
      }

      if (option.hasClass('is-disabled') || option.is(':disabled')) {
        return;
      }

      var optionVal = option.val();
      var val = this.element.val();
      var text = '';
      var trimmed = '';
      var clearSelection = false;

      if (this.settings.reload === 'typeahead') {
        val = this.selectedValues || [];
      }

      // Sets to false if the option is being removed from a multi-select instead of added
      var isAdded = true;

      if (option.hasClass('clear') || !li) {
        clearSelection = true;
      }

      if (this.settings.multiple) {
        // Working with a select multiple allows for the "de-selection" of items in the list
        if (!val) {
          val = [];
        }
        if ($.inArray(optionVal, val) !== -1) {
          val = $.grep(val, function (optionValue) {
            return optionValue !== optionVal;
          });
          li.removeClass('is-selected');
          this.previousActiveDescendant = undefined;
          isAdded = false;
        } else {
          if (!isNaN(this.settings.maxSelected) && //eslint-disable-line
          this.element.find('option:selected').length >= this.settings.maxSelected) {
            return;
          }

          val = typeof val === 'string' ? [val] : val;
          val.push(optionVal);
          li.addClass('is-selected');
          this.previousActiveDescendant = option.val();
        }

        var newOptions = this.element.find('option').filter(function () {
          return $.inArray($(this)[0].value, val) !== -1;
        });
        text = this.getOptionText(newOptions);
      } else {
        // Working with a single select
        val = optionVal;
        this.listUl.find('li.is-selected').removeClass('is-selected');
        if (!clearSelection) {
          li.addClass('is-selected');
        }
        this.previousActiveDescendant = option.val();
        text = option.text();
      }

      if (!clearSelection) {
        this.element.find('option').each(function () {
          //eslint-disable-line
          if (this.value === optionVal) {
            $(this).prop('selected', true);
            return false;
          }
        });
      }

      // Change the values of both inputs and swap out the active descendant
      if (!clearSelection) {
        this.pseudoElem.find('span').text(text);
        this.searchInput.val(text);
      } else {
        this.pseudoElem.find('span').text('');
        this.searchInput.val('');
      }

      if (this.element.attr('maxlength')) {
        trimmed = text.substr(0, this.element.attr('maxlength'));
        this.pseudoElem.find('span').text(trimmed);
        this.searchInput.val(trimmed);
      }

      // Set the new value on the <select>
      this.selectedValues = val;
      this.element.val(val);
      this.updateItemIcon(option);

      /**
      * Fires after the value in the input is changed by any means.
      * @event change
      * @memberof Dropdown
      * @property {object} event The jquery event object
      */
      if (!noTrigger) {
        // Fire the change event with the new value if the noTrigger flag isn't set
        this.element.trigger('change').triggerHandler('selected', [option, isAdded]);

        if (this.pseudoElem.find('span').width() >= this.pseudoElem.width()) {
          this.setTooltip();
        } else if (this.tooltipApi) {
          this.tooltipApi.destroy();
        }
      }

      /**
      * Fires after the value in the input is changed by user interaction.
      * @event input
      * @memberof Dropdown
      * @property {object} event The jquery event object
      */

      // If multiselect, reset the menu to the unfiltered mode
      if (this.settings.multiple) {
        if (this.list.hasClass('search-mode')) {
          this.resetList();
        }
        this.activate(true);
      }

      this.setBadge(option);
    },


    /**
     * Select an option by the value.
     * @param {string} value - A string containing the value to look for. (Case insensitive)
     */
    selectValue: function selectValue(value) {
      if (typeof value !== 'string') {
        return;
      }

      var option = this.element.find('option[value="' + value + '"]');
      if (!option || !option.length) {
        return;
      }

      this.element.find('option:selected').prop('selected', false);
      option.prop('selected', true);
      this.updated();
    },


    /**
     * Select the next item that starts with a given character (text of the option).
     * @param {string} char - The starting letter to match for. (Case insensitive)
     */
    selectStartsWith: function selectStartsWith(char) {
      if (typeof char !== 'string') {
        return;
      }

      var elem = this.element[0];
      this.filterTerm = '';

      var newIdx = -1;
      var totalMatches = 0;

      // Log search matches
      if (!this.searchMatches || !this.searchMatches[char]) {
        this.searchMatches = {};
        this.searchMatches[char] = [];
      }

      for (var i = 0; i < elem.options.length; i++) {
        var option = elem.options[i];
        // Check if its a match (Case insensitive)
        var isMatch = option.innerText.toLowerCase().indexOf(char) === 0;

        if (isMatch) {
          if (this.searchMatches[char].indexOf(i) === -1) {
            this.searchMatches[char].push(i);
            newIdx = i;
            break;
          }
          totalMatches++;
          continue;
        }
      }

      if (newIdx === -1) {
        if (!this.searchMatches[char].length) {
          return;
        }

        if (totalMatches === this.searchMatches[char].length) {
          newIdx = this.searchMatches[char][0];
          this.searchMatches[char].length = 1; // reset
        }
      }

      elem.selectedIndex = newIdx;
      this.updated();
      this.element.trigger('change');
    },


    /**
     * Set the bade on the option from the config.
     * @private
     * @param {string} option - A string containing the value to look for. (Case insensitive)
     */
    setBadge: function setBadge(option) {
      // Badge Support
      if (this.badges) {
        var badge = this.element.parent().find('.badge');

        if (badge.length === 0) {
          this.element.parent().find('.dropdown-wrapper').append('<span class="badge">1</span>');
          badge = this.element.parent().find('.badge');
        }

        badge.attr('class', 'badge ' + (option.attr('data-badge-color') ? option.attr('data-badge-color') : 'azure07')).text(option.attr('data-badge'));
      }
    },


    /**
     * Execute the source ajax option
     * @private
     * @param {function} callback  The function call back.
     * @param {boolean} doReset  if defined, acts as a "reset" source call, where the search term will be ignored.
     * @returns {function} The callback for execution.
     */
    callSource: function callSource(callback, doReset) {
      var self = this;
      var searchTerm = '';

      if (!doReset && this.isOpen() && !this.element.hasClass('search-mode')) {
        searchTerm = this.searchInput.val();
      }

      // Return false and let the normal display codepath run.
      if (!this.settings.source) {
        return false;
      }

      this.isFiltering = false;

      var sourceType = _typeof(this.settings.source);
      var response = function response(data, isManagedByTemplate) {
        // to do - no results back do not open.
        var list = '';
        var val = self.element.val();

        function replaceDoubleQuotes(content) {
          return content.replace(/"/g, '\'');
        }

        function buildOption(option) {
          if (option === null || option === undefined) {
            return;
          }

          var isString = typeof option === 'string';
          var stringContent = option;
          var id = '';
          var selected = '';
          var textContent = '';

          if (isString) {
            option = {
              value: stringContent
            };
          }

          if (option.value !== undefined) {
            option.value = replaceDoubleQuotes(option.value);
            textContent = option.label;
          }

          if (option.id !== undefined) {
            if (!isNaN(option.id)) {
              //eslint-disable-line
              option.id = '' + option.id;
            }
            option.id = replaceDoubleQuotes(option.id);
            id = ' id="' + option.id + '"';
          }

          if (option.label !== undefined) {
            option.label = replaceDoubleQuotes(option.label);
            textContent = option.label;
          }

          var selectedValues = self.selectedValues && self.selectedValues.indexOf(val) > -1;
          if (option.value === val || selectedValues) {
            option.selected = true;
            selected = ' selected';
          }

          // Render the option element
          list += '<option' + id + ' value="' + option.value + '"' + selected + '>\n          ' + textContent + '\n        </option>';
        }

        // If the incoming dataset is different than the one we started with,
        // replace the contents of the list, and rerender it.
        if (!self.isFiltering && !utils.equals(data, self.dataset)) {
          self.dataset = data;

          if (!isManagedByTemplate) {
            self.element.empty();
            for (var i = 0; i < data.length; i++) {
              var opts = void 0;

              if (data[i].group) {
                opts = data[i].options;
                list += '<optgroup label="' + data[i].group + '">';
                for (var ii = 0; ii < opts.length; ii++) {
                  buildOption(opts[ii]);
                }
                list += '</optgroup>';
              } else {
                buildOption(data[i]);
              }
            }

            self.element.append(list);
          }
          self.updateList(searchTerm);
        }

        self.element.triggerHandler('complete'); // For Busy Indicator
        self.element.trigger('requestend', [searchTerm, data]);

        if (typeof callback !== 'function') {
          return;
        }
        callback();
      };

      self.element.triggerHandler('start'); // For Busy Indicator
      self.element.trigger('requeststart');

      if (sourceType === 'function') {
        // Call the 'source' setting as a function with the done callback.
        this.settings.source(response, searchTerm, this.settings.sourceArguments);
      } else if (sourceType === 'object') {
        // Use the 'source' setting as pre-existing data.
        // Sanitize accordingly.
        var sourceData = $.isArray(this.settings.source) ? this.settings.source : [this.settings.source];
        response(sourceData);
      } else {
        // Attempt to resolve source as a URL string.  Do an AJAX get with the URL
        var sourceURL = this.settings.source.toString();
        var request = $.getJSON(sourceURL);

        request.done(function (data) {
          response(data);
        }).fail(function () {
          response([]);
        });
      }

      return true;
    },


    /**
     * Get data attributes from passed list of attributes
     * @private
     * @param {array} attr - List of all attributes.
     * @param {array} attrToExclude - List of attributes to be excluded from passed list.
     * @returns {object} It will return an object containing two keys
     * str - string of attributes
     * obj - object of attributes
     */
    getDataAttributes: function getDataAttributes(attr, attrToExclude) {
      if (!attr) {
        return;
      } else if (typeof attr === 'string') {
        attr = [attr];
      }

      var toExclude = attrToExclude || [];
      if (typeof toExclude === 'string') {
        toExclude = [toExclude];
      }
      var attrToCopy = {
        obj: {},
        str: '',
        isExclude: function isExclude(attrib) {
          return $.inArray(attrib, toExclude) > -1;
        }
      };
      for (var key in attr) {
        //eslint-disable-line
        if (!attr.hasOwnProperty(key)) {
          //eslint-disable-line
          continue; //eslint-disable-line
        }
        attrToCopy.name = '' + attr[key].name;
        attrToCopy.isData = attrToCopy.name.substr(0, 5) === 'data-';
        if (attrToCopy.isData && !attrToCopy.isExclude(attrToCopy.name)) {
          attrToCopy.obj[attrToCopy.name] = attr[key].value;
          attrToCopy.str += ' ' + attrToCopy.name + '="' + attr[key].value + '"';
        }
      }
      return { str: attrToCopy.str, obj: attrToCopy.obj }; //eslint-disable-line
    },


    /**
     * External Facing function to set value by code - Depricated set on select and trigger updated.
     * @private
     * @deprecated
     * @param {string} code - The value to match and set on the value element.
     */
    setCode: function setCode(code) {
      var self = this;
      var doSetting = function doSetting() {
        self.element.val(code);
        self.updated();
      };

      if (!self.callSource(doSetting)) {
        doSetting();
      }
    },


    /**
     * Returns true if the object is a mobile element.
     * @private
     * @returns {boolean} code - True if this is a mobile device
     */
    isMobile: function isMobile() {
      return ['ios', 'android'].indexOf(Environment.os.name) > -1;
    },


    /**
     * Returns true if the element already has the closable class.
     * @private
     * @returns {object} The list
     */
    isListClosable: function isListClosable() {
      return this.list.hasClass('is-closable');
    },


    /**
     * Disable the input element.
     */
    disable: function disable() {
      this.element.prop('disabled', true).prop('readonly', false);

      if (this.pseudoElem.is($(document.activeElement))) {
        this.pseudoElem.blur();
      }

      this.pseudoElem.addClass('is-disabled').removeClass('is-readonly').attr('tabindex', '-1').prop('readonly', false).prop('disabled', true);
      this.closeList('cancel');
    },


    /**
    * Returns true if the dropdown is disabled.
    * @returns {boolean} True if the element is disabled.
    */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
     * Enable the input element.
     */
    enable: function enable() {
      this.element.prop('disabled', false).prop('readonly', false);
      this.pseudoElem.prop('disabled', false).prop('readonly', false).attr('tabindex', '0').removeClass('is-disabled').removeClass('is-readonly');
    },


    /**
     * Make the input element readonly.
     */
    readonly: function readonly() {
      this.element.prop('disabled', false).prop('readonly', true);
      this.pseudoElem.removeClass('is-disabled').addClass('is-readonly').attr('tabindex', '0').prop('disabled', false).prop('readonly', true);
      this.closeList('cancel');
    },


    /**
     * Tear down events and restore to original state.
     * @param  {object} settings The settings object to use.
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.closeList('cancel');

      // Update the 'multiple' property
      if (this.settings.multiple && this.settings.multiple === true) {
        this.element.prop('multiple', true);
      } else {
        this.element.prop('multiple', false);
      }

      // update "readonly" prop
      if (this.element.prop('readonly') === true) {
        this.readonly();
      } else {
        this.pseudoElem.removeClass('is-readonly');
      }

      // update "disabled" prop
      this.pseudoElem[this.element.prop('disabled') ? 'addClass' : 'removeClass']('is-disabled');

      // update the list and set a new value, if applicable
      this.updateList();
      this.setDisplayedValues();

      this.element.trigger('has-updated');

      return this;
    },


    /**
     * Tear down events and restore to original state.
     */
    destroy: function destroy() {
      if (this.selectedValues) {
        delete this.selectedValues;
      }

      $.removeData(this.element[0], COMPONENT_NAME$y);
      this.closeList('cancel');
      this.label.remove();
      this.pseudoElem.off().remove();
      this.icon.remove();
      this.wrapper.remove();
      this.listfilter.destroy();
      this.element.removeAttr('style');

      var list = document.body.querySelector('#dropdown-list');
      if (list) {
        list.parentNode.removeChild(list);
      }
    },


    /**
     * Setup the internal event handlers.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this3 = this;

      var self = this;

      this.pseudoElem.on('keydown.dropdown', function (e) {
        return _this3.handlePseudoElemKeydown(e);
      }).on('click.dropdown', function (e) {
        // landmark would like the click event to bubble up if ctrl and shift are pressed
        if (!(e.originalEvent.ctrlKey && e.originalEvent.shiftKey)) {
          e.stopPropagation();
        }
      }).on('mouseup.dropdown', function (e) {
        if (e.button === 2) {
          return;
        }
        self.toggleList();
      }).on('touchend.dropdown touchcancel.dropdown', function (e) {
        e.stopPropagation();
        self.toggleList();
        e.preventDefault();
      });

      self.element.on('activated.dropdown', function () {
        self.label.trigger('click');
      }).on('updated.dropdown', function (e) {
        e.stopPropagation();
        self.updated();
      }).on('openlist.dropdown', function () {
        self.toggleList();
      });

      // for form resets.
      self.element.closest('form').on('reset.dropdown', function () {
        setTimeout(function () {
          self.element.triggerHandler('updated');
        }, 1);
      });

      // Handle Label click
      this.label.on('click', function () {
        self.pseudoElem.focus();
      });
    }
  };

  /**
   * jQuery Component Wrapper for the Dropdown
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.dropdown = function (settings) {
    // Keep the Chaining and Init the Controls or Settings
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$y);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$y, new Dropdown(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$z = 'timepicker';

  // Timepicker Modes
  var TIMEPICKER_MODES = ['standard', 'range'];

  // Timepicker defaults
  var TIMEPICKER_DEFAULTS = function TIMEPICKER_DEFAULTS() {
    return {
      timeFormat: Locale.calendar().timeFormat || 'h:mm a', // The time format
      minuteInterval: 5,
      secondInterval: 5,
      mode: TIMEPICKER_MODES[0],
      roundToInterval: true,
      parentElement: null,
      returnFocus: true,
      customValidation: false
    };
  };

  /**
   * The Timepicker Component provides a click/touch user interface for setting a time.
   * @class TimePicker
   * @param {HTMLElement|jQuery[]} element the base element
   * @param {object} [settings] incoming settings
   * @param {string} [settings.timeFormat = 'h:mm a'] The time format, defaults to the current locales time format.
   * @param {number} [settings.minuteInterval = 5]  Integer from 1 to 60.  Multiples of this value
   *  are displayed as options in the minutes dropdown.
   * @param {number} [settings.secondInterval = 5]  Integer from 1 to 60.
   * @property {string} [settings.mode = 'standard']  Can be set to 'standard', 'range',
   * @property {boolean} [settings.roundToInterval = true]  if `false`, does not automatically round user-entered values
   * from the pickers to their nearest interval.
   * @param {boolean} [settings.customValidation=false] If true the internal validation is disabled.
   * @param {null|jQuery[]} [settings.parentElement] if defined as a jQuery-wrapped element, will be used as the target element.
   * @property {string} [settings.returnFocus = true]  If set to false, focus will not be returned to
   *  the calling element. It usually should be for accessibility purposes.
   */
  function TimePicker(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, TIMEPICKER_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  TimePicker.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup().build().handleEvents().roundMinutes();
    },


    /**
     * Configure any settings for the Timepicker
     * @private
     * @returns {this} component instance
     */
    setup: function setup() {
      function sanitizeIntervals(value, type) {
        if (!type || ['minute', 'second'].indexOf(type) < 0) {
          type = 'minute';
        }

        var defaultInterval = TIMEPICKER_DEFAULTS()[type + 'Interval'];
        if (value === undefined || isNaN(value)) {
          return defaultInterval;
        }
        var intValue = parseInt(value, 10);
        return intValue > 0 && intValue < 60 ? intValue : defaultInterval;
      }

      function sanitizeTimeFormat(value) {
        if (!value || !value.toUpperCase().match('H') || !value.match('mm')) {
          return TIMEPICKER_DEFAULTS().timeFormat;
        }

        return value;
      }

      function sanitizeRoundToInterval(value) {
        return value === true;
      }

      function sanitizeMode(value) {
        var modes = ['standard', 'range'];
        return $.inArray(value, modes) > -1 ? value : TIMEPICKER_DEFAULTS().mode;
      }

      this.id = utils.uniqueId(this.element, 'timepicker') + '-id';
      this.hoursId = 'timepicker-hours-' + this.id.toString();
      this.minutesId = 'timepicker-minutes-' + this.id.toString();
      this.secondsId = 'timepicker-seconds-' + this.id.toString();
      this.periodId = 'timepicker-period-' + this.id.toString();

      if (this.element.is('[data-round-to-interval]')) {
        this.settings.roundToInterval = sanitizeRoundToInterval(this.element.attr('data-round-to-interval'));
      }
      if (this.element.is('[data-minute-interval]')) {
        this.settings.minuteInterval = sanitizeIntervals(this.element.attr('data-minute-interval'), 'minute');
      }

      this.settings.timeFormat = sanitizeTimeFormat(parseInt(this.element.attr('data-force-hour-mode'), 10) === 24 ? 'HH:mm' : this.settings.timeFormat);
      this.settings.minuteInterval = sanitizeIntervals(this.settings.minuteInterval, 'minute');
      this.settings.secondInterval = sanitizeIntervals(this.settings.secondInterval, 'second');
      this.settings.mode = sanitizeMode(this.settings.mode);
      this.settings.roundToInterval = sanitizeRoundToInterval(this.settings.roundToInterval);

      this.dayPeriods = Locale.calendar().dayPeriods;

      return this;
    },


    /**
     * Add any markup
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      // With this option forgoe the input and append the dropdowns/popup to the parent element
      if (this.settings.parentElement) {
        this.trigger = $();
        this.buildStandardPopup();
        this.setupStandardEvents();
        return this;
      }

      // Append a Button
      this.trigger = this.element.next('svg.icon');
      if (this.trigger.length === 0) {
        this.trigger = $.createIconElement('clock').insertAfter(this.element);
      }

      this.addAria();

      // Add Mask and Validation plugins for time
      this.addMask();

      return this;
    },


    /**
     * Adds ARIA-related attributes
     * @private
     * @returns {void}
     */
    addAria: function addAria() {
      this.element.attr({
        'aria-expanded': 'false',
        role: 'combobox'
      });

      // TODO: Confirm this with Accessibility Team
      this.label = $('label[for="' + this.element.attr('id') + '"]');
      this.label.append('<span class="audible">' + Locale.translate('UseArrow') + '</span>');
    },


    /**
     * Sets up a `keydown` event listener.
     * @private
     * @returns {void}
     */
    handleKeys: function handleKeys() {
      var self = this;

      this.element.on('keydown.timepicker', function (e) {
        var handled = false;

        // Esc closes an open popup with no action
        if (e.which === 27 && self.isOpen()) {
          handled = true;
          self.closeTimePopup();
        }

        // Arrow Down or Alt first opens the dialog
        if (e.which === 40 && !self.isOpen()) {
          handled = true;
          self.openTimePopup();
        }

        if (handled) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        return true;
      });
    },


    /**
     * Sets up a `blur` event listener.
     * @private
    */
    handleBlur: function handleBlur() {
      var self = this;

      this.element.on('blur.timepicker', function () {
        self.roundMinutes();

        // The action of closing the popup menu is set on a timer because technically
        // there are no fields focused on frame 0 of the popup menu's existence, which
        // would cause it to close immediately on open.
        setTimeout(function () {
          if (self.isOpen() && self.popup.find(':focus').length === 0) {
            self.closeTimePopup();
          }
        }, 20);
      });
    },


    /**
     * Checks a time format value to see if it is a Military (24-hour) format.
     * @private
     * @param {string} value - a string value representing a time format.
     * @returns {boolean} whether or not the time format is 24-hour
     */
    is24HourFormat: function is24HourFormat(value) {
      if (!value) {
        value = this.settings.timeFormat;
      }
      return (value.match('H') || []).length > 0;
    },


    /**
     * @private
     * @param {number} value incoming value
     * @returns {string} the hour text
     */
    hourText: function hourText(value) {
      return ((this.settings.timeFormat.toUpperCase().match('HH') || []).length > 0 && value < 10 ? '0' : '') + value;
    },


    /**
     * Checks a time format value to see if it includes seconds.
     * @private
     * @param {string} value a string value representing a time format.
     * @returns {boolean} whether or not seconds are included in the time format
     */
    hasSeconds: function hasSeconds(value) {
      if (!value) {
        value = this.settings.timeFormat;
      }
      return (value.match('ss') || []).length > 0;
    },


    /**
     * Checks to see if a time format contains a space for presenting the day period.
     * @private
     * @param {string} value a string value representing a time format.
     * @returns {boolean} whther or not the time format has day periods.
     */
    hasDayPeriods: function hasDayPeriods(value) {
      if (!value) {
        value = this.settings.timeFormat;
      }
      return (value.match('a') || []).length > 0;
    },


    /**
     * Gets a Locale-defined version of the time separator.
     * @returns {string} containing the time separator
     */
    getTimeSeparator: function getTimeSeparator() {
      return Locale.calendar().dateFormat.timeSeparator;
    },


    /**
     * Rounds the current value of the minutes picker to its nearest interval value.
     * @private
     */
    roundMinutes: function roundMinutes() {
      if (!stringUtils.toBoolean(this.settings.roundToInterval)) {
        return;
      }

      // separate out the minutes value from the rest of the value.
      var val = this.element.val();
      var timeSeparator = this.getTimeSeparator();
      var parts = val ? val.split(timeSeparator) : [];
      var interval = this.settings.minuteInterval;

      if (!parts[1]) {
        return;
      }

      if (!this.is24HourFormat(this.settings.timeFormat)) {
        var periodParts = parts[1].split(' ');
        parts[1] = periodParts[0];
        if (periodParts[1]) {
          parts.push(periodParts[1]);
        }
      }

      parts[1] = parseInt(parts[1], 10);
      if (parts[1] % interval === 0) {
        return;
      }

      parts[1] = Math.round(parts[1] / interval) * interval;

      parts[1] = parts[1].toString();
      parts[1] = (parts[1].length < 2 ? '0' : '') + parts[1];

      if (parts[1] === '60') {
        parts[1] = '00';
        parts[0] = (parseInt(parts[0], 10) + 1).toString();
      }

      var newVal = parts[0] + timeSeparator + parts[1] + ' ' + (parts[2] ? parts[2] : '');
      this.element.val(newVal);
    },


    /**
     * Adds Masked Input and Validation components to the input field at build time.
     * @private
     * @returns {void}
     */
    addMask: function addMask() {
      if (this.element.data('mask') && _typeof(this.element.data('mask')) === 'object') {
        this.element.data('mask').destroy();
      }
      this.element.data('mask', undefined);

      var maskOptions = {
        keepCharacterPositions: true,
        process: 'date',
        patternOptions: {
          format: this.settings.timeFormat
        }
      };

      var validation = 'time';
      var events = { time: 'blur' };
      var customValidation = this.element.attr('data-validate');
      var customEvents = this.element.attr('data-validation-events');

      if (customValidation === 'required' && !customEvents) {
        validation = customValidation + ' ' + validation;
        $.extend(events, {
          required: 'change blur'
        });
      } else if (!!customValidation && !!customEvents) {
        // Remove default validation, if found "no-default-validation" string in
        // "data-validate" attribute
        if (customValidation.indexOf('no-default-validation') > -1) {
          validation = customValidation.replace(/no-default-validation/g, '');
          events = $.fn.parseOptions(this.element, 'data-validation-events');
        } else {
          // Keep default validation along custom validation
          validation = customValidation + ' ' + validation;
          $.extend(events, $.fn.parseOptions(this.element, 'data-validation-events'));
        }
      }

      if (!this.settings.customValidation) {
        this.element.attr('data-validate', validation).attr('data-validation-events', JSON.stringify(events)).mask(maskOptions).validate().triggerHandler('updated');
      }
    },


    /**
     * Constructs all markup and subcomponents needed to build the standard Timepicker popup.
     * @private
     * @returns {void}
     */
    buildStandardPopup: function buildStandardPopup() {
      var self = this;
      var popupContent = $('<div class="timepicker-popup-content"></div>');
      var timeSeparator = this.getTimeSeparator();
      var textValue = '';
      var selected = void 0;

      this.initValues = self.getTimeFromField();
      var timeParts = $('<div class="time-parts"></div>').appendTo(popupContent);

      // Build the inner-picker HTML
      var is24HourFormat = this.is24HourFormat();
      var hasSeconds = this.hasSeconds();
      var hasDayPeriods = this.hasDayPeriods();
      var hourCounter = is24HourFormat ? 0 : 1;
      var maxHourCount = is24HourFormat ? 24 : 13;

      this.hourSelect = $('<select id="' + this.hoursId + '" data-options="{\'noSearch\': \'true\'}" class="hours dropdown"></select>');

      while (hourCounter < maxHourCount) {
        selected = '';
        if (parseInt(self.initValues.hours, 10) === hourCounter) {
          selected = ' selected';
        }
        self.hourSelect.append($('<option' + selected + '>' + self.hourText(hourCounter) + '</option>'));
        hourCounter++;
      }
      timeParts.append($('<label for="' + this.hoursId + '" class="audible">' + Locale.translate('Hours') + '</label>'));
      timeParts.append(this.hourSelect);
      timeParts.append($('<span class="label colons">' + timeSeparator + '</span>'));

      // Minutes Picker
      var minuteCounter = 0;
      this.minuteSelect = $('<select id="' + this.minutesId + '" data-options="{\'noSearch\': \'true\'}" class="minutes dropdown"></select>');

      while (minuteCounter <= 59) {
        textValue = minuteCounter < 10 ? '0' + minuteCounter : minuteCounter;

        selected = '';
        if (parseInt(self.initValues.minutes, 10) === minuteCounter) {
          selected = ' selected';
        }
        self.minuteSelect.append($('<option' + selected + '>' + textValue + '</option>'));
        minuteCounter += self.settings.minuteInterval;
      }

      // If the value inside the picker doesn't match an interval, add the value
      // as the currently selected option, right at the top
      if (!this.minuteSelect.find('option[selected]').length) {
        this.minuteSelect.prepend($('<option selected>' + self.initValues.minutes + '</option>'));
      }

      timeParts.append($('<label for="' + this.minutesId + '" class="audible">' + Locale.translate('Minutes') + '</label>'));
      timeParts.append(this.minuteSelect);

      // Seconds Picker
      if (hasSeconds) {
        var secondCounter = 0;
        this.secondSelect = $('<select id="' + this.secondsId + '" data-options="{\'noSearch\': \'true\'}" class="seconds dropdown"></select>');

        while (secondCounter <= 59) {
          textValue = secondCounter < 10 ? '0' + secondCounter : secondCounter;

          selected = '';
          if (parseInt(self.initValues.seconds, 10) === secondCounter || !self.initValues.seconds && textValue === '00') {
            selected = ' selected';
          }
          this.secondSelect.append($('<option' + selected + '>' + textValue + '</option>'));
          secondCounter += self.settings.secondInterval;
        }

        // If the value inside the picker doesn't match an interval, add the value
        // as the currently selected option, right at the top
        if (!this.secondSelect.find('option[selected]').length) {
          this.secondSelect.prepend($('<option selected>' + self.initValues.seconds + '</option>'));
        }

        timeParts.append($('<span class="label colons">' + timeSeparator + '</span>'));
        timeParts.append($('<label for="' + this.secondsId + '" class="audible">' + Locale.translate('Seconds') + '</label>'));
        timeParts.append(this.secondSelect);
      }

      if (!is24HourFormat && hasDayPeriods) {
        this.periodSelect = $('<select id="' + this.periodId + '" data-options="{\'noSearch\': \'true\'}" class="period dropdown"></select>');
        timeParts.append($('<span class="label colons"></span>'));
        var localeDays = Locale.calendar().dayPeriods;
        var localeCount = 0;
        var regexDay = new RegExp(self.initValues.period, 'i');
        var realDayValue = 'AM'; // AM

        while (localeCount < 2) {
          realDayValue = localeCount === 0 ? 'AM' : 'PM'; // ? AM : PM
          selected = '';
          if (regexDay.test(localeDays[localeCount])) {
            selected = ' selected';
          }
          this.periodSelect.append($('<option value="' + realDayValue + '"' + selected + '>' + localeDays[localeCount] + '</option>'));

          localeCount++;
        }
        timeParts.append($('<label for="' + this.periodId + '" class="audible">' + Locale.translate('TimePeriod') + '</label>'));
        timeParts.append(this.periodSelect);
      }

      if (this.settings.parentElement) {
        this.settings.parentElement.append(popupContent);
        // self.afterShow(this.settings.parentElement);
        self.popup = this.settings.parentElement.find('.timepicker-popup-content').addClass('timepicker-popup').attr('id', 'timepicker-popup');
      } else {
        popupContent.append('<div class="modal-buttonset"><button type="button" class="btn-modal-primary set-time">' + Locale.translate('SetTime') + '</button></div>');

        var placementParent = this.element;
        var placementParentXAlignment = Locale.isRTL() ? 'right' : 'left';
        var parent = this.element.parent();

        if (parent.is('.datagrid-cell-wrapper')) {
          placementParentXAlignment = 'center';
          placementParent = this.element.next('.icon');
        }

        this.trigger.popover({
          content: popupContent,
          trigger: 'immediate',
          placement: 'bottom',
          placementOpts: {
            parent: placementParent,
            parentXAlignment: placementParentXAlignment,
            strategies: ['flip', 'nudge', 'shrink']
          },
          tooltipElement: '#timepicker-popup'
        }).on('show.timepicker', function (e, ui) {
          self.afterShow(ui);
        }).on('hide.timepicker', function () {
          if (self.settings.returnFocus) {
            self.element.focus();
          }
        });
      }

      // Make adjustments to the popup HTML specific to the timepicker
      if (this.trigger.data('tooltip')) {
        self.popup = this.trigger.data('tooltip').tooltip;
        var tooltip = self.popup;
        tooltip.addClass('timepicker-popup');
      }
    },


    /**
     * Handler for the Timepicker Popover's custom `show` event.
     * @private
     * @param {object} ui timepicker popup element
     * @returns {void}
     */
    afterShow: function afterShow(ui) {
      var self = this;

      ui.find('button').button();

      // Set default values based on what's retrieved from the Timepicker's input field.
      this.hourSelect.val(this.initValues.hours);
      this.hourSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.hours);
      this.minuteSelect.val(this.initValues.minutes);
      this.minuteSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.minutes);

      if (this.secondSelect) {
        this.secondSelect.val(this.initValues.seconds);
        this.secondSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.seconds);
      }

      if (self.hasDayPeriods()) {
        this.periodSelect.val(this.initValues.period);
        this.periodSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.period);
      }

      ui.find('div.dropdown').first().focus();
      ui.find('.set-time').off('click.timepicker').on('click.timepicker', function (e) {
        e.preventDefault();
        self.setTimeOnField();
        self.closeTimePopup();
      });

      // Handle Tabbing on the dialog
      if (!this.settings.parentElement) {
        ui.on('keydown.timepicker', 'button, div.dropdown', function (e) {
          var key = e.keyCode || e.charCode || 0;

          if (key === 9) {
            self.containFocus(e);
            e.stopPropagation();
            e.preventDefault();
            return false;
          }
          return true;
        });
      }
    },


    /**
     * Focus the next prev focusable element on the popup
     * @private
     * @param {jQuery.Event} e the event object
     * @returns {void}
     */
    containFocus: function containFocus(e) {
      var reverse = e.shiftKey;

      // Set focus on (opt: next|prev) focusable element
      var focusables = this.popup.find(':focusable');
      var index = focusables.index($(':focus'));
      var next = index + 1 >= focusables.length ? 0 : index + 1;
      var prev = index - 1 < 0 ? focusables.length : index - 1;

      index = !reverse ? next : prev;

      focusables.eq(index).focus();
    },


    /**
     * Sets up events that need to be bound to a standard time picker.
     * @private
     * @returns {void}
     */
    setupStandardEvents: function setupStandardEvents() {
      var self = this;

      self.popup.on('touchend.timepicker touchcancel.timepicker', '.set-time', function (e) {
        e.preventDefault();
        e.target.click();
      }).on('keydown.timepicker', 'input.dropdown', function (e) {
        var handled = false;

        // Pressing Esc when focused on a closed dropdown menu causes the entire popup to close.
        if (e.which === 27) {
          handled = true;
          self.closeTimePopup();
          self.element.focus();
        }

        // Pressing Spacebar while the popup is open submits with the new time value.
        if (e.which === 32) {
          handled = true;
          self.popup.find('.set-time').click();
        }

        // Left & Right Arrows will switch between the available dropdowns
        if (e.which === 37 || e.which === 39) {
          handled = true;
          var inputs = self.popup.find('input[id$="-shdo"]');

          if (e.which === 37) {
            var prev = inputs.eq(inputs.index(this) - 1);
            if (!prev || prev.length === 0) {
              prev = inputs.eq(inputs.length);
            }
            prev.focus();
          }

          if (e.which === 39) {
            var next = inputs.eq(inputs.index(this) + 1);
            if (!next || next.length === 0) {
              next = inputs.eq(0);
            }
            next.focus();
          }
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }

        return true;
      });

      // Listen to the popover/tooltip's "hide" event to properly close out the
      // popover's inner controls.
      self.trigger.on('hide.timepicker', function () {
        self.onPopupHide();
      });
    },


    /**
     * Constructs all markup and subcomponents needed to build a Timepicker popup
     * containing a time range.
     * @private
     * @returns {void}
     */
    buildRangePopup: function buildRangePopup() {
      // TODO: Build this
    },


    /**
     * Sets up events that need to be bound to a range timepicker.
     * @private
     * @returns {void}
     */
    setupRangeEvents: function setupRangeEvents() {
      // TODO: Build this
    },


    /**
     * Gets the value of the Timepicker field as an object separated into hours,
     * minutes, (optional) seconds, and (optional) day period.
     * @param {string} [value] this method can optionally be passed
     * a string-based time value to calculate instead of the current field's value.
     * @returns {object} containing key/value pairs representing time parts.
     */
    getTimeFromField: function getTimeFromField(value) {
      var self = this;
      var val = value || this.element.val();
      var sep = this.getTimeSeparator();
      var parts = void 0;
      var endParts = void 0;
      var timeparts = {};

      val = val.replace(/[T\s:.-]/g, sep).replace(/z/i, '');
      parts = val.split(sep);

      // Check the last element in the array for a time period, and add it as an array
      // member if necessary
      if (!this.is24HourFormat()) {
        endParts = parts[parts.length - 1].split(' ');
        parts.pop();
        parts = parts.concat(endParts);
      }

      function isDayPeriod(thisValue) {
        return self.dayPeriods.indexOf(thisValue) > -1;
      }

      function removeLeadingWhitespace(thisValue) {
        return thisValue.replace(/^\s+|\s+$/g, '');
      }

      function addLeadingZero(thisValue) {
        if (!thisValue || isNaN(thisValue)) {
          return '00';
        }
        thisValue = parseInt(thisValue, 10);
        thisValue = thisValue < 10 ? '0' + thisValue : thisValue;
        return thisValue;
      }

      // Handle Hours
      if (!parts[0] || !parts[0].length || isNaN(parts[0])) {
        parts[0] = '1';
      }

      parts[0] = parseInt(parts[0], 10);
      if (!isNaN(parts[0])) {
        parts[0] = '' + parseInt(parts[0], 10);
      }
      timeparts.hours = self.hourText(parts[0]);

      // Handle Minutes
      if (parts[1]) {
        // remove leading whitespace
        parts[1] = removeLeadingWhitespace(parts[1]);
        parts[1] = addLeadingZero(parts[1]);
        timeparts.minutes = parts[1];
      } else {
        timeparts.minutes = '00';
      }

      // Handle Seconds/Period (slot 3)
      function handleSlot2(thisValue) {
        // Should not kick off at all if we don't pass it a value, OR if this field
        // is 24-hour display with no seconds
        if (!thisValue) {
          if (self.hasSeconds()) {
            thisValue = '00';
            timeparts.seconds = thisValue;
          }

          if (!self.is24HourFormat()) {
            thisValue = Locale.translateDayPeriod('AM');
            timeparts.period = thisValue;
          }

          return;
        }

        thisValue = removeLeadingWhitespace(thisValue);

        // Has seconds
        if (self.hasSeconds()) {
          thisValue = addLeadingZero(thisValue);
          timeparts.seconds = thisValue;
          return;
        }
        // No seconds, but has a day period
        if (!isDayPeriod(thisValue)) {
          thisValue = Locale.translateDayPeriod('AM');
        }
        timeparts.period = thisValue;
      }
      handleSlot2(parts[2]);

      // Handle Period after seconds (slot 4)
      if (parts[3]) {
        parts[3] = removeLeadingWhitespace(parts[3]);
        timeparts.period = parts[3];
      } else if (!this.is24HourFormat() && this.hasSeconds()) {
        timeparts.period = Locale.translateDayPeriod('AM');
      }

      return timeparts;
    },


    /**
     * Retrieves the values from the Timepicker popup's pickers and uses those values to set
     * the contents of the Timepicker field.
     * @returns {void}
     */
    setTimeOnField: function setTimeOnField() {
      var hours = $('#' + this.hoursId).val() || '';
      var minutes = $('#' + this.minutesId).val() || '';
      var seconds = $('#' + this.secondsId).val() || '';
      var period = ($('#' + this.periodId).val() || '').toUpperCase();
      var sep = this.getTimeSeparator();
      var timeString = '' + hours + sep + minutes + (this.hasSeconds() ? sep + seconds : '');

      period = !this.is24HourFormat() && period === '' ? $('#' + this.periodId + '-shdo').val() : period;
      timeString += period ? ' ' + Locale.translateDayPeriod(period) : '';

      /**
      * Fires when the value is changed by typing or the picker.
      * @event change
      * @memberof TimePicker
      * @property {object} event - The jquery event object
      */
      this.element.val(timeString).trigger('change');

      this.element.focus();
    },


    /**
     * Return whether or not the Timepicker popup is open.
     * @returns {boolean} whether or not the Timepicker popup is open.
     */
    isOpen: function isOpen() {
      return !!(this.popup && this.popup.is(':visible'));
    },


    /**
     * Opens the Timepicker popup, intializing all the dropdown elements and
     * setting up internal events.
     * @returns {void}
     */
    openTimePopup: function openTimePopup() {
      var self = this;

      // Get all current settings.
      self.setup();

      if (this.element.is(':disabled') || this.element.attr('readonly')) {
        return;
      }

      if (this.popup && !this.popup.hasClass('is-hidden')) {
        self.closeTimePopup();
      }

      this.element.addClass('is-active is-open');

      // Build a different Time Popup based on settings
      if (self.settings.mode === 'range') {
        self.buildRangePopup();
        self.setupRangeEvents();
      } else {
        self.buildStandardPopup();
        self.setupStandardEvents();
      }

      this.element.attr({ 'aria-expanded': 'true' });
      this.popup.find('div.dropdown').first().focus();
    },


    /**
     * Triggers the "hide" method on the tooltip plugin.  The Timepicker officially
     * "closes" after the popover's hide event fully completes because certain events
     * need to be turned off and certain markup needs to be removed only AFTER
     * the popover is hidden.
     * @returns {void}
     */
    closeTimePopup: function closeTimePopup() {
      if (this.trigger.data('tooltip')) {
        this.trigger.data('tooltip').hide();
      }
    },


    /**
     * Handles the time popover's "hide" event
     * @private
     * @returns {void}
     */
    onPopupHide: function onPopupHide() {
      if (this.settings.mode === 'standard') {
        var ddHours = $('#' + this.hoursId);
        var ddMinutes = $('#' + this.minutesId);
        var ddSeconds = $('#' + this.secondsId);
        var ddPeriod = $('#' + this.periodId);

        if (ddHours && ddHours.data('dropdown') && typeof ddHours.data('dropdown').destroy === 'function') {
          ddHours.data('dropdown').destroy();
        }
        if (ddMinutes && ddMinutes.data('dropdown') && typeof ddMinutes.data('dropdown').destroy === 'function') {
          ddMinutes.data('dropdown').destroy();
        }
        if (this.hasSeconds()) {
          if (ddSeconds && ddSeconds.data('dropdown') && typeof ddSeconds.data('dropdown').destroy === 'function') {
            ddSeconds.data('dropdown').destroy();
          }
        }
        if (this.hasDayPeriods()) {
          if (ddPeriod && ddPeriod.data('dropdown') && typeof ddPeriod.data('dropdown').destroy === 'function') {
            ddPeriod.data('dropdown').destroy();
          }
        }
        this.popup.off('click.timepicker touchend.timepicker touchcancel.timepicker keydown.timepicker');
      }
      this.element.attr({ 'aria-expanded': 'false' });
      this.trigger.off('hide.timepicker show.timepicker');
      this.trigger.data('tooltip').destroy();
      this.trigger.data('tooltip', undefined);
      $('#timepicker-popup').remove();
      this.element.removeClass('is-active is-open');
    },


    /**
     * Toggles the visibility of the Timepicker popup.
     * @returns {void}
     */
    toggleTimePopup: function toggleTimePopup() {
      if (this.isOpen()) {
        this.closeTimePopup();
      } else {
        this.openTimePopup();
      }
    },


    /**
     * Getter method for retrieving the value of the Timepicker.
     * @param {boolean} removePunctuation Gets rid of all the value's punctuation on return.
     * @returns {string} the current timepicker value
     */
    value: function value(removePunctuation) {
      var val = this.element.val();
      if (!removePunctuation || removePunctuation === false) {
        return val;
      }

      var timeSeparator = Locale.calendar().dateFormat.timeSeparator;
      var sepRegex = new RegExp(timeSeparator, 'g');

      // Remove punctuation
      val = val.replace(sepRegex, '');

      // Add leading zero for times without a double digit hour
      var parts = val.split(' ');
      if (parts[0].length < 4) {
        val = '0' + parts[0] + (parts[1] ? parts[1] : '');
      }

      return val;
    },


    /**
     * Enables the Timepicker
     * @returns {void}
     */
    enable: function enable() {
      this.element.removeAttr('disabled readonly').closest('.field').removeClass('is-disabled');
    },


    /**
    * Set input to readonly.
    * @returns {void}
    */
    readonly: function readonly() {
      this.enable();
      this.element.attr('readonly', 'readonly');
    },


    /**
     * Disables the Timepicker
     * @returns {void}
     */
    disable: function disable() {
      this.enable();
      this.element.attr('disabled', 'disabled').closest('.field').addClass('is-disabled');
    },


    /**
     * Detects whether or not the component is disabled
     * @returns {boolean} whether or not the component is disabled
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
     * Updates the component instance.  Can be used after being passed new settings.
     * @param {object} [settings] incoming settings
     * @returns {this} component instanceof
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },


    /**
     * Removes all event bindings, subcomponents and unnecessary markup from this component instance.
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.trigger.off('keydown.timepicker');
      this.element.off('focus.timepicker blur.timepicker keydown.timepicker');
      if (this.popup) {
        this.closeTimePopup();
      }

      this.trigger.remove();

      var mask = this.element.data('mask');
      if (mask && typeof mask.destroy === 'function') {
        mask.destroy();
      }

      $.removeData(this.element[0], 'validate');
      $.removeData(this.element[0], 'validationEvents');
      this.element.removeAttr('data-validate').removeData('validate validationEvents');

      this.label.find('.audible').remove();

      return this;
    },


    /**
     * Destroys the component instance.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$z);
    },


    /**
     * Sets up event listeners for the timepicker instance.
     * @fires TimePicker#events
     * @listens click  &nbsp;-&nbsp;
     * @listens touchstart  &nbsp;-&nbsp;
     * @listens touchmove  &nbsp;-&nbsp;
     * @listens touchend  &nbsp;-&nbsp;
     * @listens blur  &nbsp;-&nbsp;
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;
      this.trigger.on('click.timepicker', function () {
        self.toggleTimePopup();
      });

      this.handleKeys();
      this.handleBlur();

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Timepicker
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} textarea elements being acted on.
   */
  $.fn.timepicker = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$z);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$z, new TimePicker(this, settings));
      }
    });
  };

  // The validation rules object.
  // This contains all base rules for validation that come bundled as part of Soho.
  // These rules can be extended.
  function ValidationRules() {
    var self = this;

    // define standard validation types
    this.ValidationTypes = [];
    this.ValidationTypes.error = {
      type: 'error',
      titleMessageID: 'Error',
      pagingMessageID: 'ErrorOnPage',
      errorsForm: true
    };
    this.ValidationTypes.alert = {
      type: 'alert',
      titleMessageID: 'Alert',
      pagingMessageID: 'AlertOnPage',
      errorsForm: false
    };
    this.ValidationTypes.confirm = {
      type: 'confirm',
      titleMessageID: 'Confirm',
      pagingMessageID: 'ComfirmOnPage',
      errorsForm: false
    };
    this.ValidationTypes.info = {
      type: 'info',
      titleMessageID: 'Info',
      pagingMessageID: 'InfoOnPage',
      errorsForm: false
    };
    this.ValidationTypes.icon = {
      type: 'icon',
      titleMessageID: 'Icon',
      pagingMessageID: 'IconOnPage',
      errorsForm: false,
      icon: 'user-profile'
    };

    this.rules = {
      required: {
        isNotEmpty: function isNotEmpty(value, field) {
          var supportsPlaceholder = !!('placeholder' in document.createElement('input'));

          if (!supportsPlaceholder && field && (value === field.attr('placeholder') || value === Locale.translate('Required'))) {
            return false;
          }

          if (typeof value === 'string') {
            // strip out any HTML tags and focus only on text content.
            value = $.trim(value.replace(/<\/?[^>]*>/g, ''));
            if ($.trim(value).length === 0) {
              return false;
            }
            return true;
          }

          if (typeof value === 'number') {
            if (isNaN(value)) {
              return false;
            }
            return true;
          }

          if ($.isArray(value)) {
            return value.length > 0;
          }

          return !!value;
        },


        // Check if at least one radio button checked in group
        isRadioChecked: function isRadioChecked(field) {
          var name = field.attr('name');
          return name && name.length && $('input[name="' + name + '"]:radio:checked').length;
        },
        check: function check(value, field) {

          this.message = Locale.translate('Required');
          var valid = true;

          valid = field.is(':radio') ? this.isRadioChecked(field) : this.isNotEmpty(value, field);
          return valid;
        },

        message: 'Required',
        type: 'error',
        id: 'required'
      },

      // date: Validate date, datetime (24hr or 12hr am/pm)
      date: {
        check: function check(value, field) {
          this.message = Locale.translate('InvalidDate');

          if (value instanceof Date) {
            return value && value.getTime && !isNaN(value.getTime());
          }

          var dateFormat = value.indexOf(':') > -1 ? Locale.calendar().dateFormat.datetime : Locale.calendar().dateFormat.short;

          if (field && field.data('datepicker')) {
            dateFormat = field.data('datepicker').pattern;
          }

          var isStrict = !(dateFormat === 'MMMM d' || dateFormat === 'yyyy');
          var parsedDate = Locale.parseDate(value, dateFormat, isStrict);
          return !(parsedDate === undefined && value !== '');
        },

        message: 'Invalid Date',
        type: 'error',
        id: 'date'
      },

      // Validate date, disable dates
      availableDate: {
        check: function check(value, field) {
          this.message = Locale.translate('UnavailableDate');
          var check = true;

          if (value !== '') {
            if (self.rules.date.check(value, field)) {
              // if valid date
              var datepickerApi = field.data('datepicker');
              var options = datepickerApi ? datepickerApi.settings : {};
              var hasOptions = Object.keys(options).length > 0;
              var d = void 0;
              var i = void 0;
              var l = void 0;
              var min = void 0;
              var max = void 0;
              var dateObj = value;
              if (typeof dateObj === 'string') {
                var format = options.dateFormat !== 'locale' ? options.dateFormat : Locale.calendar().dateFormat.short;
                if (options.showTime) {
                  var timeFormat = options.timeFormat || Locale.calendar().timeFormat;
                  format += ' ' + timeFormat;
                }
                dateObj = Locale.parseDate(dateObj, format);
              }
              var d2 = options.useUTC ? Locale.dateToUTC(dateObj) : dateObj;

              if (d2 && hasOptions) {
                min = options.useUTC ? Locale.dateToUTC(new Date(options.disable.minDate)).setHours(0, 0, 0, 0) : new Date(options.disable.minDate).setHours(0, 0, 0, 0);
                max = options.useUTC ? Locale.dateToUTC(new Date(options.disable.maxDate)).setHours(0, 0, 0, 0) : new Date(options.disable.maxDate).setHours(0, 0, 0, 0);

                // dayOfWeek
                if (options.disable.dayOfWeek.indexOf(d2.getDay()) !== -1) {
                  check = false;
                }

                d2 = d2.setHours(0, 0, 0, 0);

                // min and max
                if (d2 <= min || d2 >= max) {
                  check = false;
                }

                // dates
                if (options.disable.dates.length && typeof options.disable.dates === 'string') {
                  options.disable.dates = [options.disable.dates];
                }
                for (i = 0, l = options.disable.dates.length; i < l; i++) {
                  d = options.useUTC ? Locale.dateToUTC(options.disable.dates[i]) : new Date(options.disable.dates[i]);

                  if (d2 === d.setHours(0, 0, 0, 0)) {
                    check = false;
                    break;
                  }
                }
              }
              if (hasOptions) {
                check = !!(check && !options.disable.isEnable || !check && options.disable.isEnable);
              }
            } else {
              // Invalid date
              check = false;
              this.message = '';
            }
          }

          return check;
        },

        message: 'Unavailable Date',
        type: 'error',
        id: 'availableDate'
      },

      // Range date
      rangeDate: {
        check: function check(value, field) {
          var _this = this;

          this.message = Locale.translate('rangeDate');
          var check = true;
          var api = field.data('datepicker');
          if (api) {
            var s = api.settings;
            var parts = value.split(s.range.separator);
            var checkRule = function checkRule(rule, newvalue) {
              field.val(newvalue);
              _this.message = self.rules[rule].message + ' (' + newvalue + ')';
              if (!self.rules[rule].check(newvalue, field)) {
                check = false;
              }
            };
            if (parts.length === 2) {
              checkRule('date', parts[0]);
              if (check) {
                checkRule('date', parts[1]);
              }
              if (check) {
                checkRule('availableDate', parts[0]);
              }
              if (check) {
                checkRule('availableDate', parts[1]);
              }
            }
          }
          field.val(value);
          return check;
        },

        message: 'Range Dates',
        type: 'error',
        id: 'rangeDate'
      },

      email: {
        check: function check(value) {
          this.message = Locale.translate('EmailValidation');
          var regex = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,16}(?:\.[a-z]{2})?)$/i;

          return value.length ? regex.test(value) : true;
        },

        message: 'EmailValidation',
        type: 'error',
        id: 'email'
      },

      enableSubmit: {
        check: function check(value, field) {
          var submit = field.closest('.signin').find('button[type="submit"]');
          var ok = value.length && (self.rules.email.check(value) || self.rules.passwordConfirm.check(value, field));

          if (ok) {
            submit.enable();
          } else {
            submit.disable();
          }
          return true;
        },

        message: '',
        type: 'error',
        id: 'enableSubmit'
      },

      emailPositive: {
        check: function check(value, field) {
          if ($.trim(value).length && !field.is('[readonly]')) {
            self.rules.emailPositive.positive = true;
            this.message = Locale.translate('EmailValidation');

            var isValid = self.rules.email.check(value, field);

            if (isValid) {
              this.message = '';
            }

            return isValid;
          }
          self.rules.emailPositive.positive = false;
          return true;
        },

        message: 'EmailValidation',
        type: 'error',
        id: 'emailPositive'
      },

      passwordReq: {
        check: function check(value) {
          this.message = Locale.translate('PasswordValidation');
          /* Must be at least 10 characters which contain at least
          ** one lowercase letter,
          ** one uppercase letter,
          ** one numeric digit
          ** and one special character */
          var regex = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[^a-zA-Z0-9])(?!.*\s).{10,}$/;
          return value.length ? value.match(regex) : true;
        },

        message: 'PasswordValidation',
        type: 'error',
        id: 'passwordReq'
      },

      passwordConfirm: {
        check: function check(value, field) {
          this.message = Locale.translate('PasswordConfirmValidation');
          var passwordValue = $('input[type="password"]:not(' + field.attr('id') + ')', field.closest('.signin')).eq(0).val(),
              // eslint-disable-line
          check = value === passwordValue && self.rules.passwordReq.check(passwordValue); // eslint-disable-line
          return value.length ? check : true;
        },

        message: 'PasswordConfirmValidation',
        type: 'error',
        id: 'passwordConfirm'
      },

      time: {
        check: function check(value, field) {
          value = value.replace(/ /g, '');
          this.message = Locale.translate('InvalidTime');
          var timepicker = field && field.data('timepicker');
          var timepickerSettings = timepicker ? field.data('timepicker').settings : {};
          var pattern = timepickerSettings && timepickerSettings.timeFormat ? timepickerSettings.timeFormat : Locale.calendar().timeFormat;
          var is24Hour = (pattern.match('HH') || []).length > 0;
          var maxHours = is24Hour ? 24 : 12;
          var sep = value.indexOf(Locale.calendar().dateFormat.timeSeparator);
          var valueHours = 0;
          var valueMins = 0;
          var valueSecs = 0;
          var valueM = void 0;
          var timeparts = void 0;

          if (value === '') {
            return true;
          }

          valueHours = parseInt(value.substring(0, sep), 10);
          valueMins = parseInt(value.substring(sep + 1, sep + 3), 10);

          // getTimeFromField
          if (timepicker) {
            timeparts = timepicker.getTimeFromField();

            valueHours = timeparts.hours;
            valueMins = timeparts.minutes;

            if (timepicker.hasSeconds()) {
              valueSecs = timeparts.seconds;
            }
          }

          if (valueHours.toString().length < 1 || isNaN(valueHours) || parseInt(valueHours, 10) < 0 || parseInt(valueHours, 10) > maxHours) {
            return false;
          }
          if (valueMins.toString().length < 1 || isNaN(valueMins) || parseInt(valueMins, 10) < 0 || parseInt(valueMins, 10) > 59) {
            return false;
          }
          if (valueSecs.toString().length < 1 || isNaN(valueSecs) || parseInt(valueSecs, 10) < 0 || parseInt(valueSecs, 10) > 59) {
            return false;
          }

          // AM/PM
          if (!is24Hour) {
            if (parseInt(valueHours, 10) < 1) {
              return false;
            }
            var period0 = new RegExp(Locale.calendar().dayPeriods[0], 'i');
            var period1 = new RegExp(Locale.calendar().dayPeriods[1], 'i');

            valueM = value.match(period0) || value.match(period1) || [];
            if (valueM.length === 0) {
              return false;
            }
          }

          return true;
        },

        message: 'Invalid Time',
        type: 'error',
        id: 'time'
      },

      // Test validation function which always returns false
      test: {
        check: function check(value) {
          return value === '1';
        },

        message: 'Value is not valid (test).',
        type: 'error',
        id: 'test'
      }
    };
  }

  var Validation = new ValidationRules();

  // Component Name
  var COMPONENT_NAME$A = 'toast';

  // Default Component Settings
  var TOAST_DEFAULTS = {
    title: '(Title)',
    message: '(Content)',
    position: 'top right',
    audibleOnly: false,
    progressBar: true,
    timeout: 6000,
    allowLink: false
  };

  /**
   * Toast Component.  This component produces small, temporary messages in
   *  one of the application's corners.
   * @constructor
   * @param {HTMLElement} element the target location for the Toast message
   * @param {object} [settings] incoming settings
   * @param {string} [settings.title = '(Title)'] Text that is displayed in the Toast's title.
   * @param {string} [settings.message = '(Content)' ] Text that's displayed in the Toast's body.
   * @param {string} [settings.position = 'top right'] Text that propagates into CSS classes that position the Toast in specific places
   * Can be top left, bottom left, bottom rightx
   * @param {boolean} [settings.audibleOnly = false] if true, causes the toast to be invisble on the screen, but still read out lout by screen readers.
   * @param {boolean} [settings.progressBar = true] causes the toast to have a visible progress bar that will be completely
   * disappeared when the toast should be removed.
   * @param {number} [settings.timeout = 6000] the amount of time the toast should be present on-screen.
   * @param {boolean} [settings.allowLink = false] if true, allows user to put links in the toast message.
   */
  function Toast(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(element, settings, TOAST_DEFAULTS);
    this.init();
  }

  // Toast Methods
  Toast.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.show();
    },


    /**
     * Show a Single Toast Message
     * @private
     * @returns {void}
     */
    show: function show() {
      var self = this;
      var settings = self.settings;
      var maxHideTime = parseFloat(math.convertDelayToFPS(settings.timeout));
      var isPausePlay = false;
      var percentage = 100;
      var container = $('#toast-container');
      var toast = $('\n      <div class="toast">\n        <span class="toast-title">' + xssUtils.stripHTML(settings.title) + '</span>\n        <span class="toast-message">' + xssUtils.stripHTML(settings.message) + '</span>\n      </div>');
      if (settings.allowLink) {
        toast = $('\n        <div class="toast">\n          <span class="toast-title">' + xssUtils.stripHTML(settings.title) + '</span>\n          <span class="toast-message">' + xssUtils.stripTags(settings.message, '<a>') + '</span>\n        </div>');
      }
      var closeBtn = $('\n      <button type="button" class="btn-icon btn-close" title="' + Locale.translate('Close') + '" aria-hidden="true">\n        ' + $.createIcon('close') + '\n        <span class="audible">' + Locale.translate('Close') + '</span>\n      </button>\n    ');
      var progress = $('<div class="toast-progress"></div>');

      if (!container.length) {
        container = $('<div id="toast-container" class="toast-container" aria-relevant="additions" aria-live="polite"></div>').appendTo('body');
      }

      container.removeClass('toast-top-left toast-top-right toast-bottom-right toast-bottom-left').addClass('toast-' + settings.position.replace(' ', '-'));

      settings.timeout = settings.audibleOnly ? 100 : settings.timeout;

      if (settings.progressBar) {
        toast.append(progress);
      }

      // Build the RenderLoop integration
      var timer = new RenderLoopItem({
        duration: math.convertDelayToFPS(settings.timeout),
        timeoutCallback: function timeoutCallback() {
          self.remove(toast);
        },
        updateCallback: function updateCallback(data) {
          percentage = (data.duration - data.elapsedTime) / maxHideTime * 100;

          if (Locale.isRTL()) {
            percentage = 100 - percentage;
          }

          if (settings.progressBar) {
            progress[0].style.width = percentage + '%';
          }
        }
      });
      renderLoop.register(timer);

      container.append(toast);
      toast.addClass(settings.audibleOnly ? 'audible' : 'effect-scale');
      toast.append(closeBtn);

      $(document).on('keydown keyup', function (e) {
        e = e || window.event;
        if (e.ctrlKey && e.altKey && e.keyCode === 80) {
          // [Control + Alt + P] - Pause/Play toggle
          isPausePlay = e.type === 'keydown';
          timer[isPausePlay ? 'pause' : 'resume']();
        }
      });

      toast.on('mousedown.toast touchstart.toast mouseup.toast touchend.toast', function (e) {
        isPausePlay = !!/mousedown|touchstart/i.test(e.type);
        timer[isPausePlay ? 'pause' : 'resume']();
      });

      closeBtn.on('click', function () {
        timer.destroy();
        self.remove(toast);
      });
    },


    /**
     * Remove the Message and Animate
     * @private
     * @param {jQuery[]|HTMLElement} toast the toast message to be removed
     * @returns {void}
     */
    remove: function remove(toast) {
      if (this.settings.audibleOnly) {
        toast.remove();
        return;
      }

      toast.addClass('effect-scale-hide');

      var closeTimer = new RenderLoopItem({
        duration: 20,
        updateCallback: function updateCallback() {},
        // TODO: make this work without an empty function
        timeoutCallback: function timeoutCallback() {
          toast.remove();
        }
      });
      renderLoop.register(closeTimer);
    },


    /**
     * @param {object} [settings] incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, TOAST_DEFAULTS);
      }
      this.show();
    },


    /**
     * Teardown
     * @returns {void}
     */
    destroy: function destroy() {
      $('#toast-container').remove();
      $.removeData(this.element[0], COMPONENT_NAME$A);
    }
  };

  /**
   * jQuery Plugin Wrapper for Toast
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.toast = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$A);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$A, new Toast(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$B = 'Validator';

  /**
   * Validation Message Defaults
   * @namespace
   * @property {boolean} inline
   * @property {string} message
   * @property {string} type
   * @property {boolean} showTooltip
   */
  var VALIDATION_MESSAGE_DEFAULTS = {
    inline: true,
    message: '',
    type: 'error',
    showTooltip: false
  };

  /**
   * @class Validator
   * @constructor
   * @param {jQuery[]|HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   */
  function Validator(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, VALIDATION_MESSAGE_DEFAULTS);
    this.init();
  }

  // Plugin Object
  Validator.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.fields = 'input, textarea, select, div[data-validate], div[data-validation]';
      this.isPlaceholderSupport = !!('placeholder' in document.createElement('input')); // placeholder native support is-exists

      // If we initialize with a form find all inputs
      this.inputs = this.element.find(this.fields);

      // Or Just use the current input
      if (this.element.is(this.fields)) {
        this.inputs = $().add(this.element);
      }

      this.element.addClass('validation-active');
      this.timeout = null;

      this.attachEvents();
    },


    /**
     * Gets a list of events
     * @private
     * @param {string} events a single event name, or a JSON-representation of several events
     * @returns {void}
     */
    extractEvents: function extractEvents(events) {
      if (events.indexOf('{') > -1) {
        events = JSON.parse(events.replace(/'/g, '"'));
      }

      if ((typeof events === 'undefined' ? 'undefined' : _typeof(events)) === 'object') {
        var e = '';
        for (var k in events) {
          // eslint-disable-line
          if (e.indexOf(events[k]) === -1) {
            e += events[k] + ' ';
          }
        }
        e = e.split(' ').join('.validate ');
        events = e;
      }

      return events;
    },


    /**
     * @private
     * @param {string} events a single event name, or a JSON-representation of several events
     * @param {string} type a type of event to filter against
     * @returns {array} of event types in string format
     */
    filterValidations: function filterValidations(events, type) {
      var validations = [];

      if (!events) {
        return [];
      }

      if (events.indexOf('{') > -1) {
        events = JSON.parse(events.replace(/'/g, '"'));
      }

      if ((typeof events === 'undefined' ? 'undefined' : _typeof(events)) === 'object') {
        for (var k in events) {
          // eslint-disable-line
          if (type && events[k].indexOf(type) > -1) {
            validations.push(k);
          }
        }
      }

      return validations;
    },


    /**
     * @private
     */
    attachEvents: function attachEvents() {
      var self = this;
      var attribs = '[data-validate],[data-validation]';

      // Attach required
      this.inputs.each(function () {
        var field = $(this);
        var attr = field.attr('data-validate') || field.attr('data-validation');

        if (attr && attr.indexOf('required') > -1) {
          field.addClass('required');
        }
      });

      // Link on to the current object and perform validation.
      this.inputs.filter('input, textarea, div').filter(attribs).not('input[type=checkbox], input[type=file]').each(function () {
        var field = $(this);
        var eventAttr = field.attr('data-validation-events');
        var events = self.extractEvents(eventAttr || 'blur.validate change.validate keyup.validate');

        // Custom enter event
        if (events.indexOf('enter.validate') > -1) {
          field.off('keypress.enter.validate').on('keypress.enter.validate', function (e) {
            var thisField = $(this);
            if (e.which === 13) {
              self.validate(thisField, true, e);
            }
          });
        }

        field.off(events).on(events, function (e) {
          // Skip on Tab
          if (e.type === 'keyup' && e.keyCode === 9) {
            return;
          }

          var thisField = $(this);
          var handleEventData = thisField.data('handleEvent' + [e.type || '']);

          if (thisField.is('[readonly]') && !thisField.parent().is('.field-fileupload')) {
            return;
          }

          if (handleEventData && handleEventData.type === e.type && e.handleObj.namespace === 'validate' && !thisField.closest('.modal:visible').length) {
            return;
          }
          thisField.data('handleEvent' + [e.type || ''], e.handleObj);

          setTimeout(function () {
            if (thisField.closest('.modal-engaged').length && !thisField.closest('.modal-body').length) {
              return;
            }

            self.validate(field, true, e);
          }, 300);
        });
      });

      this.inputs.filter('input[type=checkbox]').filter(attribs).off('click.validate').on('click.validate', function (e) {
        self.validate($(this), true, e);
      });

      this.inputs.filter(':radio').off('click.validate').on('click.validate', function (e) {
        var first = $(this).parent().find('.radio').first();
        self.validate(first, true, e);
      });

      var selects = this.inputs.filter('select').filter(attribs);

      if (selects.length) {
        selects.off('change.validate listopened.validate listclosed.validate').on('change.validate', function (e) {
          self.validate($(this), true, e);
        }).on('listopened.validate', function () {
          var thisField = $(this);
          var tooltip = thisField.data('tooltip');

          thisField.next('.dropdown-wrapper').next('.error-message').hide();
          if (tooltip && document.activeElement === thisField.data('dropdown').searchInput[0]) {
            tooltip.hide();
          }
          $('#validation-tooltip').hide();
        }).on('listclosed.validate', function () {
          var thisField = $(this);
          var tooltip = thisField.data('tooltip');
          var dropdownApi = thisField.data('dropdown');

          if (Environment.features.touch) {
            dropdownApi.pseudoElem.focus();
            setTimeout(function () {
              dropdownApi.pseudoElem.blur();
            }, 100);
          }

          if (dropdownApi && dropdownApi.wrapper) {
            tooltip = dropdownApi.wrapper.find('.icon-error').data('tooltip');
          }

          thisField.next('.dropdown-wrapper').next('.error-message').show();
          if (tooltip && document.activeElement !== thisField.data('dropdown').searchInput[0]) {
            tooltip.show();
          }
        });

        selects.filter(function () {
          return $(this).data('dropdown') !== undefined;
        }).each(function () {
          var pseudoElem = $(this).data('dropdown').pseudoElem;
          pseudoElem.off('blur.validate').on('blur.validate', function (e) {
            var select = $(this).closest('.field, .field-short').find('select');
            self.validate(select, true, e);
          });
        });
      }

      // Attach to Form Submit and Validate
      if (this.element.is('form') && this.element.attr('data-validate-on')) {
        var submitHandler = function submitHandler(e) {
          e.stopPropagation();
          e.preventDefault();

          self.validateForm(function (isValid) {
            self.element.off('submit.validate');
            self.element.triggerHandler('validated', isValid);
            self.element.data('isValid', isValid);
            self.element.on('submit.validate', submitHandler);
          });
        };

        this.element.off('submit.validate').on('submit.validate', submitHandler);
      }
    },


    /**
     * Validates all elements inside of a form
     * @private
     * @param {function} callback method to call when the form's validation completes.
     */
    validateForm: function validateForm(callback) {
      var _$;

      var self = this;
      var deferreds = [];

      self.inputs = this.element.find(self.fields);
      self.inputs.each(function (e) {
        var field = $(this);
        if (field.attr('data-validate')) {
          if (field.attr('data-disable-validation') === 'true' || field.hasClass('disable-validation')) {
            return;
          }

          var dfds = self.validate(field, false, e);
          for (var i = 0; i < dfds.length; i++) {
            deferreds.push(dfds[i]);
          }
        }
      });

      (_$ = $).when.apply(_$, deferreds).then(function () {
        callback(true);
      }, function () {
        callback(false);
      });
    },


    /**
     * Set disable/enable primary button in modal
     * @private
     * @param {jQuery[]|HTMLElement} field the target element
     * @param {jQuery[]|HTMLElement} modalBtn the button that needs to be set to primary.
     * @returns {void}
     */
    setModalPrimaryBtn: function setModalPrimaryBtn(field, modalBtn) {
      var modal = field.closest('.modal');
      var modalFields = modal.find('[data-validate]:visible, select[data-validate], :checkbox[data-validate]');
      var allValid = true;

      if (modalFields.length > 0) {
        modalFields.each(function () {
          var modalField = $(this);

          if (modalField.closest('.datagrid-filter-wrapper').length > 0) {
            return;
          }
          var isVisible = modalField[0].offsetParent !== null;
          if (modalField.is('.required')) {
            if (isVisible && modalField.is('.editor') && !modalField.html()) {
              allValid = false;
            }
            if ((isVisible || modalField.is('select, :checkbox')) && !modalField.val() && !modalField.is('.editor')) {
              allValid = false;
            }
          }
          if ((isVisible || modalField.is('select, :checkbox')) && !modalField.isValid()) {
            allValid = false;
          }
        });
      }

      if (allValid) {
        modalBtn.removeAttr('disabled');
      } else {
        modalBtn.attr('disabled', 'disabled');
      }
    },


    /**
     * Gets the current value of a field
     * @private
     * @param {jQuery[]} field the field being checked.
     * @returns {any} the value of the field.
     */
    value: function value(field) {
      if (field.is('input[type=checkbox]')) {
        return field.prop('checked');
      }
      if (field.is('div')) {
        // contentEditable div (Rich Text)
        return field[0].innerHTML;
      }
      return field.val();
    },


    /**
     *
     * @private
     * @param {jQuery[]} field the field being checked
     * @param {jQuery.Event} e the `validate` event
     * @returns {array} an array of types
     */
    getTypes: function getTypes(field, e) {
      var filters = this.filterValidations(field.attr('data-validation-events'), e.type);
      var validations = void 0;

      if (field.is('input.dropdown') && field.prev().prev('select').attr('data-validate')) {
        validations = field.prev().prev('select').attr('data-validate').split(' ');
      } else if (field.is('input.dropdown') && field.prev().prev('select').attr('data-validation')) {
        validations = field.prev().prev('select').attr('data-validation').split(' ');
      } else if (field.attr('data-validation')) {
        validations = field.attr('data-validation').split(' ');
      } else if (field.attr('data-validate')) {
        validations = field.attr('data-validate').split(' ');
      } else {
        validations = [];
      }

      // Filter out not needed events
      if (filters.length > 0) {
        validations = validations.filter(function (n) {
          return filters.indexOf(n) !== -1;
        });
      }

      // Filter out specific events that should not use keyup
      if (e.type === 'keyup') {
        validations = validations.filter(function (n) {
          return n !== 'date' && n !== 'time';
        });
      }

      return validations;
    },


    /**
     * Set icon on parent tabs/expandable
     * @private
     * @param {jQuery[]} field the field being appended to.
     * @param {string} type the type of icon being appended.
     * @returns {void}
     */
    setIconOnParent: function setIconOnParent(field, type) {
      var errorIcon = $.createIcon({ classes: ['icon-' + type], icon: type });
      var parent = field.closest('.tab-panel, .expandable-pane');
      var iconTarget = parent.attr('id');
      var parentContainer = field.closest('.tab-container, .tab-panel-container, .expandable-area');
      var iconContainer = void 0;
      var dropdown = void 0;
      var dropdownParent = void 0;

      // Tabs
      if (parentContainer.is('.tab-panel-container')) {
        parentContainer = parentContainer.prev('.tab-container');
      }
      if (parentContainer.is('.tab-container')) {
        // Default Tabs
        iconContainer = $('.tab-list a[href="#' + iconTarget + '"]', parentContainer).closest('.tab');

        // Tabs with Counts
        if (iconContainer.length) {
          if ($('.count', iconContainer).length) {
            iconContainer = $('.count', iconContainer);
          }
        } else {
          // Dropdown Tabs (with popupmenu)
          iconTarget = $('a[href="#' + iconTarget + '"]', '.popupmenu').closest('.popupmenu').attr('id');
          iconContainer = $('.tab-list .tab[aria-controls="' + iconTarget + '"]', parentContainer);
          dropdown = iconTarget;
        }
      } else if (parentContainer.is('.expandable-area')) {
        // Expandable
        iconContainer = $('.expandable-header[aria-controls="' + iconTarget + '"] .title', parentContainer);
      } else {
        // No action
        return;
      }

      // if Dropdown Tabs set each menu item to check
      if (dropdown && dropdown.length) {
        dropdownParent = parent.add($($(dropdown).attr('href')));
        $('a[role="menuitem"]', '#' + dropdown).each(function () {
          dropdownParent = dropdownParent.add($($(this).attr('href')));
        });
      }
      var menuitem = $('a[href="#' + parent.attr('id') + '"]', '#' + iconTarget);

      // Add icon
      if (!!parent && $('.' + type, parent).length || !!dropdownParent && $('.' + type, dropdownParent).length) {
        // if Dropdown Tabs and current menu item has no error remove icon
        if (!$('.' + type, parent).length) {
          menuitem.removeClass('is-' + type);
          $('.icon-' + type, menuitem).remove();
        }

        // if Dropdown Tabs and current menu item has error add icon
        if ($('.' + type, parent).length && $('.' + type, dropdownParent).length && !$('.icon-' + type, menuitem).length) {
          menuitem.addClass('is-' + type).append(errorIcon);
        }

        // Add icon to main tab area
        if (!$('.icon-' + type, iconContainer).length) {
          iconContainer.addClass('is-' + type).append(errorIcon);
        }
      } else {
        // Remove icon
        iconContainer = iconContainer.add(menuitem);
        iconContainer.removeClass('is-' + type);
        $('.icon-' + type, iconContainer).remove();
      }
    },


    /**
     * @private
     * @param {jQuery[]} field the field being validated
     * @param {boolean} showTooltip whether or not this field should display its
     *  validation message in a tooltip
     * @param {jQuery.Event} e the `validate` event
     * @returns {array} of jQuery deferred objects
     */
    validate: function validate(field, showTooltip, e) {
      field.data('handleEvent' + [e.type || ''], null);

      if (field.attr('data-disable-validation') === 'true' || field.hasClass('disable-validation') || field.is(':disabled')) {
        return [];
      }

      // call the validation function inline on the element
      var self = this;
      var types = self.getTypes(field, e) || [];
      var rule = void 0;
      var dfd = void 0;
      var dfds = [];
      var results = [];
      var i = void 0;
      var l = void 0;
      var validationType = void 0;
      var value = self.value(field);
      var placeholder = field.attr('placeholder');

      function manageResult(result, showResultTooltip, type, dfrd) {
        rule = Validation.rules[type];
        // Only remove if "false", not any other value ie.. undefined
        if (rule.positive === false) {
          self.removePositive(field);
        }

        validationType = Validation.ValidationTypes[rule.type] || Validation.ValidationTypes.error;
        var isInline = field.attr('data-' + validationType.type + '-type') !== 'tooltip';

        if (!result) {
          if (!self.isPlaceholderSupport && value === placeholder && rule.message !== Locale.translate('Required')) {
            return;
          }
          self.addMessage(field, rule, isInline, showResultTooltip);
          results.push(rule.type);

          if (validationType.errorsForm) {
            dfrd.reject();
          } else {
            dfrd.resolve();
          }
        } else if ($.grep(results, function (res) {
          return res === validationType.type;
        }).length === 0) {
          dfrd.resolve();

          if (rule.positive) {
            // FIX: In Contextual Action Panel control not sure why but need to add error,
            // otherwise "icon-confirm" get misaligned,
            // so for this fix adding and then removing error here

            self.addMessage(field, rule, isInline, showResultTooltip);
            self.removeMessage(field, rule, true);
            dfrd.resolve();

            self.addPositive(field);
          }
        }

        self.setIconOnParent(field, rule.type);
        var loc = self.getField(field);
        var data = loc.data(validationType.type + 'message');

        if (result && data && data.filter(function (rules) {
          return rules.id === rule.id || rule.message;
        }).length > 0) {
          self.removeMessage(field, rule, true);
        }

        // Test Enabling primary button in modal
        var modalBtn = field.closest('.modal').find('.btn-modal-primary').not('.no-validation');
        if (modalBtn.length) {
          self.setModalPrimaryBtn(field, modalBtn);
        }

        if (rule.type === 'error') {
          field.closest('form').triggerHandler('aftervalidate', { field: field, rule: rule, isValid: result });
        }
      }

      for (i = 0, l = types.length; i < l; i++) {
        rule = Validation.rules[types[i]];

        dfd = $.Deferred();

        if (!rule) {
          continue;
        }

        if ($('#calendar-popup').is(':visible')) {
          continue; // dont show validation message while selecting
        }

        if (rule.async) {
          rule.check(value, field, manageResult, dfd);
        } else {
          manageResult(rule.check(value, field), showTooltip, types[i], dfd);
        }
        dfds.push(dfd);
      }

      return dfds;
    },


    /**
     * Retrive the actionble element that should have an error class/icon appended to it.
     * @private
     * @param {jQuery[]} field the field being checked
     * @returns {jQuery[]} the field to be checked
     */
    getField: function getField(field) {
      if (field.is('select') && field.data('dropdown') !== undefined) {
        field = field.data('dropdown').pseudoElem;
      }
      return field;
    },


    /**
     * Returns true if the given object has an error
     * @param {jQuery[]} field the field being checked
     * @returns {boolean} whether or not the field currently has an error
     */
    hasError: function hasError(field) {
      return this.getField(field).hasClass('error');
    },


    /**
     * Adds a validation message/icon to a form field.
     * @private
     * @param {jQuery[]} field the field to be appended
     * @param {object} rule The validation message text
     * @param {boolean} inline whether or not the text should appear inside the input field
     *  (like a placeholder), or underneath the input field
     * @param {boolean} showTooltip whether or not the legacy validation Tooltip will contain the
     * message instead of placing it underneath
     */
    addMessage: function addMessage(field, rule, inline, showTooltip) {
      if (rule.message === '') {
        return;
      }

      if (field.is('.dropdown, .multiselect') && $('#dropdown-list').is(':visible')) {
        return;
      }

      var loc = this.getField(field);
      var dataMsg = loc.data(rule.type + 'message');
      var validationType = Validation.ValidationTypes[rule.type] || Validation.ValidationTypes.error;

      loc.addClass(rule.type === 'icon' ? 'custom-icon' : rule.type);

      // Inline messages are now an array
      if (dataMsg && dataMsg === rule.message) {
        // No need to add new message
        return;
      }

      if (dataMsg && dataMsg.filter(function (rules) {
        return (rules.id || rules.message) === (rule.id || rule.message) && rules.message === rule.message;
      }).length > 0) {
        // No need to add new message
        return;
      }

      var appendedMsg = rule.message;

      if (dataMsg) {
        for (var i = 0; i < dataMsg.length; i++) {
          appendedMsg = '\u2022 ' + dataMsg[i].message;
        }
        appendedMsg += '<br>\u2022 ' + rule.message;
      }

      if (!dataMsg) {
        dataMsg = [];
      }

      // Find the message by id and remove
      field.closest('.field, .field-short').find('[data-rule-id="' + (rule.id || rule.message) + '"]').remove();
      if (field.hasClass('dropdown') || field.hasClass('multiselect')) {
        field.parent().find('.dropdown-wrapper > [data-rule-id="' + (rule.id || rule.message) + '"]').off('click.validate').remove();
      }

      // Remove the rule if it exists in the dataMsg
      dataMsg = dataMsg.filter(function (rules) {
        return rules.id !== rule.id;
      });

      dataMsg.push({ id: rule.id, message: rule.message, type: rule.type });
      loc.data(validationType.type + 'message', dataMsg);

      // Add Aria
      if ($.fn.toast !== undefined) {
        $('body').toast({
          title: Locale.translate(validationType.titleMessageID),
          audibleOnly: true,
          message: appendedMsg
        });
      }

      if (!inline) {
        this.showTooltipMessage(field, appendedMsg, validationType.type, showTooltip);
        return;
      }

      field.data('isValid', false);
      this.showInlineMessage(field, rule);
    },


    /**
     * Shows an error icon
     *
     * @private
     * @param {jQuery[]} field the field being appended
     * @param {string} type the error type
     * @returns {jQuery[]} the new icon's markup
     */
    showIcon: function showIcon(field, type) {
      var loc = this.getField(field).addClass(type === 'icon' ? 'custom-icon' : type);
      var svg = $.createIconElement({ classes: ['icon-' + type], icon: type });
      var closestField = loc.closest('.field, .field-short');
      var parent = field.parent();

      if (closestField.find('svg.icon-' + type).length === 0) {
        if (parent.is('.editor-container')) {
          field.parent().addClass('is-error');
        }

        if (field.parent(':not(.editor-container)').find('.btn-actions').length === 1) {
          parent.find('.btn-actions').before(svg);
        } else if (parent.find('.data-description').length === 1) {
          parent.find('.data-description').before(svg);
        } else if (parent.find('.field-info').length === 1) {
          parent.find('.field-info').before(svg);
        } else if (field.is('textarea')) {
          field.after(svg);
        } else if (field.is('.dropdown, .multiselect')) {
          parent.find('.dropdown-wrapper').append(svg);
        } else if (field.is('.spinbox')) {
          parent.append(svg);
        } else if (field.is('.lookup')) {
          parent.append(svg);
        } else {
          parent.append(svg);
        }

        $('.icon-confirm', closestField).remove();
      } else {
        svg = closestField.find('svg.icon-error');
      }

      return svg;
    },


    /**
     * Shows an tooltip error
     * @private
     * @param {jQuery[]} field the field being appended
     * @param {string} message text content containing the validation message.
     * @param {string} type the validation type (error, alert, info, etc)
     * @param {boolean} showTooltip whether or not to initially show the tooltip
     */
    showTooltipMessage: function showTooltipMessage(field, message, type, showTooltip) {
      if (field.is(':radio')) {
        return;
      }

      var icon = this.showIcon(field, type);
      var representationField = field;

      // Add error classes to pseudo-markup for certain controls
      if (field.is('.dropdown, .multiselect') && field.data('dropdown') !== undefined) {
        var input = field.data('dropdown').pseudoElem;
        representationField = input;
        input.addClass(type === 'icon' ? 'custom-icon' : type);
      }
      field.closest('.field, .field-short').find('.formatter-toolbar').addClass(type === 'icon' ? 'custom-icon' : type);

      var tooltipAPI = icon.data('tooltip');

      // Error tooltips should be positioned on the 'x' so that they sit directly
      // underneath the fields that they are indicating.
      function tooltipPositionCallback(placementObj) {
        var fieldRect = representationField[0].getBoundingClientRect();
        var elRect = tooltipAPI.tooltip[0].getBoundingClientRect();
        var rtl = $('html').is('[dir="rtl"]');
        var currX = placementObj.x;
        var xAdjustment = 0;

        if (rtl) {
          if (elRect.left < fieldRect.left) {
            xAdjustment += fieldRect.left - elRect.left;
          }
        } else if (elRect.right > fieldRect.right) {
          xAdjustment += (elRect.right - fieldRect.right) * -1;
        }

        placementObj.setCoordinate('x', currX + xAdjustment);
        if (!placementObj.nudges) {
          placementObj.nudges = {};
        }
        placementObj.nudges.x = xAdjustment;

        return placementObj;
      }

      // Build Tooltip
      if (!tooltipAPI) {
        icon.tooltip({
          content: message,
          placement: 'bottom',
          placementOpts: {
            callback: tooltipPositionCallback
          },
          trigger: 'focus',
          isError: true,
          tooltipElement: '#validation-tooltip'
        });
        tooltipAPI = icon.data('tooltip');
      } else {
        tooltipAPI.content = message;
      }

      field.on('focus.validate', function () {
        if (!tooltipAPI) {
          return;
        }
        tooltipAPI.show();
      }).on('blur.validate', function () {
        if (!tooltipAPI) {
          return;
        }
        tooltipAPI.hide();
      });

      if (tooltipAPI) {
        field.attr('data-error-type', 'tooltip');
      }

      if (showTooltip && tooltipAPI) {
        tooltipAPI.show();
      }
    },


    /**
     * Shows an tooltip error
     *
     * @private
     * @param {jQuery[]} field the field being toggled
     * @param {string} message text content containing the validation message
     * @param {string} type (error, alert, info, etc.)
     * @param {HTMLElement} markup existing HTML markup to use
     * @param {boolean} isShow whether or not the message is already showing
     */
    toggleRadioMessage: function toggleRadioMessage(field, message, type, markup, isShow) {
      var all = void 0;
      var loc = void 0;
      var name = field.attr('name');

      if (name && name.length) {
        all = $(':radio[name="' + name + '"], :radio[name="' + name + '"] + label');
        loc = field.parent().is('.inline') ? $(':radio[name="' + name + '"]:last').parent() : $(':radio[name="' + name + '"]:last + label');

        if (isShow) {
          all.addClass(type === 'icon' ? 'custom-icon' : type);
          $(markup).addClass('radio-group-' + type).insertAfter(loc);
        } else {
          all.removeClass(type);
          loc.next('.radio-group-' + type).remove();
        }
      }
    },


    /**
     * Shows an inline error message on a field
     * @private
     *
     * @param {jQuery[]} field the field being modified
     * @param {string} rule The validation rule data.
     * @param {string} type the validation type (error, warn, info, etc).
     * @param {string} icon if type is icon then here pass icon string
     */
    showInlineMessage: function showInlineMessage(field, rule) {
      var loc = this.getField(field);
      var validationType = Validation.ValidationTypes[rule.type] || Validation.ValidationTypes.error;
      rule.icon = rule.icon || validationType.icon;

      var markup = void 0;
      if (rule.type === 'icon') {
        markup = '' + ('<div class="custom-icon-message" data-rule-id="' + (rule.id || rule.message) + '">\n          ' + $.createIcon({ classes: ['icon-custom'], icon: rule.icon }) + '\n          <pre class="audible">\n            ' + Locale.translate(validationType.titleMessageID) + '\n          </pre>\n          <p class="message-text">' + rule.message + '</p>\n        </div>');
      } else {
        markup = '' + ('<div class="' + validationType.type + '-message" data-rule-id="' + (rule.id || rule.message) + '">\n          ' + $.createIcon({ classes: ['icon-' + validationType.type], icon: validationType.type }) + '\n          <pre class="audible">\n            ' + Locale.translate(validationType.titleMessageID) + '\n          </pre>\n          <p class="message-text">' + rule.message + '</p>\n        </div>');
      }

      loc.addClass(rule.type === 'icon' ? 'custom-icon' : rule.type);

      if (field.is(':radio')) {
        this.toggleRadioMessage(field, rule.message, validationType.type, markup, true);
      } else {
        // All other components
        loc.closest('.field, .field-short').find('.formatter-toolbar').addClass(validationType.type === 'icon' ? 'custom-icon' : validationType.type);
        loc.closest('.field, .field-short').append(markup);
        loc.closest('.field, .field-short').find('.colorpicker-container').addClass(validationType.type === 'icon' ? 'custom-icon' : validationType.type);
      }

      if (field.is('.spinbox')) {
        loc.closest('.spinbox-wrapper').addClass(validationType.type === 'icon' ? 'custom-icon' : validationType.type);
      }

      // Remove positive errors
      if (validationType.type === 'error') {
        field.parent().find('.icon-confirm').remove();
      }

      // Trigger an event
      field.triggerHandler(validationType.type, { field: field, message: rule.message });
      field.closest('form').triggerHandler(validationType.type, { field: field, message: rule.message });
    },


    /**
     * Shows an inline error message on a field
     * @private
     * @param {jQuery[]} field the field being modified
     */
    addPositive: function addPositive(field) {
      var svg = $.createIcon({ icon: 'confirm', classes: 'icon-confirm' });

      if (!$('.icon-confirm', field.parent('.field, .field-short')).length) {
        field.parent('.field, .field-short').append(svg);
      }
    },


    /**
     * Remove the message form the field if there is one and mark the field valid, if no other messages.
     * @private
     * @param {jQuery[]} field the field which is having its error removed
     * @param {string} rule The validation rule to remove
     * @param {boolean} triggerEvents If true events will be fired
    */
    removeMessage: function removeMessage(field, rule) {
      var triggerEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      // see if anything to remove
      var loc = this.getField(field);
      var oldData = loc.data(rule.type + 'message');
      var ruleId = rule.id || rule.message;

      if (!rule) {
        return;
      }

      if (rule.type === 'error' && !oldData || oldData.filter(function (rules) {
        return rules.id === ruleId;
      }).length === 0) {
        return;
      }

      // Remove the message from the array
      var newData = oldData.filter(function (rules) {
        return rules.id !== ruleId;
      });
      var noMoreMessages = newData.length === 0;

      if (noMoreMessages) {
        loc.removeData(rule.type + 'message');
      } else {
        loc.data(rule.type + 'message', newData);
      }

      // Find the message by id and remove
      field.closest('.field, .field-short').find('[data-rule-id="' + (rule.id || rule.message) + '"]').remove();

      if (field.hasClass('dropdown') || field.hasClass('multiselect')) {
        field.parent().find('.dropdown-wrapper > [data-rule-id="' + (rule.id || rule.message) + '"]').off('click.validate').remove();
      }

      // Trigger valid and remove error / message classes
      if (noMoreMessages && rule.type === 'error' && triggerEvents) {
        field.triggerHandler('valid', { field: field, message: '' });
        field.closest('form').triggerHandler('valid', { field: field, message: '' });
      }

      if (!noMoreMessages) {
        return;
      }

      field.removeClass(rule.type + ' custom-icon');
      loc.data('isValid', true);

      if (field.hasClass('dropdown') || field.hasClass('multiselect')) {
        field.next().next().removeClass(rule.type + ' custom-icon');
        field.next().find('div.dropdown').removeClass(rule.type + ' custom-icon');
      }

      if (field.is(':radio')) {
        this.toggleRadioMessage(field, '', rule.type, '', false);
      }

      if (field.hasClass('spinbox')) {
        field.closest('.spinbox-wrapper').removeClass(rule.type + ' custom-icon');
      }
      if (field.hasClass('colorpicker')) {
        field.parent('.colorpicker-container').removeClass(rule.type);
      }
      if (field.closest('.field-fileupload').length > 0) {
        field.closest('.field-fileupload').find('input.' + rule.type).removeClass(rule.type);
      }

      // Remove tooltip style message and tooltip
      if (loc.attr('data-' + rule.type + '-type') === 'tooltip') {
        var errorIcon = field.closest('.field, .field-short').find('.icon-error');
        var tooltipAPI = errorIcon.data('tooltip');
        // Destroy tooltip
        if (tooltipAPI) {
          tooltipAPI.destroy();
        }
        if (this.inputs) {
          this.inputs.filter('input, textarea').off('focus.validate');
        }
        // Remove icon
        field.parent().find('.dropdown-wrapper > .icon-' + rule.type).off('click.validate').remove(); // SVG Error Icon
        field.parent().find('.icon-' + rule.type).remove();
        field.next('.icon-' + rule.type).off('click.validate').remove();
        field.parent('.field, .field-short').find('.icon-' + rule.type).remove();
        field.next('.inforCheckboxLabel').next('.icon-' + rule.type).remove();
      }
    },


    /**
     * Shows an inline error message on a field
     * @private
     * @param {jQuery[]} field the field being modified
     */
    removePositive: function removePositive(field) {
      $('.icon-confirm', field.parent('.field, .field-short')).remove();
    },


    /**
     * Reset all form errors and values
     * @param {jQuery[]} form The form to reset.
     */
    resetForm: function resetForm(form) {
      var formFields = form.find('input, select, textarea');

      // Clear Errors
      formFields.removeClass('error');
      form.find('.error').removeClass('error');
      form.find('.icon-error').remove();
      form.find('.icon-confirm').remove();
      form.find('.error-message').remove();

      // Clear Warnings
      formFields.removeClass('alert');
      form.find('.alert').removeClass('alert');
      form.find('.icon-alert').remove();
      form.find('.alert-message').remove();

      // Clear Informations
      formFields.removeClass('info');
      form.find('.info').removeClass('info');
      form.find('.icon-info').remove();
      form.find('.info-message').remove();

      setTimeout(function () {
        $('#validation-errors').addClass('is-hidden');
      }, 300);

      // Remove Dirty
      formFields.data('isDirty', false).removeClass('isDirty');
      form.find('.isDirty').removeClass('isDirty');

      // reset form data
      if (form.is('form')) {
        form[0].reset();
      }

      var validationTypes = $.fn.validation.ValidationTypes;
      Object.keys(validationTypes).forEach(function (validationType) {
        formFields.removeData(validationType + 'message');
      });
    },


    /**
     * See if any form errors and check for any empty required fields.
     * @param {jQuery[]} form The form to check.
     * @returns {boolean} True if the form is valid, false otherwise.
     */
    isFormValid: function isFormValid(form) {
      if ($(form).find('.error-message').length > 0) {
        return false;
      }

      var formFields = $(form).find('[data-validate*="required"]');
      for (var i = 0; i < formFields.length; i++) {
        var field = $(formFields[i]);
        var value = this.value(field);

        if ((field.is(':visible') || field.is('select')) && !value) {
          return false;
        }
      }

      return true;
    },


    /**
     * Update method
     * @param {object} [settings] incoming settings
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }
    }
  };

  // Component Name
  var VALIDATE_COMPONENT_NAME = 'validate';

  // Settings specific to error messages.
  // Used for backwards compatibility.
  var ERROR_MESSAGE_DEFAULTS = {
    type: 'error',
    inline: true
  };

  /**
   * jQuery Component Wrapper for the Validation Component
   */
  $.fn.validation = Validation;

  /**
   * Returns the specific type message data object for a Field
   * @param {object} [settings] incoming settings
   * @returns {string} messages as a string for the specific type
   */
  $.fn.getMessage = function (settings) {
    if (!settings) {
      settings = { type: 'error' };
    }
    var dataAttr = settings.type + 'message';
    var messages = $.fn.getField($(this)).data(dataAttr);
    var strMessages = '';

    if (messages) {
      if (messages.length === 1) {
        return messages[0].message;
      }

      for (var i = 0; i < messages.length; i++) {
        strMessages += '\u2022 ' + messages[i].message;
      }
    }

    return strMessages;
  };

  /**
   * Returns all messages on an object as an array.
   * @param {object} [settings] incoming settings
   * @returns {array} message data for the specific type
   */
  $.fn.getMessages = function (settings) {
    if (!settings) {
      settings = { type: 'error' };
    }
    var dataAttr = settings.type + 'message';

    var messages = $.fn.getField($(this)).data(dataAttr);
    if (!messages) {
      messages = [];
    }
    return messages;
  };

  /**
   * Retrive the actionble element that should have an error class/icon appended to it.
   * @private
   * @param {jQuery[]} field the field being checked
   * @returns {jQuery[]} the field to be checked
   */
  $.fn.getField = function (field) {
    if (field.is('select') && field.data('dropdown') !== undefined) {
      field = field.data('dropdown').pseudoElem;
    }
    return field;
  };

  /**
   * Returns the errormessage data object for a Field
   * @deprecated as of v4.4.0
   * @param {object} [settings] incoming settings
   * @returns {object} error message data
   */
  $.fn.getErrorMessage = function (settings) {
    settings = utils.extend({}, settings, ERROR_MESSAGE_DEFAULTS);
    return $(this).getMessage(settings);
  };

  /**
   * ScrollIntoView and sets focus on an element
   * @param {boolean} [alignToTop] true (default) element will be aligned to the
   *  top of the visible area of the scrollable ancestor
   * @param {object} [settings] incoming settings
   */
  $.fn.scrollIntoView = function (alignToTop, settings) {
    if (typeof alignToTop !== 'boolean') {
      alignToTop = undefined;
    }

    var instance = new Validator(this, settings);
    var elem = instance.getField($(this));
    elem[0].scrollIntoView(alignToTop);
    elem.focus();
  };

  /**
   * Add a Message to a Field
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements receiving messages
   */
  $.fn.addMessage = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$B);
      if (!instance) {
        instance = $.data(this, COMPONENT_NAME$B, new Validator(this, settings));
      }

      var rule = {
        message: settings.message,
        type: settings.type,
        triggerEvents: settings.triggerEvents,
        icon: settings.icon,
        id: settings.id || settings.message
      };

      instance.addMessage($(this), rule, settings.inline, settings.showTooltip);
    });
  };

  /**
   * Add an error Message to a Field
   * @deprecated as of v4.4.0
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements receiving errors
   */
  $.fn.addError = function (settings) {
    var inline = true;
    if (typeof settings.inline === 'boolean' && settings.inline === false) {
      inline = false;
    }
    settings = utils.extend({}, settings, ERROR_MESSAGE_DEFAULTS);
    settings.inline = inline;
    return this.each(function () {
      $(this).addMessage(settings);
    });
  };

  /**
   * Remove a Message from a Field
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements having errors removed
   */
  $.fn.removeMessage = function (settings) {
    if (!settings) {
      settings = { type: 'error' };
    }

    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$B);
      if (!instance) {
        instance = $.data(this, COMPONENT_NAME$B, new Validator(this, settings));
      }

      var field = $(this);
      var dataAttr = settings.type + 'message';
      var errors = $.fn.getField(field).data(dataAttr);
      if (!errors) {
        return;
      }

      for (var i = 0; i < errors.length; i++) {
        instance.removeMessage(field, errors[i], settings.triggerEvents);
      }
      instance.setIconOnParent(field, settings.type);

      $.removeData(this, COMPONENT_NAME$B);
    });
  };

  /**
   * Remove an error Message from a Field
   * @deprecated as of v4.4.0
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements having errors removed
   */
  $.fn.removeError = function (settings) {
    settings = utils.extend({}, settings, ERROR_MESSAGE_DEFAULTS);
    return this.each(function () {
      return $(this).removeMessage(settings);
    });
  };

  /**
   * The Actual Validate Component
   * @param {object|string} [settings] incoming settings, or an API method name
   * @param {object} args that can be passed to an API method, if called via string settings
   * @returns {jQuery[]} components being acted on
   */
  $.fn.validate = function (settings, args) {
    var settingsAreAPIFunction = typeof settings === 'string';

    return this.each(function () {
      var instance = $.data(this, VALIDATE_COMPONENT_NAME);
      if (instance && typeof instance !== 'string') {
        // If settings are a string, assume the string is a function on the instance API
        // that needs to be called, and attempt to call it.
        if (settingsAreAPIFunction) {
          if (typeof instance[settings] === 'function') {
            instance[settings](args);
          } else {
            log('warn', 'No method with name "' + settings + '" found on "' + VALIDATE_COMPONENT_NAME + '" component API.');
          }
          return;
        }

        // Settings are object-based, and can be handled normally
        instance.updated(settings);
      } else {
        instance = $.data(this, VALIDATE_COMPONENT_NAME, new Validator(this, settings));
      }
    });
  };

  /**
   * Soho Validation Utilities
   * ========================================
   */

  /**
   * jQuery Utility function wrapper for checking whether or not a field passes validation.
   * @returns {boolean} whether or not the field is valid
   */
  $.fn.isValid = function () {
    var isValidAttr = $(this).data('isValid');
    return isValidAttr === undefined || isValidAttr === null ? true : isValidAttr;
  };

  /**
   * Check validation manually.
   * @returns {void}
   */
  $.fn.validateField = function () {
    var field = $(this);
    var api = Soho.components.Validator.prototype; //eslint-disable-line

    if (api && api.validate) {
      api.validate(field, false, 0);
    }
  };

  /**
   * Clear out the stuff on the Form
   */
  $.fn.resetForm = function () {
    var api = Soho.components.Validator.prototype; //eslint-disable-line
    api.resetForm(this);
  };

  // Component Name
  var COMPONENT_NAME$C = 'datepicker';

  /**
   * A component to support date entry.
   * @class DatePicker
   * @constructor
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {boolean} [settings.showTime=false] If true the time selector will be shown.
   * @param {boolean} [settings.useCurrentTime=false] If true current time will be used for the time portion otherwise 12:00 midnight is used
   * @param {string} [settings.timeFormat] Format to use time section fx HH:mm,
   *  defaults current locale settings.
   * @param {number} [settings.minuteInterval]
   * @param {number} [settings.secondInterval]
   * @param {string} [settings.mode] Time picker options: 'standard', 'range',
   *  this controls the time picker.
   * @param {boolean} [settings.roundToInterval] In time picker mode, if a non-matching
   *  minutes value is entered,
   *  rounds the minutes value to the nearest interval when the field is blurred.
   * @param {string} [settings.dateFormat='locale'] Defaults to current locale but can be
   * @param {string} [settings.placeholder=false] Text to show in input element while empty.
   * @param {object} [settings.disable] Disable dates in various ways.
   * For example `{minDate: 'M/d/yyyy', maxDate: 'M/d/yyyy'}`. Dates should be in format M/d/yyyy
   * or be a Date() object or string that can be converted to a date with new Date().
   * @param {array} [settings.disable.dates] Disable specific dates.
   * Example `{dates: ['12/31/2018', '01/01/2019'}`.
   * @param {string|date} [settings.disable.minDate] Disable up to a minimum date.
   * Example `{minDate: '12/31/2016'}`.
   * @param {string|date} [settings.disable.maxDate] Disable up to a maximum date.
   * Example `{minDate: '12/31/2019'}`.
   * @param {array} [settings.disable.dayOfWeek] Disable a specific of days of the week 0-6.
   * Example `{dayOfWeek: [0,6]}`.
   * @param {boolean} [settings.disable.isEnable=false] Inverse the disable settings.
   * If true all the disable settings will be enabled and the rest will be disabled.
   * So you can inverse the settings.
   * @param {boolean} [settings.disable.retrictMonths=false] Restrict month selections on datepicker.
   * It requires minDate and maxDate for the feature to activate.
   * For example if you have more non specific dates to disable then enable ect.
   * @param {boolean} [settings.showLegend=false] If true a legend is show to associate dates.
   * @param {boolean} [settings.customValidation=false] If true the internal validation is disabled.
   * @param {boolean} [settings.showMonthYearPicker=false] If true the month and year will render as dropdowns.
   * @param {boolean} [settings.hideDays=false] If true the days portion of the calendar will be hidden.
   *  Usefull for Month/Year only formats.
   * @param {number} [settings.advanceMonths=5] The number of months in each direction to show in
   *  the dropdown for months (when initially opening)
   * @param {array} [settings.legend]  Legend Build up
   * for example `[{name: 'Public Holiday', color: '#76B051', dates: []},
   * {name: 'Weekends', color: '#EFA836', dayOfWeek: []}]`
   * @param {object} [settings.range] Range between two dates with various options.
   * @param {boolean} [settings.range.useRange=false] Use range of two dates options.
   * @param {string|date} [settings.range.start] Start date in range.
   * @param {string|date} [settings.range.end] End date in range.
   * @param {string} [settings.range.separator=' - '] Visual separator between two dates.
   * @param {number} [settings.range.minDays=0] Minimum days to be in range.
   * @param {number} [settings.range.maxDays=0] Maximum days to be in range.
   * @param {boolean} [settings.range.selectForward=false] Range only in forward direction.
   * @param {boolean} [settings.range.selectBackward=false] Range only in backward direction.
   * @param {boolean} [settings.range.includeDisabled=false] Include disable dates in range of dates.
   * @param {string} [settings.calendarName] The name of the calendar to use in instance of
   * multiple calendars. At this time only ar-SA and ar-EG locales have either
   * 'gregorian' or 'islamic-umalqura' as valid values.
   * @param {boolean} [settings.useUTC=false] If true the dates will use UTC format. This is only partially
   * implemented https://jira.infor.com/browse/SOHO-3437
   * @param {boolean} [settings.autoSize=false] If true the field will be sized to the width of the date.
   * @param {boolean} [settings.hideButtons=false] If true bottom and next/prev buttons will be not shown.
   */
  var DATEPICKER_DEFAULTS = {
    showTime: false,
    useCurrentTime: false,
    timeFormat: undefined,
    minuteInterval: undefined,
    secondInterval: undefined,
    mode: undefined,
    roundToInterval: undefined,
    dateFormat: 'locale', // or can be a specific format
    placeholder: false,
    disable: {
      dates: [],
      minDate: '',
      maxDate: '',
      dayOfWeek: [],
      isEnable: false,
      restrictMonths: false
    },
    showLegend: false,
    customValidation: false,
    showMonthYearPicker: false,
    hideDays: false,
    advanceMonths: 5,
    legend: [
    // Legend Build up example
    // Color in level 6 - http://usmvvwdev53:424/controls/colors
    { name: 'Public Holiday', color: '#76B051', dates: [] }, { name: 'Weekends', color: '#EFA836', dayOfWeek: [] }],
    range: {
      useRange: false, // true - if datepicker using range dates
      start: '', // Start date '03/05/2018'
      end: '', // End date '03/21/2018'
      separator: ' - ', // separator string between two dates
      minDays: 0, // Minimum days
      maxDays: 0, // Maximum days
      selectForward: false, // Only in forward direction
      selectBackward: false, // Only in backward direction
      includeDisabled: false // if true range will include disable dates in it
    },
    calendarName: null,
    useUTC: false,
    autoSize: false,
    hideButtons: false
  };

  function DatePicker(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, DATEPICKER_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  DatePicker.prototype = {
    init: function init() {
      this.build();
      this.handleEvents();
    },


    /**
     * Add markup
     * @private
     * @returns {void}
     */
    build: function build() {
      // Add "is-disabled" css class to closest ".field" if element is disabled
      if (this.element.is(':disabled')) {
        this.element.closest('.field').addClass('is-disabled');
      }

      // Append a trigger button
      this.trigger = $.createIconElement('calendar').insertAfter(this.element);
      this.addAria();

      // Set the current calendar
      this.setCurrentCalendar();
      this.isIslamic = this.currentCalendar.name === 'islamic-umalqura';
      this.conversions = this.currentCalendar.conversions;
      this.isFullMonth = this.settings.dateFormat.indexOf('MMMM') > -1;
      this.setSize();
    },


    /**
     * Set current calendar
     * @private
     * @returns {void}
     */
    setCurrentCalendar: function setCurrentCalendar() {
      if (this.settings.calendarName) {
        this.currentCalendar = Locale.getCalendar(this.settings.calendarName) || Locale.calendar();
      } else {
        this.currentCalendar = Locale.calendar();
      }
    },


    /**
     * Set size attribute based on current contents
     * @private
     * @returns {void}
     */
    setSize: function setSize() {
      if (!this.settings.autoSize) {
        return;
      }
      var elem = this.element[0];
      var padding = 45;
      elem.classList.add('input-auto');
      elem.style.width = stringUtils.textWidth(elem.value, 16) + padding + 'px';
    },


    /**
     * Add aria
     * @private
     * @returns {void}
     */
    addAria: function addAria() {
      this.label = $('label[for="' + this.element.attr('id') + '"]');
      this.label.append('<span class="audible">' + Locale.translate('PressDown') + '</span>');
    },


    /**
     * Handle Keyboard Stuff
     * @private
     * @param {object} elem to handle.
     * @returns {void}
     */
    handleKeys: function handleKeys(elem) {
      var _this = this;

      var s = this.settings;
      var self = this;
      // Handle Keys while popup is open
      if (elem.is('#monthview-popup')) {
        elem.off('keydown.datepicker').on('keydown.datepicker', '.monthview-table', function (e) {
          var key = e.keyCode || e.charCode || 0;
          var cell = $(e.target);
          var allCell = _this.calendarAPI.days.find('td:visible');
          var allCellLength = allCell.length;
          var idx = null;
          var selector = null;
          var handled = false;
          var minDate = new Date(s.disable.minDate);
          var maxDate = new Date(s.disable.maxDate);

          self.calendarAPI.validatePrevNext();

          // Arrow Down: select same day of the week in the next week
          if (key === 40) {
            handled = true;
            if (s.range.useRange) {
              idx = allCell.index(e.target) + 7;
              selector = allCell.eq(idx);
              if (idx < allCellLength) {
                _this.calendarAPI.setRangeOnCell(selector.is('.is-selected') ? null : selector);
                _this.activeTabindex(selector, true);
              }
            } else if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
              if (_this.currentDate.getMonth() < maxDate.getMonth()) {
                _this.currentDate.setDate(_this.currentDate.getDate() + 7);
              } else if (maxDate.getDate() - 1 >= _this.currentDate.getDate() + 7) {
                _this.currentDate.setDate(_this.currentDate.getDate() + 7);
              }
              _this.insertDate(_this.currentDate);
            } else {
              _this.currentDate.setDate(_this.currentDate.getDate() + 7);
              _this.insertDate(_this.currentDate);
            }
          }

          // Arrow Up: select same day of the week in the previous week
          if (key === 38) {
            handled = true;
            if (s.range.useRange) {
              idx = allCell.index(e.target) - 7;
              selector = allCell.eq(idx);
              if (idx > -1) {
                _this.calendarAPI.setRangeOnCell(selector.is('.is-selected') ? null : selector);
                _this.activeTabindex(selector, true);
              }
            } else if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
              if (_this.currentDate.getMonth() > minDate.getMonth()) {
                _this.currentDate.setDate(_this.currentDate.getDate() - 7);
              } else if (minDate.getDate() + 1 <= _this.currentDate.getDate() - 7) {
                _this.currentDate.setDate(_this.currentDate.getDate() - 7);
              }
              _this.insertDate(_this.currentDate);
            } else {
              _this.currentDate.setDate(_this.currentDate.getDate() - 7);
              _this.insertDate(_this.currentDate);
            }
          }

          // Arrow Left
          if (key === 37) {
            handled = true;
            if (s.range.useRange) {
              idx = allCell.index(e.target) - 1;
              selector = allCell.eq(idx);
              if (idx > -1) {
                _this.calendarAPI.setRangeOnCell(selector.is('.is-selected') ? null : selector);
                _this.activeTabindex(selector, true);
              }
            } else if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
              if (_this.currentDate.getMonth() > minDate.getMonth()) {
                _this.currentDate.setDate(_this.currentDate.getDate() - 1);
              } else if (minDate.getDate() + 1 !== _this.currentDate.getDate()) {
                _this.currentDate.setDate(_this.currentDate.getDate() - 1);
              }
              _this.insertDate(_this.currentDate);
            } else {
              _this.currentDate.setDate(_this.currentDate.getDate() - 1);
              _this.insertDate(_this.currentDate);
            }
          }

          // Arrow Right
          if (key === 39) {
            handled = true;
            if (s.range.useRange) {
              idx = allCell.index(e.target) + 1;
              selector = allCell.eq(idx);
              if (idx < allCellLength) {
                _this.calendarAPI.setRangeOnCell(selector.is('.is-selected') ? null : selector);
                _this.activeTabindex(selector, true);
              }
            } else if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
              if (_this.currentDate.getMonth() < maxDate.getMonth()) {
                _this.currentDate.setDate(_this.currentDate.getDate() + 1);
              } else if (maxDate.getDate() - 1 !== _this.currentDate.getDate()) {
                _this.currentDate.setDate(_this.currentDate.getDate() + 1);
              }
              _this.insertDate(_this.currentDate);
            } else {
              _this.currentDate.setDate(_this.currentDate.getDate() + 1);
              _this.insertDate(_this.currentDate);
            }
          }

          // Page Up Selects Same Day Prev Month
          if (key === 33 && !e.altKey) {
            handled = true;
            if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
              if (minDate.getMonth() !== _this.currentDate.getMonth()) {
                _this.currentDate.setMonth(_this.currentDate.getMonth() - 1);
                _this.insertDate(_this.currentDate);
              }
            } else {
              _this.currentDate.setMonth(_this.currentDate.getMonth() - 1);
              _this.insertDate(_this.currentDate);
            }
          }

          // Page Down Selects Same Day Next Month
          if (key === 34 && !e.altKey) {
            handled = true;
            if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
              if (_this.currentDate.getMonth() !== maxDate.getMonth()) {
                _this.currentDate.setMonth(_this.currentDate.getMonth() + 1);
                _this.insertDate(_this.currentDate);
              }
            } else {
              _this.currentDate.setMonth(_this.currentDate.getMonth() + 1);
              _this.insertDate(_this.currentDate);
            }
          }

          // ctrl + Page Up Selects Same Day Next Year
          if (key === 33 && e.ctrlKey) {
            handled = true;
            _this.currentDate.setFullYear(_this.currentDate.getFullYear() + 1);
            _this.insertDate(_this.currentDate);
          }

          // ctrl + Page Down Selects Same Day Prev Year
          if (key === 34 && e.ctrlKey) {
            handled = true;
            _this.currentDate.setFullYear(_this.currentDate.getFullYear() - 1);
            _this.insertDate(_this.currentDate);
          }

          // Home Moves to Start of the month
          if (key === 36) {
            handled = true;
            var d = _this.currentDate;
            var firstDay = void 0;

            if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
              if (minDate.getMonth() !== _this.currentDate.getMonth()) {
                firstDay = new Date(d.getFullYear(), d.getMonth(), 1);
              } else {
                firstDay = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
                firstDay.setDate(firstDay.getDate() + 1);
              }
            } else {
              firstDay = new Date(d.getFullYear(), d.getMonth(), 1);
            }

            _this.currentDate = firstDay;
            _this.insertDate(_this.currentDate);
          }

          // End Moves to End of the month
          if (key === 35) {
            handled = true;
            var _d = _this.currentDate;
            var lastDay = void 0;
            if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
              if (_this.currentDate.getMonth() !== maxDate.getMonth()) {
                lastDay = new Date(_d.getFullYear(), _d.getMonth() + 1, 0);
              } else {
                lastDay = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate());
                lastDay.setDate(lastDay.getDate() - 1);
              }
            } else {
              lastDay = new Date(_d.getFullYear(), _d.getMonth() + 1, 0);
            }

            _this.currentDate = lastDay;
            _this.insertDate(_this.currentDate);
          }

          // 't' selects today
          if (key === 84) {
            handled = true;
            _this.setToday();
          }

          // Space or Enter closes Date Picker, selecting the Date
          if (key === 32 || key === 13) {
            handled = true;
            if (s.range.useRange) {
              if (!s.range.first || s.range.first && !s.range.first.date) {
                allCell.removeClass('is-selected');
              }
              var _d2 = _this.calendarAPI.getCellDate(cell);
              _this.currentDate = new Date(_d2.year, _d2.month, _d2.day);
              _this.insertDate(_this.currentDate);
            } else {
              _this.closeCalendar();
              _this.element.focus();
            }
          }

          // Tab closes Date Picker and goes to next field on the modal
          if (key === 9) {
            _this.containFocus(e);
            handled = true;
          }

          // Esc closes Date Picker and goes back to field
          if (key === 27) {
            _this.closeCalendar();
            _this.element.focus();
            e.stopImmediatePropagation();
            handled = true;
          }

          if (handled) {
            e.stopPropagation();
            e.preventDefault();
            return false;
          }

          return true;
        });

        elem.off('keydown.datepicker-tab').on('keydown.datepicker-tab', 'td, input, div.dropdown, button', function (e) {
          var key = e.keyCode || e.charCode || 0;

          // Tab closes Date Picker and goes to next field on the modal
          if (key === 9) {
            if (s.range.useRange && $(e.target).is('.next')) {
              _this.calendarAPI.days.find('td:visible:last').attr('tabindex', 0).focus();
            } else {
              _this.containFocus(e);
            }
            e.stopPropagation();
            e.preventDefault();
            return false;
          }
          return true;
        });

        return;
      }

      // Handle input keys
      elem.off('keydown.datepicker').on('keydown.datepicker', function (e) {
        var handled = false;
        var key = e.keyCode || e.charCode || 0;
        var focused = $(':focus');
        var focusedlabel = focused.attr('aria-label');

        // TODO: With new mask the code around key === 9 should not be needed.

        if (focusedlabel) {
          var focusedDate = new Date(focusedlabel);
          _this.currentDate = new Date(focusedDate.getTime());
        } else if (focused.hasClass('alternate')) {
          var year = parseInt(_this.calendarAPI.header.find('.year').text(), 10);
          var month = parseInt(_this.calendarAPI.header.find('.month').attr('data-month'), 10);
          var day = parseInt(focused.text(), 10);

          if (_this.settings.showMonthYearPicker) {
            month = parseInt(_this.calendarAPI.header.find('.month select').val(), 10);
            year = parseInt(_this.calendarAPI.header.find('.year select').val(), 10);
          }

          if (focused.hasClass('prev-month')) {
            if (month === 0) {
              month = 11;
              year--;
            } else {
              month--;
            }
          } else if (focused.hasClass('next-month')) {
            if (month === 11) {
              month = 0;
              year++;
            } else {
              month++;
            }
          }
          _this.currentDate = new Date(year, month, day);
        }

        // Arrow Down or Alt first opens the dialog
        if (key === 40 && !_this.isOpen()) {
          handled = true;
          _this.openCalendar();

          setTimeout(function () {
            _this.setFocusAfterOpen();
          }, 200);
        }

        // 't' selects today
        if (key === 84) {
          handled = true;
          _this.setToday();
        }

        if (handled) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }
        return true;
      });
    },


    /**
     * Focus the next prev focusable element on the popup
     * @private
     * @param {object} e event.
     * @returns {void}
     */
    containFocus: function containFocus(e) {
      var reverse = e.shiftKey;

      // Set focus on (opt: next|prev) focusable element
      var focusables = this.popup.find(':focusable');
      var index = focusables.index($(':focus'));

      if (!reverse) {
        index = index + 1 >= focusables.length ? 0 : index + 1;
      } else {
        index = index - 1 < 0 ? focusables.length : index - 1;
      }

      var elem = focusables.eq(index);
      elem.focus();

      if (elem.is('td')) {
        elem.addClass('is-selected' + (this.settings.range.useRange ? ' range' : ''));
        this.currentDate.setDate(elem.text());
        this.currentDate.setMonth(this.calendar.find('.month').attr('data-month'));
        this.insertDate(this.currentDate);
      }
    },


    /**
     * Parse the Date Format Options
     * @private
     * @returns {void}
     */
    setFormat: function setFormat() {
      var s = this.settings;
      var localeDateFormat = (typeof Locale === 'undefined' ? 'undefined' : _typeof(Locale)) === 'object' && this.currentCalendar.dateFormat ? this.currentCalendar.dateFormat : null;
      var localeTimeFormat = (typeof Locale === 'undefined' ? 'undefined' : _typeof(Locale)) === 'object' && this.currentCalendar.timeFormat ? this.currentCalendar.timeFormat : null;

      if ((typeof localeDateFormat === 'undefined' ? 'undefined' : _typeof(localeDateFormat)) === 'object' && localeDateFormat.short !== undefined) {
        localeDateFormat = localeDateFormat.short;
      }

      if (s.dateFormat === 'locale') {
        this.pattern = localeDateFormat + (s.showTime ? ' ' + (s.timeFormat || localeTimeFormat) : '');
      } else {
        this.pattern = s.dateFormat + (s.showTime && s.timeFormat ? ' ' + s.timeFormat : '');
      }

      this.show24Hours = (this.pattern.match('H') || []).length > 0;
      this.isSeconds = (this.pattern.match('ss') || []).length > 0;
    },


    /**
     * Add masking with the mask function
     * @private
     * @returns {void}
     */
    mask: function mask() {
      this.setFormat();
      var s = this.settings;
      var customValidation = this.element.attr('data-validate');
      var customEvents = this.element.attr('data-validation-events');
      var maskOptions = {
        process: 'date',
        keepCharacterPositions: true,
        patternOptions: {
          format: this.pattern
        }
      };
      var validation = 'date availableDate';
      var events = { date: 'change blur enter', availableDate: 'change blur' };

      if (s.range.useRange) {
        maskOptions.process = 'rangeDate';
        maskOptions.patternOptions.delimeter = s.range.separator;
        validation = 'rangeDate';
        events = { rangeDate: 'change blur' };
      }

      if (customValidation === 'required' && !customEvents) {
        validation = customValidation + ' ' + validation;
        $.extend(events, { required: 'change blur' });
      } else if (!!customValidation && !!customEvents) {
        // Remove default validation, if found "no-default-validation" string in "data-validate" attr
        if (customValidation.indexOf('no-default-validation') > -1) {
          validation = customValidation.replace(/no-default-validation/g, '');
          events = $.fn.parseOptions(this.element, 'data-validation-events');
        } else {
          // Keep default validation along custom validation
          validation = customValidation + ' ' + validation;
          $.extend(events, $.fn.parseOptions(this.element, 'data-validation-events'));
        }
      }

      maskOptions.processOnInitialize = false;

      if (this.isFullMonth) {
        this.pattern = this.settings.dateFormat;
      } else {
        this.element.mask(maskOptions);
      }

      if (!s.customValidation) {
        this.element.attr({
          'data-validate': validation,
          'data-validation-events': JSON.stringify(events)
        }).validate();
      }

      this.setPlaceholder();
    },


    /**
     * Set placeholder
     * @private
     * @returns {void}
     */
    setPlaceholder: function setPlaceholder() {
      var _this2 = this;

      var formatDate = function formatDate(d) {
        return Locale.formatDate(d, { pattern: _this2.pattern });
      };
      var s = this.settings;
      var placeholder = this.pattern;

      if (s.placeholder && (!this.element.attr('placeholder') || this.element.attr('placeholder') === 'M / D / YYYY')) {
        if (s.range.useRange) {
          placeholder = s.range.first && s.range.first.date ? formatDate(s.range.first.date) + s.range.separator + this.pattern : this.pattern + s.range.separator + this.pattern;
        }
        this.element[0].setAttribute('placeholder', placeholder);
      }
    },


    /**
     * Check if the calendar div is open or not
     * @private
     * @returns {boolean} whether or not the calendar div is open.
     */
    isOpen: function isOpen() {
      return this.popup && this.popup.is(':visible') && !this.popup.hasClass('is-hidden');
    },


    /**
     * Open the Calendar Popup.
     * @private
     * @deprecated
     * @returns {void}
     */
    open: function open() {
      this.openCalendar();
    },


    /**
     * Check if file type allowed
     * @private
     * @param {object} elem to set fouus
     * @param {boolean} isFocus true if need to set foucs
     * @returns {object} element passed in
     */
    activeTabindex: function activeTabindex(elem, isFocus) {
      $('td', this.calendarAPI).removeAttr('tabindex');
      elem.attr('tabindex', 0);

      if (isFocus) {
        elem.focus();
      }
      return elem;
    },


    /**
     * Open the calendar in a popup
     * @private
     * @returns {void}
     */
    openCalendar: function openCalendar() {
      var _this3 = this;

      var self = this;
      var s = this.settings;
      var timeOptions = {};

      if ((this.element.is(':disabled') || this.element.attr('readonly')) && this.element.closest('.monthview').length === 0) {
        return;
      }

      $('#validation-tooltip').addClass('is-hidden');

      /**
      * Fires as the calendar popup is opened.
      * @event listopened
      * @memberof DatePicker
      * @property {object} event - The jquery event object
      */
      this.element.addClass('is-active is-open').trigger('listopened');
      this.timepickerContainer = $('<div class="datepicker-time-container"></div>');
      this.footer = $('' + ('<div class="popup-footer">\n        <button type="button" class="cancel btn-tertiary">\n          ' + Locale.translate('Clear') + '\n        </button>\n        <button type="button" class="is-today btn-tertiary">\n          ' + Locale.translate('Today') + '\n        </button>\n      </div>'));

      if (s.hideDays) {
        this.footer = $('' + ('<div class="popup-footer">\n          <button type="button" class="select-month btn-tertiary">\n            ' + Locale.translate('Select') + '\n          </button>\n        </div>'));
      }

      if (s.hideButtons) {
        this.footer = $('');
      }

      // Timepicker options
      if (s.showTime) {
        if (s.timeFormat === undefined) {
          // Getting time-format from date-format (dateFormat: 'M/d/yyyy HH:mm:ss')
          timeOptions.timeFormat = this.pattern.slice(this.pattern.indexOf(' ')).trim();
        } else {
          timeOptions.timeFormat = s.timeFormat;
        }
        if (s.minuteInterval !== undefined) {
          timeOptions.minuteInterval = s.minuteInterval;
        }
        if (s.secondInterval !== undefined) {
          timeOptions.secondInterval = s.minuteInterval;
        }
        if (s.mode !== undefined) {
          timeOptions.mode = s.mode;
        }
        if (s.roundToInterval !== undefined) {
          timeOptions.roundToInterval = s.roundToInterval;
        }
      }

      this.calendarContainer = $('<div class="monthview-container"></div>');

      // Show Month
      this.setValueFromField();

      // Set timepicker
      if (this.settings.showTime) {
        // Set to 12:00
        if (this.element.val() === '' && this.currentDate && this.currentDate.getDate() && !this.settings.useCurrentTime) {
          this.currentDate.setHours(0);
          this.currentDate.setMinutes(0);
          this.currentDate.setSeconds(0);
        }

        timeOptions.parentElement = this.timepickerContainer;
        this.time = this.getTimeString(this.currentDate, this.show24Hours);
        this.timepicker = this.timepickerContainer.timepicker(timeOptions).data('timepicker');
        this.timepickerContainer.find('.dropdown').dropdown();

        this.timepickerContainer.on('change.datepicker', function () {
          _this3.currentDate = _this3.setTime(_this3.currentDate);
          _this3.setValue(_this3.currentDate, true, true);
        });

        // Wait for timepicker to initialize
        setTimeout(function () {
          _this3.timepicker.initValues = _this3.timepicker.getTimeFromField(_this3.time);
          _this3.timepicker.afterShow(_this3.timepickerContainer);
          return; // eslint-disable-line
        }, 1);
      }

      this.todayDate = new Date();
      this.todayMonth = this.todayDate.getMonth();
      this.todayYear = this.todayDate.getFullYear();
      this.todayDay = this.todayDate.getDate();

      if (this.isIslamic) {
        this.todayDateIslamic = this.conversions.fromGregorian(this.todayDate);
        this.todayYear = this.todayDateIslamic[0];
        this.todayMonth = this.todayDateIslamic[1];
        this.todayDay = this.todayDateIslamic[2];
      }

      this.settings.month = this.currentMonth;
      this.settings.year = this.currentYear;
      this.settings.activeDate = this.currentDate;

      this.settings.activeDateIslamic = this.currentIslamicDate || this.todayDateIslamic;
      this.settings.isPopup = true;
      this.settings.headerStyle = 'simple';
      this.calendarAPI = new MonthView(this.calendarContainer, this.settings);
      this.calendar = this.calendarAPI.element;

      if (s.showTime) {
        this.calendar.addClass('is-timepicker');
      }
      if (s.hideDays) {
        this.calendar.addClass('is-monthyear');
      }
      this.calendar.append(s.showTime ? this.timepickerContainer : '', this.footer);

      var placementParent = this.element;
      var placementParentXAlignment = Locale.isRTL() ? 'right' : 'left';
      var parent = this.element.parent();

      if (parent.is('.datagrid-cell-wrapper')) {
        placementParentXAlignment = 'center';
        placementParent = this.element.next('.icon');
      }

      var popoverOpts = {
        content: this.calendar,
        placementOpts: {
          parent: placementParent,
          parentXAlignment: placementParentXAlignment,
          strategies: ['flip', 'nudge', 'shrink']
        },
        placement: 'bottom',
        popover: true,
        trigger: 'immediate',
        extraClass: 'monthview-popup',
        tooltipElement: '#monthview-popup',
        initializeContent: false
      };

      this.trigger.popover(popoverOpts).off('show.datepicker').on('show.datepicker', function () {
        if (Environment.os.name === 'ios') {
          $('head').triggerHandler('disable-zoom');
        }

        // Horizontal view on mobile
        if (window.innerHeight < 400 && _this3.popupClosestScrollable) {
          _this3.popup.find('.arrow').hide();
          _this3.popup.css('min-height', _this3.popupClosestScrollable[0].scrollHeight + 2 + 'px');
          _this3.popupClosestScrollable.css('min-height', '375px');
        }

        // Hide calendar until range to be pre selected
        if (s.range.useRange && s.range.first && s.range.first.date && s.range.second && s.range.second.date) {
          _this3.popup.addClass('is-hidden');
        }

        if (_this3.settings.hideButtons) {
          _this3.popup.addClass('hide-buttons');
        }
      }).off('hide.datepicker').on('hide.datepicker', function () {
        if (Environment.os.name === 'ios') {
          _this3.trigger.one('hide', function () {
            $('head').triggerHandler('enable-zoom');
          });
        }

        _this3.popupClosestScrollable.add(_this3.popup).css('min-height', '');
        _this3.closeCalendar();
      });

      this.handleKeys($('#monthview-popup'));
      $('.monthview-footer a', this.calendar).button();

      this.popup = $('#monthview-popup');
      this.popupClosestScrollable = this.popup.closest('.scrollable');
      this.popup.attr('role', 'dialog');
      this.originalDate = this.element.val();

      // Calendar Day Events
      this.calendarAPI.days.off('click.datepicker').on('click.datepicker', 'td', function () {
        var td = $(this);
        if (td.hasClass('is-disabled')) {
          self.activeTabindex(td, true);
        } else {
          if (!(s.range.useRange && s.range.first)) {
            self.calendarAPI.days.find('.is-selected').removeClass('is-selected range').removeAttr('aria-selected');
          }

          var cell = $(this);
          cell.addClass('is-selected' + (s.range.useRange ? ' range' : '')).attr('aria-selected', 'true');

          var cellDate = self.calendarAPI.getCellDate(cell);
          var day = cellDate.day;
          var month = cellDate.month;
          var year = cellDate.year;

          self.currentDate = new Date(year, month, day);

          if (self.isIslamic) {
            self.currentDateIslamic[0] = year;
            self.currentDateIslamic[1] = month;
            self.currentDateIslamic[2] = day;
            self.currentYear = year;
            self.currentMonth = month;
            self.currentDay = day;
            self.currentDate = self.conversions.toGregorian(year, month, day);
          }

          self.insertDate(self.isIslamic ? self.currentDateIslamic : self.currentDate);

          if (s.range.useRange) {
            self.isFocusAfterClose = true;
          } else {
            self.closeCalendar();
            self.element.focus();
          }
        }
      });

      // Calendar Footer Events
      this.footer.off('click.datepicker').on('click.datepicker', 'button', function (e) {
        var btn = $(this);

        if (btn.hasClass('cancel')) {
          /**
          * Fires after the value in the input is changed by any means.
          *
          * @event change
          * @memberof DatePicker
          * @property {object} event - The jquery event object
          */
          self.element.val('').trigger('change').trigger('input');
          self.currentDate = null;
          self.closeCalendar();
        }

        if (btn.hasClass('select-month')) {
          var year = parseInt(self.calendarAPI.header.find('.year select').val(), 10);
          var month = parseInt(self.calendarAPI.header.find('.month select').val(), 10);

          self.currentDate = new Date(year, month, 1);

          if (self.isIslamic) {
            self.currentDateIslamic[0] = year;
            self.currentDateIslamic[1] = month;
            self.currentDateIslamic[2] = 1;
            self.currentYear = year;
            self.currentMonth = month;
            self.currentDay = 1;
            self.currentDate = self.conversions.toGregorian(year, month, 1);
          }

          self.insertDate(self.isIslamic ? self.currentDateIslamic : self.currentDate);
          if (s.range.useRange) {
            self.isFocusAfterClose = false;
          } else {
            self.closeCalendar();
          }
        }

        if (btn.hasClass('is-today')) {
          self.setToday();
          if (!s.range.useRange) {
            self.closeCalendar();
          }
        }
        self.element.focus();
        e.preventDefault();
      });

      setTimeout(function () {
        self.setFocusAfterOpen();
      }, 50);
    },


    /**
     * Close the calendar popup.
     * @private
     * @deprecated
     * @returns {void}
     */
    close: function close() {
      this.closeCalendar();
    },


    /**
     * Close the calendar in a popup
     * @private
     * @returns {void}
     */
    closeCalendar: function closeCalendar() {
      // Remove range entries
      var cell = this.calendarAPI && this.calendarAPI.days.length ? this.calendarAPI.days.find('td.is-selected') : null;
      this.resetRange(cell);

      // Close timepicker
      if (this.settings.showTime && this.timepickerControl && this.timepickerControl.isOpen()) {
        this.timepickerControl.closeTimePopup();
      }

      if (this.popup && this.popup.length) {
        this.popup.hide().remove();
      }

      var popoverAPI = this.trigger.data('tooltip');
      if (popoverAPI) {
        popoverAPI.destroy();
      }

      if (this.element.hasClass('is-active')) {
        /**
        * Fires as the calendar popup is closed.
        *
        * @event listclosed
        * @memberof DatePicker
        * @property {object} event - The jquery event object
        */
        this.element.trigger('listclosed');
        this.element.removeClass('is-active is-open');
      }
    },


    /**
     * Set focus after opening the calendar
     * @private
     * @returns {void}
     */
    setFocusAfterOpen: function setFocusAfterOpen() {
      var s = this.settings;
      if (!this.calendar) {
        return;
      }

      if (s.hideDays) {
        this.calendar.find('div.dropdown:first').focus();
        return;
      }

      if (s.range.useRange) {
        if (s.range.first && s.range.first.label && (!s.range.second || s.range.second && !s.range.second.date)) {
          this.setRangeFirstPart(s.range.first.date);
        }
        this.calendarAPI.setRangeSelected();
        if (s.range.second && s.range.first.date && s.range.second.date) {
          this.element.val(this.getRangeValue());
        }
        // Pre selection compleated now show the calendar
        this.popup.removeClass('is-hidden');
      }
      this.activeTabindex(this.calendar.find('.is-selected'), true);
    },


    /**
     * Set range first part
     * @private
     * @param {object} date .
     * @returns {void}
     */
    setRangeFirstPart: function setRangeFirstPart(date) {
      var s = this.settings;
      var dateObj = function dateObj(d) {
        return new Date(d.year, d.month, d.day);
      };
      var labelDate = function labelDate(d) {
        return Locale.formatDate(d, { date: 'full' });
      };
      var minCell = this.calendarAPI.days.find('td:visible:first');
      var maxCell = this.calendarAPI.days.find('td:visible:last');
      var label = labelDate(date);
      var cell = this.calendarAPI.days.find('[aria-label="' + label + '"]');
      var row = cell.closest('tr');
      this.currentDate = date;

      s.range.first = { date: date, label: label, cell: cell, row: row, rowIdx: row.index(), cellIdx: cell.index() };
      s.range.extra = {
        minCell: minCell,
        maxCell: maxCell,
        min: dateObj(this.calendarAPI.getCellDate(minCell)),
        max: dateObj(this.calendarAPI.getCellDate(maxCell)),
        cellLength: row.children('td').length
      };
      this.calendarAPI.settings.range.first = s.range.first;
      this.calendarAPI.settings.range.extra = s.range.extra;
    },


    /**
     * Put the date in the field and select on the calendar
     * @private
     * @param {object} date .
     * @param {boolean} isReset .
     * @returns {void}
     */
    insertDate: function insertDate(date, isReset) {
      var s = this.settings;
      var month = date instanceof Array ? date[1] : date.getMonth();
      var year = date instanceof Array ? date[0] : date.getFullYear();
      var day = (date instanceof Array ? date[2] : date.getDate()).toString();

      // Make sure Calendar is showing that month
      if (this.calendarAPI.currentMonth !== month || this.calendarAPI.currentYear !== year) {
        this.calendarAPI.showMonth(month, year);
      }

      if (!this.isOpen()) {
        return;
      }

      // Show the Date in the UI
      var dateTd = this.calendarAPI.days.find('td:not(.alternate)').filter(function () {
        return $(this).text().toLowerCase() === day;
      });

      if (dateTd.hasClass('is-disabled')) {
        this.activeTabindex(dateTd, true);
      } else {
        if (this.settings.showTime) {
          if (isReset) {
            this.time = this.getTimeString(date, this.show24Hours);

            if (this.settings.roundToInterval) {
              $('#timepicker-minutes').val('');
              date = this.setTime(date);
            }
          } else {
            date = this.setTime(date);
          }
        }

        this.setValue(date, true);
        if (s.range.useRange) {
          this.calendarAPI.days.find('.is-selected').removeAttr('aria-selected').removeAttr('tabindex');
        } else {
          this.calendarAPI.days.find('.is-selected').removeClass('is-selected range').removeAttr('aria-selected').removeAttr('tabindex');
        }
        dateTd.addClass('is-selected' + (s.range.useRange ? ' range' : '')).attr({ 'aria-selected': true });
        this.activeTabindex(dateTd, true);
      }
    },


    /**
     * Set the Formatted value in the input
     * @private
     * @param {object} date The date to set in date format.
     * @param {boolean} trigger If true will trigger the change event.
     * @param {boolean} isTime will pass to set range.
     * @returns {void}
     */
    setValue: function setValue(date, trigger, isTime) {
      var s = this.settings;
      this.currentDate = date;

      if (date instanceof Array) {
        this.currentIslamicDate = date;
        this.currentDate = this.conversions.toGregorian(date[0], date[1], date[2]);
        date = new Date(date[0], date[1], date[2]);
      }

      if (s.range.useRange) {
        if (!isTime) {
          this.setRangeToElem(date, false);
        }
      } else {
        this.element.val(Locale.formatDate(date, { pattern: this.pattern }));
      }

      if (trigger) {
        if (s.range.useRange) {
          if (!isTime) {
            this.element.trigger('change', [s.range.data]).trigger('input', [s.range.data]);
          }
        } else {
          this.element.trigger('change').trigger('input');
        }
      }

      this.setSize();
    },


    /**
     * Set range value to element
     * @private
     * @param {object} date .
     * @param {boolean} isSingleDate .
     * @returns {void}
     */
    setRangeToElem: function setRangeToElem(date, isSingleDate) {
      var _this4 = this;

      var s = this.settings;
      var formatDate = function formatDate(d) {
        return Locale.formatDate(d, { pattern: _this4.pattern });
      };
      var labelDate = function labelDate(d) {
        return Locale.formatDate(d, { date: 'full' });
      };
      var value = formatDate(date);
      var handled = false;

      // Closed calendar
      if (!this.isOpen() && !isSingleDate) {
        handled = true;
        var d = date || new Date();
        this.currentMonth = d.getMonth();
        this.currentYear = d.getFullYear();
        this.currentDay = d.getDate();
        this.currentDate = d;

        s.range.first = s.range.first || {};
        s.range.second = s.range.second || {};
        s.range.first.date = d;
        s.range.second.date = d;
        value = this.getRangeValue();
      } else {
        // Opened calendar
        var label = labelDate(date);
        var cell = this.calendarAPI.days.find('[aria-label="' + label + '"]');
        var row = cell.closest('tr');

        if (s.range.second) {
          this.resetRange(cell);
        }

        var time = {};
        if (s.range.first) {
          time.date = date.getTime();
          time.firstdate = s.range.first.date.getTime();
          time.min = this.calendarAPI.getDifferenceToDate(s.range.first.date, s.range.minDays);
          time.max = this.calendarAPI.getDifferenceToDate(s.range.first.date, s.range.maxDays);
        }

        if (!s.range.first || isSingleDate) {
          this.setRangeFirstPart(date);
          value = this.getRangeValue();
          this.setPlaceholder();
        } else if (!s.range.second && s.range.selectBackward && time.date > time.firstdate || s.range.selectForward && time.date < time.firstdate || s.range.maxDays > 0 && time.date > time.max.aftertime || time.date < time.max.beforetime) {
          this.resetRange(cell);
          this.setRangeFirstPart(date);
          value = this.getRangeValue();
          this.setPlaceholder();
        } else {
          // Set second part for range
          handled = true;
          this.currentDate = date;
          // minDays
          if (s.range.minDays > 0) {
            if (time.date > time.firstdate && time.date < time.min.aftertime) {
              date = time.min.after;
            } else if (time.date < time.firstdate && time.date > time.min.beforetime) {
              date = time.min.before;
            }
            cell = this.calendarAPI.days.find('[aria-label="' + label + '"]');
            row = cell.closest('tr');
          }
          if (time.date > time.firstdate) {
            s.range.second = { date: date, label: label, cell: cell, row: row, rowIdx: row.index(), cellIdx: cell.index() };
          } else {
            s.range.second = s.range.first;
            s.range.first = { date: date, label: label, cell: cell, row: row, rowIdx: row.index(), cellIdx: cell.index() };
          }
          value = this.getRangeValue();
        }
      }

      // Set range value(first only or both parts) on element
      this.element.val(value);

      // Set data to use in triggerHandler
      if (!handled) {
        s.range.data = {
          value: value,
          dates: [s.range.first.date],
          startDate: s.range.first.date,
          start: formatDate(s.range.first.date)
        };
      } else {
        s.range.data = {
          value: value,
          dates: this.calendarAPI.getDateRange(s.range.first.date, s.range.second.date),
          startDate: s.range.first.date,
          start: formatDate(s.range.first.date),
          endDate: s.range.second.date,
          end: formatDate(s.range.second.date)
        };

        this.closeCalendar();
        if (this.isFocusAfterClose) {
          delete this.isFocusAfterClose;
          this.element.focus();
        }
      }
    },


    /**
     * Reset range values
     * @private
     * @param {object} cell to keep selection.
     * @returns {void}
     */
    resetRange: function resetRange(cell) {
      if (this.settings.range.useRange) {
        delete this.settings.range.first;
        delete this.settings.range.second;
        delete this.settings.range.extra;
        if (this.calendarAPI) {
          delete this.calendarAPI.settings.range.first;
          delete this.calendarAPI.settings.range.second;
          delete this.calendarAPI.settings.range.extra;
        }
        if (this.calendarAPI && this.calendarAPI.days.length) {
          this.calendarAPI.days.find('td').removeClass('range range-next range-prev range-selection end-date is-selected');
        }
        if (cell) {
          cell.addClass('is-selected');
        }
      }
    },


    /**
     * Set the range value from the field
     * @private
     * @returns {void}
     */
    setRangeValueFromField: function setRangeValueFromField() {
      var _this5 = this;

      var formatDate = function formatDate(d) {
        return Locale.formatDate(d, { pattern: _this5.pattern });
      };
      var parseDate = function parseDate(d) {
        return Locale.parseDate(d, _this5.pattern, false);
      };
      var getTime = function getTime(d) {
        return d && typeof d.getTime === 'function' ? d.getTime() : new Date().getTime();
      };
      var alignDates = function alignDates(dates) {
        var d1 = parseDate(dates[0]);
        var d2 = parseDate(dates[1]);
        if (d1 && d2) {
          d1 = getTime(d1);
          d2 = getTime(d2);
          return d1 > d2 ? [dates[1], dates[0]] : [dates[0], dates[1]];
        }
        return dates;
      };
      var s = this.settings;
      var field = {};

      field.value = s.range.value || this.element.val().trim();
      field.isEmpty = field.value === '';

      // Field value dates
      if (!field.isEmpty && field.value.indexOf(s.range.separator) > -1) {
        field.dates = alignDates(field.value.split(s.range.separator));
      } else if (!field.isEmpty && field.value.indexOf(s.range.separator.slice(0, -1)) > -1) {
        field.dates = field.value.split(s.range.separator.slice(0, -1));
      }

      // Start/End dates
      if (!s.range.data && s.range.start && s.range.end && field.isEmpty) {
        var dates = void 0;
        if (typeof s.range.start === 'string' && typeof s.range.end === 'string') {
          dates = alignDates([s.range.start, s.range.end]);
        } else if (typeof s.range.start !== 'string' && typeof s.range.end === 'string') {
          dates = alignDates([formatDate(s.range.start), s.range.end]);
        } else if (typeof s.range.start === 'string' && typeof s.range.end !== 'string') {
          dates = alignDates([s.range.start, formatDate(s.range.end)]);
        } else {
          dates = alignDates([formatDate(s.range.start), formatDate(s.range.end)]);
        }
        s.range.start = formatDate(dates[0]);
        s.range.end = formatDate(dates[1]);
      }

      s.range.first = s.range.first || {};
      s.range.second = s.range.second || {};

      // Start date
      if (s.range.data && s.range.data.startDate) {
        s.range.first.date = s.range.data.startDate;
      } else if (s.range.start && typeof s.range.start === 'string') {
        s.range.first.date = parseDate(s.range.start);
      } else if (field.dates) {
        s.range.first.date = parseDate(field.dates[0]);
      }

      // End date
      if (s.range.data && s.range.data.endDate) {
        s.range.second.date = s.range.data.endDate;
      } else if (s.range.end && typeof s.range.end === 'string') {
        s.range.second.date = parseDate(s.range.end);
      } else if (field.dates) {
        s.range.second.date = parseDate(field.dates[1]);
      }

      if (this.calendarAPI) {
        this.calendarAPI.setRangeSelected();
      }

      if (field.isEmpty || !field.isEmpty && !s.range.data) {
        var value = formatDate(s.range.first.date);
        if (value) {
          this.element.val(value);
        }
      } else {
        return false;
      }
      return true;
    },


    /**
     * Get the value from the field and set the internal variables or use current date
     * @private
     * @returns {void}
     */
    setValueFromField: function setValueFromField() {
      var s = this.settings;
      this.setCurrentCalendar();

      if (s.range.useRange && (this.element.val().trim() !== '' || s.range.start && s.range.end || s.range.data && s.range.data.startDate && s.range.data.endDate)) {
        if (!this.setRangeValueFromField()) {
          return;
        }
      }

      var self = this;
      var fieldValue = this.element.val();
      var gregorianValue = fieldValue;

      if (this.isIslamic && fieldValue) {
        var islamicValue = Locale.parseDate(this.element.val(), this.pattern);
        gregorianValue = this.conversions.toGregorian(islamicValue.getFullYear(), islamicValue.getMonth(), islamicValue.getDate());
      }

      this.currentDate = gregorianValue || new Date();
      if (typeof this.currentDate === 'string') {
        this.currentDate = Locale.parseDate(this.currentDate, this.pattern, false);
      }

      if (this.currentDate === undefined) {
        this.currentDate = Locale.parseDate(gregorianValue, this.pattern, false);
      }

      this.currentDate = this.currentDate || new Date();
      this.currentMonth = this.currentDate.getMonth();
      this.currentYear = this.currentDate.getFullYear();
      this.currentDay = this.currentDate.getDate();

      if (this.isIslamic) {
        this.currentDateIslamic = this.conversions.fromGregorian(this.currentDate);
        this.currentYear = this.currentDateIslamic[0];
        this.currentMonth = this.currentDateIslamic[1];
        this.currentDay = this.currentDateIslamic[2];
      }

      // Check and fix two digit year for main input element
      var dateFormat = self.pattern;
      var isStrict = !(dateFormat === 'MMMM d' || dateFormat === 'yyyy');
      var parsedDate = Locale.parseDate(self.element.val().trim(), dateFormat, isStrict);

      if (parsedDate !== undefined && self.element.val().trim() !== '' && !s.range.useRange) {
        self.setValue(Locale.parseDate(self.element.val().trim(), self.pattern, false));
      }

      if (s.range.useRange && s.range.first && s.range.first.date && s.range.second && !s.range.second.date) {
        this.setRangeToElem(this.currentDate, true);
      }
    },


    /**
     * Set input to enabled.
     * @returns {void}
     */
    enable: function enable() {
      this.element.removeAttr('disabled readonly').closest('.field').removeClass('is-disabled');
    },


    /**
     * Set input to disabled.
     * @returns {void}
     */
    disable: function disable() {
      this.enable();
      this.element.attr('disabled', 'disabled').closest('.field').addClass('is-disabled');
    },


    /**
     * Detects whether or not the component is disabled
     * @returns {boolean} whether or not the component is disabled
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
     * Set input to readonly.
     * @returns {void}
     */
    readonly: function readonly() {
      this.enable();
      this.element.attr('readonly', 'readonly');
    },


    /**
     * Set to todays date in current format.
     * @private
     * @returns {void}
     */
    setToday: function setToday() {
      var s = this.settings;
      this.currentDate = new Date();

      if (!this.settings.useCurrentTime) {
        this.currentDate.setHours(0, 0, 0, 0);
      }

      if (this.element.val() !== '') {
        if (this.timepicker && this.timepicker.hourSelect) {
          this.currentDate.setHours(this.timepicker.hourSelect.val());
        }

        if (this.timepicker && this.timepicker.minuteSelect) {
          this.currentDate.setMinutes(this.timepicker.minuteSelect.val());
        }

        if (this.timepicker && this.timepicker.secondSelect) {
          this.currentDate.setSeconds(this.timepicker.secondSelect.val());
        }
      }

      if (this.isIslamic) {
        var islamicDateParts = this.conversions.fromGregorian(this.currentDate);
        this.currentDateIslamic = new Date(islamicDateParts[0], islamicDateParts[1], islamicDateParts[2], this.currentDate.getHours(), this.currentDate.getMinutes(), this.currentDate.getSeconds());
      }

      if (this.isOpen()) {
        this.insertDate(this.isIslamic ? this.currentDateIslamic : this.currentDate, true);
      } else {
        if (s.range.useRange) {
          this.setRangeToElem(this.currentDate);
        } else {
          var options = { pattern: this.pattern };
          var islamicDateText = Locale.formatDate(this.isIslamic ? this.currentDateIslamic : this.currentDate, options);
          this.element.val(islamicDateText);
        }
        /**
        * Fires after the value in the input is changed by user interaction.
        *
        * @event input
        * @memberof DatePicker
        * @property {object} event - The jquery event object
        */
        if (s.range.useRange) {
          this.element.trigger('change', [s.range.data]).trigger('input', [s.range.data]);
        } else {
          this.element.trigger('change').trigger('input');
        }
      }
    },


    /**
     * Set time
     * @private
     * @param {object} date .
     * @returns {void}
     */
    setTime: function setTime(date) {
      var hours = this.popup.find('.dropdown.hours').val();
      var minutes = this.popup.find('.dropdown.minutes').val();
      var seconds = this.isSeconds ? this.popup.find('.dropdown.seconds').val() : 0;
      var period = this.popup.find('.dropdown.period');

      hours = period.length && period.val() === 'PM' && hours < 12 ? parseInt(hours, 10) + 12 : hours;
      hours = period.length && period.val() === 'AM' && parseInt(hours, 10) === 12 ? 0 : hours;

      date = new Date(date);
      date.setHours(hours, minutes, seconds);
      return date;
    },


    /**
     * Get Time String
     * @private
     * @param {object} date .
     * @param {boolean} isHours24 .
     * @returns {string} time
     */
    getTimeString: function getTimeString(date, isHours24) {
      var twodigit = function twodigit(number) {
        return (number < 10 ? '0' : '') + number;
      };
      var d = date || new Date();
      var h = d.getHours();
      var m = twodigit(d.getMinutes());
      var s = twodigit(d.getSeconds());
      var h12 = (h % 12 || 12) + ':' + m + (this.isSeconds ? ':' + s : '') + ' ' + (h < 12 ? 'AM' : 'PM');
      var h24 = h + ':' + m + ' + ' + (this.isSeconds ? ':' + s : '');

      return isHours24 ? h24 : h12;
    },


    /**
     * Get the current date from the field. In date format
     * @returns {Date} the set date object
     */
    getCurrentDate: function getCurrentDate() {
      return this.currentDate;
    },


    /**
     * Updates the component instance. Can be used after being passed new settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, DATEPICKER_DEFAULTS);
      }
      return this.teardown().init();
    },


    /**
     * Get range value to insert in element
     * @private
     * @returns {string} range dates to display in element
     */
    getRangeValue: function getRangeValue() {
      var _this6 = this;

      var s = this.settings;
      var formatDate = function formatDate(d) {
        return Locale.formatDate(d, { pattern: _this6.pattern });
      };

      if (s.range.useRange && s.range.first && s.range.first.date && s.range.second && s.range.second.date) {
        return '' + (formatDate(s.range.first.date) + s.range.separator + formatDate(s.range.second.date));
      } else if (s.range.useRange && s.range.first && s.range.first.date) {
        return s.placeholder ? '' + (formatDate(s.range.first.date) + s.range.separator + this.pattern) : formatDate(s.range.first.date);
      }
      return '';
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {void}
     */
    teardown: function teardown() {
      if (this.isOpen()) {
        this.closeCalendar();
      }

      this.element.off('blur.datepicker');
      this.trigger.remove();
      this.element.attr('data-mask', '');
      this.element.removeAttr('placeholder');
      if (this.calendarAPI) {
        this.calendarAPI.destroy();
      }
      if (this.calendar && this.calendar.length) {
        this.calendar.remove();
      }

      if (this.popup && this.popup.length) {
        this.popup.remove();
      }

      var maskApi = this.element.data('mask');
      if (maskApi) {
        maskApi.destroy();
      }

      this.element.off('keydown.datepicker blur.validate change.validate keyup.validate focus.validate');

      this.element.removeAttr('data-validate').removeData('validate validationEvents');

      return this;
    },


    /**
     * Destroy and remove added markup, reset back to default
     * @returns {void}
     */
    destroy: function destroy() {
      this.closeCalendar();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$C);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var self = this;
      var s = this.settings;

      this.trigger.on('click.datepicker', function () {
        if (self.isOpen()) {
          self.closeCalendar();
        } else {
          self.openCalendar();
        }
      });

      self.mask();
      this.handleKeys(this.element);

      // Fix two digit year for main input element
      self.element.on('blur.datepicker', function () {
        if (self.element.val().trim() !== '') {
          self.setValueFromField();
        }
      });

      // Set initialize value
      if (!this.isOpen() && s.range.useRange && !s.range.first) {
        this.setRangeValueFromField();
        var value = this.getRangeValue();
        if (value) {
          this.element.val(value);
        }
      }
    }
  };

  /**
   * jQuery Component Wrapper for Datepicker
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.datepicker = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$C);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$C, new DatePicker(this, settings));
      }
    });
  };

  /* eslint-disable no-useless-escape */

  var COMPONENT_NAME$D = 'editor';

  /**
  * The Editor Component is displays and edits markdown.
  *
  * @class Editor
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  * @param {string} [settings.buttons =
  * { editor: [ 'header1', 'header2', 'separator', 'bold', 'italic', 'underline', 'strikethrough',
  * 'separator', 'foreColor', 'backColor', 'separator', 'justifyLeft', 'justifyCenter', 'justifyRight', 'separator', 'quote', 'orderedlist',
  * 'unorderedlist', 'separator', 'anchor', 'separator', 'image', 'separator', 'source' ], source: [ 'visual' ] }]
  * An array with all the visible buttons in it.
  * @param {string} [settings.excludeButtons = { editor: ['backColor'], source: [] }] An array with all the buttons in it to excloude
  * @param {string} [settings.firstHeader = 'h3'] Allows you to set if the first header inserted is a h3 or h4 element.
  * You should set this to match the structure of the parent page for accessibility
  * @param {boolean} [settings.secondHeader = 'h4'] Allows you to set if the second header inserted is a h3 or
  * h4 element. You should set this to match the structure of the parent page for accessibility
  * @param {string} [settings.pasteAsPlainText = false] If true, when you paste into the editor the element will be unformatted to plain text.
  * @param {string} [settings.anchor = { url: 'http://www.example.com', class: 'hyperlink', target: 'NewWindow', isClickable: false, showIsClickable: false }] An object with settings related to controlling link behavior when inserted example: `{url: 'http://www.example.com', class: 'hyperlink', target: 'NewWindow', isClickable: false, showIsClickable: false},` the url is the default url to display. Class should normally stay hyperlink and represents the styling class. target can be 'NewWindow' or 'SameWindow', isClickable make the links appear clickable in the editor, showIsClickable will show a checkbox to allow the user to make clickable links in the link popup.
  * @param {string} [settings.image = { url: 'https://imgplaceholder.com/250x250/368AC0/ffffff/fa-image' }] Info object to populate the image dialog defaulting to ` {url: 'http://lorempixel.com/output/cats-q-c-300-200-3.jpg'}`
  * @param {function} [settings.onLinkClick = null] Call back for clicking on links to control link behavior.
  * @param {function} [settings.showHtmlView = false] If set to true, editor should be displayed in HTML view initialy.
  */
  var EDITOR_DEFAULTS = {
    buttons: {
      editor: ['header1', 'header2', 'separator', 'bold', 'italic', 'underline', 'strikethrough', 'separator', 'foreColor', 'backColor', 'separator', 'justifyLeft', 'justifyCenter', 'justifyRight', 'separator', 'quote', 'orderedlist', 'unorderedlist', 'separator', 'anchor', 'separator', 'image', 'separator', 'clearFormatting', 'separator', 'source'],
      source: ['visual']
    },
    excludeButtons: {
      editor: ['backColor'],
      source: []
    },
    delay: 200,
    firstHeader: 'h3',
    secondHeader: 'h4',
    placeholder: null,
    pasteAsPlainText: false,
    // anchor > target: 'SameWindow'|'NewWindow'| any string value
    anchor: { url: 'http://www.example.com', class: 'hyperlink', target: 'NewWindow', isClickable: false, showIsClickable: false },
    image: { url: 'https://imgplaceholder.com/250x250/368AC0/ffffff/fa-image' },
    onLinkClick: null,
    showHtmlView: false
  };

  function Editor(element, settings) {
    this.settings = utils.mergeSettings(element, settings, EDITOR_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Editor Methods
  Editor.prototype = {
    init: function init() {
      var _this = this;

      var s = this.settings;
      this.isIe = Environment.browser.name === 'ie';
      this.isIeEdge = Environment.browser.name === 'edge';
      this.isIe11 = this.isIe && Environment.browser.version === '11';
      this.isMac = Environment.os.name === 'Mac OS X';
      this.isFirefox = Environment.browser.name === 'firefox';
      this.textarea = null;

      this.parentElements = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pre'];
      this.id = utils.uniqueId(this.element, 'editor') + '-id';

      this.container = this.element.parent('.field, .field-short').addClass('editor-container');

      s.anchor = $.extend({}, EDITOR_DEFAULTS.anchor, s.anchor);
      s.image = $.extend({}, EDITOR_DEFAULTS.image, s.image);

      s.anchor.defaultUrl = s.anchor.url;
      s.anchor.defaultClass = s.anchor.class;
      s.anchor.defaultTargetText = s.anchor.target;
      s.anchor.defaultIsClickable = s.anchor.isClickable;

      s.anchor.targets = s.anchor.targets || {
        SameWindow: '',
        NewWindow: '_blank'
      };

      $.each(this.settings.anchor.targets, function (key, val) {
        if (_this.settings.anchor.defaultTargetText.toLowerCase() === key.toLowerCase()) {
          _this.settings.anchor.target = val;
          _this.settings.anchor.defaultTarget = val;
        }
      });

      if (!s.anchor.defaultTarget) {
        if (s.anchor.target && $.trim(s.anchor.target).length) {
          s.anchor.defaultTarget = s.anchor.target;
        } else {
          s.anchor.defaultTargetText = Locale.translate('SameWindow');
          s.anchor.defaultTarget = s.anchor.targets[s.anchor.defaultTargetText];
        }
      }

      this.setup();
      if (this.element.hasClass('is-readonly')) {
        this.readonly();
      }

      if (this.settings.showHtmlView) {
        this.toggleSource();
      }

      return this;
    },
    setup: function setup() {
      this.isActive = true;
      this.modals = {};

      this.initElements().bindSelect().bindPaste().setPlaceholders().bindWindowActions().setupKeyboardEvents().onPasteTriggered();
    },
    initElements: function initElements() {
      // Make it an editor
      this.element.attr({
        contentEditable: true,
        'aria-multiline': true,
        role: 'textbox'
      });

      // Bind functionality for Pre elements. We dont use this yet but could if we
      // want to edit code blocks.
      this.element.attr('data-editor', true);
      this.bindParagraphCreation().bindTab();

      this.initToolbar().bindButtons().bindModals().bindAnchorPreview();

      // Build the textarea that will be used as source view and for content serialization
      this.initTextarea();
      return this;
    },


    // Returns true if the source view is currently active.
    sourceViewActive: function sourceViewActive() {
      return this.element.hasClass('source-view-active');
    },


    // Bind Events for the place holder
    setPlaceholders: function setPlaceholders() {
      var _this2 = this;

      this.element.on('blur.editor', function () {
        return _this2.togglePlaceHolder();
      }).on('keypress.editor', function () {
        return _this2.togglePlaceHolder();
      });

      this.togglePlaceHolder();
      return this;
    },
    togglePlaceHolder: function togglePlaceHolder() {
      if (this.element.text().trim() === '') {
        this.element.addClass('editor-placeholder');
      } else {
        this.element.removeClass('editor-placeholder');
      }
    },


    // Returns the currently visible element - either the main editor window,
    // or the source-view textarea
    getCurrentElement: function getCurrentElement() {
      return this.sourceViewActive() ? this.textarea : this.element;
    },
    bindParagraphCreation: function bindParagraphCreation() {
      var _this3 = this;

      var currentElement = this.getCurrentElement();
      currentElement.on('keyup.editor', function (e) {
        var node = _this3.getSelectionStart();
        var tagName = void 0;

        if (node && node.getAttribute('data-editor') && node.children.length === 0) {
          document.execCommand('formatBlock', false, 'p');
        }

        if (e.which === 13) {
          node = _this3.getSelectionStart();
          tagName = node.tagName.toLowerCase();

          if (tagName !== 'li' && !_this3.isListItemChild(node)) {
            if (!e.shiftKey) {
              document.execCommand('formatBlock', false, 'p');
            }
            if (tagName === 'a') {
              document.execCommand('unlink', false, null);
            }
          }
        }
      });
      return this;
    },
    bindTab: function bindTab() {
      var _this4 = this;

      var currentElement = this.getCurrentElement();

      currentElement.on('keydown.editor', function (e) {
        if (e.which === 9) {
          // Override tab only for pre nodes
          var tag = _this4.getSelectionStart().tagName.toLowerCase();
          if (tag === 'pre') {
            e.preventDefault();
            document.execCommand('insertHtml', null, '    ');
          }
          // Tab to indent list structures!
          if (tag === 'li') {
            // If Shift is down, outdent, otherwise indent
            document.execCommand(e.shiftKey ? 'outdent' : 'indent', e);
          }
        }
      });

      return this;
    },
    initToolbar: function initToolbar() {
      if (this.toolbar) {
        return this;
      }

      this.createToolbar();
      return this;
    },


    // Set excluded buttons
    setExcludedButtons: function setExcludedButtons() {
      var _this5 = this;

      var excludeButtons = function excludeButtons(elements, toExclude) {
        var separatorIndex = -1;
        var numOfExcluded = 0;

        return elements.filter(function (x, i) {
          var r = true;
          // Exclude matching buttons but keep separator/s
          if (toExclude.indexOf(x) > -1 && x !== 'separator') {
            numOfExcluded++;
            r = false;
          } else if (x === 'separator' && i - numOfExcluded - 1 === separatorIndex) {
            // Exclude extra separator/s
            numOfExcluded = 0;
            r = false;
          }
          if (x === 'separator') {
            separatorIndex = i;
          }
          return r;
        });
      };

      // Run only if it needs (excludeButtons)
      var setButtons = function setButtons() {
        var s = _this5.settings;
        var btns = s.buttons;
        var exBtns = s.excludeButtons;

        if (_this5.sourceViewActive()) {
          return exBtns && exBtns.source && exBtns.source.length ? excludeButtons(btns.source, exBtns.source) : btns.source;
        }
        return exBtns && exBtns.editor && exBtns.editor.length ? excludeButtons(btns.editor, exBtns.editor) : btns.editor;
      };
      return setButtons();
    },
    createToolbar: function createToolbar() {
      var btns = this.setExcludedButtons();
      var toolbar = '<div class="toolbar editor-toolbar formatter-toolbar"\n                   id="editor-toolbar-' + this.id + '">';
      var buttonset = '<div class="buttonset">';

      for (var i = 0, l = btns.length; i < l; i += 1) {
        var btn = this.buttonTemplate(btns[i]);
        if (btn) {
          buttonset += btn;
        }
      }

      buttonset += '</div>';
      toolbar += buttonset + '</div>';

      if (this.element.parent().find('.icon-dirty').length) {
        this.toolbar = $(toolbar).insertBefore(this.element.parent().find('.icon-dirty'));
      } else {
        this.toolbar = $(toolbar).insertBefore(this.sourceViewActive() ? this.element.prev() : this.element);
      }
      this.toolbar.toolbar();

      // Invoke Tooltips
      this.toolbar.find('button[title]').tooltip();

      // Invoke colorpicker
      var cpElements = this.toolbar.find('[data-action="foreColor"], [data-action="backColor"]');
      cpElements.colorpicker({ placeIn: 'editor' });
      $('.trigger', cpElements).off('click.colorpicker');

      return this;
    },


    /**
    * Switch between source and editing toolbar.
    * @returns {void}
    */
    switchToolbars: function switchToolbars() {
      this.destroyToolbar();

      // Rebind everything to the new element
      this.setupTextareaEvents();
      this.initToolbar();
      this.bindButtons().bindModals().bindAnchorPreview();
      this.bindSelect().bindPaste().setupKeyboardEvents();
      this.toolbar.find('button').button();
    },
    initTextarea: function initTextarea() {
      var self = this;
      if (this.textarea && !this.settings.showHtmlView) {
        return this;
      }
      this.textarea = this.createTextarea();

      // fill the text area with any content that may already exist within the editor DIV
      this.textarea.text(xssUtils.sanitizeHTML(this.element.html().toString()));

      self.container.on('input.editor keyup.editor', '.editor', debounce(function () {
        self.textarea.html(xssUtils.sanitizeHTML(self.element.html().toString()));
        // setting the value via .val doesn't trigger the change event
        self.element.trigger('change');
      }, 500));

      this.setupTextareaEvents();
      return this.textarea;
    },
    createTextarea: function createTextarea() {
      this.sourceView = $('<div></div>').attr({
        class: 'editor-source editable hidden',
        id: 'editor-source-' + this.id
      }).insertBefore(this.element);

      $('<ul></ul>').addClass('line-numbers').appendTo(this.sourceView);
      var textareaContainer = $('<div class="text-container"></div>').appendTo(this.sourceView);

      var newTextareaID = 'source-textarea-' + ($('[id^="source-textarea-"]').length + 1);

      var labelContents = this.element.prev('.label').addClass('audible').text() + ' - HTML Source View';

      $('<label class="audible" for="' + newTextareaID + '">' + labelContents + '</label>').appendTo(textareaContainer);

      var textarea = $('<textarea id="' + newTextareaID + '" class="editable"></textarea>').appendTo(textareaContainer);
      return textarea;
    },
    triggerClick: function triggerClick(e, btn) {
      $('button[data-action="' + btn + '"]', this.toolbar).trigger('click.editor');
    },
    setupKeyboardEvents: function setupKeyboardEvents() {
      var _this6 = this;

      var self = this;
      var currentElement = this.getCurrentElement();
      var keys = {
        b: 66, // {Ctrl + B} bold
        e: 69, // {Ctrl + E} justifyCenter
        h: 72, // {Ctrl + H} anchor
        i: 73, // {Ctrl + I} italic --------with SHIFT: {Ctrl + Shift + I} image
        l: 76, // {Ctrl + L} justifyLeft
        bl: 55, // {Ctrl + + Shift + 7} bullet list
        n: 56, // {Ctrl + Shift + 8} numbered list
        q: 81, // {Ctrl + Q} blockquotes
        r: 82, // {Ctrl + R} justifyRight
        u: 85, // {Ctrl + U} underline
        h3: 51, // {Ctrl + 3} h3
        h4: 52, // {Ctrl + 4} h4
        space: 32, // {Ctrl + Space} Clear Formatting
        sv: 192 // {Ctrl + ~} toggle source -or- visualview
      };

      currentElement.on('keydown.editor', function (e) {
        e = e || window.event;

        if (e.which) {
          keys.charCode = e.which;
        } else if (e.keyCode) {
          keys.charCode = e.keyCode;
        } else {
          keys.charCode = false;
        }

        switch (e.ctrlKey && keys.charCode) {
          case keys.h3:
            _this6.triggerClick(e, 'append-' + _this6.settings.firstHeader);
            break;
          case keys.h4:
            _this6.triggerClick(e, 'append-' + _this6.settings.secondHeader);
            break;
          case keys.b:
            _this6.triggerClick(e, 'bold');
            e.preventDefault();
            break;
          case keys.e:
            _this6.triggerClick(e, 'justifyCenter');
            break;
          case keys.h:
            _this6.triggerClick(e, 'anchor');
            e.preventDefault();
            break;
          case keys.i:
            _this6.triggerClick(e, e.shiftKey ? 'image' : 'italic');
            if (!e.shiftKey) {
              e.preventDefault();
            }
            break;
          case keys.bl:
            if (e.shiftKey) {
              _this6.triggerClick(e, 'insertunorderedlist');
            }
            e.preventDefault();
            break;
          case keys.l:
            if (!e.shiftKey) {
              _this6.triggerClick(e, 'justifyLeft');
            }
            e.preventDefault();
            break;
          case keys.n:
            if (e.shiftKey) {
              _this6.triggerClick(e, 'insertorderedlist');
            }
            break;
          case keys.q:
            _this6.triggerClick(e, 'append-blockquote');
            break;
          case keys.r:
            _this6.triggerClick(e, 'justifyRight');
            break;
          case keys.u:
            _this6.triggerClick(e, 'underline');
            e.preventDefault();
            break;
          case keys.space:
            _this6.triggerClick(e, 'clearFormatting');
            break;
          case keys.sv:
            _this6.triggerClick(e, currentElement === _this6.element ? 'source' : 'visual');
            break;
          default:
            break;
        }
      });

      // Open link in new windows/tab, if clicked with command-key(for mac) or ctrl-key(for windows)
      this.element.on('mousedown.editor', 'a', function (e) {
        var href = $(this).attr('href');
        if (!self.isFirefox && (self.isMac && e.metaKey || !self.isMac && e.ctrlKey)) {
          window.open(href, '_blank');
          e.preventDefault();
        }
      });

      this.element.on('updated.editor', function () {
        _this6.updated();
      });

      return this;
    },
    setupTextareaEvents: function setupTextareaEvents() {
      var _this7 = this;

      // Adjust line numbers on input
      this.textarea.off('.editor').on('input.editor keyup.editor', function () {
        if (!_this7.sourceView.hasClass('hidden')) {
          _this7.adjustSourceLineNumbers();
        }
      }).on('focus.editor', function () {
        _this7.sourceView.addClass('is-focused');
      }).on('blur.editor', function (e) {
        _this7.sourceView.removeClass('is-focused');
        _this7.element.empty().html(xssUtils.sanitizeHTML(_this7.textarea.val()));

        if (_this7.element.data('validate')) {
          _this7.element.data('validate').validate(_this7.element, true, e);
        }
      });

      return this;
    },
    adjustSourceLineNumbers: function adjustSourceLineNumbers() {
      var container = this.textarea.parent();
      var lineHeight = parseInt(getComputedStyle(this.textarea[0]).lineHeight, 10);
      var YPadding = this.textarea.innerHeight() - this.textarea.height();

      this.textarea[0].style.height = '';

      var scrollHeight = this.textarea[0].scrollHeight;
      var lineNumberCount = Math.floor((scrollHeight - YPadding) / lineHeight);
      var numberList = this.sourceView.find('.line-numbers');
      var lastIdx = numberList.find('li').length;

      var list = '';
      var i = 0;

      if (!this.lineNumbers || lineNumberCount !== this.lineNumbers) {
        if (!this.lineNumbers) {
          // Build the list of line numbers from scratch
          this.lineNumbers = lineNumberCount;
          while (i < this.lineNumbers) {
            list += '<li role="presentation"><span>' + (i + 1) + '</span></li>';
            i++;
          }
          numberList.append(list);
        } else if (this.lineNumbers < lineNumberCount) {
          // Add extra line numbers to the bottom
          while (i < lineNumberCount - this.lineNumbers) {
            list += '<li role="presentation"><span>' + (lastIdx + i + 1) + '</span></li>';
            i++;
          }
          numberList.append(list);
        } else if (this.lineNumbers > lineNumberCount) {
          // Remove extra line numbers from the bottom
          i = this.lineNumbers - lineNumberCount;
          numberList.find('li').slice(-i).remove();
        }
        this.lineNumbers = lineNumberCount;
        container[0].style.width = 'calc(100% - ' + (numberList.outerWidth() + 1) + 'px)';
      }
      if (scrollHeight !== this.textarea[0].scrollHeight) {
        this.adjustSourceLineNumbers();
        return;
      }

      this.textarea[0].style.height = numberList[0].scrollHeight + 'px';
    },
    wrapTextInTags: function wrapTextInTags(insertedText, selectedText, action) {
      var tags = void 0;
      var finalText = void 0;
      switch (action) {
        case 'bold':
          tags = ['<b>', '</b>'];
          break;
        case 'italic':
          tags = ['<i>', '</i>'];
          break;
        case 'underline':
          tags = ['<u>', '</u>'];
          break;
        case 'strikethrough':
          tags = ['<strike>', '</strike>'];
          break;
        case 'append-blockquote':
          tags = ['<blockquote>', '</blockquote>'];
          break;
        default:
          tags = ['', ''];
      }

      if (action === 'anchor') {
        var alink = $('<a href="' + insertedText + '">' + selectedText + '</a>');

        if (this.settings.anchor.class && $.trim(this.settings.anchor.class).length) {
          alink.addClass(this.settings.anchor.class);
        }
        if (this.settings.anchor.target && $.trim(this.settings.anchor.target).length) {
          alink.attr('target', this.settings.anchor.target);
        }
        if (this.settings.anchor.isClickable) {
          alink.attr('contenteditable', false);
        } else {
          alink.removeAttr('contenteditable');
        }

        finalText = alink[0].outerHTML;
      } else {
        finalText = tags[0] + insertedText + selectedText + tags[1];
      }
      return finalText;
    },
    insertTextAreaContent: function insertTextAreaContent(text, action) {
      var el = this.textarea[0];
      var val = el.value;

      var sel = void 0;
      var startPos = void 0;
      var endPos = void 0;
      var scrollTop = void 0;

      // Always have empty text
      text = text || '';

      if (document.selection && el.tagName === 'TEXTAREA') {
        // IE textarea support
        $(el).focus();
        sel = document.selection.createRange();
        sel.text = this.wrapTextInTags(text, sel.text, action);
        $(el).focus();
      } else if (el.selectionStart || el.selectionStart === '0') {
        // MOZILLA/NETSCAPE support
        startPos = el.selectionStart;
        endPos = el.selectionEnd;
        scrollTop = el.scrollTop;
        sel = this.wrapTextInTags(text, val.substring(startPos, endPos), action);
        el.value = val.substring(0, startPos) + sel + val.substring(endPos, val.length);
        $(el).focus();
        el.selectionStart = startPos + sel.length;
        el.selectionEnd = startPos + sel.length;
        el.scrollTop = scrollTop;
      } else {
        // IE input[type=text] and other browsers
        el.value += this.wrapTextInTags(text, el.value, action);
        $(el).focus();
        el.value = el.value; // forces cursor to end
      }
    },
    buttonTemplate: function buttonTemplate(btnType) {
      var buttonLabels = this.getButtonLabels(this.settings.buttonLabels);
      var buttonTemplates = {
        bold: '<button type="button" class="btn" title="' + Locale.translate('ToggleBold') + '" data-action="bold" data-element="b">' + buttonLabels.bold + '</button>',

        italic: '<button type="button" class="btn" title="' + Locale.translate('ToggleItalic') + '" data-action="italic" data-element="i">' + buttonLabels.italic + '</button>',

        underline: '<button type="button" class="btn underline" title="' + Locale.translate('ToggleUnderline') + '" data-action="underline" data-element="u">' + buttonLabels.underline + '</button>',

        strikethrough: '<button type="button" class="btn" title="' + Locale.translate('StrikeThrough') + '" data-action="strikethrough" data-element="strike">' + buttonLabels.strikethrough + '</button>',

        foreColor: '<button type="button" class="btn colorpicker-editor-button" title="' + Locale.translate('TextColor') + '" data-action="foreColor" data-element="foreColor">' + buttonLabels.foreColor + '</button>',

        backColor: '<button type="button" class="btn colorpicker-editor-button" title="' + Locale.translate('BackgroundColor') + '" data-action="backColor" data-element="backColor">' + buttonLabels.backColor + '</button>',

        superscript: '<button type="button" class="btn" title="' + Locale.translate('Superscript') + '" data-action="superscript" data-element="sup">' + buttonLabels.superscript + '</button>',

        subscript: '<button type="button" class="btn" title="' + Locale.translate('Subscript') + '" data-action="subscript" data-element="sub">' + buttonLabels.subscript + '</button>',

        separator: '<div class="separator"></div>',

        anchor: '<button type="button" class="btn" title="' + Locale.translate('InsertAnchor') + '" data-action="anchor" data-modal="modal-url-' + this.id + '" data-element="a">' + buttonLabels.anchor + '</button>',

        image: '<button type="button" class="btn" title="' + Locale.translate('InsertImage') + '" data-action="image" data-modal="modal-image-' + this.id + '" data-element="img">' + buttonLabels.image + '</button>',

        header1: '<button type="button" class="btn" title="' + Locale.translate('ToggleH3') + '" data-action="append-' + this.settings.firstHeader + '" data-element="' + this.settings.firstHeader + '">' + buttonLabels.header1 + '</button>',

        header2: '<button type="button" class="btn" title="' + Locale.translate('ToggleH4') + '" data-action="append-' + this.settings.secondHeader + '" data-element="' + this.settings.secondHeader + '">' + buttonLabels.header2 + '</button>',

        quote: '<button type="button" class="btn" title="' + Locale.translate('Blockquote') + '" data-action="append-blockquote" data-element="blockquote">' + buttonLabels.quote + '</button>',

        orderedlist: '<button type="button" class="btn" title="' + Locale.translate('OrderedList') + '" data-action="insertorderedlist" data-element="ol">' + buttonLabels.orderedlist + '</button>',

        unorderedlist: '<button type="button" class="btn" title="' + Locale.translate('UnorderedList') + '" data-action="insertunorderedlist" data-element="ul">' + buttonLabels.unorderedlist + '</button>',

        justifyLeft: '<button type="button" class="btn" title="' + Locale.translate('JustifyLeft') + '" data-action="justifyLeft" >' + buttonLabels.justifyLeft + '</button>',

        justifyCenter: '<button type="button" class="btn" title="' + Locale.translate('JustifyCenter') + '" data-action="justifyCenter">' + buttonLabels.justifyCenter + '</button>',

        justifyRight: '<button type="button" class="btn" title="' + Locale.translate('JustifyRight') + '" data-action="justifyRight" >' + buttonLabels.justifyRight + '</button>',

        clearFormatting: '<button type="button" class="btn" title="' + Locale.translate('ClearFormatting') + '" data-action="clearFormatting" >' + buttonLabels.clearFormatting + '</button>',

        source: '<button type="button" class="btn" title="' + Locale.translate('ViewSource') + '" data-action="source" >' + buttonLabels.source + '</button>',

        visual: '<button type="button" class="btn" title="' + Locale.translate('ViewVisual') + '" data-action="visual" >' + buttonLabels.visual + '</button>'
      };
      return buttonTemplates[btnType] || false;
    },
    getIcon: function getIcon(textName, iconName, className) {
      return '<span class="audible">' + Locale.translate(textName) + '</span>' + $.createIcon({ classes: className || '', icon: iconName });
    },
    getButtonLabels: function getButtonLabels(buttonLabelType) {
      var buttonLabels = {
        bold: this.getIcon('Bold', 'bold'),
        italic: this.getIcon('Italic', 'italic'),
        underline: this.getIcon('Underline', 'underline'),
        superscript: '<span aria-hidden="true"><b>x<sup>1</sup></b></span>',
        subscript: '<span aria-hidden="true"><b>x<sub>1</sub></b></span>',
        strikethrough: this.getIcon('StrikeThrough', 'strike-through'),
        foreColor: this.getIcon('TextColor', 'fore-color'),
        backColor: this.getIcon('BackgroundColor', 'back-color'),
        anchor: this.getIcon('InsertAnchor', 'link'),
        image: this.getIcon('InsertImage', 'insert-image'),
        header1: this.getIcon('ToggleH3', 'h3'),
        header2: this.getIcon('ToggleH4', 'h4'),
        quote: this.getIcon('Blockquote', 'quote'),
        orderedlist: this.getIcon('OrderedList', 'number-list'),
        unorderedlist: this.getIcon('UnorderedList', 'bullet-list'),
        pre: '<span aria-hidden="true"><b>0101</b></span>',
        indent: '<span aria-hidden="true"><b>&rarr;</b></span>',
        outdent: '<span aria-hidden="true"><b>&larr;</b></span>',
        justifyLeft: this.getIcon('JustifyLeft', 'left-text-align'),
        justifyCenter: this.getIcon('JustifyCenter', 'center-text'),
        justifyRight: this.getIcon('JustifyRight', 'right-text-align'),
        clearFormatting: this.getIcon('clearFormatting', 'clear-formatting'),
        source: this.getIcon('ViewSource', 'html', 'html-icon'),
        visual: this.getIcon('ViewSource', 'visual', 'visual-icon')
      };

      var customButtonLabels = void 0;

      if ((typeof buttonLabelType === 'undefined' ? 'undefined' : _typeof(buttonLabelType)) === 'object') {
        customButtonLabels = buttonLabelType;
      }
      if ((typeof customButtonLabels === 'undefined' ? 'undefined' : _typeof(customButtonLabels)) === 'object') {
        for (var attrname in customButtonLabels) {
          if (customButtonLabels.hasOwnProperty(attrname)) {
            // eslint-disable-line
            buttonLabels[attrname] = customButtonLabels[attrname];
          }
        }
      }
      return buttonLabels;
    },


    // Show the Buttons
    activateButton: function activateButton(tag) {
      this.toolbar.find('[data-element="' + tag + '"]').addClass('is-active');
    },


    // Bind Events to Toolbar Buttons
    bindButtons: function bindButtons() {
      var self = this;

      this.toolbar.on('touchstart.editor click.editor', 'button', function (e) {
        var btn = $(this);
        var action = btn.attr('data-action');

        // Don't do anything if it's the More Button
        if (btn.is('.btn-actions')) {
          return;
        }

        e.preventDefault();
        self.getCurrentElement().focus();

        if (self.selection === undefined) {
          self.checkSelection();
        }

        if (!self.sourceViewActive()) {
          btn.toggleClass('is-active');
        }

        if (action) {
          self.execAction(action, e);
        }

        return false;
      });

      return this;
    },
    bindModals: function bindModals() {
      var self = this;

      this.modals = {
        url: this.createURLModal(),
        image: this.createImageModal()
      };

      $('[name="em-target-' + this.id + '"]').dropdown();

      $('#modal-url-' + this.id + ', #modal-image-' + this.id).modal().on('beforeopen', function () {
        self.savedSelection = self.saveSelection();

        if ($(this).attr('id') === 'modal-url-' + self.id) {
          if (!self.selectionRange) {
            return undefined;
          }
        }
      }).off('open').on('open', function () {
        var isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        var id = $(this).attr('id');
        var input = $('input:first', this);
        var button = $('.modal-buttonset .btn-modal-primary', this);

        $('[name="em-url-' + self.id + '"]').val(self.settings.anchor.url);
        $('[name="em-class-' + self.id + '"]').val(self.settings.anchor.class);
        $('[name="em-target-' + self.id + '"]').val(self.settings.anchor.target).trigger('updated');
        $('[name="em-isclickable-' + this.id + '"]').prop('checked', self.settings.anchor.isClickable);

        setTimeout(function () {
          if (isTouch && id === 'modal-image-' + self.id) {
            button.focus();
          } else {
            input.focus().select();
          }
        }, 10);
      }).off('close').on('close', function (e, isCancelled) {
        self.restoreSelection(self.savedSelection);

        if (isCancelled) {
          return;
        }

        // insert image or link
        if ($(this).attr('id') === 'modal-url-' + self.id) {
          var currentLink = $(self.findElementInSelection('a', self.element[0]));
          if (currentLink.length) {
            self.updateCurrentLink(currentLink);
          } else {
            self.createLink($('[name="em-url-' + self.id + '"]', this));
          }
        } else {
          self.insertImage($('#image-' + self.id).val());
        }
      });

      return this;
    },


    /**
    * Function that creates the Url Modal Dialog. This can be customized by making
     a modal with ID `#modal-url-${this.id}`
    * @private
    * @returns {void}
    */
    createURLModal: function createURLModal() {
      var _this8 = this;

      var s = this.settings;
      var urlModal = $('#modal-url-' + this.id);

      if (urlModal.length > 0) {
        return urlModal;
      }

      var targetOptions = '';
      var isTargetCustom = true;

      $.each(s.anchor.targets, function (key, val) {
        targetOptions += '<option value="' + val + '">' + Locale.translate(key) + '</option>';
        if (_this8.settings.anchor.defaultTargetText.toLowerCase() === key.toLowerCase()) {
          isTargetCustom = false;
        }
      });

      if (isTargetCustom) {
        targetOptions += '<option value="' + s.anchor.target + '">' + s.anchor.target + '</option>';
      }
      // TODO: Rename to link when you get strings
      return $('<div class="modal editor-modal-url" id="modal-url-' + this.id + '"></div>').html('<div class="modal-content">\n        <div class="modal-header">\n          <h1 class="modal-title">' + Locale.translate('InsertAnchor') + '</h1>\n        </div>\n        <div class="modal-body">\n          <div class="field">\n            <label for="em-url-' + this.id + '">' + Locale.translate('Url') + '</label>\n            <input id="em-url-' + this.id + '" name="em-url-' + this.id + '" type="text" value="' + s.anchor.url + '">\n          </div>\n          ' + (s.anchor.showIsClickable ? '<div class="field">\n            <input type="checkbox" class="checkbox" id="em-isclickable-' + this.id + '" name="em-isclickable-' + this.id + '" checked="' + s.anchor.isClickable + '">\n            <label for="em-isclickable-' + this.id + '" class="checkbox-label"> ' + Locale.translate('Clickable') + '</label>\n          </div>' : '') + '\n          <div class="field">\n            <label for="em-class-' + this.id + '">' + Locale.translate('CssClass') + '</label>\n            <input id="em-class-' + this.id + '" name="em-class-' + this.id + '" type="text" value="' + s.anchor.class + '">\n          </div>\n          <div class="field">\n            <label for="em-target-' + this.id + '" class="label"> ' + Locale.translate('Target') + '</label>\n            <select id="em-target-' + this.id + '" name="em-target-' + this.id + '" class="dropdown">\n              ' + targetOptions + '\n            </select>\n          </div>\n          <div class="modal-buttonset">\n            <button type="button" class="btn-modal btn-cancel"> ' + Locale.translate('Cancel') + '</button>\n            <button type="button" class="btn-modal-primary"> ' + Locale.translate('Insert') + '</button>\n          </div>\n        </div>\n      </div>').appendTo('body');
    },


    /**
     * Function that creates the Image Dialog. This can be customized by making a
      modal with ID `#modal-image-{this.id}`
     * @private
     * @returns {void}
     */
    createImageModal: function createImageModal() {
      var imageModal = $('#modal-image-' + this.id);

      if (imageModal.length > 0) {
        return imageModal;
      }
      return $('<div class="modal editor-modal-image" id="modal-image-' + this.id + '"></div>\'').html('<div class="modal-content">\n        <div class="modal-header">\n          <h1 class="modal-title">' + Locale.translate('InsertImage') + '</h1>\n        </div>\n        <div class="modal-body">\n          <div class="field">\n            <label for="image-' + this.id + '">' + Locale.translate('Url') + '</label>\n            <input id="image-' + this.id + '" name="image-' + this.id + '" type="text" value="' + this.settings.image.url + '">\n          </div>\n          <div class="modal-buttonset">\n            <button type="button" class="btn-modal btn-cancel">\n              ' + Locale.translate('Cancel') + '</button>\n            <button type="button" class="btn-modal-primary">\n              ' + Locale.translate('Insert') + '</button>\n          </div>\n        </div>\n      </div>').appendTo('body');
    },
    bindAnchorPreview: function bindAnchorPreview() {
      this.element.find('a').tooltip({
        content: function content() {
          return $(this).attr('href');
        }
      });
    },
    updateCurrentLink: function updateCurrentLink(alink) {
      var emUrl = xssUtils.stripTags($('[name="em-url-' + this.id + '"]').val());
      var emClass = xssUtils.stripTags($('[name="em-class-' + this.id + '"]').val());
      var emTarget = xssUtils.stripTags($('[name="em-target-' + this.id + '"]').val());
      var emIsClickable = this.settings.anchor.showIsClickable ? $('[name="em-isclickable-' + this.id + '"]').is(':checked') : this.settings.anchor.isClickable;

      if (alink) {
        alink[0].setAttribute('href', this.fixLinkFormat(emUrl && $.trim(emUrl).length ? emUrl : this.settings.anchor.defaultUrl));
        alink[0].setAttribute('class', emClass && $.trim(emClass).length ? emClass : this.settings.anchor.defaultClass);
        alink[0].setAttribute('data-url', (emUrl && $.trim(emUrl).length ? emUrl : this.settings.anchor.defaultUrl).replace('http://', ''));
      }

      if (emIsClickable) {
        alink.attr('contenteditable', false);
      } else {
        alink.removeAttr('contenteditable');
      }

      if (emTarget && $.trim(emTarget).length) {
        alink.attr('target', emTarget);
      } else {
        alink.removeAttr('target');
      }
    },
    createLink: function createLink(input) {
      var _this9 = this;

      // Restore Selection in the Editor and Variables
      this.restoreSelection(this.savedSelection);

      // Fix and Format the Link
      var cleanValue = xssUtils.stripTags(this.fixLinkFormat(input[0].value));
      input.val(cleanValue);

      // Set selection url/class/target for Link
      this.settings.anchor.url = input.val();
      this.settings.anchor.class = $('[name="em-class-' + this.id + '"]').val();
      this.settings.anchor.target = $('[name="em-target-' + this.id + '"]').val();
      this.settings.anchor.isClickable = this.settings.anchor.showIsClickable ? $('[name="em-isclickable-' + this.id + '"]').is(':checked') : this.settings.anchor.isClickable;

      var alink = $('<a data-url="' + cleanValue + '" href="' + cleanValue + '">' + cleanValue + '</a>');

      if (this.settings.anchor.class && $.trim(this.settings.anchor.class).length) {
        alink.addClass(this.settings.anchor.class);
      }
      if (this.settings.anchor.target && $.trim(this.settings.anchor.target).length) {
        alink.attr('target', this.settings.anchor.target);
      }
      if (this.settings.anchor.isClickable) {
        alink.attr('contenteditable', false);
      } else {
        alink.removeAttr('contenteditable');
      }

      if (this.sourceViewActive()) {
        this.insertTextAreaContent(input.val(), 'anchor');
      } else {
        var sel = void 0;
        var range = void 0;
        var rangeChildren = void 0;
        var rangeStr = void 0;
        var rangeImg = void 0;

        if (!this.selection.isCollapsed || this.isIe11) {
          // get example from: http://jsfiddle.net/jwvha/1/
          // and info: http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div
          if (window.getSelection) {
            // IE9 and non-IE
            sel = window.getSelection();
            if (sel.getRangeAt && sel.rangeCount) {
              range = sel.getRangeAt(0);
              rangeStr = '' + range;
              if (rangeStr.trim() !== '') {
                alink.html(rangeStr);
              }

              rangeChildren = range.commonAncestorContainer.children;
              var len = rangeChildren ? rangeChildren.length : 0;
              for (var i = 0; i < len; i++) {
                var rangeChild = rangeChildren[i];

                if (rangeChild instanceof HTMLImageElement) {
                  rangeImg = rangeChild;
                }
              }
              if (rangeImg) {
                alink.html(rangeImg.outerHTML);
              }

              range.deleteContents();

              // Range.createContextualFragment() would be useful here but is
              // only relatively recently standardized and is not supported in
              // some browsers (IE9, for one)
              var el = document.createElement('div');
              el.innerHTML = alink[0].outerHTML;
              var frag = document.createDocumentFragment();
              var node = void 0;
              var lastNode = void 0;

              while (node = el.firstChild) {
                // eslint-disable-line
                lastNode = frag.appendChild(node);
              }
              range.insertNode(frag);

              // Preserve the selection
              if (lastNode) {
                range = range.cloneRange();
                range.setStartAfter(lastNode);
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);
              }
            }
          }
        } else {
          document.execCommand('insertHtml', null, alink[0].outerHTML);
          setTimeout(function () {
            _this9.getCurrentElement().focus();
          }, 1);
        }
        this.bindAnchorPreview();
      }
    },
    fixLinkFormat: function fixLinkFormat(value) {
      if (value.match(/^https?:\/\//)) {
        return value;
      }
      return 'http://' + value;
    },


    // Setup Events For Text Selection
    bindSelect: function bindSelect() {
      var _this10 = this;

      var selectionTimer = '';

      this.selectionHandler = function () {
        clearTimeout(selectionTimer);
        selectionTimer = setTimeout(function () {
          _this10.checkSelection();
        }, _this10.settings.delay);
      };

      var currentElement = this.getCurrentElement();

      currentElement.off('mouseup.editor keyup.editor').on('mouseup.editor keyup.editor', this.selectionHandler);

      return this;
    },
    checkSelection: function checkSelection() {
      var newSelection = void 0;

      if (this.selection === undefined) {
        if (this.sourceViewActive()) {
          newSelection = this.textarea.val().substring(this.textarea[0].selectionStart, this.textarea[0].selectionEnd).toString().trim();
          this.hideToolbarActions();
          return;
        }
      }

      newSelection = window.getSelection();
      var selectionElement = this.getSelectionElement();
      if (!selectionElement) {
        this.hideToolbarActions();
      } else {
        this.checkSelectionElement(newSelection, selectionElement);
      }
      return this;
    },
    getSelectionElement: function getSelectionElement() {
      var range = void 0;
      var current = void 0;
      var parent = void 0;
      var result = void 0;
      var selection = window.getSelection();
      var getElement = function getElement(e) {
        var localParent = e;
        try {
          while (!localParent.getAttribute('data-editor')) {
            localParent = localParent.parentNode;
          }
        } catch (errb) {
          return false;
        }
        return localParent;
      };

      // First try on current node
      try {
        range = selection.getRangeAt(0);
        current = range.commonAncestorContainer;
        parent = current.parentNode;
        result = current.getAttribute('data-editor') ? current : getElement(parent);
        // If not search in the parent nodes.
      } catch (err) {
        result = getElement(parent);
      }
      return result;
    },


    // See if the Editor is Selected and Show Toolbar
    checkSelectionElement: function checkSelectionElement(newSelection, selectionElement) {
      var currentElement = this.sourceViewActive() ? this.sourceView[0] : this.element[0];

      this.selection = newSelection;
      this.selectionRange = this.selection.getRangeAt(0);
      if (currentElement === selectionElement) {
        this.setToolbarButtonStates();
        return;
      }
      this.hideToolbarActions();
    },


    // Set button states for toolbar buttons
    setToolbarButtonStates: function setToolbarButtonStates() {
      this.toolbar.find('button').removeClass('is-active');
      this.checkActiveButtons();
      return this;
    },
    checkActiveButtons: function checkActiveButtons() {
      this.checkButtonState('bold');
      this.checkButtonState('italic');
      this.checkButtonState('underline');
      this.colorpickerButtonState('foreColor');
      if (this.toolbar.find('.buttonset [data-action="backColor"]').length) {
        this.colorpickerButtonState('backColor');
      }

      var parentNode = this.getSelectedParentElement();

      while (parentNode.tagName !== undefined && this.parentElements.indexOf(parentNode.tagName.toLowerCase) === -1) {
        this.activateButton(parentNode.tagName.toLowerCase());

        // we can abort the search upwards if we leave the contentEditable element
        if (this.element.is(parentNode)) {
          break;
        }
        parentNode = parentNode.parentNode;
      }
    },
    checkButtonState: function checkButtonState(command) {
      if (!document.queryCommandState) {
        return;
      }

      if (document.queryCommandState(command)) {
        this.toolbar.find('[data-action="' + command + '"]').addClass('is-active');
      } else {
        this.toolbar.find('[data-action="' + command + '"]').removeClass('is-active');
      }
    },
    rangeSelectsSingleNode: function rangeSelectsSingleNode(range) {
      var startNode = range.startContainer;
      return startNode === range.endContainer && startNode.hasChildNodes() && range.endOffset === range.startOffset + 1;
    },
    getSelectedParentElement: function getSelectedParentElement() {
      var selectedParentElement = null;
      var range = this.selectionRange;

      if (this.rangeSelectsSingleNode(range)) {
        selectedParentElement = range.startContainer.childNodes[range.startOffset];
      } else if (range.startContainer.nodeType === 3) {
        selectedParentElement = range.startContainer.parentNode;
      } else {
        selectedParentElement = range.startContainer;
      }
      return selectedParentElement;
    },


    // Hide Toolbar
    hideToolbarActions: function hideToolbarActions() {
      if (this.toolbar !== undefined) {
        this.toolbar.removeClass('is-active');
      }
    },


    // Handle Pasted In Text
    bindPaste: function bindPaste() {
      var self = this;
      var currentElement = self.getCurrentElement();

      this.pasteWrapper = function (e) {
        var paste = void 0;
        if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
          paste = e.originalEvent.clipboardData.getData('text/plain'); // Standard
        } else {
          paste = window.clipboardData && window.clipboardData.getData ? window.clipboardData.getData('Text') : false; // MS : false
        }

        var p = void 0;
        var paragraphs = void 0;
        var html = '';

        if (self.sourceViewActive()) {
          return this;
        }

        if (paste && !e.defaultPrevented) {
          e.preventDefault();
          paragraphs = paste.split(/[\r\n]/g);

          for (p = 0; p < paragraphs.length; p += 1) {
            if (paragraphs[p] !== '') {
              if (navigator.userAgent.match(/firefox/i) && p === 0) {
                html += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
              } else if (/\.(gif|jpg|jpeg|tiff|png)$/i.test(paragraphs[p])) {
                html += '<img src="' + self.htmlEntities(paragraphs[p]) + '" />';
              } else {
                html += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
              }
            }
          }

          if (document.queryCommandSupported('insertText')) {
            document.execCommand('insertHTML', false, html);
            return false;
          }
          // IE > 7
          self.pasteHtmlAtCaret(html);
        }
      };

      this.pasteWrapperHtml = function (e) {
        if (self.sourceViewActive()) {
          return this;
        }
        var types = void 0;
        var clipboardData = void 0;
        var pastedData = void 0;
        var paste = void 0;
        var p = void 0;
        var paragraphs = void 0;

        if (e.clipboardData || e.originalEvent) {
          if (e.clipboardData && e.clipboardData.types) {
            clipboardData = e.clipboardData;
          } else if (e.originalEvent && e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
            clipboardData = e.originalEvent.clipboardData;
          }
        }

        if (clipboardData && clipboardData.types) {
          types = clipboardData.types;
          if (types instanceof DOMStringList && types.contains('text/html') || types.indexOf && types.indexOf('text/html') !== -1 || self.isIeEdge) {
            pastedData = e.originalEvent.clipboardData.getData('text/html');
          }
          if (types instanceof DOMStringList && types.contains('text/plain')) {
            pastedData = e.originalEvent.clipboardData.getData('text/plain');
          }
          if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object' && types[0] && types[0] === 'text/plain' && !types[1]) {
            pastedData = e.originalEvent.clipboardData.getData('text/plain');
          }
        } else {
          paste = window.clipboardData ? window.clipboardData.getData('Text') : '';
          paragraphs = paste.split(/[\r\n]/g);
          pastedData = '';
          for (p = 0; p < paragraphs.length; p += 1) {
            if (paragraphs[p] !== '') {
              if (navigator.userAgent.match(/firefox/i) && p === 0) {
                pastedData += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
              } else if (/\.(gif|jpg|jpeg|tiff|png)$/i.test(paragraphs[p])) {
                pastedData += '<img src="' + self.htmlEntities(paragraphs[p]) + '" />';
              } else {
                pastedData += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
              }
            }
          }
        }

        self.pastedData = self.isIe11 ? pastedData : self.getCleanedHtml(pastedData);

        /**
        * Fires before paste.
        *
        * @event beforepaste
        * @memberof Editor
        * @type {object}
        * @property {object} event - The jquery event object
        * @property {string} pastedData .
        */
        $.when(self.element.triggerHandler('beforepaste', [{ pastedData: self.pastedData }])).done(function () {
          if (self.pastedData && !e.defaultPrevented) {
            if (!self.isIe11 && !self.isIeEdge) {
              e.preventDefault();
            }

            if (document.queryCommandSupported('insertText')) {
              document.execCommand('insertHTML', false, self.pastedData);
              return false;
            }
            self.pasteHtmlAtCaret(self.pastedData);
          }

          /**
          * Fires after paste.
          *
          * @event afterpaste
          * @memberof Editor
          * @type {object}
          * @property {object} event - The jquery event object
          * @property {string} pastedData .
          */
          self.element.triggerHandler('afterpaste', [{ pastedData: self.pastedData }]);
          self.pastedData = null;
        });
        if (!self.isIe11) {
          return false;
        }
      };

      currentElement.on('paste.editor', self.settings.pasteAsPlainText ? self.pasteWrapper : self.pasteWrapperHtml);

      return this;
    },
    pasteHtmlAtCaret: function pasteHtmlAtCaret(html) {
      var self = this;
      var templIE11 = 'x-text-content-templ-x';

      var sel = void 0;
      var range = void 0;
      if (window.getSelection) {
        sel = window.getSelection();
        if (sel.getRangeAt && sel.rangeCount) {
          range = sel.getRangeAt(0);
          range.deleteContents();

          if (self.isIe11) {
            html = templIE11;
          }

          // Range.createContextualFragment() would be useful here but is
          // only relatively recently standardized and is not supported in
          // some browsers
          var el = document.createElement('div');

          el.innerHTML = html;

          var frag = document.createDocumentFragment();
          var node = void 0;
          var lastNode = void 0;

          while (node = el.firstChild) {
            // eslint-disable-line
            lastNode = frag.appendChild(node);
          }
          range.insertNode(frag);

          // Preserve the selection
          if (lastNode) {
            range = range.cloneRange();
            range.setStartAfter(lastNode);
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
          }

          // IE 11
          if (self.isIe11) {
            var maxRun = 50;
            var deferredIE11 = $.Deferred();

            var waitForPastedData = function waitForPastedData(elem, savedContent) {
              maxRun--;
              if (maxRun < 0) {
                deferredIE11.reject();
                return;
              }
              // If data has been processes by browser, process it
              if (elem.childNodes && elem.childNodes.length > 0) {
                // Retrieve pasted content via innerHTML
                // (Alternatively loop through elem.childNodes or elem.getElementsByTagName here)
                html = elem.innerHTML;
                // self.pastedData = getCleanedHtml(elem.innerHTML);
                // Restore saved content
                elem.innerHTML = '';
                elem.appendChild(savedContent);
                deferredIE11.resolve();
              } else {
                // Else wait 5ms and try again
                setTimeout(function () {
                  waitForPastedData(elem, savedContent);
                }, 5);
              }
            };

            // Everything else: Move existing element contents to a DocumentFragment for safekeeping
            var savedContent = document.createDocumentFragment();
            while (self.element[0].childNodes.length > 0) {
              savedContent.appendChild(self.element[0].childNodes[0]);
            }
            // Then wait for browser to paste content into it and cleanup
            waitForPastedData(self.element[0], savedContent);

            $.when(deferredIE11).done(function () {
              var str = '';
              var thisNode = self.element.find(':contains(+ ' + templIE11 + ')').filter(function () {
                return this.textContent === templIE11;
              });

              if (!thisNode.length) {
                thisNode = self.element.find(':contains(+ ' + templIE11 + ')').filter(function () {
                  return this.textContent.indexOf(templIE11) > -1 && this.tagName !== 'UL';
                });
              }

              html = self.getCleanedHtml(html);

              // Working with list
              // Start with "<li"
              var pasteHtml = '';
              if (/(^(\s+?)?<li)/ig.test(html)) {
                // Pasted data starts and ends with "li" tag
                if (/((\s+?)?<\/li>(\s+?)?$)/ig.test(html)) {
                  // ends with "</li>"
                  // Do not add "ul" if pasting on "li" node
                  if (!thisNode.is('li')) {
                    html = '<ul>' + html + '</ul>';
                  }
                  pasteHtml = html;
                } else if (thisNode.is('li')) {
                  // Missing at the end "</li>" tag
                  // Pasting on "li" node
                  pasteHtml = html + '</li>';
                } else {
                  // Not pasting on "li" node

                  // If ul was closed and have extra nodes after list close
                  str = html.match(/<\/ul|<\/ol/gi) || [];
                  // Pasted data contains "ul or ol" tags
                  if (str.length) {
                    pasteHtml = html;
                  } else {
                    pasteHtml = html + '</li></ul>';
                  }
                }
              } else if (/((\s+?)?<\/li>(\s+?)?$)/ig.test(html)) {
                // Ends with "</li>" tag, but not started with "li" tag

                // Pasting on "li" node
                if (thisNode.is('li')) {
                  pasteHtml = '<li>' + html;
                } else {
                  str = html.match(/<ul|<ol/gi) || [];
                  // Pasted data contains "ul or ol" tags
                  if (str.length) {
                    html += str[str.length - 1].replace(/<(ul|ol)/gi, '<$1>');
                  } else {
                    html = '<ul>' + html + '</ul>';
                  }
                  pasteHtml = html;
                }
              }

              if (pasteHtml) {
                DOM.html(thisNode, pasteHtml, '*');
              }

              // Default case
              str = self.element[0].innerHTML;
              if (str.indexOf(templIE11) > -1) {
                str = str.replace(templIE11, html);
              }
              self.element[0].innerHTML = self.getCleanedHtml(str);
            });
          }
        }
      } else if (document.selection && document.selection.type !== 'Control') {
        document.selection.createRange().pasteHTML(html);
      }
    },


    // Get cleaned extra from html
    getCleanedHtml: function getCleanedHtml(pastedData) {
      var attributeStripper = void 0;
      var s = pastedData || '';

      var badAttributes = ['start', 'xmlns', 'xmlns:o', 'xmlns:w', 'xmlns:x', 'xmlns:m', 'onmouseover', 'onmouseout', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onload', 'onfocus', 'onblur', 'onclick', 'style'];

      // Remove extra word formating
      if (this.isWordFormat(s)) {
        s = this.cleanWordHtml(s);
      }

      // Remove bad attributes
      for (var i = 0, l = badAttributes.length; i < l; i++) {
        attributeStripper = new RegExp(' ' + badAttributes[i] + '="(.*?)"', 'gi');
        s = this.stripAttribute(s, badAttributes[i], attributeStripper);

        attributeStripper = new RegExp(' ' + badAttributes[i] + '=\'(.*?)\'', 'gi');
        s = this.stripAttribute(s, badAttributes[i], attributeStripper);
      }

      // Remove "ng-" directives and "ng-" classes
      s = s.replace(/\sng-[a-z-]+/, '');

      // Remove comments
      s = s.replace(/<!--(.*?)-->/gm, '');

      // Remove extra spaces
      s = s.replace(/\s\s+/g, ' ').replace(/\s>+/g, '>');

      // Remove extra attributes from list elements
      s = s.replace(/<(ul|ol)(.*?)>/gi, '<$1>');

      // Remove empty list
      s = s.replace(/<li><\/li>/gi, '');
      s = s.replace(/<(ul|ol)><\/(ul|ol)>/gi, '');

      // Remove html and body tags
      s = s.replace(/<\/?(html|body)(.*?)>/gi, '');

      // Remove header tag and content
      s = s.replace(/<head\b[^>]*>(.*?)<\/head>/gi, '');

      // Remove empty tags
      s = s.replace(/<[^/>]+>[\s]*<\/[^>]+>/gi, '');

      return s;
    },
    htmlEntities: function htmlEntities(str) {
      // converts special characters (like <) into their escaped/encoded values (like &lt;).
      // This allows you to show to display the string without the browser reading it as HTML.
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    },
    bindWindowActions: function bindWindowActions() {
      var _this11 = this;

      var editorContainer = this.element.closest('.editor-container');
      var currentElement = this.getCurrentElement();
      var self = this;

      this.element
      // Work around for Firefox with using keys was not focusing on first child in editor
      // Firefox behaves differently than other browsers
      .on('mousedown.editor', function () {
        _this11.mousedown = true;
      }).on('focus.editor', function () {
        if (_this11.isFirefox && !_this11.mousedown && _this11.element === currentElement) {
          _this11.setFocus();
        }
      })

      // Work around for Chrome's bug wrapping contents in <span>
      // http://www.neotericdesign.com/blog/2013/3/working-around-chrome-s-contenteditable-span-bug
      .on('DOMNodeInserted', function (e) {
        var target = $(e.target);
        var helper = $('<b>helper</b>');

        if (e.target.tagName === 'IMG') {
          target.removeAttr('id style srcset');
        } else if (e.target.tagName === 'SPAN') {
          target.before(helper);
          helper.after(target.contents());
          helper.add(target).remove();
        }
      });

      editorContainer.on('focus.editor', '.editor, .editor-source', function () {
        var elem = $(this);

        editorContainer.addClass('is-active');
        setTimeout(function () {
          if (elem.hasClass('error')) {
            editorContainer.parent().find('.editor-toolbar').addClass('error');
            editorContainer.parent().find('.editor-source').addClass('error');
          }
        }, 100);
      }).on('blur.editor', '.editor, .editor-source', function () {
        editorContainer.removeClass('is-active');
        editorContainer.parent().find('.editor-toolbar').removeClass('error');
        editorContainer.parent().find('.editor-source').removeClass('error');
      });

      if (self.settings.onLinkClick) {
        editorContainer.on('click.editorlinks', 'a', function (e) {
          self.settings.onLinkClick(e, { elem: _this11, url: e.currentTarget.getAttribute('data-url') });
          e.preventDefault();
          e.stopImmediatePropagation();
          e.stopPropagation();
        });
      }

      // Attach Label
      var label = this.element.prevAll('.label');
      for (var i = 0, l = label.length; i < l; i++) {
        label[i].style.cursor = 'default';
      }
      label.on('click.editor', function () {
        currentElement.focus();
      });
      currentElement.attr('aria-label', label.text());
      return this;
    },


    // Restore Text Selection
    restoreSelection: function restoreSelection(savedSel) {
      var sel = window.getSelection();

      if (!savedSel) {
        savedSel = this.savedSelection;
      }

      if (savedSel) {
        sel.removeAllRanges();
        for (var i = 0, len = savedSel.length; i < len; i += 1) {
          sel.addRange(savedSel[i]);
        }
      }
    },


    // Save Text Selection
    saveSelection: function saveSelection() {
      var ranges = void 0;
      var sel = window.getSelection();

      if (sel.getRangeAt && sel.rangeCount) {
        ranges = [];
        for (var i = 0, len = sel.rangeCount; i < len; i += 1) {
          ranges.push(sel.getRangeAt(i));
        }
        return ranges;
      }
      return null;
    },


    // Get the Element the Caret idea from http://bit.ly/1kRmZIL
    getSelectionStart: function getSelectionStart() {
      var node = document.getSelection().anchorNode;
      var startNode = node && node.nodeType === 3 ? node.parentNode : node;
      return startNode;
    },
    getrange: function getrange() {
      return window.getSelection().getRangeAt(0);
    },


    // Find element within the selection
    // http://stackoverflow.com/questions/6052870/how-to-know-if-there-is-a-link-element-within-the-selection
    findElementInSelection: function findElementInSelection(tagname, container) {
      var el = void 0;
      var comprng = void 0;
      var selparent = void 0;
      var rng = this.getrange();

      if (rng) {
        selparent = rng.commonAncestorContainer || rng.parentElement();
        // Look for an element *around* the selected range
        for (el = selparent; el !== container; el = el.parentNode) {
          if (el && el.tagName && el.tagName.toLowerCase() === tagname) {
            return el;
          }
        }

        // Look for an element *within* the selected range
        if (!rng.collapsed && (rng.text === undefined || rng.text) && selparent.getElementsByTagName) {
          el = selparent.getElementsByTagName(tagname);
          comprng = document.createRange ? document.createRange() : document.body.createTextRange();

          for (var i = 0, len = el.length; i < len; i++) {
            // determine if element el[i] is within the range
            if (document.createRange) {
              // w3c
              comprng.selectNodeContents(el[i]);
              if (rng.compareBoundaryPoints(Range.END_TO_START, comprng) < 0 && rng.compareBoundaryPoints(Range.START_TO_END, comprng) > 0) {
                return el[i];
              }
            } else {
              // microsoft
              comprng.moveToElementText(el[i]);
              if (rng.compareEndPoints('StartToEnd', comprng) < 0 && rng.compareEndPoints('EndToStart', comprng) > 0) {
                return el[i];
              }
            }
          }
        }
      }
    },


    // Restore if Selection is a Link
    restoreLinkSelection: function restoreLinkSelection() {
      var currentLink = $(this.findElementInSelection('a', this.element[0]));

      this.settings.anchor.url = this.settings.anchor.defaultUrl;
      this.settings.anchor.class = this.settings.anchor.defaultClass;
      this.settings.anchor.target = this.settings.anchor.defaultTarget;
      this.settings.anchor.isClickable = this.settings.anchor.defaultIsClickable;

      if (currentLink.length) {
        this.settings.anchor.url = currentLink.attr('href');
        this.settings.anchor.class = currentLink.attr('class');
        this.settings.anchor.target = currentLink.attr('target');
        var contenteditable = currentLink.attr('contenteditable');

        if (contenteditable === false || contenteditable === 'false') {
          this.settings.anchor.isClickable = true;
        }
      }
    },


    // Run the CE action.
    execAction: function execAction(action) {
      var currentElement = this.getCurrentElement();

      // Visual Mode
      if (currentElement === this.element) {
        if (action.indexOf('append-') > -1) {
          this.execFormatBlock(action.replace('append-', ''));
        } else if (action === 'anchor') {
          this.restoreLinkSelection();
          this.modals.url.data('modal').open();
        } else if (action === 'image') {
          this.modals.image.data('modal').open();
        } else if (action === 'foreColor' || action === 'backColor') {
          this.colorpickerActions(action);
        } else if (action === 'clearFormatting') {
          this.clearFormatting();
        } else if (action === 'source' || action === 'visual') {
          this.toggleSource();
        } else {
          document.execCommand(action, false, null);
        }
      } else {
        // Source Mode
        switch (action) {
          case 'visual':
            this.toggleSource();
            break;
          case 'anchor':
            this.modals.url.data('modal').open();
            break;
          default:
            this.insertTextAreaContent(null, action);
            break;
        }
      }
    },
    insertImage: function insertImage(url) {
      document.execCommand('insertImage', false, url);
    },
    toggleSource: function toggleSource() {
      if (this.sourceViewActive()) {
        this.element.empty().html(xssUtils.sanitizeHTML(this.textarea.val()));
        this.element.removeClass('source-view-active hidden');
        this.sourceView.addClass('hidden').removeClass('is-focused');
        this.element.trigger('focus.editor');
      } else {
        // Format The Text being pulled from the WYSIWYG editor
        var val = this.element.html().toString().trim().replace(/\s+/g, ' ').replace(/<br( \/)?>/g, '<br>\n').replace(/<\/p> /g, '</p>\n\n').replace(/<\/blockquote>( )?/g, '</blockquote>\n\n');

        this.textarea.val(val).focus();

        // var val = this.element.html().toString();
        // this.textarea.val(this.formatHtml(val)).focus();

        this.element.addClass('source-view-active hidden');
        this.sourceView.removeClass('hidden');
        this.adjustSourceLineNumbers();
        this.textarea.focus();
      }
      this.switchToolbars();
    },


    /**
     * Function to clear formatting on selected area.
     * @private
     * @returns {void}
     */
    clearFormatting: function clearFormatting() {
      var _this12 = this;

      var parentEl = this.getSelectionParentElement();
      var parentTag = parentEl.tagName;
      var align = {};

      // Function to get text-align value if found
      var getTextAlign = function getTextAlign() {
        var isFound = function isFound(el) {
          return el && el.style && el.style.textAlign !== '';
        };
        var elem = parentEl;
        var found = isFound(elem);
        var max = 9999;
        while (!found && max > 0) {
          max--;
          elem = elem ? elem.parentNode : null;
          found = elem && elem === _this12.element[0] || isFound(elem);
        }
        var r = { found: elem && elem !== parentEl && elem !== _this12.element[0] };
        if (r.found) {
          r.elem = elem;
          r.textAlign = elem.style.textAlign;
        }
        return r;
      };

      // Clear other formated tags.
      var clearFormatedTags = function clearFormatedTags() {
        var replaceTag = function replaceTag(elem) {
          var parent = elem.parentNode;
          var p = document.createElement('p');
          p.innerHTML = elem.innerHTML;
          parent.replaceChild(p, elem);
        };
        if (_this12.parentElements.indexOf(parentTag) > -1) {
          if (parentTag !== 'p') {
            replaceTag(parentEl);
          }
        } else {
          _this12.parentElements.forEach(function (el) {
            if (el !== 'p') {
              var nodes = [].slice.call(parentEl.querySelectorAll(el));
              nodes.forEach(function (node) {
                return replaceTag(node);
              });
            }
          });
        }
      };

      // Clear all lists belongs to selection area
      var clearLists = function clearLists() {
        var normalizeList = function normalizeList(list) {
          var items = [].slice.call(list.querySelectorAll('li'));
          if (items.length > 0) {
            var fragment = document.createDocumentFragment();
            items.forEach(function (item) {
              var textNode = document.createTextNode(item.textContent);
              fragment.appendChild(textNode);
              fragment.appendChild(document.createElement('br'));
            });
            var target = items[0].parentNode;
            target.parentNode.insertBefore(fragment, target.nextSibling);
            target.parentNode.removeChild(target);
          }
        };
        if (parentTag === 'li') {
          normalizeList(parentEl.parentNode);
        } else if (/ul|ol/.test(parentTag)) {
          normalizeList(parentEl);
        } else {
          var lists = [].slice.call(parentEl.parentNode.querySelectorAll('ul, ol'));
          lists.forEach(function (list) {
            return normalizeList(list);
          });
        }
      };

      // Check if selection contains given node
      var containsNodeInSelection = function containsNodeInSelection(node) {
        var sel = window.getSelection();
        var r = false;
        if (_this12.isIe11) {
          var rangeAt = sel.getRangeAt(0);
          var range = document.createRange();
          range.selectNode(node);
          var s2s = rangeAt.compareBoundaryPoints(Range.START_TO_END, range);
          var s2e = rangeAt.compareBoundaryPoints(Range.START_TO_START, range);
          var e2s = rangeAt.compareBoundaryPoints(Range.END_TO_START, range);
          var e2e = rangeAt.compareBoundaryPoints(Range.END_TO_END, range);
          r = s2s !== s2e || e2s !== e2e || s2s !== e2e;
        } else {
          r = sel.containsNode(node, true);
        }
        return r;
      };

      // Convert hyperlinks to plain text in selected area.
      var hyperlinksToText = function hyperlinksToText() {
        var toText = function toText(a) {
          var parent = a.parentNode;
          var text = a.firstChild;
          parent.insertBefore(text, a);
          parent.removeChild(a);
          parent.normalize();
        };
        if (parentTag === 'a') {
          toText(parentEl);
        } else {
          var links = [].slice.call(parentEl.querySelectorAll('a'));
          links.forEach(function (a) {
            if (containsNodeInSelection(a)) {
              toText(a);
            }
          });
        }
      };

      if (parentEl && parentTag) {
        parentTag = parentTag.toLowerCase();
        align = getTextAlign();
        clearLists();
        clearFormatedTags();
        hyperlinksToText();
      }

      // Some browser (IE, Firefox) use attr 'align' instead style `text-align`
      var gParentEl = parentEl.parentNode;
      if (gParentEl !== this.element[0]) {
        var alignAttrElems = [].slice.call(gParentEl.querySelectorAll('[align]'));
        alignAttrElems.forEach(function (el) {
          return el.removeAttribute('align');
        });
      }
      document.execCommand('removeFormat', false, null);

      // Restore style `text-align`, some browser (chrome, safari) clear `text-align` on parent node with command `removeFormat`
      if (align.found) {
        align.elem.style.textAlign = align.textAlign;
      }
    },


    /**
     * Get selection parent element.
     * @private
     * @returns {object} parent element.
     */
    getSelectionParentElement: function getSelectionParentElement() {
      var parentEl = null;
      var sel = void 0;
      if (window.getSelection) {
        sel = window.getSelection();
        if (sel.rangeCount) {
          parentEl = sel.getRangeAt(0).commonAncestorContainer;
          if (parentEl.nodeType !== 1) {
            parentEl = parentEl.parentNode;
          }
        }
      } else {
        sel = document.selection;
        if (sel && sel.type !== 'Control') {
          parentEl = sel.createRange().parentElement();
        }
      }
      return parentEl;
    },


    // Set ['foreColor'|'backColor'] button icon color in toolbar
    colorpickerButtonState: function colorpickerButtonState(action) {
      var cpBtn = $('[data-action="' + action + '"]', this.toolbar);
      var cpApi = cpBtn.data('colorpicker');

      var color = document.queryCommandValue(action);

      // Set selection color checkmark in picker popup
      // by adding/updating ['data-value'] attribute
      if (cpApi) {
        if (this.isFirefox && action === 'backColor') {
          color = $(window.getSelection().focusNode.parentNode).css('background-color');
        }
        // IE-11 queryCommandValue returns the as decimal
        if (typeof color === 'number') {
          color = cpApi.decimal2rgb(color);
        }
        color = cpApi.rgb2hex(color);
        cpBtn.attr('data-value', color).find('.icon').css('fill', color === 'transparent' ? '' : color);
      }
      return { cpBtn: cpBtn, cpApi: cpApi, color: color };
    },


    // Colorpicker actions ['foreColor'|'backColor']
    colorpickerActions: function colorpickerActions(action) {
      var _this13 = this;

      var state = this.colorpickerButtonState(action);
      var cpBtn = state.cpBtn;
      var cpApi = state.cpApi;

      cpBtn.on('selected.editor', function (e, item) {
        var value = ('#' + item.data('value')).toLowerCase();
        value = value !== '#' ? value : '';
        cpBtn.attr('data-value', value).find('.icon').css('fill', value);

        if (_this13.isIe || action === 'foreColor') {
          if (value) {
            document.execCommand(action, false, value);
          } else {
            document.execCommand('removeFormat', false, action);
          }
        } else {
          // [action: backColor] - for Chrome/Firefox/Safari

          // FIX: "backColor" - Chrome/Firefox/Safari
          // some reason font/span node not get inserted with "backColor"
          // so use "fontSize" command to add node, then remove size attribute
          // this fix will conflict with combination of font size & background color
          document.execCommand('fontSize', false, '2');
          var parent = _this13.getSelectionParentElement().parentNode;
          var els = parent.getElementsByTagName('font');

          // Using timeout, firefox not executes with current call stack
          setTimeout(function () {
            for (var i = 0, l = els.length; i < l; i++) {
              if (els[i].hasAttribute('size')) {
                els[i].style.backgroundColor = value;
                els[i].removeAttribute('size');
              }
            }
          }, 0);
        }

        setTimeout(function () {
          _this13.getCurrentElement().focus();
        }, 0);
      });

      // Toggle colorpicker
      cpApi.toggleList();
    },
    execFormatBlock: function execFormatBlock(el) {
      var selectionData = this.getSelectionData(this.selection.anchorNode);
      // FF handles blockquote differently on formatBlock
      // allowing nesting, we need to use outdent
      // https://developer.mozilla.org/en-US/docs/Rich-Text_Editing_in_Mozilla
      if (el === 'blockquote' && selectionData.el && selectionData.el.parentNode.tagName.toLowerCase() === 'blockquote') {
        return document.execCommand('outdent', false, null);
      }
      if (selectionData.tagName === el) {
        el = 'p';
      }
      // When IE we need to add <> to heading elements and
      // blockquote needs to be called as indent
      // http://stackoverflow.com/questions/10741831/execcommand-formatblock-headings-in-ie
      // http://stackoverflow.com/questions/1816223/rich-text-editor-with-blockquote-function/1821777#1821777
      if (this.isIe) {
        if (el === 'blockquote') {
          return document.execCommand('indent', false, el);
        }
        el = '<' + el + '>';
      }

      return document.execCommand('formatBlock', false, el);
    },


    // Get What is Selected
    getSelectionData: function getSelectionData(el) {
      var tagName = void 0;

      if (el && el.tagName) {
        tagName = el.tagName.toLowerCase();
      }

      while (el && this.parentElements.indexOf(tagName) === -1) {
        el = el.parentNode;
        if (el && el.tagName) {
          tagName = el.tagName.toLowerCase();
        }
      }

      return { el: el, tagName: tagName };
    },
    isListItemChild: function isListItemChild(node) {
      var parentNode = node.parentNode;
      var tagName = parentNode.tagName.toLowerCase();

      while (this.parentElements.indexOf(tagName) === -1 && tagName !== 'div') {
        if (tagName === 'li') {
          return true;
        }
        parentNode = parentNode.parentNode;
        if (parentNode && parentNode.tagName) {
          tagName = parentNode.tagName.toLowerCase();
        } else {
          return false;
        }
      }
      return false;
    },
    destroyToolbar: function destroyToolbar() {
      // Unbind all events attached to the old element that involve triggering the toolbar hide/show

      var toolbarApi = this.toolbar.data('toolbar');
      if (toolbarApi) {
        toolbarApi.destroy();
      }

      var tooltips = this.toolbar.find('button');
      for (var i = 0, l = tooltips.length; i < l; i++) {
        var tooltip = $(tooltips[i]).data('tooltip');
        if (tooltip && typeof tooltip.destroy === 'function') {
          tooltip.destroy();
        }
      }

      var colorpickers = $('[data-action="foreColor"], [data-action="backColor"]', this.element);
      for (var _i = 0, _l = colorpickers.length; _i < _l; _i++) {
        var colorpicker = $(colorpickers[_i]).data('colorpicker');
        if (colorpicker && typeof colorpicker.destroy === 'function') {
          colorpicker.destroy();
        }
      }

      this.toolbar.off('touchstart.editor click.editor click.editor mousedown.editor');
      this.toolbar.remove();
      this.toolbar = undefined;
      this.element.off('mouseup.editor keypress.editor input.editor keyup.editor keydown.editor focus.editor mousedown.editor DOMNodeInserted.editor updated.editor blur.editor paste.editor');
      this.textarea.off('mouseup.editor click.editor keyup.editor input.editor focus.editor blur.editor');
      this.element.prev('.label').off('click.editor');

      this.element.closest('.editor-container').off('focus.editor blur.editor click.editorlinks');

      var state = this.colorpickerButtonState('foreColor');
      var cpBtn = state.cpBtn;
      cpBtn.off('selected.editor');

      state = this.colorpickerButtonState('backColor');
      cpBtn = state.cpBtn;
      cpBtn.off('selected.editor');

      $(window).off('resize.editor');

      if (this.modals) {
        for (var _i2 = 0, _l2 = this.modals.length; _i2 < _l2; _i2++) {
          var modal = $(this.modals[_i2]);
          var modalApi = modal.data('modal');
          modal.off('beforeclose.editor close.editor open.editor beforeopen.editor');
          if (modalApi && typeof modalApi.destroy === 'function') {
            modalApi.destroy();
          }
        }
      }
      this.modals = {};

      this.element.trigger('destroy.toolbar.editor');
    },


    /**
     * Updates the component instance.  Can be used after being passed new settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, EDITOR_DEFAULTS);
      }
      return this.teardown().init();
    },
    teardown: function teardown() {
      this.element.off('input.editor keyup.editor');
      $('html').off('mouseup.editor');

      this.destroyToolbar();
      if (this.sourceView) {
        this.sourceView.off('.editor');
        this.sourceView.remove();
        this.sourceView = null;
      }

      if ($('[data-editor="true"]').length === 1) {
        $('#modal-url-' + this.id + ', #modal-image-' + this.id).remove();
      }

      return this;
    },


    /**
     * Destroy this component instance and remove all events and reset back to default.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$D);
    },


    /**
    * Disable the editable area.
    * @returns {void}
    */
    disable: function disable() {
      this.element.addClass('is-disabled').attr('contenteditable', 'false');
      this.container.addClass('is-disabled');
    },


    /**
    * Enable the editable area.
    * @returns {void}
    */
    enable: function enable() {
      this.element.removeClass('is-disabled is-readonly').attr('contenteditable', 'true');
      this.container.removeClass('is-disabled is-readonly');
    },


    /**
    * Make the editable area readonly.
    * @returns {void}
    */
    readonly: function readonly() {
      this.element.removeClass('is-readonly').attr('contenteditable', 'false');
      this.container.addClass('is-readonly');
    },


    // Fix to Firefox get focused by keyboard
    setFocus: function setFocus() {
      var el = $.trim(this.element.html()).slice(0, 1) === '<' ? $(':first-child', this.element)[0] : this.element[0];

      window.setTimeout(function () {
        var sel = void 0;
        var range = void 0;
        if (window.getSelection && document.createRange) {
          range = document.createRange();
          range.selectNodeContents(el);
          range.collapse(true);
          sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
        } else if (document.body.createTextRange) {
          range = document.body.createTextRange();
          range.moveToElementText(el);
          range.collapse(true);
          range.select();
        }
      }, 1);
    },


    // Called whenever a paste event has occured
    onPasteTriggered: function onPasteTriggered() {
      if (!this.isFirefox && document.addEventListener) {
        document.addEventListener('paste', function (e) {
          if (typeof e.clipboardData !== 'undefined') {
            var copiedData = e.clipboardData.items[0]; // Get the clipboard data
            // If the clipboard data is of type image, read the data
            if (copiedData.type.indexOf('image') === 0) {
              var imageFile = copiedData.getAsFile();
              // We will use HTML5 FileReader API to read the image file
              var reader = new FileReader();

              reader.onload = function (evt) {
                var result = evt.target.result; // base64 encoded image
                document.execCommand('insertImage', false, result);
                // Create an image element and append it to the content editable div
                // var img = document.createElement('img');
                // img.src = result;
                // document.getElementById('editablediv').appendChild(img);
              };
              // Read the image file
              reader.readAsDataURL(imageFile);
            }
          }
        }, false);
      }
    },
    isWordFormat: function isWordFormat(content) {
      return (/<font face="Times New Roman"|class="?Mso|style="[^"]*\bmso-|style='[^'']*\bmso-|w:WordDocument/i.test(content) || /class="OutlineElement/.test(content) || /id="?docs\-internal\-guid\-/.test(content)
      );
    },
    cleanWordHtml: function cleanWordHtml(content) {
      var s = content;

      // Word comments like conditional comments etc
      s = s.replace(/<!--[\s\S]+?-->/gi, '');

      // Remove comments, scripts (e.g., msoShowComment), XML tag, VML content,
      // MS Office namespaced tags, and a few other tags
      s = s.replace(/<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|img|meta|link|style|\w:\w+)(?=[\s\/>]))[^>]*>/gi, '');

      // Convert <s> into <strike> for line-though
      s = s.replace(/<(\/?)s>/gi, '<$1strike>');

      // Replace nsbp entites to char since it's easier to handle
      s = s.replace(/&nbsp;/gi, '\xA0');

      // Convert <span style="mso-spacerun:yes"></span> to string of alternating
      // breaking/non-breaking spaces of same length
      s = s.replace(/<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00a0]*)<\/span>/gi, function (str, spaces) {
        return spaces.length > 0 ? spaces.replace(/./, ' ').slice(Math.floor(spaces.length / 2)).split('').join('\xA0') : '';
      });

      // Remove line breaks / Mso classes
      s = s.replace(/(\n|\r| class=(\'|")?Mso[a-zA-Z]+(\'|")?)/g, ' ');

      var badTags = ['style', 'script', 'applet', 'embed', 'noframes', 'noscript'];

      // Remove everything in between and including "badTags"
      for (var i = 0, l = badTags.length; i < l; i++) {
        var re = new RegExp('<' + badTags[i] + '.*?' + badTags[i] + '(.*?)>', 'gi');
        s = s.replace(re, '');
      }

      return s;
    },


    // Strip attributes
    stripAttribute: function stripAttribute(s, attribute, attributeStripper) {
      return attribute === 'style' ? this.stripStyles(s, attributeStripper) : s.replace(attributeStripper, '');
    },


    // Strip styles
    stripStyles: function stripStyles(s, styleStripper) {
      var stylesToKeep = ['color', 'background', 'font-weight', 'font-style', 'text-decoration', 'text-align'];
      return s.replace(styleStripper, function (m) {
        m = m.replace(/( style=|("|\'))/gi, '');
        var attributes = m.split(';');
        var strStyle = '';
        for (var i = 0; i < attributes.length; i++) {
          var entry = attributes[i].split(':');
          strStyle += stylesToKeep.indexOf(entry[0]) > -1 ? entry[0] + ':' + entry[1] + ';' : '';
        }
        return strStyle !== '' ? ' style="' + strStyle + '"' : '';
      });
    },
    getIndent: function getIndent(level) {
      var result = '';
      var i = level * 2;
      if (level > -1) {
        while (i--) {
          result += ' ';
        }
      }
      return result;
    },
    formatHtml: function formatHtml(html) {
      html = html.trim();
      var result = '';
      var indentLevel = 0;
      var tokens = html.split(/</);

      for (var i = 0, l = tokens.length; i < l; i++) {
        var parts = tokens[i].split(/>/);
        if (parts.length === 2) {
          if (tokens[i][0] === '/') {
            indentLevel--;
          }
          result += this.getIndent(indentLevel);
          if (tokens[i][0] !== '/') {
            indentLevel++;
          }
          if (i > 0) {
            result += '<';
          }
          result += parts[0].trim() + ' + >\n';
          if (parts[1].trim() !== '') {
            result += this.getIndent(indentLevel) + parts[1].trim().replace(/\s+/g, ' ') + '\n';
          }
          if (parts[0].match(/^(area|base|br|col|command|embed|hr|img|input|link|meta|param|source)/)) {
            indentLevel--;
          }
        } else {
          result += this.getIndent(indentLevel) + parts[0] + '\n';
        }
      }
      return result.trim();
    },


    /**
     * Clear the editor of its contents.
     */
    clear: function clear() {
      this.element.empty();
      this.textarea.empty();
      this.sourceView.find('.line-numbers').empty();
      this.sourceView.find('.textarea-print').empty();
    }
  };

  // Initialize the plugin (Once)
  $.fn.editor = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$D);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$D, new Editor(this, settings));
      }
    });
  };

  // The name of this component
  var COMPONENT_NAME$E = 'hierarchy';

  /**
  * The displays customizable hierarchical data such as an org chart.
  *
  * @class Hierarchy
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  * @param {string} [settings.legend] Pass in custom markdown for the legend structure.
  * @param {string} [settings.legendKey] Key to use for the legend matching
  * @param {string} [settings.dataset=[]] Hierarchical Data to display
  * @param {boolean} [settings.newData=[]] New data to be appended into dataset
  * @param {string} [settings.templateId] Additional product name information to display
  * @param {boolean} [settings.mobileView=false] If true will only show mobile view, default using device info.
  * @param {number} [settings.leafHeight=null] Set the height of the leaf
  * @param {number} [settings.leafWidth=null] Set the width of the leaf
  * @param {string} [settings.beforeExpand=null] A callback that fires before node expansion of a node.
  * @param {boolean} [settings.paging=false] If true show pagination.
  * @param {boolean} [settings.renderSubLevel=false] If true elements with no children will be rendered detached
  * @param {object} [settings.emptyMessage = { title: 'No Data', info: , icon: 'icon-empty-no-data' }]
  * An empty message will be displayed when there is no chart data. This accepts an object of the form
  * `emptyMessage: {
  *   title: 'No Data Available',
  *   info: 'Make a selection on the list above to see results',
  *   icon: 'icon-empty-no-data',
  *   button: {text: 'xxx', click: <function>
  *   }`
  * Set this to null for no message or will default to 'No Data Found with an icon.'
  */
  var HIERARCHY_DEFAULTS = {
    legend: [],
    legendKey: '',
    dataset: [],
    newData: [],
    templateId: '', // Id to the Html Template
    mobileView: false,
    leafHeight: null,
    leafWidth: null,
    beforeExpand: null,
    paging: false,
    renderSubLevel: false,
    rootClass: 'hierarchy',
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' }
  };

  function Hierarchy(element, settings) {
    this.settings = utils.mergeSettings(element, settings, HIERARCHY_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Hierarchy Methods
  Hierarchy.prototype = {
    init: function init() {
      var isMobile = this.settings.mobileView;
      var s = this.settings;
      this.settings.rootClass = 'hierarchy';

      s.colorClass = ['azure08', 'turquoise02', 'amethyst06', 'slate06', 'amber06', 'emerald07', 'ruby06'];
      this.handleEvents();

      // Safety check, check for data
      if (s.dataset) {
        if (s.dataset.length === 0) {
          this.element.emptymessage(s.emptyMessage);
          return;
        } else if (s.dataset[0] && s.dataset[0].children.length > 0) {
          this.render(s.dataset[0]);
        } else if (s.dataset && s.dataset.children.length > 0) {
          this.render(s.dataset);
        }
      }

      if (s.leafHeight !== null && s.leafWidth !== null) {
        var style = '\'body .hierarchy .leaf,body .hierarchy .sublevel .leaf,body .hierarchy .container .root.leaf { width: ' + s.leafWidth + 'px;  height: ' + s.leafHeight + 'px;  }\'';

        $('<style type="text/css" id="hierarchyLeafStyles">' + style + '</style>').appendTo('body');
      }

      if (isMobile) {
        this.element.addClass('is-mobile');
      }
    },


    /**
     * Attach all event handlers
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;
      var s = this.settings;

      // Expand or Collapse
      self.element.off('click.hierarchy').on('click.hierarchy', '.btn', function (e) {
        if (s.newData.length > 0) {
          s.newData = [];
        }

        var nodeId = $(this).closest('.leaf').attr('id');
        var nodeData = $('#' + nodeId).data();
        var domObject = {
          branch: $(this).closest('li'),
          leaf: $(this).closest('.leaf'),
          button: $(this)
        };

        if (nodeData.isExpanded) {
          self.collapse(e, nodeData, domObject);
        } else {
          self.expand(e, nodeData, domObject);
        }
      });

      this.element.on('keypress', '.leaf', function (e) {
        var nodeId = $(this).attr('id');
        var nodeData = $('#' + nodeId);

        if (e.which === 13) {
          if (nodeData.isExpanded) {
            self.collapse(e, nodeData);
          } else {
            self.expand(e, nodeData);
          }
        }
      });

      self.element.off('dblclick.hierarchy').on('dblclick.hierarchy', '.leaf', function (e) {
        var nodeId = e.currentTarget.id;
        var nodeData = $('#' + nodeId).data();
        var dblClickEvent = { event: e, data: nodeData };
        e.stopImmediatePropagation();

        _this.element.trigger('dblclick', dblClickEvent);
      });

      /**
      * Fires when node is selected
      * @event selected
      * @memberof Hierarchy
      * @param {object} event - The jquery event object
      * @param {object} eventInfo - More info to identify the node.
      */
      self.element.on('mouseup', '.leaf, .back button', function (e) {
        var leaf = $(this);
        var target = $(e.target);
        var hierarchy = leaf.closest('.hierarchy').data('hierarchy');
        var nodeData = leaf.data();
        var nodeId = $(this).attr('id');
        var targetInfo = { target: e.target, pageX: e.pageX, pageY: e.pageY };
        var isButton = target.is('button');
        var isNotBack = !target.hasClass('btn-back');
        var isBack = target.is('.btn-back');
        var svgHref = target.find('use').prop('href');
        var isCollapseButton = svgHref ? svgHref.baseVal === '#icon-caret-up' : false;
        var isExpandButton = svgHref ? svgHref.baseVal === '#icon-caret-down' : false;
        var isForward = svgHref ? svgHref.baseVal === '#icon-caret-right' : false;
        var isActions = target.hasClass('btn-actions');
        var isAction = target.is('a') && target.parent().parent().is('ul.popupmenu');
        var eventType = 'selected';

        e.stopImmediatePropagation();

        if (isAction && $(target).parent().data('disabled')) {
          return;
        }

        $('.is-selected').removeClass('is-selected');
        $('#' + nodeId).addClass('is-selected');

        // Is collapse event
        if (isButton && isCollapseButton && isNotBack) {
          eventType = 'collapse';
        }

        // Is expand event
        if (isButton && isExpandButton && isNotBack) {
          eventType = 'expand';
        }

        if (isBack) {
          eventType = 'back';
        }

        if (isActions) {
          eventType = 'actions';
          hierarchy.buildActionsMenu(nodeData, leaf);
        }

        if (isAction) {
          eventType = 'action';
        }

        if (isButton && isForward && isNotBack) {
          eventType = 'forward';
        }

        // Is right click event
        if (e.which === 3) {
          eventType = 'rightClick';
        }

        if (!hierarchy) {
          return;
        }

        var eventInfo = {
          data: nodeData,
          actionReference: isAction ? target.data('actionReference') : null,
          targetInfo: targetInfo,
          eventType: eventType,
          isForwardEvent: hierarchy.isForwardEvent(eventType),
          isBackEvent: hierarchy.isBackEvent(eventType),
          isAddEvent: hierarchy.isAddEvent(eventType),
          isExpandEvent: hierarchy.isExpandEvent(eventType),
          isCollapseEvent: hierarchy.isCollapseEvent(eventType),
          isSelectedEvent: hierarchy.isSelectedEvent(eventType),
          isActionsEvent: hierarchy.isActionsEvent(eventType),
          isActionEvent: hierarchy.isActionEvent(eventType),
          allowLazyLoad: hierarchy.allowLazyLoad(nodeData, eventType)
        };

        leaf.trigger('selected', eventInfo);
      });
    },


    /**
     * Manually set selection on a leaf
     * @public
     * @param {string} nodeId id used to find leaf
     */
    selectLeaf: function selectLeaf(nodeId) {
      var leaf = $('#' + nodeId);
      $('.is-selected').removeClass('is-selected');
      leaf.addClass('is-selected');

      var eventInfo = {
        data: leaf.data(),
        actionReference: null,
        isForwardEvent: false,
        isBackEvent: false,
        isAddEvent: false,
        isExpandEvent: false,
        isCollapseEvent: false,
        isSelectedEvent: true,
        isActionsEvent: false,
        isActionEvent: false,
        allowLazyLoad: false
      };

      leaf.trigger('selected', eventInfo);
    },


    /**
     * Update existing leaf actions with new actions
     * @public
     * @param {object} eventInfo eventType, target, data, ect..
     * @param {array} updatedActions -actions to be appended to the menu
     */
    updateActions: function updateActions(eventInfo, updatedActions) {
      var leaf = $(eventInfo.targetInfo.target).closest('.leaf');
      var nodeData = eventInfo.data;
      var popupMenu = $(leaf).find('.popupmenu');
      var lineItemsToRemove = popupMenu.find('li').not(':eq(0)');

      $(lineItemsToRemove).each(function (idx, item) {
        $(item).remove();
      });

      nodeData.menu.actions = updatedActions;
      popupMenu.append(this.getActionMenuItems(nodeData));
    },


    /**
     * @private
     * @param {object} data associated with leaf
     * @param {leaf} leaf jQuery reference in DOM
     */
    buildActionsMenu: function buildActionsMenu(data, leaf) {
      var popupMenu = $(leaf).find('.popupmenu');
      var template = [];

      // Safety
      if (data.menu === undefined) {
        return;
      }

      // Reset & rebuild
      popupMenu.empty();

      if (data.menu.details) {
        popupMenu.addClass('has-detail-fields');
        template.push('<li><div class="detail-fields">' + data.menu.details.map(function (v) {
          return '<div class="dt-fields-row"><div class="dt-fields-cell">' + v.key + '</div><div class="dt-fields-cell">' + v.value + '</div></div>';
        }).join('') + '</div></li>');
      }

      if (data.menu.actions) {
        template.push(this.getActionMenuItems(data));
      }

      template.forEach(function (i) {
        popupMenu.append(i);
      });
    },


    /**
     * @private
     * @param {object} data the data to be iterated
     * @returns {string} returns list items as a string
     */
    getActionMenuItems: function getActionMenuItems(data) {
      var actions = data.menu.actions.map(function (a) {
        if (a.disabled === undefined) {
          a.disabled = false;
        }

        return a;
      });

      // Ignoring next line. Eslint expects template literals vs string concat.
      // However template literals break JSON.stringify() in this case
      /* eslint-disable */
      return '' + actions.map(function (a) {
        return '\n      <li data-disabled=\'' + a.disabled + '\' class=\'' + (a.menu ? 'submenu' : '') + '\'>\n        <a href=\'' + a.url + '\' data-action-reference=\'' + JSON.stringify(a.data) + ('\'>\n          ' + a.value + '\n          ' + (a.menu ? '<svg class="arrow icon-dropdown icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-dropdown"></use></svg>' : '') + '\n        </a>\n        ' + (a.menu ? '<div class="wrapper" role="application" aria-hidden="true">\n          <ul class="popupmenu">\n            ' + a.menu.map(function (i) {
          return '\n            <li data-disabled=\'' + a.disabled + '\'>\n              <a href=\'' + a.url + '\' data-action-reference=\'' + JSON.stringify(a.data) + ('\'>' + i.value + '</a>\n            </li>');
        }).join('') + '\n          </ul>\n        </div>' : '') + '\n      </li>');
      }).join('');
      /* eslint-enable */
    },


    /**
     * Check if event is back
     * @private
     * @param {string} eventType is back
     * @returns {boolean} true if back event
     */
    isBackEvent: function isBackEvent(eventType) {
      return eventType === 'back';
    },


    /**
     * Check if event is forward
     * @private
     * @param {string} eventType is forward
     * @returns {boolean} true if forward event
     */
    isForwardEvent: function isForwardEvent(eventType) {
      return eventType === 'forward';
    },


    /**
     * Check if event is add
     * @private
     * @param {string} eventType is add
     * @returns {boolean} true if add event
     */
    isAddEvent: function isAddEvent(eventType) {
      return eventType === 'add';
    },


    /**
     * Check if event is expand
     * @private
     * @param {string} eventType is expand
     * @returns {boolean} true if expand event
     */
    isExpandEvent: function isExpandEvent(eventType) {
      return eventType === 'expand';
    },


    /**
     * Check if event is collapse
     * @private
     * @param {string} eventType is collapse
     * @returns {boolean} true if collapse event
     */
    isCollapseEvent: function isCollapseEvent(eventType) {
      return eventType === 'collapse';
    },


    /**
     * Check if event is selected
     * @private
     * @param {string} eventType is selected
     * @returns {boolean} true if selected event
     */
    isSelectedEvent: function isSelectedEvent(eventType) {
      return eventType === 'selected';
    },


    /**
     * Checks if is actions event
     * @private
     * @param {string} eventType is actions
     * @returns {boolean} true if actions event
     */
    isActionsEvent: function isActionsEvent(eventType) {
      return eventType === 'actions';
    },


    /**
     * @private
     * @param {string} evenType is action
     * @returns {boolean} true if action
     */
    isActionEvent: function isActionEvent(evenType) {
      return evenType === 'action';
    },


    /**
     * Check to see if lazy load is allowed
     * @private
     * @param {object} data contains info
     * @param {string} eventType is expand
     * @returns {boolean} true if lazy load is allowed
     */
    allowLazyLoad: function allowLazyLoad(data, eventType) {
      if (data === undefined || eventType === undefined) {
        return false;
      }
      return !data.isLoaded && !data.isLeaf && eventType === 'expand';
    },


    /**
     * Process data attached through jquery data
     * @private
     * @param {string} nodeId .
     * @param {string} currentDataObject .
     * @param {string} newDataObject .
     * @param {string} params .
     * @returns {object} data
     */
    data: function data(nodeId, currentDataObject, newDataObject, params) {
      /* eslint-disable no-use-before-define */
      if (params === undefined) {
        params = {};
      }

      var s = this.settings;
      var obj = currentDataObject.isRootNode ? currentDataObject : currentDataObject[0];
      var nodeData = [];

      if (s.newData.length > 0) {
        s.newData = [];
      }

      function addChildrenToObject(thisObj, thisParams) {
        if (thisParams.insert) {
          delete thisObj.isLeaf;
          thisObj.isExpanded = true;
        }
        if (newDataObject.length !== 0 && thisParams.insert) {
          thisObj.children = [newDataObject];
        } else {
          thisObj.children = newDataObject;
        }
      }

      function checkForChildren(self, thisObj, thisNewDataObject) {
        Object.keys(thisObj).forEach(function (prop) {
          if (prop === 'id' && nodeId === thisObj.id) {
            if (!thisObj.isLoaded && !thisObj.isRootNode) {
              addChildrenToObject(thisObj, params);
            }
            nodeData.push(thisObj);
          }
        });
        if (thisObj.children) {
          processData(self, thisObj.children, thisNewDataObject); // eslint-disable-line
        }
      }

      function processData(self, thisObj, thisNewDataObject) {
        if (thisObj.length === undefined) {
          checkForChildren(self, thisObj, thisNewDataObject);
        } else {
          for (var i = 0, l = thisObj.length; i < l; i++) {
            checkForChildren(self, thisObj[i], thisNewDataObject);
          }
        }
      }

      if (newDataObject !== undefined) {
        processData(this, obj, newDataObject);
      }

      if (nodeData.length !== 0) {
        $('#' + nodeData[0].id).data(nodeData[0]);
      }

      return nodeData[0];
      /* eslint-enable no-use-before-define */
    },


    /**
     * Add data as children for the given nodeId.
     * @private
     * @param {string} nodeId .
     * @param {object} currentDataObject info
     * @param {object} newDataObject .
     * @returns {void}
     */
    add: function add(nodeId, currentDataObject, newDataObject) {
      var s = this.settings;
      var id = currentDataObject.id !== undefined ? currentDataObject.id : nodeId;
      var node = $('#' + id);
      var parentContainer = node.parent().hasClass('leaf-container') ? node.parent().parent() : node.parent();
      var selectorObject = {};
      var isSubLevelChild = parentContainer.parent().attr('class') !== 'sub-level';
      var subListExists = parentContainer.children('.sublist').length === 1;

      if (isSubLevelChild) {
        if (subListExists) {
          selectorObject.element = parentContainer.children('.sublist');
        } else {
          selectorObject.el = parentContainer.append('<ul class=\'sublist\'></ul>');
          selectorObject.element = $(selectorObject.el).find('.sublist');
        }
      } else {
        selectorObject.el = parentContainer.children('ul');
        selectorObject.element = $(selectorObject.el);
      }

      if (selectorObject.element.length === 0) {
        selectorObject.el = parentContainer.append('<ul></ul>');
        selectorObject.element = $(selectorObject.el).find('ul');
      }

      if (!currentDataObject.isRootNode) {
        for (var i = 0, l = newDataObject.length; i < l; i++) {
          s.newData.push(newDataObject[i]);
        }
        this.createLeaf(newDataObject, selectorObject.element);
      }

      this.updateState(node, false, null, 'add');
    },


    /**
     * Closes popupmenu
     * @private
     * @param {object} node leaf containing btn-actions
     */
    closePopupMenu: function closePopupMenu(node) {
      var actionButton = node.find('.btn-actions');

      if (actionButton.length !== 0) {
        actionButton.data('popupmenu').close();
      }
    },


    /**
     * Expand the nodes until nodeId is displayed on the page.
     * @private
     * @param {object} event .
     * @param {object} nodeData info
     * @param {object} domObject .
     * @returns {void}
     */
    expand: function expand(event, nodeData, domObject) {
      var s = this.settings;
      var node = domObject.leaf;
      var nodeTopLevel = node.next();

      // close popupmenu if open
      this.closePopupMenu(node);

      nodeTopLevel.animateOpen();
      /**
      * Fires when leaf expanded.
      *
      * @event expanded
      * @memberof Hierarchy
      * @type {object}
      * @param {object} event - The jquery event object
      * @param {array} args [nodeData, dataset]
      */
      this.element.trigger('expanded', [nodeData, s.dataset]);

      if (node.hasClass('root')) {
        nodeTopLevel = nodeTopLevel.next('ul');
        nodeTopLevel.animateOpen();
      }

      node.parent().removeClass('branch-collapsed').addClass('branch-expanded');
      this.updateState(node, false, null, 'expand');
    },


    /**
     * Collapse the passed in nodeId.
     * @private
     * @param {object} event .
     * @param {object} nodeData info
     * @param {object} domObject .
     * @returns {void}
     */
    collapse: function collapse(event, nodeData, domObject) {
      var _this2 = this;

      var s = this.settings;
      var node = domObject.leaf;
      var nodeTopLevel = node.next();

      // close popupmenu if open
      this.closePopupMenu(node);

      nodeTopLevel.animateClosed().on('animateclosedcomplete', function () {
        /**
        * Fires when leaf collapsed.
        *
        * @event collapsed
        * @memberof Hierarchy
        * @type {object}
        * @param {object} event - The jquery event object
        * @param {array} args [nodeData, dataset]
        */
        _this2.element.trigger('collapsed', [nodeData, s.dataset]);
      });

      if (node.hasClass('root')) {
        nodeTopLevel = nodeTopLevel.next('ul');
        nodeTopLevel.animateClosed();
      }

      node.parent().removeClass('branch-expanded').addClass('branch-collapsed');
      this.updateState(node, false, null, 'collapse');
    },


    /**
    * Main render method
    * @private
    * @param {object} data info.
    * @returns {void}
    */
    render: function render(data) {
      /* eslint-disable no-use-before-define */
      var s = this.settings;
      var thisLegend = s.legend;
      var thisChildren = data.children;
      var rootNodeHTML = [];
      var structure = {
        legend: '<legend><ul></ul></legend>',
        chart: s.paging ? '<ul class="container"><li class="chart display-for-paging"></li></ul>' : '<ul class="container"><li class="chart"></li></ul>',
        toplevel: s.paging ? '<ul class="child-nodes"></ul>' : '<ul class="top-level"></ul>',
        sublevel: s.paging ? '' : '<ul class="sub-level"></ul>'
      };

      var chartContainer = this.element.append(structure.chart);
      var chart = $('.chart', chartContainer);

      if (thisLegend.length !== 0) {
        this.element.prepend(structure.legend);
        var element = $('legend', chartContainer);
        this.createLegend(element);
      }

      // check to see how many children are not leafs and have children
      if (this.isSingleChildWithChildren()) {
        $(chart).addClass('has-single-child');
      }

      // Create root node
      this.setColor(data);

      if (s.paging && data.parentDataSet) {
        var backMarkup = '' + '<div class="back">' + '<button type="button" class="btn-icon hide-focus btn-back">' + '<svg class="icon" focusable="false" aria-hidden="true" role="presentation">' + '<use xlink:href="#icon-caret-left"></use>' + '</svg>' + '<span>Back</span>' + '</button>' + '</div>';

        // Append back button to chart to go back to view previous level
        var backButton = $(backMarkup).appendTo(chart);

        // Attach data reference to back button
        backButton.children('button').data(data);

        // Class used to adjust heights and account for back button
        $(chart).addClass('has-back');
      }

      if (data.isMultiRoot) {
        var multiRootHTML = '<div class="leaf multiRoot"><div><h2>' + data.multiRootText + '</h2></div></div>';
        multiRootHTML = xssUtils.sanitizeHTML(multiRootHTML);
        rootNodeHTML.push(multiRootHTML);
        $(rootNodeHTML[0]).addClass('root').appendTo(chart);
      } else {
        var leaf = this.getTemplate(data);
        leaf = xssUtils.sanitizeHTML(leaf);
        rootNodeHTML.push(leaf);
        $(rootNodeHTML[0]).addClass('root').appendTo(chart);
        this.updateState($('.leaf.root'), true, data);
      }

      function renderSubChildren(self, subArray, thisData) {
        if (subArray !== null && subArray !== undefined) {
          for (var i = 0, l = subArray.length; i < l; i++) {
            var obj = subArray[i];
            subArrayChildren(self, obj, thisData); // eslint-disable-line
          }
        }
      }

      // Create children nodes
      if (thisChildren.length > 0) {
        for (var i = 0, l = thisChildren.length; i < l; i++) {
          var childObject = data.children[i].children;

          // If child has no children then render the element in the top level
          // If paging then render all children in the top level
          // If not paging and child has children then render in the sub level
          if (this.isLeaf(thisChildren[i]) && !s.paging && s.renderSubLevel) {
            this.createLeaf(data.children[i], $(structure.toplevel));
          } else if (s.paging) {
            this.createLeaf(data.children[i], $(structure.toplevel));
          } else {
            this.createLeaf(data.children[i], $(structure.sublevel));
          }

          if (childObject !== undefined && childObject !== null) {
            var subArray = data.children[i].children;
            var self = this;
            renderSubChildren(self, subArray, data);
          }
        }
      }

      function subArrayChildren(self, obj, thisData) {
        Object.keys(obj).forEach(function (prop) {
          if (prop === 'children') {
            var nodeId = obj.id;
            var currentDataObject = obj;
            var newDataObject = obj.children;

            if (newDataObject !== null && newDataObject !== undefined) {
              if (newDataObject.length > 0) {
                self.add(nodeId, currentDataObject, newDataObject);
              }
            }
            return renderSubChildren(self, newDataObject, thisData);
          }
          return true;
        });
      }

      var containerWidth = this.element.find('.container').outerWidth();
      var windowWidth = $(window).width();
      var center = (containerWidth - windowWidth) / 2;
      this.element.scrollLeft(center);

      // Add a no-sublevel class if only two levels (to remove extra border)
      var topLevel = this.element.find('.top-level');
      if (this.element.find('.sub-level').length === 0 && topLevel.length === 1) {
        topLevel.addClass('no-sublevel');
      }

      /* eslint-enable no-use-before-define */
    },


    /**
    * Checks to see if children have children
    * @private
    * @returns {boolean} true if have children
    */
    isSingleChildWithChildren: function isSingleChildWithChildren() {
      var s = this.settings;
      if (s.dataset && s.dataset[0] && s.dataset[0].children) {
        var i = s.dataset[0].children.length;
        var count = 0;

        while (i--) {
          if (!s.dataset[0].children[i].isLeaf) {
            count++;
          }
        }

        return count === 1;
      }
      return false;
    },


    /**
     * Builds leaf template
     * @private
     * @param {object} data leaf data
     * @returns {string} compiled template as HTML string
     */
    getTemplate: function getTemplate(data) {
      var template = Tmpl.compile('{{#dataset}}' + $('#' + xssUtils.stripTags(this.settings.templateId)).html() + '{{/dataset}}', { dataset: data });

      // Init popupmenu after rendered in DOM
      setTimeout(function () {
        var actionButton = $('#btn-' + xssUtils.stripTags(data.id));
        if (actionButton.length !== 0) {
          actionButton.hideFocus().popupmenu();
        }
      }, 1);

      return $(template).prop('outerHTML');
    },


    /**
    * Add the legend from the Settings
    * @private
    * @param {object} element .
    * @returns {void}
    */
    createLegend: function createLegend(element) {
      var s = this.settings;
      var mod = 4;
      var index = 0;

      for (var i = 0, l = s.legend.length; i < l; i++) {
        var thislabel = s.legend[i].label;
        var color = s.colorClass[i];

        if (i - 1 % mod + 1 === mod) {
          element.append('<ul></ul>');
          index++;
        }

        element.children('ul').eq(index).append('' + ('<li>\n          <span>' + thislabel + '</span>\n          <span class="key ' + color + '"></span>\n        </li>'));
      }
    },


    /**
    * Creates a leaf node under element for nodeData
    * @private
    * @param {object} nodeData contains info.
    * @param {object} container .
    * @returns {void}
    */
    createLeaf: function createLeaf(nodeData, container) {
      var self = this;
      var chartClassName = self.settings.rootClass;
      var chart = $('.' + chartClassName + ' .chart', self.container);
      var elClassName = container.attr('class');
      var el = elClassName !== undefined ? $('.' + elClassName) : container;

      if (el.length < 1) {
        if (elClassName === 'top-level') {
          container.insertAfter('.root');
        } else {
          container.appendTo(chart);
        }
      }

      function processDataForLeaf(thisNodeData) {
        self.setColor(thisNodeData);

        var leaf = self.getTemplate(thisNodeData);
        var parent = el.length === 1 ? el : container;
        var branchState = thisNodeData.isExpanded || thisNodeData.isExpanded === undefined ? 'branch-expanded' : 'branch-collapsed';

        if (thisNodeData.isLeaf) {
          branchState = '';
        }

        if ($('#' + thisNodeData.id).length === 1) {
          return;
        }

        parent.append('<li class=' + branchState + '>' + $(leaf)[0].outerHTML + '</li>');

        if (thisNodeData.children) {
          var childrenNodes = '';

          for (var j = 0, l = thisNodeData.children.length; j < l; j++) {
            self.setColor(thisNodeData.children[j]);
            var childLeaf = self.getTemplate(thisNodeData.children[j]);

            if (j === thisNodeData.children.length - 1) {
              childrenNodes += '<li>' + $(childLeaf)[0].outerHTML + '</li>';
            } else {
              childrenNodes += '<li>' + $(childLeaf)[0].outerHTML + '</li>';
            }
          }

          parent = $('#' + thisNodeData.id).parent();
          parent.append('<ul>' + childrenNodes + '</ul>');

          var childLength = thisNodeData.children.length;
          while (childLength--) {
            self.updateState($('#' + thisNodeData.children[childLength].id), false, thisNodeData.children[childLength]);
          }
        }
      }

      if (nodeData.length) {
        for (var i = 0, l = nodeData.length; i < l; i++) {
          var isLast = i === nodeData.length - 1;
          processDataForLeaf(nodeData[i], isLast);
          self.updateState($('#' + xssUtils.stripTags(nodeData[i].id)), false, nodeData[i]);
        }
      } else {
        processDataForLeaf(nodeData, true);
        self.updateState($('#' + xssUtils.stripTags(nodeData.id)), false, nodeData);
      }
    },


    /**
    * Determine the color from settings
    * @private
    * @param {object} data contains info.
    * @returns {void}
    */
    setColor: function setColor(data) {
      var s = this.settings;
      for (var i = 0, l = s.legend.length; i < l; i++) {
        if (data[s.legendKey] === s.legend[i].value) {
          data.colorClass = s.colorClass[i];
          break;
        } else if (data[s.legendKey] === '') {
          data.colorClass = 'default-color';
        }
      }

      if (data.children && !data.isRootNode) {
        for (var k = 0, ln = data.children.length; k < ln; k++) {
          for (var j = 0, x = s.legend.length; j < x; j++) {
            if (data.children[k][s.legendKey] === s.legend[j].value) {
              data.children[k].colorClass = s.colorClass[j];
            }
          }
        }
      }
    },


    /**
     * Check to see if particular node is a leaf
     * @private
     * @param {object} dataNode contains data info
     * @returns {boolean} whether or not a particular node is a leaf
     */
    isLeaf: function isLeaf(dataNode) {
      var s = this.settings;
      if (dataNode.children === undefined) {
        dataNode.isLeaf = true;
        return dataNode.isLeaf;
      }

      if (s.beforeExpand) {
        return dataNode.isLeaf;
      }

      if (dataNode.children && dataNode.children.length > 0) {
        return false;
      }

      return true;
    },


    /**
     * Handle all leaf state here,
     * get the current state via .data() and re-attach the new state
     * @private
     * @param {string} leaf .
     * @param {string} isRoot .
     * @param {string} nodeData .
     * @param {string} eventType .
     * @returns {void}
     */
    updateState: function updateState(leaf, isRoot, nodeData, eventType) {
      // set data if it has not been set already
      if ($.isEmptyObject($(leaf).data()) && nodeData) {
        var d = nodeData === undefined ? {} : nodeData;
        $(leaf).data(d);
      }

      var s = this.settings;
      var btn = $(leaf).find('.btn');
      var data = $(leaf).data();
      var expandCaret = s.paging ? 'caret-right' : 'caret-up';

      // data has been loaded if it has children
      if (data.children && data.children.length !== 0 || eventType === 'add') {
        data.isExpanded = true;
        data.isLoaded = true;
      }

      if (isRoot) {
        data.isRootNode = true;
        data.isLoaded = true;
      }

      if (data.isExpanded === undefined && data.children || eventType === 'expand') {
        data.isExpanded = true;
      }

      // defaults to collapsed state
      if (data.isExpanded === undefined || eventType === 'collapse') {
        data.isExpanded = false;
      }

      if (data.isExpanded) {
        btn.find('svg.icon').changeIcon(expandCaret);
        btn.addClass('btn-expand').removeClass('btn-collapse');
      } else {
        btn.find('svg.icon').changeIcon('caret-down');
        btn.addClass('btn-collapse').removeClass('btn-expand');
      }

      if (data.isLeaf || data.isRootNode) {
        btn.addClass('btn-hidden');
      }

      if (data.isLeaf) {
        data.isLoaded = false;
        data.isExpanded = false;
      }

      // Keep reference of the parent dataset for paging
      data.parentDataSet = s.dataset;

      // Reset data
      $(leaf).data(data);
    },


    /**
     * Reloads hierarchy control with new dataset
     * @private
     * @param {object} options hierarchy
     * @returns {void}
     */
    reload: function reload(options) {
      this.destroy();
      this.element.hierarchy(options);
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {void}
     */
    unbind: function unbind() {
      this.element.empty();
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, HIERARCHY_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Removes the component from existence
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      this.element.removeData(COMPONENT_NAME$E);
    }
  };

  /**
   * jQuery Component Wrapper for Hierarchy
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.hierarchy = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$E);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$E, new Hierarchy(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$F = 'fieldfilter';

  /**
   * Ability to have a dropdown next to the field.
   *
   * @class FieldFilter
   * @constructor
   *
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {array} [settings.dataset]  Array of data
   * @param {object} [settings.dropdownOpts]  Gets passed to this control's dropdown
   * @param {string} [settings.template] An Html String with the mustache template for the view.
   */
  var FIELDFILTER_DEFAULTS = {
    dataset: [],
    dropdownOpts: {}, // Dropdown custom settings
    template: '' + ('<label>' + Locale.translate('FieldFilter') + '</label>\n    <select class="dropdown no-init field-filter-dropdown">\n      {{#dataset}}\n        <option\n          {{#value}} value="{{value}}"{{/value}}\n          {{#selected}} selected{{/selected}}\n          {{#disabled}} class="is-disabled" disabled{{/disabled}}\n          {{#icon}} data-icon="{{icon}}"{{/icon}}\n        >{{text}}</option>\n      {{/dataset}}\n    </select>')
  };
  function FieldFilter(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, FIELDFILTER_DEFAULTS);
    this.init();
  }

  // FieldFilter Methods
  FieldFilter.prototype = {
    init: function init() {
      this.render();
      this.handleEvents();
      this.setFiltered();
    },


    /**
     * Render the template against the dataset.
     * @private
     * @param {array} dataset  The dataset to use
     * @returns {void}
     */
    render: function render(dataset) {
      var s = this.settings;
      dataset = dataset || s.dataset;
      // Render "mustache" Template
      if ((typeof Tmpl === 'undefined' ? 'undefined' : _typeof(Tmpl)) === 'object' && dataset && s.template) {
        // create a copy of an inlined template
        if (s.template instanceof $) {
          s.template = '' + s.template.html();
        } else if (typeof s.template === 'string') {
          // If a string doesn't contain HTML elments,
          // assume it's an element ID string and attempt to select with jQuery
          if (!stringUtils.containsHTML(s.template)) {
            s.template = $('#' + s.template).html();
          }
        }

        var renderedTmpl = Tmpl.compile(s.template, { dataset: !s.dropdownOpts.source ? dataset : [] }); // eslint-disable-line
        var emptyTmpl = '' + ('<label for="ffdropdown-empty" class="audible">\n          ' + Locale.translate('FieldFilter') + '\n        </label>\n        <select id="ffdropdown-empty" name="ffdropdown-empty" class="dropdown no-init field-filter-dropdown"></select>');

        if (dataset.length > 0) {
          this.element.before(renderedTmpl);
        } else if (dataset.length === 0) {
          this.element.before(renderedTmpl || emptyTmpl);
        }

        // Set element id
        var id = this.element.attr('id') || this.element.attr('name');
        if (typeof id === 'undefined') {
          id = utils.uniqueId(this.element, 'fieldfilter-');
          this.element[0].setAttribute('id', id);
        }
        var ffId = id + '-ff';

        // Set Field
        this.field = this.element.closest('.field');

        // RTL list x-position
        var isRTL = Locale.isRTL();
        s.dropdownOpts = s.dropdownOpts || {};
        if (isRTL && _typeof(s.dropdownOpts) === 'object') {
          if (s.dropdownOpts.placementOpts) {
            s.dropdownOpts.placementOpts.x = this.element.outerWidth();
          } else {
            s.dropdownOpts.placementOpts = { x: this.element.outerWidth() };
          }
        }

        // Set Dropdown
        s.dropdownOpts.cssClass = s.dropdownOpts.cssClass ? s.dropdownOpts.cssClass + ' ffdropdown' : 'ffdropdown';
        s.dropdownOpts.noSearch = true;

        // Find the field filter dropdown
        this.ffdropdown = this.field.find('select.dropdown.field-filter-dropdown');
        this.ffdropdown.dropdown(s.dropdownOpts).prev('label').addClass('audible');

        this.ffdropdown[0].setAttribute('id', ffId);
        this.ffdropdown[0].setAttribute('name', ffId);
        this.ffdropdown.prev('label')[0].setAttribute('for', ffId);

        // Add css classes
        this.field.addClass('fieldfilter-wrapper').find('div.dropdown.field-filter-dropdown span').addClass('audible');

        // Dropdown api
        this.ddApi = this.ffdropdown.data('dropdown');
        if (this.ddApi && this.ddApi.icon) {
          this.ddApi.icon.addClass('ffdropdown-icon');
        }
      }
    },


    /**
     * Set currently filtered item
     * @private
     * @returns {object} The api
     */
    setFiltered: function setFiltered() {
      if (this.ddApi) {
        var item = this.ddApi.element.find('option:selected');
        this.filtered = this.getTriggerData(item);
      }
      return this;
    },


    /**
     * Get currently triggerData for given item args
     * @private
     * @param {object} args selected item.
     * @returns {object} The api
     */
    getTriggerData: function getTriggerData(args) {
      var s = this.settings;
      var dataset = s.dropdownOpts.source && this.ddApi ? this.ddApi.dataset : s.dataset;
      return { idx: args.index(), item: args, data: dataset[args.index()] };
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {object} The api
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.ffdropdown.on('listopened.' + COMPONENT_NAME$F, function () {
        // drowpdownWidth - border (52)
        $('#dropdown-list ul').width(_this.element.outerWidth() + 52);
      }).on('selected.' + COMPONENT_NAME$F, function (e, args) {
        /**
         * Fires after the value in the dropdown is selected.
         * @event filtered
         * @memberof FieldFilter
         * @property {object} event The jquery event object.
         * @property {object} data for selected item.
         */
        var triggerData = _this.getTriggerData(args);
        _this.element.triggerHandler('filtered', [triggerData]);
      });

      return this;
    },
    // END: Handle Events -------------------------------------------------

    /**
     * Set component to readonly.
     * @returns {object} The api
     */
    readonly: function readonly() {
      this.ffdropdown.readonly();
      return this;
    },


    /**
     * Set component to enabled.
     * @returns {object} The api
     */
    enable: function enable() {
      this.ffdropdown.enable();
      return this;
    },


    /**
     * Set component to disabled.
     * @returns {object} The api
     */
    disable: function disable() {
      this.ffdropdown.disable();
      return this;
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.ffdropdown.off('.' + COMPONENT_NAME$F);

      // Remove Dropdown
      if (this.ddApi && typeof this.ddApi.destroy === 'function') {
        this.ddApi.destroy();
      }
      this.ffdropdown.add(this.ffdropdown.prev('label')).remove();

      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element[0], settings, FIELDFILTER_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Teardown process for this plugin
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$F);
    }
  };

  /**
   * jQuery Component Wrapper for FieldFilter
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.fieldfilter = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$F);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$F, new FieldFilter(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$G = 'fieldoptions';

  /**
  * A control bind next to another component to add some extra functionality.
  * @class FieldOptions
  * @constructor
  *
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  */
  var FIELDOPTIONS_DEFAULTS = {};

  function FieldOptions(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, FIELDOPTIONS_DEFAULTS);
    this.init();
  }

  // FieldOptions Methods
  FieldOptions.prototype = {
    init: function init() {
      this.setElements();
      this.handleEvents();
    },


    /**
     * Set all elements used by the Control
     * @private
     * @returns {object} The api
     */
    setElements: function setElements() {
      var _this = this;

      this.isFirefox = Environment.browser.name === 'firefox';
      this.isSafari = Environment.browser.name === 'safari';

      this.field = this.element.closest('.field, .radio-group');
      this.targetElem = this.element;

      var label = this.field.find('label');
      if (label) {
        this.label = label;
      }

      // In some cases, adjust the target element
      if (this.element[0].className.match(/(dropdown|multiselect)/)) {
        this.targetElem = this.element.data('dropdown').pseudoElem;
      }
      if (this.element[0].className.match(/(fileupload)/)) {
        this.targetElem = this.field.find('.fileupload[type="text"]');
      }

      this.field.addClass('is-fieldoptions');

      this.fieldParent = this.element.closest('.field').parent();
      this.trigger = this.field.find('.btn-actions');

      // Fix: Some reason firfox "event.relatedTarget" not working
      // with un-focusable elements(ie.. div) on focusout, use "contentEditable"
      // https://stackoverflow.com/a/43010274
      if (this.isFirefox && this.trigger.length) {
        this.trigger[0].contentEditable = true;
        this.trigger.on('keydown.' + COMPONENT_NAME$G, function (e) {
          var key = e.which || e.keyCode || e.charCode || 0;
          if (key !== 9) {
            e.preventDefault();
            e.stopPropagation();
          }
        });
      }

      // Adjust some setting for popupmenu this trigger(action button)
      setTimeout(function () {
        _this.popupmenuApi = _this.trigger.data('popupmenu');
        if (_this.popupmenuApi) {
          _this.popupmenuApi.settings.returnFocus = false;
          _this.popupmenuApi.settings.offset.y = 10;
        }
      }, 100);

      return this;
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {object} The api
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      var self = this;
      var datepicker = this.element.data('datepicker');
      var timepicker = this.element.data('timepicker');
      var dropdown = this.element.data('dropdown');
      var lookup = this.element.data('lookup') || this.element.hasClass('lookup');
      var isCheckbox = this.element.is('.checkbox');
      var isFileupload = this.element.is('.fileupload');
      var isSearchfield = this.element.is('.searchfield');
      var isColorpicker = this.element.is('.colorpicker');
      var isRadio = this.element.closest('.radio-group').length > 0;
      var isFieldset = this.element.is('.data') && this.element.closest('.summary-form').length > 0;

      // Helper functions
      var isFocus = function isFocus(elem) {
        return $(':focus').is(elem);
      };
      var addFocused = function addFocused(elem) {
        (elem || _this2.element).addClass('is-focused');
      };
      var removeFocused = function removeFocused(elem) {
        (elem || _this2.element).removeClass('is-focused');
      };
      var canActive = function canActive() {
        var r = isFocus(_this2.element);
        r = datepicker && datepicker.isOpen() ? false : r;
        r = timepicker && timepicker.isOpen() ? false : r;
        r = dropdown && dropdown.isOpen() ? false : r;
        return r;
      };
      var doActive = function doActive() {
        self.element.add(self.trigger).add(self.field).add(self.fieldParent).addClass('is-active');
      };
      var doUnactive = function doUnactive() {
        self.element.add(self.trigger).add(self.field).add(self.fieldParent).removeClass('is-active');
      };
      var canUnactive = function canUnactive(e) {
        var r = !isFocus(_this2.element);
        r = _this2.trigger.is(e.relatedTarget) ? false : r;
        r = _this2.trigger.is('.is-open') ? false : r;
        r = datepicker && datepicker.isOpen() ? false : r;
        r = timepicker && timepicker.isOpen() ? false : r;
        r = $(e.relatedTarget).prev().is(_this2.element) ? false : r;
        r = dropdown && dropdown.isOpen() ? false : r;
        r = lookup && lookup.modal && lookup.modal.isOpen() ? false : r;
        r = isColorpicker && _this2.element.is('.is-open') ? false : r;
        return r;
      };
      var onPopupToggle = function onPopupToggle(elem) {
        if (elem.trigger) {
          elem.trigger.off('show.' + COMPONENT_NAME$G).on('show.' + COMPONENT_NAME$G, function () {
            doActive();
          }).off('hide.' + COMPONENT_NAME$G).on('hide.' + COMPONENT_NAME$G, function (e) {
            if (canUnactive(e)) {
              doUnactive();
              _this2.element.removeClass('is-open');
            }
          });
        }
      };
      var getTriggerTopVal = function getTriggerTopVal() {
        var height = _this2.element.height();
        var returns = void 0;

        if (isFieldset) {
          var lineHeight = parseInt(_this2.element.css('line-height'), 10);
          if (height > lineHeight) {
            _this2.element.css({ 'margin-bottom': '', 'padding-bottom': '' });
            returns = (height - lineHeight) / 2 * -1;
          } else {
            _this2.element.css({ 'margin-bottom': '8px', 'padding-bottom': '12px' });
            returns = 6;
          }
        } else if (isRadio) {
          returns = (height - _this2.trigger.height()) / 2 * -1;
        }
        return returns;
      };
      var setTriggerCssTop = function setTriggerCssTop() {
        _this2.trigger.css({ top: getTriggerTopVal() + 'px' });
      };

      // Set field-options visibility.
      // In touch environments, the button should always be visible.
      // In desktop environments, the button should only display when the field is in use.
      if (Environment.features.touch) {
        this.field.addClass('visible');
        this.trigger.on('beforeopen.' + COMPONENT_NAME$G, function (e) {
          if (!canActive(e)) {
            return;
          }
          doActive();
        }).on('close.' + COMPONENT_NAME$G, function (e) {
          if (!canUnactive(e)) {
            return;
          }
          doUnactive();
        });
      } else {
        this.field.removeClass('visible');
        this.field.on('mouseover.' + COMPONENT_NAME$G, function () {
          if (self.element.prop('disabled') || self.element.closest('is-disabled').length) {
            return;
          }

          if (self.field[0].className.indexOf('visible') < 0) {
            self.field[0].classList.add('visible');
          }
        }).on('mouseout.' + COMPONENT_NAME$G, function () {
          if (self.field[0].className.indexOf('visible') > -1) {
            self.field[0].classList.remove('visible');
          }
        });
      }

      // Adjust stack order for dropdown
      if (dropdown) {
        setTimeout(function () {
          var popupmenu = _this2.trigger.data('popupmenu');
          if (popupmenu) {
            popupmenu.menu.closest('.popupmenu-wrapper').css({ 'z-index': '4502' });
          }
        }, 0);
      }
      // Bind active/unactive on show datepicker or timepicker
      if (datepicker || timepicker) {
        if (datepicker) {
          onPopupToggle(datepicker);
        } else {
          onPopupToggle(timepicker);
        }
      }
      // Adjust return focus for timepicker
      if (timepicker) {
        timepicker.settings.returnFocus = false;
      }
      // Move trigger(action-button) in to lookup-wrapper
      if (lookup || isColorpicker) {
        this.field.on('click.' + COMPONENT_NAME$G, '.lookup-wrapper .trigger, .colorpicker-container .trigger', function () {
          doActive();
        });

        if (isColorpicker) {
          this.element.on('beforeopen.' + COMPONENT_NAME$G, function () {
            doActive();
          });
        }
      }
      // Checkbox add parent css class
      if (isCheckbox) {
        this.trigger.addClass('is-checkbox');
      }
      // Bind fileupload events
      if (isFileupload) {
        this.element.on('change.' + COMPONENT_NAME$G, function () {
          _this2.targetElem.focus();
        });
        this.field.on('click.' + COMPONENT_NAME$G, '.trigger, .trigger-close', function () {
          doActive();
        });
      }
      // Move trigger(action-button) in to searchfield-wrapper
      if (isSearchfield) {
        setTimeout(function () {
          _this2.trigger.add(_this2.trigger.next('.popupmenu')).appendTo(_this2.element.closest('.searchfield-wrapper'));
        }, 0);
      }
      // Fieldset - set trigger(action-button) top value and bind events
      if (isFieldset) {
        setTriggerCssTop();
        this.targetElem.add(this.trigger).on('keydown.' + COMPONENT_NAME$G, function (e) {
          var key = e.which || e.keyCode || e.charCode || 0;
          if (key === 13) {
            setTimeout(function () {
              doActive();
            }, 0);
          }
        });
        this.targetElem.attr('tabindex', 0).on('click.' + COMPONENT_NAME$G, function () {
          doActive();
        });
        $(document).on('click.' + COMPONENT_NAME$G, function (e) {
          if (!$(e.target).is(_this2.element)) {
            doUnactive();
          }
        });
        $('body').on('resize.' + COMPONENT_NAME$G, function () {
          setTriggerCssTop();
        });
      }
      // Radio group - set trigger(action-button) top value and bind events
      if (isRadio) {
        setTriggerCssTop();
        this.element.on('focusin.' + COMPONENT_NAME$G, '.radio', function () {
          var delay = _this2.isSafari ? 200 : 0;
          addFocused();
          setTimeout(function () {
            doActive();
          }, delay);
        }).on('focusout.' + COMPONENT_NAME$G, '.radio', function () {
          removeFocused();
        });
        $('body').on('resize.' + COMPONENT_NAME$G, function () {
          setTriggerCssTop();
        });
      }

      // Element events
      this.targetElem.on('focusin.' + COMPONENT_NAME$G, function () {
        doActive();
        if (isRadio && _this2.isSafari) {
          addFocused();
        }
      }).on('focusout.' + COMPONENT_NAME$G, function (e) {
        var delay = _this2.isSafari ? 200 : 0;
        if (isRadio && _this2.isSafari) {
          removeFocused();
        }
        setTimeout(function () {
          if (canUnactive(e)) {
            doUnactive();
          }
        }, delay);
      });

      // Trigger(action button) events
      this.trigger.on('focusin.' + COMPONENT_NAME$G + ' click.' + COMPONENT_NAME$G, function () {
        doActive();
      }).on('focusout.' + COMPONENT_NAME$G, function (e) {
        if (canUnactive(e)) {
          doUnactive();
        }
      }).on('selected.' + COMPONENT_NAME$G, function () {
        _this2.popupmenuApi.settings.returnFocus = true;
      }).on('close.' + COMPONENT_NAME$G, function (e) {
        if (canUnactive(e)) {
          doUnactive();
        }
      });

      // FIX: Safari - by default does not get focus on some elements while using tab key
      // https://stackoverflow.com/a/29106095
      if (this.isSafari || isFileupload) {
        if (isRadio) {
          this.element.attr('tabindex', 0);
        }
        this.targetElem.on('keydown.' + COMPONENT_NAME$G, function (e) {
          var key = e.which || e.keyCode || e.charCode || 0;
          if (key === 9 && !e.shiftKey) {
            if (isRadio) {
              _this2.targetElem.find(':checked, .radio:first').not(':disabled').focus();
              _this2.targetElem.find('.radio').off('keydown.' + COMPONENT_NAME$G).on('keydown.' + COMPONENT_NAME$G, function (e2) {
                var key2 = e2.which || e2.keyCode || e2.charCode || 0;
                if (key2 === 9 && !e.shiftKey) {
                  setTimeout(function () {
                    _this2.trigger.focus();
                  }, 0);
                }
              });
            } else {
              _this2.trigger.focus();
            }
            doActive();
            e.preventDefault();
            e.stopPropagation();
          }
        });
      }

      this.element.on('listopened.' + COMPONENT_NAME$G, function () {
        doActive();
      }).on('listclosed.' + COMPONENT_NAME$G, function () {
        doUnactive();
      });

      return this;
    },
    // END: Handle Events -------------------------------------------------

    /**
    * Set component to enabled.
    * @returns {object} The api
    */
    enable: function enable() {
      this.trigger.prop('disabled', false);
      return this;
    },


    /**
    * Set component to disabled.
    * @returns {object} The api
    */
    disable: function disable() {
      this.trigger.prop('disabled', true);
      return this;
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.field.off(['click.' + COMPONENT_NAME$G, 'mouseover.' + COMPONENT_NAME$G, 'mouseout.' + COMPONENT_NAME$G].join(' '));

      this.element.off(['beforeopen.' + COMPONENT_NAME$G, 'change.' + COMPONENT_NAME$G, 'focusin.' + COMPONENT_NAME$G, 'focusout.' + COMPONENT_NAME$G, 'listclosed.' + COMPONENT_NAME$G, 'listopened.' + COMPONENT_NAME$G].join(' '));

      this.trigger.off(['beforeopen.' + COMPONENT_NAME$G, 'click.' + COMPONENT_NAME$G, 'focusin.' + COMPONENT_NAME$G, 'focusout.' + COMPONENT_NAME$G, 'selected.' + COMPONENT_NAME$G, 'close.' + COMPONENT_NAME$G].join(' '));

      this.targetElem.off(['click.' + COMPONENT_NAME$G, 'keydown.' + COMPONENT_NAME$G].join(' '));

      $('body').off(['resize.' + COMPONENT_NAME$G].join(' '));

      $(document).off(['click.' + COMPONENT_NAME$G].join(' '));

      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, FIELDOPTIONS_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
    * Teardown process for this plugin
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$G);
    }
  };

  /**
   * jQuery Component Wrapper for FieldOptions
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.fieldoptions = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$G);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$G, new FieldOptions(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$H = 'fileupload';

  /**
  * A list of items with add/remove/delete and sort functionality.
  * @class FileUpload
  * @constructor
  *
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  */

  var FILEUPLOAD_DEFAULTS = {};

  function FileUpload(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, FILEUPLOAD_DEFAULTS);
    this.init();
  }

  // FileUpload Methods
  FileUpload.prototype = {
    init: function init() {
      this.build();
    },


    // Example Method
    build: function build() {
      var _this = this;

      var self = this;
      var elem = this.element;
      var hasInlineLabel = !elem.is('input.fileupload');

      this.fileInput = hasInlineLabel ? elem.find('input') : elem;

      elem.closest('.field').addClass('field-fileupload');

      // append markup
      var id = elem.find('input').attr('name');
      if (!hasInlineLabel) {
        id = elem.attr('id') || elem.attr('name');
      }

      var elemClass = !hasInlineLabel ? elem.attr('class') : elem.find('input').attr('class');
      elemClass = elemClass ? ' ' + elemClass : '';

      var instructions = Locale.translate('FileUpload');
      var label = $('<label for="' + id + '-filename">' + elem.text() + ' <span class="audible">' + instructions + '</span></label>');
      var shadowField = $('<input readonly id="' + id + '-filename" class="fileupload-background-transparent' + elemClass + '" type="text">');
      var svg = '<span class="trigger" tabindex="-1">' + $.createIcon('folder') + '</span>';
      var svgClose = '<span class="trigger-close" tabindex="-1">' + $.createIcon('close') + '</span>';

      if (!hasInlineLabel) {
        var orgLabel = elem.prev('label');

        // Could be wrapped (angular)
        if (orgLabel.length === 0) {
          orgLabel = elem.parent().prev('label');
        }

        label = $('<label for="' + (elem.attr('id') || elem.attr('name')) + '-filename">' + orgLabel.text() + '</label>');
        elem.before(label, shadowField);
        this.fileInput.after(svgClose);
        this.fileInput.after(svg);
        orgLabel.addClass('audible').append('<span class="audible">' + instructions + '</span>');
      } else {
        elem.before(label, shadowField);
        this.fileInput.after(svgClose);
        this.fileInput.after(svg);
      }

      // if there is a value attribute, then this will be used as the current value since unable to set files[0].name
      // move it to the text input and remove it off the file input
      var fileInputValue = this.fileInput.attr('value');
      if (fileInputValue && fileInputValue.length > 0) {
        shadowField.val(fileInputValue);
        this.fileInput.attr('value', '');
      }

      this.textInput = shadowField;
      this.svg = elem.parent().find('.trigger');
      this.svgClose = elem.parent().find('.trigger-close');

      /*
      * Added Keydown for Keyboard Backspace and remove Keypress because it doesn't detect Backspace
      */
      this.textInput.on('keydown.fileupload', function (e) {
        var handle = false;
        if (e.which === 13 || e.which === 32) {
          elem.parent().find('[type="file"]').trigger('click');
          handle = true;
        } else if (e.which === 8) {
          _this.clearUploadFile();
          handle = true;
        }
        if (handle) {
          e.stopPropagation();
        }
      });

      this.svg.on('click.fileupload', function (e) {
        _this.fileInput.trigger('click');
        if (hasInlineLabel) {
          _this.fileInput.data('handleEvent' + [e.type || ''], e.handleObj);
        }
      });

      this.svgClose.on('click.fileupload', function (e) {
        _this.clearUploadFile();
        if (hasInlineLabel) {
          _this.fileInput.data('handleEvent +' + [e.type || ''], e.handleObj);
        }
      });

      if (this.fileInput.is(':disabled')) {
        this.textInput.prop('disabled', true);
      }

      if (elem.hasClass('required')) {
        label.addClass('required');
        elem.removeClass('required');
      }

      if (this.fileInput.attr('data-validate')) {
        this.textInput.attr('data-validate', this.fileInput.attr('data-validate'));
        this.textInput.validate();
      }

      if (this.fileInput.attr('readonly')) {
        this.textInput.prop('disabled', false);
        this.textInput[0].classList.remove('fileupload-background-transparent');
        this.fileInput.attr('disabled', 'disabled');
      }

      /*
      * New Event for File Upload Change
      */
      this.fileInput.on('change.fileupload', function () {
        if (this.files.length > 0) {
          self.textInput.val(this.files[0].name).trigger('change');
          self.svgClose.show().addClass('is-visible');
        } else {
          self.clearUploadFile();
        }
      });

      // Fix - Not to buble events when clicked on trigger/close icons
      this.fileInput.on('click.fileupload', function (e) {
        var handleEventData = _this.fileInput.data('handleEvent' + [e.type || '']);
        if (handleEventData && handleEventData.type === e.type && e.handleObj.namespace === 'fileupload') {
          _this.fileInput.data('handleEvent' + [e.type || ''], null);
          e.preventDefault();
        }
      });

      // Fix: not sure why, but some browser(ie. safari) need to rerender,
      // some rules were not applying from css file
      self.fileInput.css({ position: 'static', left: 0 });
      setTimeout(function () {
        self.fileInput.css({ position: 'fixed', left: '-10000px' });
      }, 0);
    },


    /*
    * Clear the Input Upload File
    */
    clearUploadFile: function clearUploadFile() {
      var val = this.fileInput.val();
      this.fileInput.add(this.textInput).val('');
      this.svgClose.hide().removeClass('is-visible');
      if (val !== '') {
        this.fileInput.triggerHandler('change');
      }
    },


    // Unbind all events
    unbind: function unbind() {
      this.svg.add(this.svgClose).off('click.fileupload');
      this.fileInput.off('change.fileupload');
      this.textInput.off('keydown.fileupload');

      this.element.closest('.field-fileupload').removeClass('field-fileupload').find('>label:first, >[type="text"]:first, .trigger, .trigger-close, .icon-dirty, .msg-dirty').remove();

      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, FILEUPLOAD_DEFAULTS);
      }
      // Nothing to do here as there are no settings.
      return this;
    },


    /**
    * Teardown process for this plugin
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$H);
    },


    /**
    * Disable the input and button.
    * @returns {void}
    */
    disable: function disable() {
      this.textInput.prop('disabled', true);
      this.fileInput.prop('disabled', true);
    },


    /**
    * Enable the input and button.
    * @returns {void}
    */
    enable: function enable() {
      this.textInput.prop('disabled', false).prop('readonly', false);
      this.fileInput.removeAttr('disabled');
    },


    /**
    * Make the input readonly and disable the button.
    * @returns {void}
    */
    readonly: function readonly() {
      this.textInput.prop('readonly', true);
      this.fileInput.prop('disabled', true);

      this.textInput.prop('disabled', false);
      this.textInput.removeClass('fileupload-background-transparent');
    }
  };

  /**
   * jQuery Component Wrapper for FileUpload
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.fileupload = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$H);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$H, new FileUpload(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$I = 'fileuploadadvanced';

  /**
  * A trigger field for uploading a single file.
  * @class FileUploadAdvanced
  * @constructor
  *
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  * @param {boolean} [settings.isStandalone=true] On page(true)|on modal(false), used for some visual style only.
  * @param {string} [settings.standaloneClass='standalone'] Css class if on page.
  * @param {string} [settings.allowedTypes='*'] Restrict file types(ie. 'jpg|png|gif') ['*' all types]
  * @param {number} [settings.maxFilesInProcess=99999] Max number of files can be uploaded
  * @param {number} [settings.maxFileSize=-1] Max file size in bytes, -1 for unlimited
  * @param {string} [settings.fileName='myfile'] Variable name to read from server
  * @param {boolean} [settings.isDisabled=false] Make control disabled
  * @param {boolean} [settings.showBrowseButton=true] Add way to browse files to upload
  * @param {Function} [settings.send] Method for send file to upload
  * @param {string} [settings.textDropArea] Text to show in drop area
  * @param {string} [settings.textDropAreaWithBrowse] Text to show in drop area when browse option true
  * @param {string} [settings.textBtnCancel] Hidden text for cancel button
  * @param {string} [settings.textBtnCloseError] Hidden text for error close button
  * @param {string} [settings.textBtnRemove] Hidden text for remove button
  * @param {string} [settings.errorAllowedTypes] Error text for allowed types
  * @param {string} [settings.errorMaxFileSize] Error text for max file size
  * @param {string} [settings.errorMaxFilesInProcess] Error text for max files in process
  */

  var FILEUPLOADADVANCED_DEFAULTS = {
    isStandalone: true, //
    standaloneClass: 'standalone', // css class if on page
    allowedTypes: '*', // restrict file types(ie. 'jpg|png|gif') ['*' all types]
    maxFilesInProcess: 99999, // max files can be upload
    maxFileSize: -1, // max file size in bytes, -1 for unlimited
    fileName: 'myfile', // variable name to read from server
    isDisabled: false, // Disabled
    showBrowseButton: true, // Browse files to upload
    send: null, // Function to send files to server

    // Text strings
    textDropArea: null,
    textDropAreaWithBrowse: null,
    textBtnCancel: null,
    textBtnCloseError: null,
    textBtnRemove: null,

    // Error strings
    errorAllowedTypes: null,
    errorMaxFileSize: null,
    errorMaxFilesInProcess: null
  };

  function FileUploadAdvanced(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, FILEUPLOADADVANCED_DEFAULTS);
    this.init();
  }

  // FileUploadAdvanced Methods
  FileUploadAdvanced.prototype = {
    init: function init() {
      this.build();
      this.handleEvents();
    },


    /**
     * Add markup
     * @private
     * @returns {void}
     */
    build: function build() {
      var s = this.settings;
      var html = void 0;
      var cssClassList = s.isStandalone ? s.standaloneClass : '';

      // Re-evaluate strings
      s.textDropArea = s.textDropArea || Locale.translate('TextDropArea');
      s.textDropAreaWithBrowse = s.textDropAreaWithBrowse || Locale.translate('TextDropAreaWithBrowse');
      s.textBtnCancel = s.textBtnCancel || Locale.translate('TextBtnCancel');
      s.textBtnCloseError = s.textBtnCloseError || Locale.translate('TextBtnCloseError');
      s.textBtnRemove = s.textBtnRemove || Locale.translate('TextBtnRemove');
      s.errorAllowedTypes = s.errorAllowedTypes || '<em>' + Locale.translate('Error') + '</em>: ' + Locale.translate('ErrorAllowedTypes');
      s.errorMaxFileSize = s.errorMaxFileSize || '<em>' + Locale.translate('Error') + '</em>: ' + Locale.translate('ErrorMaxFileSize');
      s.errorMaxFilesInProcess = s.errorMaxFilesInProcess || '<em>' + Locale.translate('Error') + '</em>: ' + Locale.translate('ErrorMaxFilesInProcess');

      // Disabled
      if (this.element.is('.is-disabled')) {
        s.isDisabled = true;
      }
      if (s.isDisabled) {
        cssClassList += ' is-disabled';
      }

      // Browse files option
      if (s.showBrowseButton) {
        var types = '';
        var id = utils.uniqueId(this.element, 'fileupload-adv-');
        var fileExtensions = s.allowedTypes.split(/[\s|]+/g);
        var isExtra = s.maxFilesInProcess > 1 ? ' multiple' : '';
        isExtra += s.isDisabled ? ' disabled' : '';

        if (fileExtensions.length === 1) {
          if (fileExtensions[0] !== '*') {
            types = '.' + fileExtensions[0];
          }
        } else {
          for (var i = 0, l = fileExtensions.length; i < l; i++) {
            types += '.' + (fileExtensions[i] + (i !== l - 1 ? ',' : ''));
          }
        }

        html = '' + ('<div class="fileupload-wrapper ' + cssClassList + '">\n          <div class="container drop-area">\n            ' + $.createIcon('upload') + '\n            <label class="fileupload-adv-browse-lbl">\n              <span>' + s.textDropAreaWithBrowse + '</span>\n              <input type="file" name="' + id + '" accept="' + types + '"' + isExtra + ' />\n            </label>\n          </div>\n        </div>');
      } else {
        // Without browse files option

        html = '' + ('<div class="fileupload-wrapper ' + cssClassList + '">\n          <div class="container drop-area">\n            ' + $.createIcon('upload') + '\n            <p>' + s.textDropArea + '</p>\n          </div>\n        </div>');
      }

      DOM.append(this.element, html, '<div><svg><use><label><span><input>');
      this.dropArea = $('.drop-area', this.element);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;
      var s = this.settings;

      this.dropArea
      // Drag enter
      .on('dragenter.fileuploadadvanced', function (e) {
        self.element.triggerHandler('filesdragenter');
        e.stopPropagation();
        e.preventDefault();

        if (s.isDisabled) {
          return;
        }
        $(this).addClass('hover');
      })

      // Drag over
      .on('dragover.fileuploadadvanced', function (e) {
        e.stopPropagation();
        e.preventDefault();
      })

      // Drop
      .on('drop.fileuploadadvanced', function (e) {
        var files = e.originalEvent.dataTransfer.files;
        e.preventDefault();
        if (s.isDisabled) {
          return;
        }

        /**
        * Fires when file/s drag and droped to drop area.
        *
        * @event filesdroped
        * @memberof FileUploadAdvanced
        * @property {object} event - The jquery event object
        * @property {array} files - List of files droped
        */
        self.element.triggerHandler('filesdroped', [files]);

        $(this).removeClass('hover is-focus');

        // Clear previous errors in general area
        $('span.msg', this.element).closest('.error').remove();

        // Max files can be upload
        if (files.length + $('.progress', this.element).length > s.maxFilesInProcess) {
          self.showError(s.errorMaxFilesInProcess);
          return;
        }

        self.handleFileUpload(files);
      });

      if (s.showBrowseButton && !s.isDisabled) {
        var label = this.dropArea.find('.fileupload-adv-browse-lbl');
        var input = label.find('input[type="file"]');

        // Only let open dialog if clicked on link or input
        label.click(function (e) {
          if (!$(e.target).is('.hyperlink, input[type="file"]')) {
            e.preventDefault();
          }
        });

        input.hideFocus();
        input.on('hidefocusremove.fileuploadadvanced', function (e) {
          e.stopPropagation();
          _this.dropArea.addClass('is-focus');
        }).on('hidefocusadd.fileuploadadvanced', function (e) {
          e.stopPropagation();
          _this.dropArea.removeClass('is-focus');
        }).on('change.fileuploadadvanced', function (e) {
          e.stopPropagation();
          self.handleFileUpload(this.files);
        });
      }

      // If the files are dropped outside the div, files will open in the browser window.
      // To avoid this prevent 'drop' event on document.
      $(document).on('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced', function (e) {
        e.stopPropagation();
        e.preventDefault();

        if (e.type === 'dragover') {
          self.dropArea.removeClass('hover');
        }
      });
    },


    /**
    * Read the file contents using HTML5 FormData()
    * @param {object} files File object containing uploaded files.
    * @returns {void}
    */
    handleFileUpload: function handleFileUpload(files) {
      var s = this.settings;
      var fileName = s.fileName.replace('[]', '');

      /* eslint-disable no-continue */
      for (var i = 0, l = files.length; i < l; i++) {
        // Check if file type allowed
        if (!this.isFileTypeAllowed(files[i].name)) {
          this.showError(s.errorAllowedTypes, files[i]);
          continue;
        }

        // Check for max file size
        if (s.maxFileSize !== -1 && files[i].size > s.maxFileSize) {
          this.showError(s.errorMaxFileSize, files[i]);
          continue;
        }

        /**
        * Fires before create the progress status object.
        *
        * @event beforecreatestatus
        * @memberof FileUploadAdvanced
        * @property {object} event - The jquery event object
        * @property {object} file - file to set the status
        */
        this.element.triggerHandler('beforecreatestatus', [files[i]]);
        /* global FormData */
        var fd = new FormData();
        fd.append(fileName + '[]', files[i]);

        var status = this.createStatus(files[i]);
        status.container.find('.status-icon .action').focus();

        /**
        * Fires after create the progress status object.
        *
        * @event aftercreatestatus
        * @memberof FileUploadAdvanced
        * @property {object} event - The jquery event object
        * @property {object} file - file to set the status
        */
        this.element.triggerHandler('aftercreatestatus', [files[i]]);

        if (typeof s.send === 'function') {
          s.send(fd, status);
        } else {
          this.sendFileToServer(fd, status);
        }
      }
      /* eslint-enable no-continue */

      if (s.showBrowseButton) {
        // Clear browse file input
        this.dropArea.find('.fileupload-adv-browse-lbl input[type="file"]').val('');
      }
    },


    /**
    * Create status object
    * @param {object} file to create progress status.
    * @returns {object} contains file and status methods to access.
    */
    createStatus: function createStatus(file) {
      var _this2 = this;

      var self = this;
      var s = this.settings;
      var container = $('' + ('<div class="container">\n        <div class="file-row">\n          <span class="status-icon">\n            <button type="button" class="btn-icon action">\n              ' + $.createIcon({ icon: 'close', classes: ['icon-close'] }) + '\n              <span>' + s.textBtnCancel + '</span>\n            </button>\n          </span>\n          <span class="description">' + file.name + '</span>\n          <div class="l-pull-right">\n            <span class="size">' + this.formatFileSize(file.size) + '</span>\n          </div>\n        </div>\n        <div class="progress-row">\n          <span class="progress">\n            <span class="progress-bar" data-value="0"></span>\n          </span>\n        </div>\n      </div>'));

      var btnCancel = $('.action', container).button();
      var rightSide = $('.l-pull-right', container);
      var progressBar = $('.progress-bar', container).progress({ animationLength: 10 });

      // Add this container
      this.dropArea.after(container);

      // Update progress-bar
      var setProgress = function setProgress(progress) {
        /**
        * Fires when file progress status changes.
        *
        * @event fileprogress
        * @memberof FileUploadAdvanced
        * @property {object} event - The jquery event object
        * @property {object} status - `{ file, progress }`
        */
        _this2.element.triggerHandler('fileprogress', [{ file: file, progress: progress }]);
        progressBar.attr('data-value', progress).triggerHandler('updated');
      };

      // Set abort action
      var setAbort = function setAbort(jqxhr) {
        btnCancel.on('click.fileuploadadvanced', function () {
          /**
          * Fires when file aborted.
          *
          * @event fileaborted
          * @memberof FileUploadAdvanced
          * @property {object} event - The jquery event object
          * @property {object} file - aborted
          */
          _this2.element.triggerHandler('fileaborted', [file]);
          jqxhr.abort();
          btnCancel.off('click.fileuploadadvanced');
          container.remove();
        });
      };

      // Set completed state
      var setCompleted = function setCompleted(data) {
        container.addClass('completed');

        // Add "Completed" icon
        btnCancel.after($.createIcon('check'));

        // Add "Remove from server" button
        rightSide.append('' + ('<button type="button" class="btn-icon action">\n          ' + $.createIcon({ classes: ['icon-close'], icon: 'close' }) + '\n          <span>' + s.textBtnRemove + '</span>\n        </button>'));

        // Set "Remove from server" button action
        $('.action', rightSide).button().on('click.fileuploadadvanced', function () {
          $(this).off('click.fileuploadadvanced');
          container.remove();

          // TODO: server call for removing data
          data.remove();
        });

        // Remove Cancel button and progress-bar area
        btnCancel.off('click.fileuploadadvanced');
        btnCancel.add(progressBar.closest('.progress-row')).remove();
        /**
        * Fires when file complete uploading.
        *
        * @event filecompleteuploading
        * @memberof FileUploadAdvanced
        * @property {object} event - The jquery event object
        * @property {object} file uploaded
        */
        self.element.triggerHandler('filecompleteuploading', [file]);
      };

      return { file: file, container: container, setProgress: setProgress, setAbort: setAbort, setCompleted: setCompleted };
    },


    /**
    * Function you can implement to send data to the server.
    * @param {object} formData - Contains the form data / file data.
    * @param {object} status - Status of the upload operation
    * @returns {void}
    */
    sendFileToServer: function sendFileToServer(formData, status) {
      var jqXHR = { abort: function abort() {} };
      var tempData = { remove: function remove() {} };
      var percent = 0;
      var total = parseFloat(status.file.size);
      /* eslint-disable new-cap */
      var timer = new $.fn.timer(function () {
        status.setCompleted(tempData);
      }, total);
      /* eslint-enable new-cap */

      $(timer.event).on('update', function (e, data) {
        percent = Math.ceil(data.counter / total * 100);
        status.setProgress(percent);
      });

      status.setAbort(jqXHR);
    },


    /**
     * Show error on ui
     * @private
     * @param {string} error to display
     * @param {object} file contains the error.
     * @returns {void}
     */
    showError: function showError(error, file) {
      var container = void 0;
      var s = this.settings;

      if (error === s.errorMaxFilesInProcess) {
        // This error show without file name or size in general area
        container = $('' + ('<div class="container error">\n          <div class="file-row">\n            <span class="status-icon">\n              <button type="button" class="btn-icon action">\n                ' + $.createIcon({ classes: ['icon-close'], icon: 'close' }) + '\n                <span>' + s.textBtnCloseError + '</span>\n              </button>\n            </span>\n            <span class="msg">' + error + '</span>\n          </div>\n        </div>'));
      } else {
        container = $('' + ('<div class="container error">\n          <div class="file-row">\n            <span class="status-icon">\n              <button type="button" class="btn-icon action">\n                ' + $.createIcon({ classes: ['icon-close'], icon: 'close' }) + '\n                <span>' + s.textBtnCloseError + '</span>\n              </button>\n            </span>\n            <span class="description">' + file.name + '</span>\n            <div class="l-pull-right">\n              <span class="size">' + this.formatFileSize(file.size) + '</span>\n            </div>\n          </div>\n          <div class="msg">\n            <p>' + error + '</p>\n          </div>\n        </div>'));
      }

      $('.action', container).button().on('click.fileuploadadvanced', function () {
        container.remove();
      });

      // Add this container
      this.dropArea.after(container);
    },


    /**
     * Check if file type allowed
     * @private
     * @param {string} fileName to check types
     * @returns {boolean} true if allowed to uploaded
     */
    isFileTypeAllowed: function isFileTypeAllowed(fileName) {
      var fileExtensions = this.settings.allowedTypes.toLowerCase().split(/[\s|]+/g);
      var ext = fileName.split('.').pop().toLowerCase();
      if (this.settings.allowedTypes !== '*' && $.inArray(ext, fileExtensions) < 0) {
        return false;
      }
      return true;
    },


    /**
     * Helper function that formats the file sizes
     * @private
     * @param {number} bytes to be formated
     * @returns {string} formated to use in ui
     */
    formatFileSize: function formatFileSize(bytes) {
      var scale = {
        GB: 1000000000,
        MB: 1000000,
        KB: 1000
      };
      if (typeof bytes !== 'number') {
        return '';
      }
      if (bytes >= scale.GB) {
        return (bytes / scale.GB).toFixed(2) + ' GB';
      }
      if (bytes >= scale.MB) {
        return (bytes / scale.MB).toFixed(2) + ' MB';
      }
      return (bytes / scale.KB).toFixed(2) + ' KB';
    },


    /**
    * Set component to enabled.
    * @returns {void}
    */
    enable: function enable() {
      this.settings.isDisabled = false;
      this.unbind();
      this.element.find('.fileupload-wrapper').removeClass('is-disabled').find('.fileupload-adv-browse-lbl input[type="file"]').removeAttr('disabled');
      this.handleEvents();
    },


    /**
    * Set component to disabled.
    * @returns {void}
    */
    disable: function disable() {
      this.settings.isDisabled = true;
      this.unbind();
      this.element.find('.fileupload-wrapper').addClass('is-disabled').find('.fileupload-adv-browse-lbl input[type="file"]').attr('disabled', 'disabled');
      this.handleEvents();
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {void}
     */
    unbind: function unbind() {
      this.dropArea.find('.fileupload-adv-browse-lbl input[type="file"]').off('hidefocusremove.fileuploadadvanced hidefocusadd.fileuploadadvanced change.fileuploadadvanced');

      this.dropArea.off('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced');
      $(document).off('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced');
      $('.action', this.element).off('click.fileuploadadvanced');
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, FILEUPLOADADVANCED_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
    * Destroy and remove added markup, all events
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $('.fileupload-wrapper', this.element).remove();
      $.removeData(this.element[0], COMPONENT_NAME$I);
    }
  };

  /*
  ERROR
  --------
  https://social.technet.microsoft.com/Forums/ie/en-US/ec3c0be0-0834-4873-8e94-700e9df9c822/edge-browser-drag-and-drop-files-not-working?forum=ieitprocurrentver

  */

  /**
   * jQuery Component Wrapper for FileUpload Advanced
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.fileuploadadvanced = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$I);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$I, new FileUploadAdvanced(this, settings));
      }
    });
  };

  // Default Settings
  var COMPONENT_NAME$J = 'homepage';

  /**
  * The Homepage handles card layout at multiple breakpoints.
  *
  * @class Homepage
  * @constructor
  * @param {HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  * @param {boolean} [settings.animate] Disable animation during resize
  * @param {number} [settings.columns] Display in 3 (default) or 4 column layout
  * @param {string} [settings.easing]
  * @param {number} [settings.gutterSize]
  * @param {number} [settings.widgetWidth]
  * @param {number} [settings.widgetHeight]
  * @param {number} [settings.timeout]
  */
  var HOMEPAGE_DEFAULTS = {
    animate: true,
    columns: 3,
    easing: 'blockslide', // Private
    gutterSize: 20, // Private
    widgetWidth: 360, // Private
    widgetHeight: 370, // Private
    timeout: 100 // Private
  };

  function Homepage(element, settings) {
    this.settings = utils.mergeSettings(element, settings, HOMEPAGE_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Homepage Methods
  Homepage.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.isTransitionsSupports = this.supportsTransitions();
      this.initHeroWidget();
      this.handleEvents();

      // Initial Sizing
      this.resize(this, false);
    },


    /**
     * Initialize columns.
     * @private
     * @param {number} row to be initialize.
     * @returns {void}
     */
    initColumns: function initColumns(row) {
      row = row || 0;
      this.rowsAndCols[row] = [];

      for (var i = 0, l = this.settings.columns; i < l; i++) {
        this.rowsAndCols[row][i] = true; // Make all columns available in first row[true]
      }
    },


    /**
     * Initialize hero widget.
     * @private
     * @returns {void}
     */
    initHeroWidget: function initHeroWidget() {
      var heroWidget = $('.hero-widget');
      if (heroWidget.length > 1) {
        heroWidget = heroWidget.not(':first').remove();
      }
      this.heroWidget = heroWidget;
    },


    /**
     * Initialize rows and cols.
     * @private
     * @returns {void}
     */
    initRowsAndCols: function initRowsAndCols() {
      this.rowsAndCols = []; // Keeping all blocks as rows and columns
      this.initColumns();
    },


    /**
     * Get availability where we can fit this given block.
     * @private
     * @param {object} block to get availability.
     * @returns {object} [x and y] where we can fit this block
     */
    getAvailability: function getAvailability(block) {
      var abort = false;
      var smallest = {};
      var rows = this.rowsAndCols.length;

      // Loop thru each row and column soon it found first available spot
      // Then check for if block's width can fit in(yes), asign to [smallest] and break both loops
      for (var i = 0, l = rows; i < l && !abort; i++) {
        for (var j = 0, innerCheck = true, cols = this.rowsAndCols[i].length; j < cols && !abort; j++) {
          if (this.rowsAndCols[i][j] && block.w + j <= cols) {
            if (block.w > 1 && cols > j + 1) {
              for (var n = 0; n < block.w; n++) {
                if (!this.rowsAndCols[i][j + n]) {
                  innerCheck = false;
                  break;
                }
              }
            }
            if (block.h > 1 && rows > i + 1) {
              for (var _n = 0; _n < block.h; _n++) {
                if (!this.rowsAndCols[i + _n][j]) {
                  innerCheck = false;
                  break;
                }
              }
            }
            if (innerCheck) {
              smallest.row = i;
              smallest.col = j;
              abort = true;
            }
          }
        }
      }

      // If did not found any available spot from previous loops
      // Add new row and asign to [smallest] first column in this new row
      if (!Object.getOwnPropertyNames(smallest).length) {
        this.initColumns(rows);
        smallest.row = rows;
        smallest.col = 0;
      }

      return smallest; // {x:0, y:0}
    },


    /**
     * Make all spots as unavailable, depends on block's width and height
     * Soon we used this block
     * @private
     * @param {number} r as row.
     * @param {number} c as col.
     * @param {number} block to fit.
     * @returns {void}
     */
    fitBlock: function fitBlock(r, c, block) {
      var addRow = true;

      block.x = c;
      block.y = r;

      if (block.w === 1 && block.h === 1) {
        // Single block can fit anywhere
        this.rowsAndCols[r][c] = false;
      } else if (block.w !== 1) {
        // If more then one row or column then loop thru to block's width and height
        // If height is more then current rows then add new row
        // Mark those spots as unavailable[false]

        // Left to right
        for (var i = r, l = block.h + r; i < l; i++) {
          for (var j = c, l2 = block.w + c; j < l2; j++) {
            if (!this.rowsAndCols[i]) {
              this.initColumns(i);
            }
            this.rowsAndCols[i][j] = false;
          }
        }
      } else {
        // Top to bottom
        for (var _i = r, _l = block.h + r; _i < _l; _i++) {
          for (var _j = c, _l2 = block.h + c; _j < _l2; _j++) {
            if (!this.rowsAndCols[_i]) {
              this.initColumns(_i);
            }
            this.rowsAndCols[_i][c] = false;
          }
        }
      }

      // Check if reach to end of columns then assign flag[addRow]
      for (var _i2 = 0, _l3 = this.rowsAndCols[r].length; _i2 < _l3; _i2++) {
        if (this.rowsAndCols[r][_i2]) {
          addRow = false;
        }
      }

      // If reach to end of columns and next row is not avaiable then add new row
      // Make all columns available, if not assigned earlier as unavailable
      if (addRow) {
        if (!this.rowsAndCols[r + 1]) {
          this.initColumns(r + 1);
        }
      }
    },


    /**
     * Setup each block sizes, based on classes provided from markup
     * @private
     * @returns {void}
     */
    setBlocks: function setBlocks() {
      var cards = this.element.find('.card, .widget');
      this.blocks = [];

      for (var i = 0, l = cards.length; i < l; i++) {
        var card = $(cards[i]);
        var h = card.hasClass('double-height') ? 2 : 1;
        var w = void 0;

        if (card.hasClass('quad-width')) {
          w = 4;
        } else if (card.hasClass('triple-width')) {
          w = 3;
        } else if (card.hasClass('double-width')) {
          w = 2;
        } else {
          w = 1;
        }

        this.blocks.push({ w: w, h: h, elem: card, text: card.text() });
      }

      // Max sized columns brings to top
      if (this.settings.columns > 1) {
        for (var _i3 = 0, j = 0, _w = 0, _l4 = this.blocks.length; _i3 < _l4; _i3++) {
          if (this.blocks[_i3].w >= this.settings.columns && _i3 && _w) {
            this.arrayIndexMove(this.blocks, _i3, j);
          }
          _w += this.blocks[_i3].w;
          if (_w >= this.settings.columns) {
            _w = 0; // reset
            j = this.blocks[j].w >= this.settings.columns ? j + 1 : _i3; // record to move
          }
        }
      }
    },


    /**
     * Move an array element position
     * @private
     * @param {array} arr .
     * @param {number} from index.
     * @param {number} to index.
     * @returns {void}
     */
    arrayIndexMove: function arrayIndexMove(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
    },


    /**
     * Resize Method
     * @private
     * @param {object} self .
     * @param {boolean} animate .
     * @returns {void}
     */
    resize: function resize(self, animate) {
      // Sizes of "breakpoints" is  320, 660, 1000 , 1340 (for 320)
      // or 360, 740, 1120, 1500 or (for 360)
      var bpXL = self.settings.widgetWidth * 4 + self.settings.gutterSize * 3;
      var bpDesktop = self.settings.widgetWidth * 3 + self.settings.gutterSize * 2;
      var bpTablet = self.settings.widgetWidth * 2 + self.settings.gutterSize;
      var bpPhone = self.settings.widgetWidth;

      var bp = bpXL; // 1340
      // Math min against window.screen.width for single line mobile support
      var elemWidth = self.element.outerWidth();

      // elemWidth -= 30; //extra break space

      // Find the Breakpoints
      var xl = elemWidth >= bpXL;
      var desktop = elemWidth >= bpDesktop && elemWidth <= bpXL;
      var tablet = elemWidth >= bpTablet && elemWidth <= bpDesktop;
      var phone = elemWidth <= bpTablet;

      var maxAttr = this.element.attr('data-columns');
      var content = self.element.find('> .content');
      this.settings.columns = parseInt(maxAttr || this.settings.columns, 10);

      // Assign columns as breakpoint sizes
      if (xl && self.settings.columns === 4) {
        self.settings.columns = 4;
        bp = bpXL;
      }
      if (desktop || xl && self.settings.columns === 3) {
        self.settings.columns = 3;
        bp = bpDesktop;
      }
      if (tablet) {
        self.settings.columns = 2;
        bp = bpTablet;
      }
      if (phone) {
        self.settings.columns = 1;
        bp = bpPhone;
      }

      if (content.length) {
        content[0].style.marginLeft = '-' + bp / 2 + 'px';
      }

      this.setBlocks(); // setup blocks
      this.initRowsAndCols(); // setup colums

      // Loop thru each block, make fit where available and
      // If block more wider than available size, make as  available size
      // Assign new left and top css positions
      for (var i = 0, l = self.blocks.length; i < l; i++) {
        // let left, top, pos, available,
        var block = self.blocks[i];

        // Remove extra classes if assigned earlier
        block.elem.removeClass('to-single to-double to-triple');

        // If block more wider than available size, make as available size
        if (block.w > self.settings.columns) {
          block.w = self.settings.columns;

          if (self.settings.columns === 1) {
            block.elem.addClass('to-single');
          } else if (self.settings.columns === 2) {
            block.elem.addClass('to-double');
          } else if (self.settings.columns === 3) {
            block.elem.addClass('to-triple');
          }
        }

        // Get Availability
        var available = self.getAvailability(block);

        // Set positions
        var box = self.settings.widgetWidth + self.settings.gutterSize;
        var totalWidth = box * self.settings.columns;

        var left = Locale.isRTL() ? totalWidth - (box * block.w + box * available.col) : box * available.col; // eslint-disable-line
        var top = (self.settings.widgetHeight + self.settings.gutterSize) * available.row;
        var pos = { left: left, top: top };

        if (animate) {
          var easing = self.settings.easing;
          var blockslide = [0.09, 0.11, 0.24, 0.91];

          if (easing === 'blockslide') {
            if (self.isTransitionsSupports) {
              self.applyCubicBezier(block.elem, blockslide);
              block.elem[0].style.left = pos.left + 'px';
              block.elem[0].style.top = pos.top + 'px';
            } else {
              // IE-9
              block.elem.animate(pos, self.settings.timeout);
            }
          } else {
            // Other easing effects ie (linear, swing)
            block.elem.animate(pos, self.settings.timeout, easing);
          }
        } else {
          block.elem[0].style.left = pos.left + 'px';
          block.elem[0].style.top = pos.top + 'px';
        }

        // Mark all spots as unavailable for this block, as we just used this one
        self.fitBlock(available.row, available.col, block);
      }

      /**
      * Fires after the page is resized and layout is set.
      * Can be used for any special adjustments.
      * @event resize
      * @memberof Homepage
      * @type {object}
      * @param {object} event - The jquery event object
      */
      self.element.triggerHandler('resize', self.settings.columns);
    },


    /**
     * Apply cubic-bezier effects
     * @private
     * @param {object} el as element.
     * @param {string} cubicBezier effect to apply.
     * @returns {void}
     */
    applyCubicBezier: function applyCubicBezier(el, cubicBezier) {
      var value = 'all .3s cubic-bezier(' + cubicBezier + ')';
      el[0].style['-webkit-transition'] = value;
      el[0].style['-moz-transition'] = value;
      el[0].style['-ms-transition'] = value;
      el[0].style['-o-transition'] = value;
      el[0].style.transition = value;
    },


    /**
     * Check if browser supports transitions
     * @private
     * @returns {boolean} true if supports transitions
     */
    supportsTransitions: function supportsTransitions() {
      var s = document.createElement('p').style;
      var p = 'transition';

      if (typeof s[p] === 'string') {
        return true;
      }

      // Tests for vendor specific prop
      var v = ['Moz', 'webkit', 'Webkit', 'Khtml', 'O', 'ms'];
      p = p.charAt(0).toUpperCase() + p.substr(1);

      for (var i = 0, l = v.length; i < l; i++) {
        if (typeof s[v[i] + p] === 'string') {
          return true;
        }
      }
      return false;
    },


    /**
     * Detach events
     * @private
     * @returns {void}
     */
    detachEvents: function detachEvents() {
      $('body').off('resize.homepage');
      $('.application-menu').off('applicationmenuopen.homepage applicationmenuclose.homepage');
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, HOMEPAGE_DEFAULTS);
      }
      return this.detachEvents().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.detachEvents();
      $.removeData(this.element[0], COMPONENT_NAME$J);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      $('body').on('resize.homepage', function () {
        _this.resize(_this, _this.settings.animate);
      });

      $('.application-menu').on('applicationmenuopen.homepage applicationmenuclose.homepage', function () {
        _this.resize(_this, _this.settings.animate);
      });
    }
  };

  /**
   * jQuery Component Wrapper for Homepage
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.homepage = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$J);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$J, new Homepage(this, settings));
      }
    });
  };

  /* eslint-disable no-underscore-dangle */

  // The name of this component.
  var COMPONENT_NAME$K = 'pager';

  /**
  * The Pager Component supports paging on lists.
  * @class Pager
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  *
  * @param {string} [settings.componentAPI]  If defined, becomes the definitive way to call methods on
  * parent component.
  * @param {string} [settings.type = 'list']  Different types of pagers option sets.
  * list - just shows next and previous and a listing of page numbers you can click
  * pageof - for datagrid also shows next and previous and first and last with a page number input and page size selector used optionally for
  * firstlast - for lists shows next and previous and first and last with option to set showPageSizeSelector
  * standalone - lets you control all the options with settings, events and methods. In the future i will refactor the others out.
  * @param {string} [settings.position = 'bottom']  Can be on 'bottom' or 'top'.
  * @param {number} [settings.activePage = 1]  Start on this page
  * @param {boolean} [settings.hideOnOnePage = false]  If true, hides the pager if there is only one page worth of results.
  * @param {Function} [settings.source] Call back function for pager data source
  * @param {number} [settings.pagesize = 15]  Can be calculated or a specific number
  * @param {array} [settings.pagesizes = [15, 25, 50, 75]] Array of numbers of the page size selector
  * @param {boolean} [settings.showPageSizeSelector = true] If false will not show page size selector
  * @param {boolean} [settings.onPageSizeChange] Call back function for page change
  * @param {boolean} [settings.showFirstButton = true] If false the first button will be hidden (standalone mode)
  * @param {boolean} [settings.enableFirstButton = true] If false the first button will be disabled (standalone mode)
  * @param {boolean} [settings.onFirstPage] Call back function for first page button click
  * @param {boolean} [settings.showPreviousButton = true] If false the previous button will be hidden (standalone mode)
  * @param {boolean} [settings.enablePreviousButton = true] If false the previous button will be disabled (standalone mode)
  * @param {boolean} [settings.onPreviousPage] Call back function for previous page button click
  * @param {boolean} [settings.showNextButton = true] If false the next button will be hidden (standalone mode)
  * @param {boolean} [settings.enableNextButton = true] If false the next button will be disabled (standalone mode)
  * @param {boolean} [settings.onNextPage] Call back function for next page button click
  * @param {boolean} [settings.showLastButton = true] If false the last button will be hidden (standalone mode)
  * @param {boolean} [settings.enableLastButton = true] If false the last button will be disabled (standalone mode)
  * @param {boolean} [settings.onLastPage] Call back function for next page button click
  * @param {boolean} [settings.indeterminate = false] If true will not show anything that lets you go to a specific page (deprecated for standalone)
  * @param {boolean} [settings.firstPageTooltip = 'First Page'] Tooltip for the first page, defaults to an internally translated tooltip.
  * @param {boolean} [settings.previousPageTooltip = 'Previous Page'] Tooltip for the first page, defaults to an internally translated tooltip.
  * @param {boolean} [settings.nextPageTooltip = 'Next Page'] Tooltip for the first page, defaults to an internally translated tooltip.
  * @param {boolean} [settings.lastPageTooltip = 'Last Page'] Tooltip for the first page, defaults to an internally translated tooltip.
  */
  var PAGER_DEFAULTS = {
    componentAPI: undefined,
    type: 'list',
    position: 'bottom',
    activePage: 1,
    hideOnOnePage: false,
    source: null,
    pagesize: 15,
    pagesizes: [15, 25, 50, 75],
    showPageSizeSelector: true,
    onPageSizeChange: null,
    showFirstButton: true,
    enableFirstButton: true,
    showPreviousButton: true,
    enablePreviousButton: true,
    showNextButton: true,
    enableNextButton: true,
    showLastButton: true,
    enableLastButton: true,
    indeterminate: false,
    onFirstPage: null,
    onPreviousPage: null,
    onNextPage: null,
    onLastPage: null,
    firstPageTooltip: 'FirstPage',
    previousPageTooltip: 'PreviousPage',
    nextPageTooltip: 'NextPage',
    lastPageTooltip: 'LastPage'
  };

  var PAGER_NON_NUMBER_BUTTON_SELECTOR = 'li:not(.pager-prev):not(.pager-next):not(.pager-first):not(.pager-last)';
  function Pager(element, settings) {
    this.settings = utils.mergeSettings(element, settings, PAGER_DEFAULTS);
    this.settings.dataset = settings.dataset; // by pass deep copy
    this.element = $(element);
    this.init();
  }

  Pager.prototype = {

    /**
     * Init the pager.
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup();
      this.createPagerBar();
      this.setActivePage(this.settings.activePage, true); // Get First Page
      this.renderBar();
      this.renderPages('initial');
      this.handleEvents();
      this.pagerInfo = {};
      this._pageCount = 0;
    },


    /**
     * Setting the internals of the pager.
     * @private
     * @returns {void}
     */
    setup: function setup() {
      // Add [pagesize] if not found in [pagesizes]
      if ($.inArray(this.settings.pagesize, this.settings.pagesizes) === -1) {
        var sortNumber = function sortNumber(a, b) {
          return a - b;
        };
        this.settings.pagesizes.push(this.settings.pagesize);
        this.settings.pagesizes = this.settings.pagesizes.sort(sortNumber);
      }

      var widgetContainer = this.element.parents('.card, .widget');

      // Adjust for the possibility of the pager being attached to a Table instead
      // of normal grid markup
      if (this.element.is('tbody')) {
        this.isTable = true;
        this.settings.type = 'table';
        this.mainContainer = this.element.closest('.datagrid-container');

        if (!this.settings.componentAPI) {
          this.settings.componentAPI = this.mainContainer.data('datagrid');
        }

        if (widgetContainer.length) {
          widgetContainer[0].classList.add('has-datagrid');
        }
      }

      // If contained by a widget/card container, build some settings for that
      var listviewContainer = this.element.is('.listview');
      if (listviewContainer) {
        this.isTable = false;
        this.isListView = true;
        this.mainContainer = this.element;

        if (!this.settings.componentAPI) {
          this.settings.componentAPI = this.element.data('listview');
        }
      }

      this.isRTL = Locale.isRTL();
      this.tabbableSelector = '.pager-first > a, .pager-prev > a, .pager-next > a, .pager-last > a, .pager-no > a, .pager-count input, .pager-pagesize button';

      return this;
    },


    /**
     * Add the pager dom elements.
     * @private
     */
    createPagerBar: function createPagerBar() {
      this.pagerBar = this.element.prev('.pager-toolbar');

      if (this.pagerBar.length === 0) {
        this.pagerBar = $('<ul class="pager-toolbar"></ul>');

        var firstButton = '<li class="pager-first">\n        <a href="#" title="' + this.settings.firstPageTooltip + '">' + $.createIcon({ icon: 'first-page' }) + '\n          <span class="audible">' + Locale.translate('FirstPage') + '</span>\n        </a>\n      </li>';

        var prevButton = '<li class="pager-prev">\n          <a href="#" rel="prev" title="' + this.settings.previousPageTooltip + '">' + $.createIcon({ icon: 'previous-page' }) + '\n            <span class="audible">' + Locale.translate('PreviousPage') + '</span>\n          </a>\n        </li>';

        var nextButton = '<li class="pager-next">\n          <a href="#" rel="next" title="' + this.settings.nextPageTooltip + '">' + $.createIcon({ icon: 'next-page' }) + '\n            <span class="audible">' + Locale.translate('NextPage') + '</span>\n          </a>\n        </li>';

        var lastButton = '<li class="pager-last">\n        <a href="#" title="' + this.settings.lastPageTooltip + '">' + $.createIcon({ icon: 'last-page' }) + '\n        <span class="audible">' + Locale.translate('LastPage') + '</span>\n        </a>\n      </li>';

        if (this.settings.type === 'table' || this.settings.type === 'pageof' || this.settings.type === 'firstlast' || this.settings.type === 'standalone') {
          this.pagerBar.html(firstButton + prevButton + nextButton + lastButton);
        } else {
          this.pagerBar.html(prevButton + nextButton);
        }
        this.pagerBar.children('li').children('a').button();
      }

      if (this.settings.type === 'standalone') {
        this.element.append(this.pagerBar);
      } else if (this.isTable) {
        this.mainContainer.after(this.pagerBar);
      } else if (this.settings.position === 'bottom') {
        this.element.after(this.pagerBar);
      } else {
        this.element.before(this.pagerBar);
      }

      if (this.isListView) {
        this.pagerBar.addClass('is-listview');
      }

      // Inside of Listviews, place the pager bar inside of the card/widget footer
      var widgetContainer = this.element.closest('.card, .widget');
      if (widgetContainer.length) {
        var self = this;
        var widgetTypes = ['widget', 'card'];

        widgetTypes.forEach(function (type) {
          var widgetContent = self.element.closest('.' + type + '-content');
          if (!widgetContent.length) {
            return;
          }

          var widgetFooter = widgetContent.next('.' + type + '-footer');
          if (!widgetFooter.length) {
            widgetFooter = $('<div class="' + type + '-footer"></div>').insertAfter(widgetContent);
          }

          self.pagerBar.appendTo(widgetFooter);
        });
      }

      this.pagerBar.find('a').tooltip();
    },


    /**
    * Fires when the first page button is clicked.
    * @event firstpage
    * @memberof Pager
    * @property {object} event - The jquery event object
    * @property {function} request - Various paging info
    */
    /**
    * Fires when the previous page button is clicked.
    * @event previouspage
    * @memberof Pager
    * @property {object} event - The jquery event object
    * @property {function} request - Various paging info
    */
    /**
    * Fires when the next page button is clicked.
    * @event nextpage
    * @memberof Pager
    * @property {object} event - The jquery event object
    * @property {function} request - Various paging info
    */
    /**
     *Fires when the last page button is clicked.
     * @event lastpage
     * @memberof Pager
     * @property {object} event - The jquery event object
     * @property {function} request - Various paging info
     */
    /**
     * Attach All relevant events
     * @private
     */
    handleEvents: function handleEvents() {
      var self = this;

      // Attach button click and touch
      this.pagerBar.on('click.pager', 'a', function (e) {
        var li = $(this).parent();
        var opts = {
          activePage: self.activePage,
          pagerInfo: self.pagerInfo,
          settings: self.settings,
          element: self.element
        };

        e.preventDefault();

        if ($(this).attr('disabled')) {
          return false;
        }

        if (li.is('.pager-prev')) {
          self.setActivePage(self.activePage - 1, false, 'prev');
          if (self.settings.onPreviousPage) {
            self.settings.onPreviousPage(this, opts);
          }
          self.element.trigger('previouspage', opts);
          return false;
        }

        if (li.is('.pager-next')) {
          self.setActivePage((self.activePage === -1 ? 0 : self.activePage) + 1, false, 'next');
          if (self.settings.onNextPage) {
            self.settings.onNextPage(this, opts);
          }
          self.element.trigger('nextpage', opts);
          return false;
        }

        if (li.is('.pager-first')) {
          self.setActivePage(1, false, 'first');
          if (self.settings.onFirstPage) {
            self.settings.onFirstPage(this, opts);
          }
          self.element.trigger('firstpage', opts);
          return false;
        }

        if (li.is('.pager-last')) {
          self.setActivePage(self.pageCount(), false, 'last'); // TODO Calculate Last Page?
          if (self.settings.onLastPage) {
            self.settings.onLastPage(this, opts);
          }
          self.element.trigger('lastpage', opts);
          return false;
        }

        // Go to the page via the index of the button
        self.setActivePage($(this).parent().index() + (self.settings.type === 'table' || self.settings.type === 'pageof' ? -1 : 0), false, 'page');

        return false;
      });

      self.pagerBar.on('keydown.pager', self.tabbableSelector, function (event) {
        event = event || window.event;
        var key = event.which || event.keyCode || event.charCode || false;
        var isLeft = key === 37 || key === 40;
        var isRight = key === 39 || key === 38;

        var elem = event.currentTarget;
        if (elem.nodeName === 'INPUT') {
          // work on up down key
          isLeft = key === 40;
          isRight = key === 38;
        }

        if (!isLeft && !isRight) {
          return true;
        }

        var parent = elem.nodeName === 'INPUT' ? elem.parentNode.parentNode : elem.parentNode;
        var next = parent.nextSibling;
        var prev = parent.previousSibling;
        var isFirst = prev === null;
        var isLast = next === null;

        event.preventDefault();

        if (isLeft && !isFirst) {
          var link = prev.querySelector('a, button, input');
          link.removeAttribute('tabindex');
          elem.setAttribute('tabindex', '-1');
          link.focus();
          return false;
        }

        if (isLeft && isFirst) {
          var _link = parent.parentNode.lastChild.querySelector('a, button, input');
          _link.removeAttribute('tabindex');
          elem.setAttribute('tabindex', '-1');
          _link.focus();
          return false;
        }

        if (isRight && !isLast) {
          var _link2 = next.querySelector('a, button, input');
          _link2.removeAttribute('tabindex');
          elem.setAttribute('tabindex', '-1');
          _link2.focus();
          return false;
        }

        if (isRight && isLast) {
          var _link3 = parent.parentNode.firstChild.querySelector('a, button, input');
          _link3.removeAttribute('tabindex');
          elem.setAttribute('tabindex', '-1');
          _link3.focus();
        }

        return false;
      });
    },


    /**
     * Show page size selector
     * @param  {boolean} toggleOption Toggle vs show
     */
    showPageSizeSelector: function showPageSizeSelector(toggleOption) {
      toggleOption = ('' + toggleOption).toLowerCase() === 'true';
      this.settings.showPageSizeSelector = toggleOption;
      if (toggleOption) {
        this.isShowPageSizeSelectorCall = toggleOption;
        this.pageCount();
      } else {
        this.pagerBar.find('.pager-pagesize').remove();
      }
    },


    /**
     * Show first page button.
     * @param  {boolean} toggleOption Toggle vs show
     */
    showFirstButton: function showFirstButton(toggleOption) {
      toggleOption = ('' + toggleOption).toLowerCase() === 'true';
      this.settings.showFirstButton = toggleOption;
      if (toggleOption) {
        this.pagerBar.find('.pager-first a').show();
      } else {
        this.pagerBar.find('.pager-first a').hide();
      }
    },


    /**
     * Show previous page button.
     * @param  {boolean} toggleOption Toggle vs show
     */
    showPreviousButton: function showPreviousButton(toggleOption) {
      toggleOption = ('' + toggleOption).toLowerCase() === 'true';
      this.settings.showPreviousButton = toggleOption;
      if (toggleOption) {
        this.pagerBar.find('.pager-prev a').show();
      } else {
        this.pagerBar.find('.pager-prev a').hide();
      }
    },


    /**
     * Show next page button.
     * @param  {boolean} toggleOption Toggle vs show
     */
    showNextButton: function showNextButton(toggleOption) {
      toggleOption = ('' + toggleOption).toLowerCase() === 'true';
      this.settings.showNextButton = toggleOption;
      if (toggleOption) {
        this.pagerBar.find('.pager-next a').show();
      } else {
        this.pagerBar.find('.pager-next a').hide();
      }
    },


    /**
     * Show last page button.
     * @param  {boolean} toggleOption Toggle vs show
     */
    showLastButton: function showLastButton(toggleOption) {
      toggleOption = ('' + toggleOption).toLowerCase() === 'true';
      this.settings.showLastButton = toggleOption;
      if (toggleOption) {
        this.pagerBar.find('.pager-last a').show();
      } else {
        this.pagerBar.find('.pager-last a').hide();
      }
    },


    /**
     * Enable first page button.
     * @param  {boolean} toggleOption Toggle vs show
     */
    enableFirstButton: function enableFirstButton(toggleOption) {
      toggleOption = ('' + toggleOption).toLowerCase() === 'true';
      this.settings.enableFirstButton = toggleOption;

      if (toggleOption) {
        this.pagerBar.find('.pager-first a').removeAttr('disabled');
      } else {
        this.pagerBar.find('.pager-first a').attr('disabled', 'disabled');
      }
    },


    /**
     * Enable previous page button.
     * @param  {boolean} toggleOption Toggle vs show
     */
    enablePreviousButton: function enablePreviousButton(toggleOption) {
      toggleOption = ('' + toggleOption).toLowerCase() === 'true';
      this.settings.enablePrevButton = toggleOption;

      if (toggleOption) {
        this.pagerBar.find('.pager-prev a').removeAttr('disabled');
      } else {
        this.pagerBar.find('.pager-prev a').attr('disabled', 'disabled');
      }
    },


    /**
     * Enable next page button.
     * @param {boolean} toggleOption Toggle vs show
     */
    enableNextButton: function enableNextButton(toggleOption) {
      toggleOption = ('' + toggleOption).toLowerCase() === 'true';
      this.settings.enableNextButton = toggleOption;

      if (toggleOption) {
        this.pagerBar.find('.pager-next a').removeAttr('disabled');
      } else {
        this.pagerBar.find('.pager-next a').attr('disabled', 'disabled');
      }
    },


    /**
     * Enable last page button.
     * @param {boolean} toggleOption Toggle vs show
     */
    enableLastButton: function enableLastButton(toggleOption) {
      toggleOption = ('' + toggleOption).toLowerCase() === 'true';
      this.settings.enableLastButton = toggleOption;

      if (toggleOption) {
        this.pagerBar.find('.pager-last a').removeAttr('disabled');
      } else {
        this.pagerBar.find('.pager-last a').attr('disabled', 'disabled');
      }
    },


    /**
     * Set or Get Current Page.
     * @param  {object} pagingInfo The paging info object
     * @param  {boolean} force Force the update
     * @param  {string} op The paging operation type.
     * @returns {void}
     */
    setActivePage: function setActivePage(pagingInfo, force, op) {
      if (this.settings.type === 'standalone') {
        return this.activePage;
      }

      var lis = this.pagerBar.find(PAGER_NON_NUMBER_BUTTON_SELECTOR);
      var pageNum = void 0;

      // Backwards compatibility with having "pageNum" as the first argument
      // instead of "pagingInfo"
      if (!isNaN(pagingInfo)) {
        pageNum = pagingInfo;
        pagingInfo = {
          activePage: pageNum
        };
      }

      // Check to make sure our internal active page is set
      if (!this.activePage || isNaN(this.activePage)) {
        this.activePage = this.settings.activePage;
      }

      // If any of the following conditions are met, don't rerender the pages.
      // Only rerender the pager bar.
      if (pageNum === undefined || pageNum === 0 || isNaN(pageNum) || pageNum > this.pageCount() && this.pageCount() > 0 || pageNum === this.activePage && !force) {
        this.renderBar(pagingInfo);
        return this.activePage;
      }

      this.activePage = pageNum;

      // Remove selected
      if (!this.settings.source) {
        lis.filter('.selected').removeClass('selected').removeAttr('aria-selected').find('a').removeAttr('aria-disabled').find('.audible').html(Locale.translate('Page'));

        // Set selected Page
        lis.eq(pageNum - 1).addClass('selected').attr('aria-selected', true).find('a').attr('aria-disabled', true).find('.audible').html(Locale.translate('PageOn'));
      }

      this.renderBar(pagingInfo);
      this.renderPages(op);
      if (this.settings.componentAPI && this.settings.componentAPI.saveUserSettings) {
        this.settings.componentAPI.saveUserSettings();
      }
      return pageNum;
    },


    /**
    * Fires when the page size changer is used.
    * @event pagesizechange
    * @memberof Pager
    * @property {object} event - The jquery event object
    * @property {function} request - Various paging info
    */
    /**
     * Get the Total Number of pages
     * @private
     * @param  {object} pages The pages to set.
     * @returns {void}
     */
    pageCount: function pageCount(pages) {
      var _this = this;

      var self = this;
      var isShowPageSizeSelectorCall = this.isShowPageSizeSelectorCall;

      // Remove call, after cached
      delete this.isShowPageSizeSelectorCall;

      if (pages === undefined && this.settings.indeterminate) {
        this._pageCount = this.settings.pagesize; //eslint-disable-line
      }

      if (pages === undefined && !this.settings.source && !isShowPageSizeSelectorCall) {
        return this._pageCount; //eslint-disable-line
      }

      if (pages !== undefined) {
        this._pageCount = pages; //eslint-disable-line
      }

      // Add in fake pages
      if (!this.isTable) {
        var i = void 0;
        var thisClass = void 0;
        var thisText = void 0;
        var isAriaSelected = void 0;
        var isAriaDisabled = void 0;
        this.pagerBar.find(PAGER_NON_NUMBER_BUTTON_SELECTOR).remove();

        for (i = pages; i > 0; i--) {
          if (i === (this.activePage || 1)) {
            thisClass = 'class="pager-no selected"';
            thisText = Locale.translate('PageOn');
            isAriaSelected = 'aria-selected="true"';
            isAriaDisabled = 'aria-disabled="true"';
          } else {
            thisClass = 'class="pager-no"';
            thisText = Locale.translate('Page');
            isAriaSelected = '';
            isAriaDisabled = '';
          }

          $('<li ' + thisClass + isAriaSelected + '><a href="#" ' + isAriaDisabled + '><span class="audible">' + thisText + ' </span>' + i + '</a></li>').insertAfter(this.pagerBar.find('.pager-prev'));
        }
      }

      if (this.isTable && !this.settings.indeterminate && this.pagerBar.find('.pager-count').length === 0) {
        var text = Locale.translate('PageOf');
        text = text.replace('{0}', '<input name="pager-pageno" value="' + this.activePage + '" autocomplete="off">');
        text = text.replace('{1}', '<span class="pager-total-pages">' + (pages || 1) + '</span>');
        $('<li class="pager-count"><label>' + text + ' </label>').insertAfter(this.pagerBar.find('.pager-prev'));

        // Setup interactivty with the numeric page input
        var lastValue = null;

        this.pagerBar.find('.pager-count input').on('focus', function () {
          lastValue = $(this).val();
        }).on('blur', function () {
          if (lastValue !== $(this).val()) {
            $(this).val(self.setActivePage(parseInt($(this).val(), 10), false, 'page'));
          }
        }).on('keydown', function (e) {
          if (e.which === 13) {
            self.setActivePage(parseInt($(this).val(), 10), false, 'page');

            e.stopPropagation();
            e.preventDefault();
          }
        });
      }

      // Add functionality to change page size.
      if (self.settings.showPageSizeSelector && this.pagerBar.find('.btn-menu').length === 0) {
        var pageSize = $('<li class="pager-pagesize"></li>');
        var pageSizeButton = $('' + ('<button type="button" class="btn-menu">' + '<span>') + Locale.translate('RecordsPerPage').replace('{0}', this.settings.pagesize) + '</span> ' + $.createIcon({ icon: 'dropdown' }) + ' </button>').appendTo(pageSize);

        var last = this.pagerBar.find('.pager-last');
        if (last.length === 0) {
          last = this.pagerBar.find('.pager-next');
        }
        pageSize.insertAfter(last);

        var menu = $('<ul class="popupmenu is-selectable"></ul>');

        for (var k = 0; k < self.settings.pagesizes.length; k++) {
          var size = self.settings.pagesizes[k];
          menu.append('<li ' + (size === self.settings.pagesize ? ' class="is-checked"' : '') + '><a href="#">' + size + '</a></li>');
        }

        pageSizeButton.after(menu);

        var popupOpts = {
          placementOpts: {
            parent: pageSizeButton,
            parentXAlignment: this.isRTL ? 'left' : 'right',
            strategies: ['flip']
          }
        };

        pageSizeButton.popupmenu(popupOpts).on('selected.pager', function (e, args) {
          var tag = args;
          tag.closest('.popupmenu').find('.is-checked').removeClass('is-checked');
          tag.parent('li').addClass('is-checked');
          self.settings.pagesize = parseInt(tag.text(), 10);

          if (self.settings.componentAPI) {
            self.settings.componentAPI.settings.pagesize = self.settings.pagesize;
          }
          self.setActivePage(1, true, 'first');

          if (self.settings.onPageSizeChange) {
            self.settings.onPageSizeChange(_this, {
              tag: args,
              pagesize: self.settings.pagesize,
              settings: self.settings
            });
          }

          self.element.trigger('pagesizechange', {
            tag: args,
            pagesize: self.settings.pagesize,
            settings: self.settings
          });

          // Update the number of records per page
          self.pagerBar.find('.btn-menu span').text(Locale.translate('RecordsPerPage').replace('{0}', self.settings.pagesize));
        });
      }

      var pattern = ('' + this._pageCount).replace(/\d/g, '#');
      this.pagerBar.find('.pager-count input').attr('data-mask', '').mask({ pattern: pattern, mode: 'number', processOnInitialize: false });

      this._pageCount = this._pageCount || 1;
      if (this.settings.indeterminate) {
        return 999999999;
      }
      return this._pageCount;
    },


    /**
     * Reliably gets all the pre-rendered elements in the container and returns them for use.
     * @private
     * @returns {array} TThe pagable items
     */
    getPageableElements: function getPageableElements() {
      var elements = this.element.children().not('.datagrid-expandable-row');

      // Adjust for cases where the root is a <ul>
      if (elements.is('ul')) {
        elements = elements.children();
      }

      if (elements.is('table')) {
        elements = elements.find('tr');
      }

      return elements;
    },


    /**
     * Renders the pager bar based on derived or forced settings.
     * @private
     * @param {SohoPagingInfo} pagingInfo - an object containing information on how to
     * render the pager.
     * @returns {undefined}
     */
    renderBar: function renderBar(pagingInfo) {
      // How many can fit?
      var pb = this.pagerBar;
      var elems = void 0;
      var pc = void 0;
      var width = this.element.parent().width() / pb.find('li:first').width();
      var VISIBLE_BUTTONS = 3; // Take out the ones that should be visible (buttons and selected)
      var howMany = Math.floor(width - VISIBLE_BUTTONS);

      if (!pagingInfo) {
        pagingInfo = {};
      }

      // Check Data Attr
      if (this.element.attr('data-pagesize')) {
        this.settings.pagesize = this.element.attr('data-pagesize');
      }

      // Adjust Page count numbers
      if (!this.settings.source && this.settings.type !== 'standalone') {
        var pageableLength = this.getPageableElements().not('.is-filtered').length;
        pc = Math.ceil(pageableLength / this.settings.pagesize);

        if (this.isTable) {
          var isFiltered = function isFiltered(value) {
            return !value.isFiltered;
          };
          var dataLength = this.settings.dataset.filter(isFiltered).length;

          pc = Math.ceil(dataLength / this.settings.pagesize);
        }
        this.pageCount(pc);
      }

      // Update the input field's number
      this.pagerBar.find('.pager-count input').val(this.activePage);

      // Update the total number of pages
      if (this._pageCount !== '0' && !isNaN(this._pageCount)) {
        this.pagerBar.find('.pager-total-pages').text(this._pageCount);
      }

      // Update the number of records per page
      this.pagerBar.find('.btn-menu span').text(Locale.translate('RecordsPerPage').replace('{0}', this.settings.pagesize));

      // Refresh Disabled
      var prev = pb.find('.pager-prev a');
      var next = pb.find('.pager-next a');
      var first = pb.find('.pager-first a');
      var last = pb.find('.pager-last a');
      var prevGroup = prev.add(first).add('.pager-prev').add('.pager-first');
      var nextGroup = next.add(last).add('.pager-next').add('.pager-last');
      var disabledAttrs = { disabled: 'disabled' };

      // Reset all pager buttons' disabled/focusable states
      this.pagerBar[0].classList.remove('hidden');
      prevGroup.add(nextGroup).removeAttr('disabled');

      // hide buttons feature
      if (!this.settings.showFirstButton) {
        first.hide();
      }

      if (!this.settings.enableFirstButton) {
        this.enableFirstButton(false);
      }

      if (!this.settings.showPreviousButton) {
        prev.hide();
      }

      if (!this.settings.enablePreviousButton) {
        this.enablePreviousButton(false);
      }

      if (!this.settings.showNextButton) {
        next.hide();
      }

      if (!this.settings.enableNextButton) {
        this.enableNextButton(false);
      }

      if (!this.settings.showLastButton) {
        last.hide();
      }

      if (!this.settings.enableLastButton) {
        this.enableLastButton(false);
      }

      if (this.settings.showPageSizeSelector) {
        this.showPageSizeSelector(true);
      }

      if (this.settings.type === 'standalone') {
        this.initTabIndexes(pb);
        return;
      }

      // Explicit false turns buttons back on.
      if (pagingInfo.firstPage === false) {
        prevGroup.removeAttr('disabled');
      }

      if (pagingInfo.lastPage === false) {
        nextGroup.removeAttr('disabled');
      }

      // First page
      if (pagingInfo.firstPage === true || pagingInfo.firstPage === undefined && this.activePage === 1) {
        prevGroup.attr(disabledAttrs);
      }

      // Last page
      if (pagingInfo.lastPage === true || pagingInfo.lastPage === undefined && this.activePage === this.pageCount()) {
        nextGroup.attr(disabledAttrs);
      }

      if (this.hidePagerBar(pagingInfo)) {
        this.pagerBar[0].classList.add('hidden');
      }

      // Remove from the front until selected is visible and we have at least howMany showing
      if (!this.settings.source) {
        elems = pb.find(PAGER_NON_NUMBER_BUTTON_SELECTOR);
        elems.show();
        if (elems.length < howMany) {
          this.initTabIndexes(pb);
          return;
        }

        elems.each(function () {
          var li = $(this);
          if (pb.find('.pager-next').offset().top - pb.offset().top > 1 && !li.is('.selected')) {
            $(this).hide();
          }
        });
      }

      this.initTabIndexes(pb);
    },


    /**
     * Sync the tabindexes
     * @param {object} pb The pager bar elem.
     * @private
     */
    initTabIndexes: function initTabIndexes(pb) {
      var tabbables = pb.find(this.tabbableSelector);
      tabbables.attr('tabindex', '-1');
      tabbables.filter(':not([disabled])').first().removeAttr('tabindex');
    },


    /**
     * Render a page of items.
     * @private
     * @param {object} op The paging operation.
     * @param {function} callback The pager callback.
     * @param {string} trigger The triggering action.
     */
    renderPages: function renderPages(op, callback, trigger) {
      if (this.settings.type === 'standalone') {
        return;
      }

      var expr = void 0;
      var self = this;
      var request = {
        activePage: self.activePage,
        pagesize: self.settings.pagesize,
        indeterminate: self.settings.indeterminate,
        type: op,
        trigger: trigger,
        total: self.settings.componentAPI ? self.settings.componentAPI.settings.dataset.length : -1
      };

      /**
      * Fires just before changing page. Returning false from the request function will cancel paging.
      * @event beforepaging
      * @memberof Pager
      * @property {object} event - The jquery event object
      * @property {function} request - The paging request info
      */
      var doPaging = self.element.triggerHandler('beforepaging', request);
      if (doPaging === false) {
        return;
      }

      if (self.settings.source && op) {
        var response = function response(data, pagingInfo) {
          if (pagingInfo && pagingInfo.activePage) {
            if (pagingInfo.activePage > -1) {
              self.activePage = pagingInfo.activePage;
            }
          }

          // Render Data
          pagingInfo.preserveSelected = true;

          // Call out to the component's API to pull in dataset information.
          // This method should also tell the Pager how to re-render itself.
          self.settings.componentAPI.loadData(data, pagingInfo, true);

          if (callback && typeof callback === 'function') {
            callback(true);
          }

          /**
          * Fires after changing paging has completed.
          * @event afterpaging
          * @memberof Pager
          * @property {object} event - The jquery event object
          * @property {object} pagingInfo - The paging info object
          */
          self.element.trigger('afterpaging', pagingInfo);
        };

        if (self.settings.componentAPI.sortColumn && self.settings.componentAPI.sortColumn.sortId) {
          request.sortAsc = self.settings.componentAPI.sortColumn.sortAsc;
          request.sortField = self.settings.componentAPI.sortColumn.sortField;
          request.sortId = self.settings.componentAPI.sortColumn.sortId;
        }

        if (self.settings.componentAPI.filterExpr) {
          request.filterExpr = self.settings.componentAPI.filterExpr;
        }
        self.settings.source(request, response);
      }

      /**
      * Fires when change page.
      * @event paging
      * @memberof Pager
      * @property {object} event The jquery event object
      * @property {object} request The paging request object
      */
      self.element.trigger('paging', request);
      var elements = self.getPageableElements().not('.is-hidden');

      // Render page objects
      if (!self.settings.source) {
        var rows = self.settings.pagesize;

        self.updatePagingInfo(request);

        if (self.settings.componentAPI && typeof self.settings.componentAPI.renderRows === 'function' && request.type && request.type !== 'initial') {
          self.settings.componentAPI.renderRows();
        }

        elements.hide();

        // collapse expanded rows
        self.element.children().filter('.datagrid-expandable-row.is-expanded').removeClass('is-expanded').hide().prev().removeClass('.is-expanded').find('.plus-minus').removeClass('active');

        expr = self.activePage === 1 ? ':not(".is-filtered"):lt(' + rows + ')' : ':not(".is-filtered"):lt(' + self.activePage * rows + '):gt(' + ((self.activePage - 1) * rows - 1) + ')';

        elements.filter(expr).show();
      } else {
        elements.show();
      }

      if (!self.settings.source) {
        self.element.trigger('afterpaging', request);
      }
    },


    /**
     * Update the component and optionally apply new settings.
     * @param  {object} settings the settings to update to.
     * @returns {object} The plugin api for chaining.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      if (settings.showPageSizeSelector !== undefined) {
        this.showPageSizeSelector(this.settings.showPageSizeSelector);
      }

      if (settings.showFirstButton !== undefined) {
        this.showFirstButton(this.settings.showFirstButton);
      }

      if (settings.showPreviousButton !== undefined) {
        this.showPreviousButton(this.settings.showPreviousButton);
      }

      if (settings.showNextButton !== undefined) {
        this.showNextButton(this.settings.showNextButton);
      }

      if (settings.showLastButton !== undefined) {
        this.showLastButton(this.settings.showLastButton);
      }

      if (settings.pagesizes) {
        this.settings.pagesizes = settings.pagesizes;
      }

      this.updatePagingInfo(this.settings);

      if (settings.enableFirstButton !== undefined) {
        this.enableFirstButton(this.settings.enableFirstButton);
      }

      if (settings.enablePreviousButton !== undefined) {
        this.enablePreviousButton(this.settings.enablePreviousButton);
      }

      if (settings.enableNextButton !== undefined) {
        this.enableNextButton(this.settings.enableNextButton);
      }

      if (settings.enableLastButton !== undefined) {
        this.enableLastButton(this.settings.enableLastButton);
      }

      return this;
    },


    /**
     * Updates this instance of pager with externally-provided settings.
     * @param {object} pagingInfo - contains settings that will change buttons on the pager.
     * @param {number} pagingInfo.pagesize - the number of items visible per page
     * @param {number} pagingInfo.total - the total number of pages
     * @param {number} pagingInfo.activePage - the currently visible page
     * @param {boolean} [pagingInfo.firstPage=false] - passed if the currently visible page is the
     * first one
     * @param {boolean} [pagingInfo.lastPage=false] - passed if the currently visible page is the
     * last one
     * @param {boolean} [pagingInfo.hideDisabledPagers=false] - causes the pager to become completely
     * hidden if all buttons are disabled
     * @returns {void}
     */
    updatePagingInfo: function updatePagingInfo(pagingInfo) {
      if (!pagingInfo) {
        return;
      }

      // Grab and retain the pagesize
      if (pagingInfo.pagesize) {
        this.settings.pagesize = pagingInfo.pagesize;
        if (this.isTable && this.settings.componentAPI) {
          this.settings.componentAPI.settings.pagesize = pagingInfo.pagesize;
        }
      }

      // Set a default total if none are defined.
      if (!pagingInfo.total) {
        pagingInfo.total = 0;
      }

      if (this.settings.source) {
        this._pageCount = Math.ceil(pagingInfo.total / this.settings.pagesize);
        // Set first and last page if passed
        // If we get a page number as a result, rendering has already happened and
        // we should not attempt to re-render.
        this.setActivePage(pagingInfo, false, 'pageinfo');
        return;
      }

      this.renderBar(pagingInfo);
    },


    /**
     * Reclaim the pager height so that datagrid can use it's full container, if only one page.
     * @private
     * @param  {object} pagingInfo The pager states.
     * @returns {void}
     */
    hidePagerBar: function hidePagerBar(pagingInfo) {
      if (this.settings.hideOnOnePage && pagingInfo.total <= pagingInfo.pagesize) {
        return true;
      }

      if (pagingInfo.firstPage === true && pagingInfo.lastPage === true && pagingInfo.hideDisabledPagers) {
        return true;
      }

      return false;
    },


    /**
     * Tear down and detatch all events
     */
    destroy: function destroy() {
      if (this.pagerBar) {
        this.pagerBar.remove();
      }
      $.removeData(this.element[0], COMPONENT_NAME$K);
    }
  };

  /**
   * jQuery Component Wrapper for pager
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.pager = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$K);
      if (!instance) {
        instance = $.data(this, COMPONENT_NAME$K, new Pager(this, settings));
      } else {
        instance.updated(settings);
      }
    });
  };

  var COMPONENT_NAME$L = 'listview';

  /**
   * Creates lists of small pieces of relevant, actionable information.
   * @class ListView
   * @constructor
   *
   * @param {jquery[]|htmlelement} element the base element
   * @param {object} [settings] incoming settings
   * @param {array} [settings.dataset] Array of data to feed the template
   * @param {string} [settings.template] Html Template String
   * @param {string} [settings.description] Audible Label (or use parent title)
   * @param {boolean} [settings.paging=false] If true, activates paging
   * @param {number} [settings.pagesize=10] If paging is activated, sets the number of listview items available per page
   * @param {string} [settings.pagingType='list'] The paging type to use, this can be 'list', 'table' or 'firstlast'
   * @param {boolean} [settings.searchable=false] If true, associates itself with a Searchfield/Autocomplete and allows itself to be filtered
   * @param {boolean} [settings.highlight=true] If false the highlighting of text when using searchable is disabled. You may want to disable this on larger lists.
   * @param {string|boolean} [settings.selectable='single'] selection mode, can be false, 'single', 'multiple' or 'mixed'
   * @param {boolean} [settings.selectOnFocus=true] If true the first item in the list will be selected as it is focused.
   * @param {boolean} [settings.showCheckboxes=true] If false will not show checkboxes used with multiple selection mode only
   * @param {boolean} [settings.hoverable=true] If true the list element will show a hover action to indicate its actionable.
   * @param {string} [settings.emptyMessage] Text to go in emptyMessage.
   * @param {function|string} [settings.source] If source is a string then it serves as
    the url for an ajax call that returns the dataset. If its a function it is a call back for getting the data asyncronously.
   * @param {boolean} [settings.forceToRenderOnEmptyDs=false] If true list will render as an empty list with ul tag, but not any li tags in it.
   * @param {boolean} [settings.disableItemDeactivation=false] If true when an item is
    activated the user should not be able to deactivate it by clicking on the activated item. They can only select another row.
   * @param {boolean} [settings.showPageSizeSelector=false] If true the page size select will be shown when paging.
   */

  var LISTVIEW_DEFAULTS = {
    dataset: [],
    template: null,
    description: null,
    paging: false,
    pagesize: 10,
    pagingType: 'list',
    searchable: false,
    highlight: true,
    selectable: 'single',
    selectOnFocus: true,
    showCheckboxes: true,
    hoverable: true,
    emptyMessage: null,
    source: null,
    forceToRenderOnEmptyDs: false,
    disableItemDeactivation: false,
    showPageSizeSelector: false
  };

  function ListView(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, LISTVIEW_DEFAULTS);
    this.init();

    return this;
  }

  ListView.prototype = {

    /**
     * Initialize this component.
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup();
      this.handleEvents();
      this.refresh();
      this.selectedItems = [];
      this.lastSelectedItem = 0; // Rember index to use shift key
      this.isSelectedAll = false; // Rember if all selected or not
      this.sortInit('listview', 'click.listview', 'data-sortlist');
      this.handleResize();
    },


    /**
     * Do initial dom and settings setup.
     * @private
     * @returns {void}
     */
    setup: function setup() {
      var self = this;
      var card = this.element.closest('.card, .widget');
      var selectable = this.element.attr('data-selectable');
      var selectOnFocus = this.element.attr('data-select-onfocus');

      if (selectable && selectable.length) {
        this.settings.selectable = selectable;
      }

      if (selectOnFocus && selectOnFocus.length) {
        this.settings.selectOnFocus = JSON.parse(selectOnFocus);
      }

      self.actionButton = card.find('.btn-actions');

      if (self.actionButton.length > 0) {
        // Action Buttons may already be invoked via initialize.js.
        if (!self.actionButton.data('popupmenu')) {
          self.actionButton.popupmenu();
        }
      }

      this.element.attr({ tabindex: '-1', 'x-ms-format-detection': 'none' });

      // Configure Paging
      if (this.element.is('.paginated') || this.settings.paging === true) {
        this.element.pager({
          componentAPI: this,
          pagesize: this.settings.pagesize,
          source: this.settings.source,
          showPageSizeSelector: this.settings.showPageSizeSelector,
          type: this.settings.pagingType || 'list'
        });

        this.pager = this.element.data('pager');
      }

      var cardWidgetContent = this.element.parent('.card-content, .widget-content');
      if (cardWidgetContent[0]) {
        cardWidgetContent[0].style.overflow = 'hidden';
      }

      // Add Aria Roles
      this.element.attr({
        role: 'listbox',
        'aria-label': this.settings.description || card.find('.card-title, .widget-title').text()
      });

      // Associate with an existing searchfield, if applicable
      if (this.settings.searchable) {
        this.searchfield = this.element.parent().find('.searchfield, .autocomplete');

        if (!this.searchfield.length) ;

        this.listfilter = new ListFilter({
          filterMode: 'contains'
        });
      }

      if (this.settings.emptyMessage) {
        // Object { title: "No Data Available", info: "", icon: "icon-empty-no-data" }
        self.emptyMessageContainer = $('<div>').emptymessage(this.settings.emptyMessage);
      }

      if (this.settings.dataset) {
        // Search the global variable space for a dataset variable name, if provided.
        if (typeof this.settings.dataset === 'string') {
          var dataset = window[this.settings.dataset];
          if (dataset && dataset.length) {
            this.settings.dataset = dataset;
          }
        }
      }
    },


    /**
     * Calculate the totals for totalling examples.
     * This is displayed in the template by referencing {{totals}}.
     * @private
     * @param {array} dataset the incoming dataset
     * @returns {number} the total number of listview items.
     */
    getTotals: function getTotals(dataset) {
      var totals = { count: dataset.length };
      var property = void 0;

      if (!dataset[0]) {
        return undefined;
      }

      for (property in dataset[0]) {
        //eslint-disable-line
        totals[property] = 0;
      }

      for (var i = 0; i < dataset.length; i++) {
        for (property in dataset[i]) {
          //eslint-disable-line
          totals[property] += parseFloat(dataset[i][property]);
        }
      }
      return totals;
    },


    /**
     * Render the template against the dataset.
     * @private
     * @param {array} dataset  The dataset to use
     * @param {object} pagerInfo  Pager instructions
     */
    render: function render(dataset, pagerInfo) {
      var self = this;
      var totals = {};

      // Render "mustache" Template
      if ((typeof Tmpl === 'undefined' ? 'undefined' : _typeof(Tmpl)) === 'object' && dataset && this.settings.template) {
        // create a copy of an inlined template
        if (this.settings.template instanceof $) {
          this.settings.template = '' + this.settings.template.html();
        } else if (typeof this.settings.template === 'string') {
          // If a string doesn't contain HTML elments,
          // assume it's an element ID string and attempt to select with jQuery
          if (!stringUtils.containsHTML(this.settings.template)) {
            this.settings.template = $('#' + this.settings.template).html();
          }
        }

        if (this.settings.template.indexOf('{{#totals}}') > -1) {
          totals = this.getTotals(dataset);
        }

        var renderedTmpl = Tmpl.compile(this.settings.template, { dataset: dataset, totals: totals });

        if (dataset.length > 0 || this.settings.forceToRenderOnEmptyDs) {
          this.element.html(renderedTmpl);
        } else if (self.emptyMessageContainer) {
          this.element.empty();
          DOM.append(this.element, this.emptyMessageContainer[0].outerHTML, '<div><svg><use><span><b>');
        } else if (dataset.length === 0) {
          this.element.html(renderedTmpl || '<ul></ul>');
        }
      }

      // Render Pager
      if (this.settings.paging) {
        this.renderPager(pagerInfo);
        this.pager.setActivePage(this.pager.settings.activePage, true);
      }

      // Add Aria
      $('ul', this.element).attr({ role: 'presentation' });

      // Add Checkboxes
      var first = this.element.find('li, tbody > tr').first();
      var items = this.element.find('li, tr');
      var isMultiselect = this.settings.selectable === 'multiple' || this.settings.selectable === 'mixed';

      // Set Initial Tab Index
      this.focusItem = first.attr('tabindex', 0);

      // Let the link be focus'd
      if (!this.settings.selectable && first.find('a').length === 1) {
        first.removeAttr('tabindex');
      }

      items.each(function (i) {
        var item = $(this);

        item.attr('role', 'option');

        if (isMultiselect) {
          // Add Selection Checkboxes
          self.element.addClass('is-multiselect');

          // Create a Toolbar for the "Selected Items" area
          var selectedToolbar = self.element.prevAll('.toolbar');
          if (selectedToolbar.length && selectedToolbar.data('toolbar')) {
            selectedToolbar.data('toolbar').toggleMoreMenu();
          }

          if (self.settings.showCheckboxes) {
            // For mixed selection mode primarily append a checkbox object
            item.prepend('<label class="listview-selection-checkbox l-vertical-center inline inline-checkbox"><input tabindex="-1" type="checkbox" class="checkbox"><span class="label-text">&nbsp;</span></label>');
          }
        }

        // Add Aria
        item.attr({ 'aria-posinset': i + 1, 'aria-setsize': items.length });

        // Add Aria disabled
        if (item.hasClass('is-disabled')) {
          item.attr('aria-disabled', 'true');
        }
      });

      // TODO: Invoke the "element" here after we write an updated method.
      this.element.children().initialize();
      /**
       * Fires after the listbox is fully rendered.
       *
       * @event rendered
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {array} dataset .
       */
      this.element.trigger('rendered', [dataset]);

      // Handle refresh
      this.element.off('updated.listview').on('updated.listview', function (e, settings) {
        self.updated(settings);
      });
    },


    /**
     * Add and update the pager (if used)
     * @private
     * @param {object} updatedPagerInfo contains updated paging settings
     * @returns {void}
     */
    renderPager: function renderPager(updatedPagerInfo) {
      if (!this.pager) {
        return;
      }

      this.pager.updatePagingInfo(updatedPagerInfo);
      // this.pager.setActivePage(1, true);
    },


    /**
     * Get the Data Source. Can be an array, Object or Url and render the list.
     * @private
     * @param {array} dataset contains a potential new dataset to display inside the listview.
     */
    refresh: function refresh(dataset) {
      this.loadData(dataset);

      if (this.list) {
        this.render(this.list.data);
      }
    },


    /**
     * Load Data from an external API
     * @param {object} ds  The dataset to use or will use settings.dataset.
     * @param {object} pagerInfo  The pager settings to use (see pager api)
     * @param {boolean} isResponse Flag used to avoid dup source calls.
     * @returns {void}
     */
    loadData: function loadData(ds, pagerInfo, isResponse) {
      var ajaxDs = false;
      var self = this;

      ds = ds || this.settings.dataset;
      pagerInfo = pagerInfo || {};

      if (!Array.isArray(ds)) {
        return;
      }

      function done(response, pagingInfo) {
        self.settings.dataset = response;
        ds = response;
        self.render(ds, pagingInfo);
      }

      var s = this.settings.source;

      if (typeof ds === 'string' && (ds.indexOf('http') === 0 || ds.indexOf('/') === 0)) {
        s = ds;
        ajaxDs = true;
      }

      // If paging is not active, and a source is present, attempt to retrieve
      // information from the datasource.
      // TODO: Potentially abstract this datasource concept out for use elsewhere
      if ((s || ajaxDs) && !isResponse) {
        switch (typeof s === 'undefined' ? 'undefined' : _typeof(s)) {
          case 'function':
            s(pagerInfo, done);
            break;
          case 'string':
            if (s.indexOf('http') === 0 || s.indexOf('/') === 0) {
              $.getJSON(s, done);
            }
            return;
          default:
            this.settings.dataset = s;
            ds = s;
            this.render(s, pagerInfo);
            break;
        }
        return;
      }

      // Otherwise, simply render with the existing dataset
      this.render(ds, pagerInfo);
    },


    /**
     * Toggle all items from selected to deselected, useful for multi/mixed selection
     * @returns {void}
     */
    toggleAll: function toggleAll() {
      this[this.isSelectedAll ? 'deselectItemsBetweenIndexes' : 'selectItemsBetweenIndexes']([0, $('li, tbody tr', this.element).length - 1]);
      this.isSelectedAll = !this.isSelectedAll;
    },


    /**
     * Select Items between a set of indexes. Used for shift selection.
     * @private
     * @param {array} indexes an array containing two numeric indicies that will
     *  be used to make a selection.
     * @returns {void}
     */
    selectItemsBetweenIndexes: function selectItemsBetweenIndexes(indexes) {
      this.clearSelection();
      indexes.sort(function (a, b) {
        return a - b;
      });
      for (var i = indexes[0]; i <= indexes[1]; i++) {
        var item = $('li, tbody tr', this.element).eq(i);

        if (!item.is('.is-disabled, .is-selected')) {
          this.select(item);
        }
      }
    },


    /**
    * De-Select Items between a set of indexes. Used for shift selection.
    * @private
    * @param {array} indexes an array containing two numeric indicies that will
    *  be used to deselect.
    * @returns {void}
    */
    deselectItemsBetweenIndexes: function deselectItemsBetweenIndexes(indexes) {
      indexes.sort(function (a, b) {
        return a - b;
      });
      for (var i = indexes[0]; i <= indexes[1]; i++) {
        var item = $('li, tbody tr', this.element).eq(i);
        if (!item.is('.is-disabled') && item.is('.is-selected')) {
          this.select(item);
        }
      }
    },


    /**
    * Clear all currently selected list items.
    * @private
    * @returns {void}
    */
    clearSelection: function clearSelection() {
      if (window.getSelection) {
        window.getSelection().removeAllRanges();
      } else if (document.selection) {
        document.selection.empty();
      }
    },


    /**
    * Handle page/form resize
    * @private
    * @returns {void}
    */
    handleResize: function handleResize() {
      var items = $('li .listview-heading, tr .listview-heading', this.element);
      var item1 = items.eq(1);
      var item1W = item1.width();

      if (item1.length && item1W) {
        items[0].style.width = item1W + 'px';
      }

      if (this.element.data('pager')) {
        this.element.data('pager').renderBar();
      }
    },


    /**
     * @private
     * @param {jquery.event} e custom jQuery `contents-checked` event.
     * @param {jquery[]} searchfield the element representing a searchfield.
     * @returns {void}
     */
    handleSearch: function handleSearch(e, searchfield) {
      this.filter(searchfield);
    },


    /**
     * Filters the contents of Listviews that are paired with a Searchfield.
     * @param {jquery[]} searchfield the element representing a searchfield.
     * @returns {void}
     */
    filter: function filter(searchfield) {
      if (!searchfield) {
        return;
      }

      searchfield = $(searchfield);

      // Get the search string and trim whitespace
      var searchFieldVal = searchfield.val().trim();

      // Clear
      if (!searchFieldVal) {
        this.resetSearch();
      }

      // Make sure there is a search term...and its not the
      // same as the previous term
      if (searchFieldVal.length < 2 || this.searchTerm === searchFieldVal) {
        return;
      }

      // Set a global "searchTerm" and get the list of elements
      this.searchTerm = searchfield.val();
      var list = this.element.find('li, tbody > tr');

      this.resetSearch();

      // Filter the results and highlight things
      var results = this.listfilter.filter(list, this.searchTerm);

      if (this.settings.highlight) {
        results.highlight(this.searchTerm);
      }

      // Hide elements that aren't in the results array
      list.not(results).addClass('hidden');

      this.renderPager();
    },


    /**
     * Reset the current search parameters and highlight.
     * @private
     * @returns {void}
     */
    resetSearch: function resetSearch() {
      var list = this.element.find('li, tbody > tr');

      list.removeClass('hidden');

      if (this.settings.highlight) {
        list.each(function () {
          $(this).unhighlight();
        });
      }
    },


    /**
     * Focus the provided list item with the keyboard
     * @private
     * @param {jquery} item  The list item (as jQuery) to focus
     * @returns {void}
     */
    focus: function focus(item) {
      if (item.is(':hidden') || item.is('.is-disabled')) {
        return;
      }

      if (this.focusItem) {
        this.focusItem.removeAttr('tabindex');
      }
      this.focusItem = item.attr('tabindex', 0).focus();

      if (!this.settings.selectable && item.find('a').length === 1) {
        item.find('a').focus();
        item.removeAttr('tabindex');
      }

      if (this.settings.selectOnFocus && this.settings.selectable !== 'multiple' && this.settings.selectable !== 'mixed') {
        this.select(item);
      }
    },


    /**
     * Remove the given list item.
     * @param {jquery|number} li Either the actually jQuery list element or a zero based index
     * @returns {void}
     */
    remove: function remove(li) {
      if (typeof li === 'number') {
        li = $(this.element.children()[0]).children().eq(li);
      }
      // Un-select selected item
      // and donot trigger selected event, sinnce we removeing
      if (li.is('.is-selected')) {
        this.select(li, true);
      }
      li.remove();
    },


    /**
     * Remove all list items.
     * @returns {void}
     */
    clear: function clear() {
      var root = $(this.element.children()[0]);
      root.empty();
    },


    /**
     * Remove all selected items entirely from the list.
     * @returns {void}
     */
    removeAllSelected: function removeAllSelected() {
      var self = this;
      $.each(this.selectedItems, function (index, selected) {
        self.remove(selected);
      });
    },


    /**
     * Deselect all selected items.
     * @returns {void}
     */
    clearAllSelected: function clearAllSelected() {
      var self = this;
      $.each(this.selectedItems, function (index, selected) {
        // Un-select selected item
        self.select(selected);
      });
    },


    /**
     * Initialize the sorted list
     * @private
     * @param {string} control component name
     * @param {string} onEvent the name of the event to sort on
     * @param {string} attr the name of the HTML attribute to retrieve options from.
     * @returns {void}
     */
    sortInit: function sortInit(control, onEvent, attr) {
      if (!attr || $.trim(attr) === '') {
        return;
      }
      $('[' + attr + ']').each(function () {
        var element = $(this);
        var options = $.fn.parseOptions(element, attr);

        element.on(onEvent, function (e) {
          $(options.list).data(control).setSortColumn(options);
          e.preventDefault();
        });
      });
    },


    /**
    * Sort the list with the given options.
    * @private
    * @param {object} [options] incoming sort options
    * @returns {void}
    */
    setSortColumn: function setSortColumn(options) {
      var field = options.orderBy || this.list.sort.field;
      var reverse = options.order;

      if (!this.list.data && !field) {
        return;
      }

      reverse = reverse ? reverse === 'desc' : !(this.list.sort && this.list.sort[field] && this.list.sort[field].reverse);

      // reload data
      if (options.reloadApi || options.reloadApiNoSort) {
        this.loadData();
      }

      // reload data but no sort change
      if (options.reloadApiNoSort) {
        field = this.list.sort.field;
        reverse = this.list.sort[field].reverse;
      }

      var sort = this.sortFunction(field, reverse);
      this.list.data.sort(sort);
      this.render(this.list.data);

      this.list.sort = { field: field };
      this.list.sort[field] = { reverse: reverse };
      /**
       * Fires after sorted.
       *
       * @event sorted
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {object} this.element
       * @property {string} this.list.sort
       */
      this.element.trigger('sorted', [this.element, this.list.sort]);
    },


    /**
    * Overridable function to conduct sorting
    * @private
    * @param {string} field  The field in the dataset to sort on.
    * @param {string} reverse  If true sort descending.
    * @param {function} primer  A sorting primer function.
    * @returns {function} a customized sorting algorithm
    */
    sortFunction: function sortFunction(field, reverse, primer) {
      if (!primer) {
        primer = function primer(a) {
          a = a === undefined || a === null ? '' : a;
          if (typeof a === 'string') {
            a = a.toUpperCase();

            if (!isNaN(parseFloat(a))) {
              a = parseFloat(a);
            }
          }
          return a;
        };
      }

      var key = primer ? function (x) {
        return primer(x[field]);
      } : function (x) {
        return x[field];
      };

      reverse = !reverse ? 1 : -1;

      return function (a, b) {
        return a = key(a), b = key(b), reverse * ((a > b) - (b > a)); //eslint-disable-line
      };
    },


    /**
    * Deselect the given list item.
    * @param {jquery[]|number} li  Either the actually jQuery list element or a zero based index
    */
    deselect: function deselect(li) {
      if (typeof li === 'number') {
        li = $(this.element.children()[0]).children().eq(li);
      }
      if (li.is('.is-selected')) {
        this.select(li);
      }
    },


    /**
     * Deprivated - use `deselect()`
     * @deprecated as of v4.3.0
     * @param {jquery[]|number} li a list item
     * @returns {void}
     */
    unselect: function unselect(li) {
      this.deselect(li);
    },


    /**
     * Select the given list item.
     * @param {jquery|number} li Either the actually jQuery list element or a zero based index
     * @param {boolean} noTrigger Do not trigger the selected event.
     */
    select: function select(li, noTrigger) {
      var self = this;
      var isChecked = false;
      var isMixed = self.settings.selectable === 'mixed';

      self.selectedItems = [];
      if (typeof li === 'number') {
        li = $(this.element.children()[0]).children().eq(li);
      }

      isChecked = li.hasClass('is-selected');

      // focus
      if (!li.is('[tabindex="0"]')) {
        if (this.focusItem) {
          this.focusItem.removeAttr('tabindex');
        }
        li.attr('tabindex', 0);
      }

      if (this.settings.selectable === false || this.settings.selectable === 'false') {
        return;
      }

      // Select
      if (this.settings.selectable !== 'multiple' && this.settings.selectable !== 'mixed') {
        li.parent().children().removeAttr('aria-selected');
        li.parent().find('.is-selected').removeClass('is-selected');
        self.selectedItems[0] = $(this);
      }

      if (isChecked) {
        self.selectedItems = [];
        li.removeClass('is-selected hide-selected-color');
      } else if (this.settings.selectable) {
        li.addClass('is-selected' + (isMixed ? ' hide-selected-color' : ''));
        self.lastSelectedItem = li.index(); // Rember index to use shift key
      }

      li.parent().find('.is-selected').each(function (i) {
        self.selectedItems[i] = $(this);
      });

      li.attr('aria-selected', !isChecked);
      li.find('.listview-selection-checkbox input').prop('checked', !isChecked);

      if (!noTrigger) {
        var triggerStr = isChecked ? 'unselected' : 'selected';
        var selectedData = [];

        for (var i = 0; i < this.selectedItems.length; i++) {
          var posinset = this.selectedItems[i][0].getAttribute('aria-posinset');
          selectedData.push(this.settings.dataset[posinset - 1]);
        }

        /**
         * Fires when a item is selected.
         * @event selected
         * @memberof ListView
         * @property {object} event - The jquery event object
         * @property {object} selected items and item info and item data
         */
        this.element.triggerHandler(triggerStr, {
          selectedItems: this.selectedItems,
          elem: li,
          selectedData: selectedData
        });

        if (triggerStr === 'unselected') {
          /**
           * Fires when a item is deselected.
           *
           * @event deselected
           * @memberof ListView
           * @property {object} event - The jquery event object
           * @property {object} selected items and item info
           */
          this.element.triggerHandler('deselected', { selectedItems: this.selectedItems, elem: li, selectedData: selectedData });
        }
      }

      var parent = this.element.closest('.card, .widget');
      if (!parent.length) {
        parent = this.element.parent();
      }

      var toolbar = parent.find('.listview-toolbar, .contextual-toolbar');
      var toolbarControl = toolbar.data('toolbar');

      if (self.selectedItems.length > 0) {
        if (toolbarControl) {
          toolbarControl.toggleMoreMenu();
        }
        // Order of operations: set up event, change display prop, animate, toggle menu.
        // Menu toggle takes place after the animation starts
        toolbar.one('animateopencomplete', function () {
          self.element.addClass('is-toolbar-open');
          toolbar.trigger('recalculate-buttons').removeClass('is-hidden');
        });
        if (toolbar[0]) {
          toolbar[0].style.display = 'block';
        }
        // toolbar.animateOpen({distance: 52});
        toolbar.animateOpen({ distance: 40 });

        var title = toolbar.find('.title, .selection-count');
        if (!title || !title.length) {
          title = $('<div class="title selection-count"></div>');
          toolbar.prepend(title);
        }
        title.text(self.selectedItems.length + ' ' + (Locale ? Locale.translate('Selected') : 'Selected'));
      } else {
        toolbar.addClass('is-hidden').one('animateclosedcomplete', function (e) {
          e.stopPropagation();
          this.style.display = 'none';
          self.element.removeClass('is-toolbar-open');
        }).animateClosed();
      }
    },


    /**
     * Toggle acivation state on the list item
     * @private
     * @param {jquery} li The jQuery list element.
     * @returns {void}
     */
    toggleItemActivation: function toggleItemActivation(li) {
      var isActivated = li.hasClass('is-activated');

      if (isActivated) {
        if (!this.settings.disableItemDeactivation) {
          this.deactivateItem(li);
        }
        return;
      }

      this.activateItem(li);
    },


    /**
     * Set item to activated, unactivate others and fire an event.
     * @private
     * @param {jquery|number} li The jQuery list element or the index.
     * @returns {void}
     */
    activateItem: function activateItem(li) {
      var idx = typeof li === 'number' ? li : li.index();
      var active = this.element.find('li.is-activated');
      var elemCanActivate = true;

      if (typeof li === 'number') {
        li = this.element.find('ul').children().eq(li);
      }
      this.deactivateItem(active);
      /**
       * Fires before activate item.
       *
       * @event beforeactivate
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {object} args index, elem, data
       */
      elemCanActivate = this.element.triggerHandler('beforeactivate', [{ index: idx, elem: li, data: this.settings.dataset[idx] }]);

      if (elemCanActivate === false) {
        return;
      }
      li.addClass('is-activated');

      /**
       * Fires after activate item.
       *
       * @event itemactivated
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {object} args index, elem, data
       */
      this.element.triggerHandler('itemactivated', [{ index: idx, elem: li, data: this.settings.dataset[idx] }]);
    },


    /**
    * Return an object containing info about the currently activated item.
    * @returns {object} An object containing the active row's index, dom element and data.
    */
    activatedItem: function activatedItem() {
      var active = this.element.find('li.is-activated');
      var idx = active.index();

      return {
        index: idx,
        elem: active,
        data: this.settings.dataset[idx]
      };
    },


    /**
     * Set item to deactivated, and fire an event.
     * @param {jquery|number} li The jQuery list element. The li element or the index.
     *  If null the currently activated one will be deactivated.
     * @returns {void}
     */
    deactivateItem: function deactivateItem(li) {
      if (typeof li === 'number') {
        li = this.element.find('ul').children().eq(li);
      }

      if (li === undefined) {
        li = this.element.find('li.is-activated');
      }

      li.removeClass('is-activated');
      var idx = li.index();

      if (idx < 0) {
        return;
      }

      /**
       * Fires after deactivated item.
       *
       * @event itemdeactivated
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {object} args index, elem, data
       */
      this.element.triggerHandler('itemdeactivated', [{ index: idx, elem: li, data: this.settings.dataset[idx] }]);
    },


    /**
     * @returns {jquery[]} the currently selected ListView item, or an empty jQuery selector
     *  if there are currently no items selected.
     */
    getSelected: function getSelected() {
      return this.element.find('.is-selected');
    },


    /**
     * Refresh the list with any optioned options that might have been set.
     * @param {object} [settings] incoming settings
     * @returns {object} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }
      this.refresh(settings ? settings.dataset : null);
      return this;
    },


    /**
     * Disables the functionality of a ListView.
     * @returns {void}
     */
    disable: function disable() {
      this.element.addClass('is-disabled');
    },


    /**
    * Enables the functionality of a ListView.
    * @returns {void}
    */
    enable: function enable() {
      this.element.removeClass('is-disabled');
    },


    /**
     * Detatch all bound events.
     * @private
     * @returns {object} component instance
     */
    teardown: function teardown() {
      $('body').off('resize.listview');
      this.element.prev('.listview-header').off('click.listview');
      if (this.searchfield) {
        this.searchfield.off('contents-checked.searchable-listview');
      }
      this.element.off('change.selectable-listview', '.listview-checkbox input');
      this.element.off('contextmenu.listview dblclick.listview', 'li, tr');
      this.element.off('click.listview', 'li, tr, input[checkbox]');
      this.element.off('keydown.listview', 'li, tr, a');
      this.element.off('focus.listview', 'li, tbody tr');
      this.element.off('focus.listview click.listview touchend.listview keydown.listview change.selectable-listview afterpaging.listview updated.listview').empty();
      return this;
    },


    /**
     * Detatch all events and tear down data object
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      this.element.removeData(COMPONENT_NAME$L);
    },


    /**
      * Attach Events used by the Control
      * @private
      * @returns {void}
      */
    handleEvents: function handleEvents() {
      var self = this;
      var isSelect = false;
      var isFocused = false;
      var isMultiple = self.settings.selectable === 'multiple' || self.settings.selectable === 'mixed';

      this.element.off('focus.listview', 'li, tbody tr').on('focus.listview', 'li, tbody tr', function (evt) {
        var item = $(this);

        // Ignore favorite clicks
        if (evt.originalEvent && evt.originalEvent.target && $(evt.originalEvent.target).is('.icon-favorite')) {
          return;
        }

        // First element if disabled
        if (item.is(':first-child') && item.hasClass('is-disabled')) {
          var e = $.Event('keydown.listview');

          e.keyCode = 40; // move down
          isSelect = true;
          item.trigger(e);
        }

        if (!isSelect && !item.hasClass('is-disabled') && self.settings.selectOnFocus && self.settings.selectable !== 'multiple' && self.settings.selectable !== 'mixed') {
          self.select(item);
          isSelect = true;
          isFocused = true;
        }
      });

      // Keyboard
      this.element.off('keydown.listview', 'li, tr, a').on('keydown.listview', 'li, tr, a', function (e) {
        var elem = $(this);
        var item = elem.is('a') ? elem.closest('li') : $(this);
        var list = item.is('a') ? item.closest('ul') : item.parent();
        var key = e.keyCode || e.charCode || 0;
        var metaKey = e.metaKey;

        if (item.index() === 0 && e.keyCode === 38) {
          return false;
        }

        if ((key === 40 || key === 38) && !metaKey) {
          // move down or up
          var newItem = e.keyCode === 40 ? item.nextAll(':not(.is-disabled):visible:first') : item.prevAll(':not(.is-disabled):visible:first');

          if (newItem.length && ($(e.target).is(item) || e.shiftKey || elem.is('a'))) {
            self.focus(newItem);
          }
          e.preventDefault();
          e.stopPropagation(); // prevent container from scrolling
        }

        if (key === 35 || key === 40 && metaKey) {
          // end
          var last = list.children().last();
          self.focus(last);
          e.stopPropagation();
          return false;
        }

        if (key === 36 || key === 38 && metaKey) {
          // home
          var first = list.children().first();
          self.focus(first);
          e.stopPropagation();
          return false;
        }

        if (key === 32) {
          // Space to toggle selection
          if ($(e.target).is(item)) {
            if (isMultiple && e.shiftKey) {
              self.selectItemsBetweenIndexes([self.lastSelectedItem, item.index()]);
            } else {
              self.select(item);
            }
            e.preventDefault();
          }
        }

        // If multiSelect is enabled, press Control+A to toggle select all items
        if (isMultiple && (e.ctrlKey || e.metaKey) && key === 65) {
          self.toggleAll();
          self.focus(item);
          e.preventDefault();
        }

        return true;
      });

      // Selection View Click/Touch
      if (this.settings.selectable) {
        this.element.addClass('is-selectable');

        var pattern = $(this.element).closest('.list-detail, .builder');

        this.element.off('click.listview', 'li, tr, input[checkbox]').on('click.listview', 'li, tr, input[checkbox]', function (e) {
          var item = $(this);
          var isCheckbox = $(e.target).closest('.listview-selection-checkbox').length > 0;
          var isMixed = self.settings.selectable === 'mixed';
          var target = $(e.target);

          // ignore clicking favorites element or a hyperlink
          if (target.hasClass('icon-favorite') || target.hasClass('hyperlink')) {
            return;
          }

          if (!isFocused && !item.hasClass('is-disabled') && (!isMixed || isCheckbox)) {
            isSelect = true;

            if (isMultiple && e.shiftKey) {
              self.selectItemsBetweenIndexes([self.lastSelectedItem, item.index()]);
              e.preventDefault();
            } else {
              self.select(item);
            }
            item.focus();
          }

          if (!item.hasClass('is-disabled') && isMixed && !isCheckbox) {
            item.focus();
            self.toggleItemActivation(item);
          }

          if (pattern.length > 0 && $(window).outerWidth() < 767 && !item.hasClass('is-disabled') && !isCheckbox) {
            self.element.trigger('drilldown', [item]);
          }

          isFocused = false;

          e.preventDefault();
          e.stopPropagation();

          self.element.trigger('click', [{
            elem: item,
            data: self.settings.dataset[item.attr('aria-posinset') - 1],
            index: item.index(),
            originalEvent: e
          }]);
        });

        this.element.off('dblclick.listview', 'li, tr').on('dblclick.listview', 'li, tr', function (e) {
          var item = $(this);

          e.preventDefault();
          e.stopPropagation();
          self.element.trigger('dblclick', [{
            elem: $(this),
            data: self.settings.dataset[item.attr('aria-posinset') - 1],
            index: item.index(),
            originalEvent: e
          }]);
          return false;
        });

        this.element.off('contextmenu.listview', 'li, tr').on('contextmenu.listview', 'li, tr', function (e) {
          var item = $(this);

          e.preventDefault();
          e.stopPropagation();
          self.element.trigger('contextmenu', [{
            elem: $(this),
            data: self.settings.dataset[item.attr('aria-posinset') - 1],
            index: item.index(),
            originalEvent: e
          }]);
          return false;
        });
      }

      if (!this.settings.hoverable || this.settings.hoverable === 'false') {
        this.element.removeClass('is-selectable');
        this.element.addClass('disable-hover');
      }

      if (!this.settings.selectable || this.settings.selectable === 'false') {
        this.element.removeClass('is-selectable');
        this.element.addClass('disable-hover');
      }

      if (this.settings.selectable === 'multiple' || this.settings.selectable === 'mixed') {
        this.element.off('change.selectable-listview', '.listview-checkbox input').on('change.selectable-listview', '.listview-checkbox input', function (e) {
          $(this).parent().trigger('click');
          e.stopPropagation();
        });
      }

      // For use with Searchfield
      if (this.settings.searchable) {
        this.searchfield.off('contents-checked.searchable-listview').on('contents-checked.searchable-listview', function (e) {
          self.handleSearch(e, $(this));
        });
      }

      // If used with a Pager Control, listen for the end of the page and scroll
      // the Listview to the top
      if (this.element.data('pager')) {
        this.element.off('afterpaging.listview').on('afterpaging.listview', function () {
          self.element.scrollTop(0);
        });
      }

      $('body').off('resize.listview').on('resize.listview', function () {
        self.handleResize();
      });

      // Animate open and Closed from the header
      self.element.prev('.listview-header').off('click.listview').on('click.listview', function () {
        var icon = $(this).find('.plus-minus');
        if (icon.hasClass('active')) {
          icon.removeClass('active');
          self.element.animateClosed();
        } else {
          icon.addClass('active');
          self.element.animateOpen();
        }
      });
    }
  };

  /**
   * jQuery Component Wrapper for ListView
   * @param {object} settings The settings to apply.
   * @returns {jQuery[]} The jquery object for chaining.
   */
  $.fn.listview = function (settings) {
    /**
     * NOTE: Much of this is here for backwards-compatibility reasons.  In the future we need to
     * make sure these enhancements make it to the components.
     */
    var cs = $(this);
    var attr = cs.attr('data-dataset');
    var tmpl = cs.attr('data-tmpl');
    var inlineOpts = utils.parseOptions(this) || {};

    inlineOpts.dataset = inlineOpts.dataset || attr;
    inlineOpts.template = inlineOpts.template || tmpl;

    if (window[inlineOpts.dataset]) {
      inlineOpts.dataset = window[inlineOpts.dataset];
    }

    if (inlineOpts.template && inlineOpts.template.length) {
      inlineOpts.template = $('#' + inlineOpts.template).html();
    }

    var combinedSettings = utils.extend({}, settings, inlineOpts);

    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$L);
      if (instance) {
        instance.updated(combinedSettings);
      } else {
        instance = $.data(this, COMPONENT_NAME$L, new ListView(this, combinedSettings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$M = 'listbuilder';

  /**
   * A list of items with add/remove/delete and sort functionality.
   * @class ListBuilder
   * @constructor
   * @param {jQuery[]|HTMLElement} element The base element.
   * @param {object} [settings] incoming settings.
   *
   * @param {array} [settings.dataset]  Array of data
   * @param {string} [settings.handle]  The CSS Class of the handle element
   * @param {string|jQuery[]} [settings.btnAdd]  "Add" action button (takes a string representing a
   *  "data-action" attribute, or a jQuery-wrapped element reference).
   * @param {string|jQuery[]} [settings.btnEdit]  "Edit" action button (takes a string representing a
   *  "data-action" attribute, or a jQuery-wrapped element reference).
   * @param {string|jQuery[]} [settings.btnDelete]  "Delete" action button (takes a string representing a
   *  "data-action" attribute, or a jQuery-wrapped element reference).
   * @param {string|jQuery[]} [settings.btnGoUp]  "GoUp" action button (takes a string representing a
   *  "data-action" attribute, or a jQuery-wrapped element reference).
   * @param {string|jQuery[]} [settings.btnGoDown]  "GoDown" action button (takes a string representing a
   *  "data-action" attribute, or a jQuery-wrapped element reference).
   * @param {string} [settings.template]  representing HTML content that builds a list
   * @param {string} [settings.templateNewItem]  representing HTML content that builds a single list item
   * @param {string} [settings.templateItemContent]  representing HTML content that replaces the inner content
   *  section of each item.
   */

  var LISTBUILDER_DEFAULTS = {
    dataset: [],
    handle: '.handle',
    btnAdd: 'add',
    btnEdit: 'edit',
    btnDelete: 'delete',
    btnGoUp: 'goup',
    btnGoDown: 'godown',
    template: '' + '<ul data-handle=".handle">' + '{{#dataset}}' + '{{#text}}' + '<li' + '{{#value}} data-value="{{value}}"{{/value}}' + '{{#selected}} selected="selected"{{/selected}}' + '{{#disabled}} class="is-disabled"{{/disabled}}' + '>' + '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>' + '<div class="item-content"><p>{{text}}</p></div>' + '</li>' + '{{/text}}' + '{{/dataset}}' + '</ul>',
    templateNewItem: '' + '<li data-value="{{text}}" role="option">' + '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>' + '<div class="item-content"><p>{{text}}</p></div>' + '</li>',
    templateItemContent: '<p>{{text}}</p>'
  };

  function ListBuilder(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, LISTBUILDER_DEFAULTS);
    if (settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.init();
  }

  // ListBuilder Methods
  ListBuilder.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      var _this = this;

      this.loadListview().initDataset().setElements().handleEvents();

      setTimeout(function () {
        _this.setSelected();
      }, 0);
    },


    /**
     * Load listview
     * @private
     * @returns {this} component instance
     */
    loadListview: function loadListview() {
      var s = this.settings;
      var lv = $('.listview', this.element);

      if (!s.dataset.length && lv.length && $('li', lv).length) {
        this.listApi = lv.listview({ selectable: 'single' }).data('listview');
      } else if (lv.length) {
        this.listApi = lv.listview({ dataset: s.dataset, template: s.template, selectable: 'single' }).data('listview');
      }
      return this;
    },


    /**
     * Initialize dataset
     * @private
     * @returns {this} component instance
     */
    initDataset: function initDataset() {
      var s = this.settings;
      var nodes = $('.listview li', this.element);

      this.dataset = [];
      for (var i = 0, l = nodes.length; i < l; i++) {
        var data = void 0;
        var li = $(nodes[i]);
        if (s.dataset) {
          // Make sure it's not reference pointer to data object, make copy of data
          data = JSON.parse(JSON.stringify(s.dataset[i]));
          data.node = li;
        } else {
          data = this.extractNodeData(li);
        }
        this.dataset.push(data);
      }
      return this;
    },


    /**
     * Extract node data
     * @private
     * @param {jQuery[]} node element to be checked for data
     * @returns {object} data from the node.
     */
    extractNodeData: function extractNodeData(node) {
      var data = { node: node, text: $.trim($('.item-content', node).text()) };
      var value = node.attr('data-value');
      if (typeof value !== 'undefined') {
        data.value = value;
      }
      return data;
    },


    /**
     * Set elements
     * @private
     * @returns {this} component instance
     */
    setElements: function setElements() {
      var _this2 = this;

      var s = this.settings;

      // Action buttons
      var setAction = function setAction(selector) {
        if (_this2.isjQuery(selector)) {
          return selector;
        } else if (typeof selector === 'string') {
          return $('[data-action="' + selector + '"]', _this2.element);
        }
        return null;
      };
      s.btnAdd = setAction(s.btnAdd);
      s.btnGoUp = setAction(s.btnGoUp);
      s.btnGoDown = setAction(s.btnGoDown);
      s.btnEdit = setAction(s.btnEdit);
      s.btnDelete = setAction(s.btnDelete);

      // Init tooltips
      this.topButtons = s.btnAdd.add(s.btnGoUp).add(s.btnGoDown).add(s.btnEdit).add(s.btnDelete);
      this.topButtons.tooltip();

      // Make Draggable
      this.ul = $('.listview ul', this.element);
      this.arrangeApi = this.ul.arrange({
        handle: s.handle,
        placeholder: s.templateNewItem
      }).data('arrange');

      return this;
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this3 = this;

      var data = void 0;
      var self = this;
      var s = self.settings;

      // TOP BUTTONS =============================================================
      var topButtonsClick = function topButtonsClick(btn, method) {
        btn.off('click.listbuilder').on('click.listbuilder', function () {
          self[method]();
        });
      };
      topButtonsClick(s.btnAdd, 'addItem');
      topButtonsClick(s.btnGoUp, 'moveItemUp');
      topButtonsClick(s.btnGoDown, 'moveItemDown');
      topButtonsClick(s.btnEdit, 'editItem');
      topButtonsClick(s.btnDelete, 'deleteItem');

      // DRAGGABLE ===============================================================
      this.arrangeApi.element.on('beforearrange.listbuilder', function (e, status) {
        var d = _this3.getDataByNode(status.start);
        var str = s.templateItemContent.replace(/{{text}}/g, d.data.text);

        _this3.arrangeApi.placeholders.attr('data-value', d.data.text).find('.item-content').html(str);
      }).on('arrangeupdate.listbuilder', function (e, status) {
        _this3.updateAttributes();
        _this3.arrayIndexMove(_this3.dataset, status.startIndex, status.endIndex);
        data = _this3.getDataByNode(status.end);
        data.indexBeforeMove = status.startIndex;
        _this3.element.triggerHandler('arrangeupdate', [data]);
      });

      $('li:not(.is-disabled) ' + this.arrangeApi.handle, this.ul).on('mousedown.listbuilder touchstart.listbuilder', function () {
        var li = $(this);
        if (!li.is('.is-selected')) {
          li.trigger('click');
        }
      });

      $('.listview', this.element).off('selected.listbuilder').on('selected.listbuilder', function (e, args) {
        data = _this3.getDataByNode(args.elem[0]);

        /**
         * Fires when a item is selected.
         * @event selected
         * @memberof ListBuilder
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} data - Data for this selected item
         */
        _this3.element.triggerHandler('selected', [data]);
      });

      this.updatedEventsStr = 'arrangeupdate.listbuilder aftergoup.listbuilder aftergodown.listbuilder exiteditmode.listbuilder';
      this.element.off(this.updatedEventsStr).on(this.updatedEventsStr, function (e, updatedData) {
        /**
         * Fires when a item is updated.
         * @event updated
         * @memberof ListBuilder
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} data - Data for this item
         */
        _this3.element.triggerHandler('updated', [updatedData]);
      });

      return this;
    },
    // END: Handle Events -----------------------------------------------------

    /**
     * Add an item into edit mode.
     * @private
     * @returns {void}
     */
    addItem: function addItem() {
      var self = this;
      var s = this.settings;

      /**
       * Fires before add new item.
       *
       * @event beforeadd
       * @memberof ListBuilder
       * @type {object}
       * @property {object} event - The jquery event object
       */
      $.when(this.element.triggerHandler('beforeadd')).done(function () {
        var li = void 0;
        var data = void 0;
        var index = 0;

        var node = self.listApi.selectedItems[0];
        var str = s.templateNewItem.replace(/{{text}}/g, Locale.translate('NewItem'));

        if (node && node.length > 0) {
          data = self.getDataByNode(node);
          index = data.index + 1;
          $(str).insertAfter(node);
          li = $('li', self.ul).eq(index);
        } else {
          self.ul.prepend(str);
          li = $('li:first-child', self.ul);
        }

        self.dataset.push(self.extractNodeData(li));
        self.arrayIndexMove(self.dataset, self.dataset.length - 1, index);
        self.updateAttributes();
        li.trigger('click');
        self.arrangeApi.updated();
        self.editItem(true);

        data = { index: index, data: self.dataset[index] };

        /**
         * Fires after add new item.
         * @event afteradd
         * @memberof ListBuilder
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} data - Data for this new item
         */
        self.element.triggerHandler('afteradd', [data]);
      });
    },


    /**
     * Move the currently selected item up.
     * @private
     * @returns {void}
     */
    moveItemUp: function moveItemUp() {
      var self = this;
      var node = self.listApi.selectedItems[0];

      if (node && node.length > 0) {
        var data = self.getDataByNode(node);
        if (typeof data.index !== 'undefined' && data.index > 0) {
          /**
           * Fires before move up item.
           * @event beforegoup
           * @memberof ListBuilder
           * @type {object}
           * @property {object} event - The jquery event object
           * @property {object} data - Data for this item
           */
          $.when(self.element.triggerHandler('beforegoup', [data])).done(function () {
            var prev = node.prev();
            node.insertBefore(prev);
            self.updateAttributes();
            self.arrayIndexMove(self.dataset, data.index, data.index - 1);
            data.indexBeforeMove = data.index;
            data.index--;

            /**
             * Fires after move up item.
             * @event aftergoup
             * @memberof ListBuilder
             * @type {object}
             * @property {object} event - The jquery event object
             * @property {object} data - Data for this item
             */
            self.element.triggerHandler('aftergoup', [data]);
          });
        }
      }
    },


    /**
     * Move the currently selected item down.
     * @private
     * @returns {void}
     */
    moveItemDown: function moveItemDown() {
      var self = this;
      var node = self.listApi.selectedItems[0];
      if (node && node.length > 0) {
        var data = self.getDataByNode(node);
        if (typeof data.index !== 'undefined' && data.index < self.dataset.length - 1) {
          /**
           * Fires before move down item.
           * @event beforegodown
           * @memberof ListBuilder
           * @type {object}
           * @property {object} event - The jquery event object
           * @property {object} data - Data for this item
           */
          $.when(self.element.triggerHandler('beforegodown', [data])).done(function () {
            var next = node.next();
            node.insertAfter(next);
            self.updateAttributes();
            self.arrayIndexMove(self.dataset, data.index, data.index + 1);
            data.indexBeforeMove = data.index;
            data.index++;

            /**
             * Fires after move down item.
             * @event aftergodown
             * @memberof ListBuilder
             * @type {object}
             * @property {object} event - The jquery event object
             * @property {object} data - Data for this item
             */
            self.element.triggerHandler('aftergodown', [data]);
          });
        }
      }
    },


    /**
     * Edit the selected item
     * @private
     * @param {boolean} isNewItem  Is it a newly added item?
     * @returns {void}
     */
    editItem: function editItem(isNewItem) {
      var node = this.listApi.selectedItems[0];
      if (node && node.length > 0) {
        if (node.is('.is-editing')) {
          this.commitEdit(node, isNewItem);
        } else {
          this.makeEditable(node, isNewItem);
        }
      }
    },


    /**
     * Make the node editable
     * @private
     * @param {object} node  The HTML element to edit
     * @param {boolean} isNewItem  Is it a newly added item?
     * @returns {void}
     */
    makeEditable: function makeEditable(node, isNewItem) {
      var self = this;
      var data = self.getDataByNode(node);
      var container = $('.item-content', node);

      if (typeof data.index !== 'undefined' && data.index < self.dataset.length) {
        /**
         * Fires before edit item.
         * @event beforeedit
         * @memberof ListBuilder
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} data - Data for this item
         */
        $.when(self.element.triggerHandler('beforeedit', [data])).done(function () {
          var origValue = container.text().trim();
          var editInput = $('<input name="edit-input" class="edit-input" type="text" value="' + origValue + '" />');

          node.addClass('is-editing');
          container.html(editInput);
          editInput.focus().select();

          editInput.on('click.listbuilder', function () {
            return false;
          }).on('blur.listbuilder', function () {
            return self.commitEdit(node, isNewItem);
          }).on('keypress.listbuilder', function (e) {
            var key = e.keyCode || e.charCode || 0;
            if (key === 13) {
              self.commitEdit(node, isNewItem);
              node.focus();
            }
          });

          /**
           * Fires when enter to edit mode.
           * @event entereditmode
           * @memberof ListBuilder
           * @type {object}
           * @property {object} event - The jquery event object
           * @property {object} data - Data for this item
           */
          self.element.triggerHandler('entereditmode', [data]);
        });
      }
    },


    /**
     * Commit the changes to item.
     * @private
     * @param {object} node  The HTML element to commit changes
     * @param {boolean} isNewItem  Is it a newly added item?
     * @returns {void}
     */
    commitEdit: function commitEdit(node, isNewItem) {
      var s = this.settings;
      var data = this.getDataByNode(node);
      var container = $('.item-content', node);
      var editInput = $('.edit-input', container);

      if (isNewItem) {
        data.data.value = editInput.val();
      }
      data.data.text = editInput.val();
      editInput.off('click.listbuilder blur.listbuilder keypress.listbuilder');
      container.html(s.templateItemContent.replace(/{{text}}/g, editInput.val()));
      node.removeClass('is-editing');

      /**
       * Fires when exited to edit mode.
       * @event exiteditmode
       * @memberof ListBuilder
       * @type {object}
       * @property {object} event - The jquery event object
       * @property {object} data - Data for this item
       */
      this.element.triggerHandler('exiteditmode', [data]);
    },


    /**
     * Delete the selected item.
     * @private
     * @returns {void}
     */
    deleteItem: function deleteItem() {
      var self = this;
      var node = self.listApi.selectedItems[0];
      if (node && node.length > 0) {
        var data = self.getDataByNode(node);
        if (typeof data.index !== 'undefined') {
          /**
           * Fires before delete item.
           * @event beforedelete
           * @memberof ListBuilder
           * @type {object}
           * @property {object} event - The jquery event object
           * @property {object} data - Data for this item
           */
          $.when(self.element.triggerHandler('beforedelete', [data])).done(function () {
            self.listApi.removeAllSelected();
            self.updateAttributes();
            self.dataset.splice(data.index, 1);

            /**
             * Fires after delete item.
             * @event afterdelete
             * @memberof ListBuilder
             * @type {object}
             * @property {object} event - The jquery event object
             * @property {object} data - Data for this item
             */
            self.element.triggerHandler('afterdelete', [data]);
          });
        }
      }
    },


    /**
     * Get data from dataset by node
     * @param {jQuery[]} node  The HTML element to get data
     * @returns {object} node data
     */
    getDataByNode: function getDataByNode(node) {
      var data = {};
      for (var i = 0, l = this.dataset.length; i < l; i++) {
        var d = this.dataset[i];
        if ($(d.node).is(node)) {
          data = { index: i, data: d };
          break;
        }
      }
      return data;
    },


    /**
     * Move an array element position
     * @private
     * @param {array} arr .
     * @param {number} from .
     * @param {number} to .
     * @returns {void}
     */
    arrayIndexMove: function arrayIndexMove(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
    },


    /**
     * Check if given object is a jQuery object
     * @private
     * @param {object} obj .
     * @returns {boolean} true if jQuery
     */
    isjQuery: function isjQuery(obj) {
      return obj && (obj instanceof jQuery || obj.constructor.prototype.jquery);
    },


    /**
     * Move cursor to end
     * http://stackoverflow.com/a/26900921
     * @private
     * @param {object} el as element.
     * @returns {void}
     */
    moveCursorToEnd: function moveCursorToEnd(el) {
      setTimeout(function () {
        if (typeof el.selectionStart === 'number') {
          el.selectionEnd = el.value.length;
          el.selectionStart = el.value.length;
        } else if (typeof el.createTextRange !== 'undefined') {
          var range = el.createTextRange();
          range.collapse(false);
          range.select();
        }
      }, 100);
    },


    /**
     * Update attributes
     * @private
     * @returns {void}
     */
    updateAttributes: function updateAttributes() {
      var nodes = $('li', this.ul);

      for (var i = 0, l = nodes.length; i < l; i++) {
        $(nodes[i]).attr({ 'aria-posinset': i + 1, 'aria-setsize': l });
      }
    },


    /**
     * Update dataset
     * @private
     * @param {object} ds as dataset.
     * @returns {void}
     */
    updateDataset: function updateDataset(ds) {
      var _this4 = this;

      var nodes = $('li', this.ul);
      var lv = $('.listview', this.element).data('listview');

      lv.deselectItemsBetweenIndexes([0, nodes.length - 1]);
      this.settings.dataset = ds;
      lv.loadData(this.settings.dataset);

      this.initDataset().setElements().handleEvents();

      setTimeout(function () {
        _this4.setSelected();
      }, 0);
    },


    /**
     * Set pre selected items
     * @private
     * @returns {object} this api
     */
    setSelected: function setSelected() {
      var nodes = $('li[selected]', this.ul);
      for (var i = 0, l = nodes.length; i < l; i++) {
        var li = $(nodes[i]);
        li.removeAttr('selected');
        if (!li.is('.is-selected')) {
          li.trigger('click');
        }
      }
      return this;
    },


    /**
     * Make selected
     * @private
     * @param {object} selector .
     * @returns {void}
     */
    select: function select(selector) {
      var li = this.getListItem(selector);

      if (li && !li.is('.is-selected')) {
        li.trigger('click');
      }
    },


    /**
     * Make unselected
     * @private
     * @param {object} selector .
     * @returns {void}
     */
    unselect: function unselect(selector) {
      var li = this.getListItem(selector);

      if (li && li.is('.is-selected')) {
        li.trigger('click');
      }
    },


    /**
     * Get an item from list, selector: can be
     * jQuery, DOM element, zero based index or 'first'|'last' as string
     * @private
     * @param {object} selector .
     * @returns {object} item node
     */
    getListItem: function getListItem(selector) {
      var li = $();
      if (this.isElement(selector) && $.contains(this.ul, selector)) {
        li = this.isjQuery(selector) ? selector : $(selector);
      } else {
        var idx = parseInt(selector, 10);
        var items = $('li', this.ul);
        if (!isNaN(idx) && idx > -1 && idx < items.length) {
          li = items.eq(idx); // zero based index
        } else if (('' + selector).toLowerCase() === 'first') {
          li = items.first(); // first
        } else if (('' + selector).toLowerCase() === 'last') {
          li = items.last(); // last
        }
      }
      // Make sure to return only one item -or- null
      if (li.length < 1) {
        return null;
      } else if (li.length > 1) {
        return li.eq(0);
      }
      return li;
    },


    /**
     * Check if given object is a DOM object
     * @private
     * @param {object} obj .
     * @returns {object} item node
     */
    isElement: function isElement(obj) {
      /* global Element */
      return this.isjQuery(obj) && obj.get(0) instanceof Element || obj instanceof Element;
    },


    /**
     * Make enable.
     * @returns {void}
     */
    enable: function enable() {
      this.element.removeClass('is-disabled').find('.toolbar .buttonset button').removeAttr('disabled').end().find('.toolbar .buttonset button[data-original-disabled]').attr('disabled', 'disabled').removeAttr('data-original-disabled');

      this.ul.find('li').removeClass('is-disabled').end().find('li[data-original-disabled]').addClass('is-disabled').removeAttr('data-original-disabled');
    },


    /**
     * Make disable.
     * @returns {void}
     */
    disable: function disable() {
      this.element.addClass('is-disabled').find('.toolbar .buttonset button[disabled]').attr('data-original-disabled', 'disabled').end().find('.toolbar .buttonset button').attr('disabled', 'disabled');

      this.ul.find('li.is-disabled').attr('data-original-disabled', 'is-disabled').end().find('li').addClass('is-disabled');
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {this} component instance
     */
    unbind: function unbind() {
      this.element.off(this.updatedEventsStr);
      $('.listview', this.element).off('selected.listbuilder');

      $('li ' + this.arrangeApi.handle, this.ul).off('mousedown.listbuilder touchstart.listbuilder');

      this.arrangeApi.element.off('beforearrange.listbuilder arrangeupdate.listbuilder').destroy();

      this.topButtons.off('click.listbuilder');
      if (this.topButtons) {
        for (var i = 0, l = this.topButtons.length; i < l; i++) {
          var tooltipApi = $(this.topButtons[i]).data('tooltip');
          if (tooltipApi && typeof tooltipApi.destroy === 'function') {
            tooltipApi.destroy();
          }
        }
      }

      if (this.listApi && typeof this.listApi.destroy === 'function') {
        this.listApi.destroy();
      }

      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} [settings] incoming settings.
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, LISTBUILDER_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Teardown process for this plugin
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$M);
    }
  };

  /**
   * jQuery Component Wrapper for ListBuilder
   * @param {object} settings The settings to apply.
   * @returns {jQuery[]} The jquery object for chaining.
   */
  $.fn.listbuilder = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$M);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$M, new ListBuilder(this, settings));
      }
    });
  };

  // The name of this component.
  var COMPONENT_NAME$N = 'modal';

  /**
  * Responsive and Accessible Modal Control
  * @class Modal
  * @param {string} element The component element.
  * @param {string} settings The component settings.
  *
  * @param {string} [settings.trigger='click'] The method of opening the dialog. Supports click, immediate.
  * @param {array} [settings.buttons=null]  A list of buttons that will sit in the toolbar's Buttonset area.
  * @param {isAlert} [settings.isAlert=false] Adds alertdialog role for message dialogs.
  * @param {content} [settings.content=null] Ability to pass in dialog html content.
  * @param {string} [settings.cssClass=null] Append a css class to top level.
  * @param {boolean} [settings.autoFocus=true] If true the first input will be focused.
  * @param {string} [settings.id=null] Optionally tag a dialog with an id.
  * @param {number} [settings.frameHeight=180] Optional extra height to add.
  * @param {number} [settings.frameWidth=46] Optional extra width to add.
  * @param {function} [settings.beforeShow=null] A call back function that can be used to return data for the modal.
  * @param {boolean} [settings.useFlexToolbar] If true the new flex toolbar will be used (For CAP)
  * @param {boolean} [settings.showCloseBtn] If true, show a close icon button on the top right of the modal.
  * return the markup in the response and this will be shown in the modal. The busy indicator will be shown while waiting for a response.
  */
  var MODAL_DEFAULTS = {
    trigger: 'click',
    buttons: null,
    isAlert: false,
    content: null,
    cssClass: null,
    autoFocus: true,
    id: null,
    frameHeight: 180,
    frameWidth: 46,
    beforeShow: null,
    useFlexToolbar: false,
    showCloseBtn: false
  };

  function Modal(element, settings) {
    this.settings = utils.mergeSettings(element, settings, MODAL_DEFAULTS);
    this.element = $(element);
    this.init();
    this.reStructure();
  }

  // Actual Plugin Code
  Modal.prototype = {

    /**
     * @private
     * @returns {boolean} whether or not the Modal is a Contextual Action Panel (CAP)
     */
    get isCAP() {
      return this.element.is('.contextual-action-panel');
    },

    init: function init() {
      var self = this;

      // Used for tracking events tied to the Window object
      this.id = this.element.attr('id') || parseInt($('.modal').length, 10) + 1;
      // Find the button or anchor with same dialog ID
      this.trigger = $('button[data-modal="' + this.element.attr('id') + '"], a[data-modal="' + this.element.attr('id') + '"]');
      this.overlay = $('<div class="overlay"></div>');
      this.oldActive = this.trigger;

      if (this.settings.trigger === 'click') {
        this.trigger.on('click.modal', function () {
          self.open();
        });
      }

      if (this.settings.trigger === 'immediate') {
        setTimeout(function () {
          self.open();
        }, 1);
      }

      self.isCancelled = false;

      if (window.history && window.history.pushState) {
        $(window).off('popstate.modal');

        $(window).on('popstate.modal', function () {
          self.destroy();
        });
      }

      // ensure is appended to body for new dom tree
      if (this.settings.content) {
        this.settings.trigger = this.settings.content instanceof jQuery ? this.settings.trigger : 'immediate';
        this.appendContent();
        setTimeout(function () {
          self.open();
        }, 1);
        return;
      }

      if (this.settings.beforeShow) {
        this.settings.trigger = this.settings.content instanceof jQuery ? this.settings.trigger : 'immediate';
        this.appendContent();
        this.callSource();
        return;
      }

      self.addButtons(this.settings.buttons);
      this.element.appendTo('body');
      this.element[0].style.display = 'none';
    },
    appendContent: function appendContent() {
      var _this = this;

      var isAppended = false;

      this.element = $('' + ('<div class="modal">' + '<div class="modal-content">' + '<div class="modal-header"><h1 class="modal-title">') + this.settings.title + '</h1></div>' + '<div class="modal-body-wrapper">' + '<div class="modal-body"></div>' + '</div>' + '</div>' + '</div>');

      if (this.settings.showCloseBtn) {
        var closeBtn = $('\n        <button type="button" class="btn-icon btn-close" title="' + Locale.translate('Close') + '" aria-hidden="true">\n          ' + $.createIcon('close') + '\n          <span class="audible">' + Locale.translate('Close') + '</span>\n        </button>\n      ');
        this.element.find('.modal-content').append(closeBtn);
        closeBtn.on('click.modal', function () {
          return _this.close();
        }).tooltip();
      }

      if (this.settings.id) {
        this.element.attr('id', this.settings.id);
      }

      if ($(this.settings.content).is('.modal')) {
        this.element = $(this.settings.content);
      } else if (this.settings.content && this.settings.content.length > 0) {
        if (this.settings.content instanceof jQuery && this.settings.content.parent().is('.modal-body')) {
          isAppended = true;
          this.element = this.settings.content.closest('.modal');
        } else {
          this.element.find('.modal-body').append(this.settings.content);
        }

        if (this.settings.content instanceof jQuery && !this.settings.beforeShow) {
          this.settings.content.removeClass('hidden is-hidden');
          this.settings.content.show();
        }
      }

      if (this.settings.beforeShow) {
        this.busyIndicator = $('<div class="overlay busy"></div>' + '<div class="busy-indicator-container blocked-ui" aria-live="polite" role="status">' + '<div class="busy-indicator active">' + '<div class="bar one"></div>' + '<div class="bar two"></div>' + '<div class="bar three"></div>' + '<div class="bar four"></div>' + '<div class="bar five"></div>' + '</div>' + '<span>Loading...</span>' + '</div>');
        $('body').append(this.busyIndicator);
      }

      if (!isAppended) {
        this.element.appendTo('body');
      }

      if (this.settings.cssClass) {
        this.element.addClass(this.settings.cssClass);
      }

      if (this.settings.title) {
        this.element.find('.modal-title').text(this.settings.title);
      }

      if (!isAppended) {
        this.addButtons(this.settings.buttons);
      }

      utils.fixSVGIcons(this.element);
    },
    reStructure: function reStructure() {
      var body = $('.modal-body', this.element);
      var hr = $('hr:first-child', body);
      var buttonset = $('.modal-buttonset', this.element);

      if (body && body.length && !body.parent().hasClass('modal-body-wrapper')) {
        body.wrap('<div class="modal-body-wrapper"></div>');
      }
      if (hr && hr.length && !hr.parent().hasClass('modal-content')) {
        hr.insertAfter(this.element.find('.modal-header'));
      }
      if (buttonset && buttonset.length && !buttonset.parent().hasClass('modal-content')) {
        buttonset.insertAfter(this.element.find('.modal-body-wrapper'));
      }
    },


    /**
     * Check if the submit button should be disabled based on validation status.
     * @private
     * @returns {void}
     */
    disableSubmit: function disableSubmit() {
      var body = this.element;
      var fields = body.find('[data-validate]:visible');
      var inlineBtns = body.find('.modal-buttonset button');
      var primaryButton = inlineBtns.filter('.btn-modal-primary').not('.no-validation');

      if (fields.length > 0) {
        primaryButton.removeAttr('disabled');

        var allValid = true;
        fields.each(function () {
          var field = $(this);
          if (field.closest('.datagrid-filter-wrapper').length > 0) {
            return;
          }

          var isVisible = field[0].offsetParent !== null;

          if (field.is('.required')) {
            if (isVisible && !field.val()) {
              allValid = false;
            }
          } else {
            field.validateField();
            if (isVisible && !field.isValid()) {
              allValid = false;
            }
          }

          if (allValid) {
            primaryButton.removeAttr('disabled');
          }
        });

        if (!allValid && !primaryButton.is(':disabled')) {
          primaryButton.attr('disabled', 'true');
        }
      }
    },
    addButtons: function addButtons(buttons) {
      var self = this;
      var body = this.element.find('.modal-body');
      var bodywrapper = body.parent();
      var flexToolbar = this.element.find('.flex-toolbar');
      var btnWidth = 100;
      var isPanel = false;
      var buttonset = void 0;

      this.modalButtons = buttons;

      if (!buttons) {
        var inlineBtns = this.element.find('.modal-buttonset button');

        // Buttons in markup
        btnWidth = 100 / inlineBtns.length;
        for (var i = 0, l = inlineBtns.length; i < l; i++) {
          inlineBtns[i].style.width = btnWidth + '%';
        }
        inlineBtns.button();
        inlineBtns.not('[data-ng-click], [ng-click], [onclick], :submit').on('click.modal', function (e) {
          if ($(e.target).is('.btn-cancel')) {
            self.isCancelled = true;
          }
          self.close();
        });
        return;
      }

      if (this.isCAP) {
        // CAP is responsible for rendering this part, and will have done so by the
        // time this code runs
        isPanel = true;
        buttonset = this.element.find('.buttonset');
      } else {
        buttonset = this.element.find('.modal-buttonset');
        if (!buttonset.length) {
          buttonset = $('<div class="modal-buttonset"></div>').insertAfter(bodywrapper);
        }
      }

      btnWidth = 100 / buttons.length;

      if (buttons) {
        buttonset.empty();
      }

      var decorateButtons = function decorateButtons(props, cnt) {
        var btn = $('<button type="button">\n        <span></span>\n      </button>');
        var span = btn.find('span');

        span.text(props.text);
        btn.attr('type', props.type || 'button');

        if (props.cssClass === 'separator') {
          btn = $('<div class="separator"></div>');
        }

        if (props.cssClass) {
          btn.attr('class', props.cssClass);
        } else if (props.isDefault) {
          btn.addClass('btn-modal-primary');
        } else {
          btn.addClass('btn-modal');
        }

        if (props.audible) {
          span.addClass('audible');
        }

        if (props.validate !== undefined && !props.validate) {
          btn.addClass('no-validation');
        }

        var attrs = {};
        var attrTypes = ['id', 'name', 'text'];

        for (var k = 0; k < attrTypes.length; k++) {
          if (props[attrTypes[k]]) {
            attrs[attrTypes[k]] = props[attrTypes[k]];
          }
        }

        if (props.type === 'input') {
          var label = $('<label class="audible" for="filter">' + props.text + '</label>');
          var input = $('<input class="searchfield">').attr(attrs);

          if (flexToolbar.length) {
            flexToolbar.find('.toolbar-section.search').append(label, input);
          } else {
            buttonset.append(label, input);
          }
          input.searchfield(props.searchfieldSettings);
          return;
        }

        if (props.icon && props.icon.charAt(0) === '#') {
          $.createIconElement({
            classes: [props.icon === '#icon-close' ? 'icon-close' : ''],
            icon: props.icon.substr('#icon-'.length)
          }).prependTo(btn);
        }

        btn[0].setAttribute('id', props.id || utils.uniqueId(self.element, 'button', 'modal'));

        var func = buttons[cnt].click;

        btn.on('click.modal', function (e) {
          if (func) {
            func.apply(self.element[0], [e, self]);
            return;
          }
          self.close();
        });

        if (!isPanel) {
          btn[0].style.width = btnWidth + '%';
        }

        btn.button();

        if ((self.settings.useFlexToolbar || self.settings.centerTitle) && props.align) {
          if (props.align === 'left') {
            flexToolbar.find('.toolbar-section').eq(0).append(btn);
          }

          if (props.align === 'center') {
            flexToolbar.find('.toolbar-section').eq(1).find('h2').append(btn);
          }

          if (props.align === 'right') {
            flexToolbar.find('.toolbar-section').eq(2).append(btn);
          }
        } else {
          buttonset.append(btn);
        }
      };

      for (var cnt = 0; cnt < buttons.length; cnt++) {
        decorateButtons(buttons[cnt], cnt);
      }
    },


    /**
    * Size the inner content on resize.
    * @private
    * @returns {void}
    */
    sizeInner: function sizeInner() {
      var messageArea = this.element.find('.detailed-message');
      // Set a max width
      var h = $(window).height() - messageArea.offset().top - 150;
      messageArea[0].style.maxHeight = h + 'px';
      messageArea[0].style.overflow = 'auto';
      messageArea[0].style.width = messageArea.width() + 'px';
    },
    callSource: function callSource() {
      if (typeof this.settings.beforeShow !== 'function') {
        return;
      }

      var self = this;
      var response = function response(content) {
        if (content === false) {
          return false;
        }

        $('#modal-busyindicator').trigger('complete.busyindicator');

        // Returning `true` from the response will cause a modal area to render to the page,
        // but remain hidden.  In this scenario it will be up to the app developer to reveal
        // the modal when needed.
        if (content === true) {
          if (self.busyIndicator) {
            self.busyIndicator.remove();
            delete self.busyIndicator;
          }

          return true;
        }

        if (!(content instanceof jQuery)) {
          content = $(content);
        }

        self.open(true);

        self.element.find('.modal-body').empty();
        self.element.find('.modal-body').append(content);

        content.show();

        return true;
      };

      var callBackOpts = {};
      this.settings.beforeShow(response, callBackOpts);
    },


    /**
     * Open the modal via the api.
     * @param {boolean} ajaxReturn Flag used internally to denote its an ajax result return.
     */
    open: function open(ajaxReturn) {
      var _this2 = this;

      var messageArea = null;
      var elemCanOpen = true;

      if (this.busyIndicator) {
        this.busyIndicator.remove();
        delete this.busyIndicator;
      }

      if (!this.trigger || this.trigger.length === 0) {
        this.oldActive = $(':focus'); // Save and restore focus for A11Y
      }

      this.element.after(this.overlay);
      if (this.element && !this.element.parent().hasClass('modal-wrapper')) {
        this.element.wrap('<div class="modal-page-container"><div class="modal-wrapper"></div>');
      }
      this.root = this.element.closest('.modal-page-container');

      messageArea = this.element.find('.detailed-message');
      if (messageArea.length === 1) {
        $('body').on('resize.modal-' + this.id, function () {
          _this2.sizeInner();
        });
        this.sizeInner();
      }

      /**
      * Fires when the modal is about to open. You can return false to abort opening.
      * @event beforeopen
      * @memberof Modal
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */
      elemCanOpen = this.element.triggerHandler('beforeopen', [this]);
      $('body').triggerHandler('beforeopen', [this]);
      this.isCancelled = false;

      if (elemCanOpen === false) {
        this.overlay.remove();
        this.root[0].style.display = 'none';
        return;
      }

      if (!ajaxReturn) {
        this.callSource();

        if (this.settings.beforeShow) {
          return;
        }
      }

      // Look for other nested dialogs and adjust the zindex.
      $('.modal').each(function (i) {
        var modal = $(this);
        this.style.zIndex = (1020 + (i + 1)).toString();

        if (modal.data('modal') && modal.data('modal').overlay) {
          modal.data('modal').overlay[0].style.zIndex = (1020 + i).toString();
        }

        if (!modal.data('modal')) {
          var overlay = modal.closest('.modal-page-container').next('.overlay');
          if (overlay && overlay[0]) {
            overlay[0].style.zIndex = (1020 + i).toString();
          }
        }
      });

      $('body > *').not(this.element).not('.modal, .overlay, .modal-page-container').attr('aria-hidden', 'true');

      // Ensure aria-labelled by points to the id
      if (this.settings.isAlert) {
        this.element.attr('aria-labelledby', 'message-title');
        this.element.attr('aria-describedby', 'message-text');
      } else {
        var h1 = this.element.find('h1:first');
        var id = h1.attr('id');

        if (!id) {
          id = (this.element.attr('id') ? this.element.attr('id') : 'h1') + '-title';
          h1.attr('id', id);
        }

        var body = this.element.find('.modal-body');
        var descById = (this.element.attr('id') ? this.element.attr('id') : 'message') + '-text';

        this.element.attr('aria-labelledby', id);

        // Contextual Action Panel Case - Has a toolbar
        if (this.element.find('.toolbar .title').length) {
          this.element.find('.toolbar .title').attr('id', descById);
          this.element.attr('aria-describedby', descById);
        } else {
          body.attr('id', descById);
          this.element.attr('aria-describedby', descById);
        }
      }

      this.mainContent = $('body').children('.scrollable-container');
      if (!this.mainContent.length) {
        this.mainContent = $('body');
      }

      this.removeNoScroll = !this.mainContent.hasClass('no-scroll');
      this.mainContent.addClass('no-scroll');

      $('body').on('resize.modal-' + this.id, function () {
        _this2.resize();
      });
      this.resize();

      // Center
      this.root[0].style.display = '';
      this.element[0].style.display = '';

      setTimeout(function () {
        _this2.resize();
        _this2.element.addClass('is-visible').attr('role', _this2.settings.isAlert ? 'alertdialog' : 'dialog');
        _this2.root.attr('aria-hidden', 'false');
        _this2.overlay.attr('aria-hidden', 'true');
        _this2.element.attr('aria-modal', 'true'); // This is a forward thinking approach, since aria-modal isn't actually supported by browsers or ATs yet
      }, 1);

      // Add the 'modal-engaged' class after all the HTML markup and CSS classes have a
      // chance to be established
      // (Fixes an issue in non-V8 browsers (FF, IE) where animation doesn't work correctly).
      // http://stackoverflow.com/questions/12088819/css-transitions-on-new-elements
      $('body').addClass('modal-engaged');

      // Handle Default button.
      $(this.element).on('keypress.modal', function (e) {
        var target = $(e.target);

        if (target.is('.editor, .searchfield, textarea, :button') || target.closest('.tab-list').length || $('#dropdown-list').length) {
          return;
        }

        if (e.which === 13 && _this2.isOnTop() && !target.closest('form').find(':submit').length && _this2.element.find('.btn-modal-primary:enabled').length) {
          e.stopPropagation();
          e.preventDefault();

          if (!target.hasClass('fileupload') && !$(target).is(':input') || target.hasClass('colorpicker')) {
            _this2.element.find('.btn-modal-primary:enabled').trigger('click');
          }
        }
      });

      // Override this page's skip-link default functionality to instead focus the top
      // of this element if it's clicked.
      $('.skip-link').on('focus.modal', function (e) {
        e.preventDefault();
        _this2.getTabbableElements().first.focus();
      });

      function focusElement(self) {
        var focusElem = self.element.find(':focusable').not('.modal-header .searchfield').first();
        self.keepFocus();

        /**
        * Fires when the modal opens.
        * @event open
        * @memberof Modal
        * @property {object} event - The jquery event object
        * @property {object} ui - The dialog object
        */
        self.element.trigger('open', [self]);

        if (focusElem.length === 0) {
          focusElem = self.element.find('.btn-modal-primary');
        }

        if (focusElem.length === 1 && focusElem.is('.btn-modal')) {
          focusElem = self.element.find('.btn-modal-primary');
        }

        if (focusElem.length === 1 && focusElem.is('button') && !focusElem.is(':disabled')) {
          focusElem.addClass('hide-focus');
        }

        if (!self.settings.autoFocus) {
          return;
        }

        // If the selected element is a tab, actually make sure it's the "selected" tab.
        var selected = void 0;
        var tabParent = void 0;

        if (focusElem.is('.tab:not(.is-selected) a')) {
          tabParent = focusElem.closest('.tab-container');
          selected = tabParent.find('.is-selected');
          if (selected.length) {
            focusElem = selected;
            tabParent.data('tabs').select(selected.children('a').attr('href'));
            return;
          }
        }

        // Otherwise, just focus
        focusElem.focus();
      }

      var pagerElem = this.element.find('.paginated');
      pagerElem.on('afterpaging', function () {
        _this2.resize();
      });

      setTimeout(function () {
        _this2.disableSubmit();
      }, 10);

      var fields = this.element.find('[data-validate]');
      fields.removeClass('disable-validation');

      setTimeout(function () {
        focusElement(_this2);
      }, 200);

      /**
      * Fires after the modal has opened.
      * @event afteropen
      * @memberof Modal
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */
      setTimeout(function () {
        _this2.element.trigger('afteropen');
      }, 300);
    },
    resize: function resize() {
      // 90% -(180 :extra elements-height)
      var calcHeight = $(window).height() * 0.9 - this.settings.frameHeight;
      var calcWidth = $(window).width() * 1 - this.settings.frameWidth;

      var wrapper = this.element.find('.modal-body-wrapper');

      // Remove width for backwards compat
      this.element.find('.modal-contents').css('width', '');

      if (wrapper.length) {
        wrapper[0].style.maxHeight = calcHeight + 'px';
        wrapper[0].style.maxWidth = calcWidth + 'px';
      }

      if (this.element.hasClass('lookup-modal')) {
        var table = this.element.find('.datagrid-body');
        var hasPager = this.element.find('.pager-toolbar');
        var container = table.closest('.datagrid-container');

        calcHeight = calcHeight - (container.prev().is('.toolbar') ? 130 : 60) - (container.next().is('.pager-toolbar') ? 35 : 0);
        table[0].style.maxHeight = calcHeight + (hasPager.length ? -15 : 0) + 'px';
        table[0].style.maxWidth = calcWidth + 'px';
      }

      var toolbars = this.element.find('.toolbar');
      if (toolbars.length) {
        toolbars.triggerHandler('recalculate-buttons');
      }
    },


    /**
     * Utility function to check via the api if the modal is open.
     * @returns {boolean} The current state open (true) or closed (false).
     */
    isOpen: function isOpen() {
      return this.element.is('.is-visible');
    },
    isOnTop: function isOnTop() {
      var max = 0;
      var dialog = this.element;

      $('.modal.is-visible').each(function () {
        if (max < this.style.zIndex) {
          max = this.style.zIndex;
        }
      });

      return max === dialog[0].style.zIndex;
    },
    getTabbableElements: function getTabbableElements() {
      var allTabbableElements = $(this.element).find('a[href], area[href], input:not([disabled]),' + 'select:not([disabled]), textarea:not([disabled]),' + 'button:not([disabled]), iframe, object, embed, *[tabindex],' + '*[contenteditable]').filter(':visible');
      return {
        first: allTabbableElements[0],
        last: allTabbableElements[allTabbableElements.length - 1]
      };
    },
    keepFocus: function keepFocus() {
      var self = this;
      var tabbableElements = void 0;

      // Escape key
      $(document).off('keydown.modal-' + this.id).on('keydown.modal-' + this.id, function (e) {
        var keyCode = e.which || e.keyCode;
        if (keyCode === 27) {
          var modals = $('.modal.is-visible');

          if (modals.length > 1) {
            modals.not(':last').on('beforeclose.modal', function () {
              return false;
            });
            modals.on('afterclose.modal', function () {
              modals.off('beforeclose.modal');
            });
            var apiModal = modals.last().data('modal');
            if (apiModal && apiModal.close) {
              apiModal.close();
            }
          } else {
            self.close();
          }
        }
      });

      $(self.element).off('keypress.modal keydown.modal').on('keypress.modal keydown.modal', function (e) {
        var keyCode = e.which || e.keyCode;

        if (keyCode === 9) {
          tabbableElements = self.getTabbableElements();

          // Move focus to first element that can be tabbed if Shift isn't used
          if (e.target === tabbableElements.last && !e.shiftKey) {
            e.preventDefault();
            tabbableElements.first.focus();
          } else if (e.target === tabbableElements.first && e.shiftKey) {
            e.preventDefault();
            tabbableElements.last.focus();
          }

          self.element.find('#message-title').removeAttr('tabindex');
        }
      });
    },


    /**
     * Close the modal.
     * @param  {boolean} destroy Call the destroy method.
     * @returns {boolean} If the dialog was open returns false. If the dialog was closed is true.
     */
    close: function close(destroy) {
      if (!this.isOpen()) {
        return true;
      }

      var elemCanClose = this.element.triggerHandler('beforeclose');
      var self = this;
      var fields = this.element.find('[data-validate]');

      this.root = this.element.closest('.modal-page-container');
      fields.addClass('disable-validation');

      if (elemCanClose === false) {
        return false;
      }

      if (this.mainContent && this.removeNoScroll) {
        this.mainContent.removeClass('no-scroll');
      }
      $('body').off('resize.modal-' + this.id);

      this.element.off('keypress.modal keydown.modal');
      this.element.removeClass('is-visible');

      this.overlay.attr('aria-hidden', 'true');
      if (this.root) {
        this.root.attr('aria-hidden', 'true');
      }

      if ($('.modal-page-container[aria-hidden="false"]').length < 1) {
        $('body').removeClass('modal-engaged');
        $('body > *').not(this.element.closest('.modal-page-container')).removeAttr('aria-hidden');
        $('.overlay').remove();
      }

      // Fire Events
      self.element.trigger('close', self.isCancelled);

      // Restore focus
      if (this.oldActive && $(this.oldActive).is('a:visible, button:visible, input:visible, textarea:visible')) {
        this.oldActive.focus();
        this.oldActive = null;
      } else if (this.trigger.parents('.toolbar, .formatter-toolbar').length < 1) {
        this.trigger.focus();
      }

      // close tooltips
      $('#validation-errors, #tooltip, #validation-tooltip').addClass('is-hidden');

      // remove the event that changed this page's skip-link functionality in the open event.
      $('.skip-link').off('focus.modal');

      setTimeout(function () {
        self.overlay.remove();
        self.root[0].style.display = 'none';
        self.element.trigger('afterclose');

        if (self.settings.trigger === 'immediate' || destroy) {
          self.destroy();
        }
      }, 300); // should match the length of time needed for the overlay to fade out

      return false;
    },


    /**
     * Destroy the modal.
     * @param {settings} settings The settings to update on the modal
     * @returns {object} The modal object for chaining.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      return this;
    },


    /**
     * Destroy the modal.
     */
    destroy: function destroy() {
      var self = this;
      var canDestroy = this.element.trigger('beforedestroy');

      if (!canDestroy) {
        return;
      }

      function destroyCallback() {
        if (self.modalButtons) {
          self.element.find('button').off('click.modal');
        }

        if (self.element.find('.detailed-message').length === 1) {
          $('body').off('resize.modal-' + this.id);
        }

        if (self.settings.trigger === 'click') {
          self.trigger.off('click.modal');
        }

        self.element.closest('.modal-page-container').remove();
        $.removeData(self.element[0], 'modal');

        $(window).off('popstate.modal');
      }

      if (!this.isOpen()) {
        destroyCallback();
        return;
      }

      this.element.one('afterclose.modal', function () {
        destroyCallback();
      });

      this.close(true);
    }
  };

  /**
   * The Message Component is used to show warning / error messages.
   * @class Message
   * @param {object} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.title='Message Title']  Title text or content shown in the message
   * @param {string} [settings.status='']  Pass a status to style icon and title color ('error', 'alert', 'confirm')
   * @param {string} [settings.message='Message Summary']  The message content or text
   * @param {number} [settings.width='auto']  Pass a specific with or defaults to auto
   * @param {object} [settings.buttons=null]  Array of buttons to add to the message (see modal examples as well)
   * @param {string} [settings.cssClass=null]  Extra Class to add to the dialog for customization.
   * @param {string} [settings.returnFocus=null]  JQuery Element selector to focus on return
   */
  var MESSAGE_DEFAULTS = {
    title: 'Message Title',
    status: '',
    message: 'Message Summary',
    width: 'auto',
    buttons: null,
    cssClass: null,
    returnFocus: null
  };

  function Message(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(element, settings, MESSAGE_DEFAULTS);
    this.init();
  }

  Message.prototype = {
    init: function init() {
      var self = this;
      var content = void 0;

      // Create the Markup
      this.message = $('<div class="modal message"></div>');
      this.messageContent = $('<div class="modal-content"></div>');
      this.title = $('<h1 class="modal-title" id="message-title">' + xssUtils.stripHTML(this.settings.title) + '</h1>').appendTo(this.messageContent).wrap('<div class="modal-header"></div>');
      this.content = $('<div class="modal-body"><p class="message" id="message-text">' + xssUtils.stripHTML(this.settings.message) + '</p></div>').appendTo(this.messageContent);

      // Append The Content if Passed in
      if (!this.element.is('body')) {
        content = this.element;
        this.content.empty().append(content.show());
      }

      this.message.append(this.messageContent).appendTo('body');
      this.message.modal({
        trigger: 'immediate',
        buttons: this.settings.buttons,
        resizable: this.settings.resizable,
        close: this.settings.close,
        isAlert: true
      });

      // Adjust Width if Set as a Setting
      if (this.settings.width !== 'auto') {
        this.content.closest('.modal')[0].style.maxWidth = 'none';
        this.content.closest('.modal')[0].style.width = this.settings.width + (/(px|%)/i.test('' + this.settings.width) ? '' : 'px');
      }

      if (this.settings.cssClass) {
        this.message.addClass(this.settings.cssClass);
      }

      // Setup the destroy event to fire on close.
      // Needs to fire after the "close" event on the modal.
      this.message.on('beforeclose.message', function () {
        var ok = self.element.triggerHandler('beforeclose');
        return ok;
      }).on('beforeopen.message', function () {
        var ok = self.element.triggerHandler('beforeopen');
        return ok;
      }).on('open.message', function () {
        self.element.trigger('open');
      }).on('afterclose.message', function () {
        self.destroy();
        if (self.settings.returnFocus) {
          self.settings.returnFocus.focus();
        }

        $(document).off('keypress.message keydown.message');
      });

      $(document).on('keypress.message keydown.message', function (e) {
        var keyCode = e.which || e.keyCode;

        if (keyCode === 27) {
          setTimeout(function () {
            var modalData = self.message.data('modal');
            if (modalData !== undefined) {
              modalData.close();
            }
          }, 0);
        }
      });

      if (this.settings.status === 'error') {
        this.title.addClass('has-status is-error').prepend($.createIconElement('error'));
      } else if (this.settings.status === 'alert') {
        this.title.addClass('has-status is-alert').prepend($.createIconElement('alert'));
      } else if (this.settings.status === 'confirm') {
        this.title.addClass('has-status is-confirm').prepend($.createIconElement('confirm'));
      } else {
        this.title.removeClass('has-status is-error is-alert is-confirm').find('svg').remove();
      }
    },
    destroy: function destroy() {
      var modalData = this.message.data('modal');
      if (modalData !== undefined) {
        modalData.destroy();
      }

      this.message.off('beforeclose.message beforeopen.message open.message afterclose.message').remove();
    }
  };

  /**
   * jQuery Component Wrapper for Messages
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.message = function (settings) {
    // Support Chaining and Init the Control or Set Settings
    return this.each(function () {
      return new Message(this, settings);
    });
  };

  /**
  * jQuery Component Wrapper for Modal
  * @param {object} settings The settings to apply.
  * @returns {jQuery[]} The jquery object for chaining.
  */
  $.fn.modal = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$N);
      var elem = $(this);

      if (!elem.is('.modal')) {
        instance = elem.closest('.modal').data(COMPONENT_NAME$N);
      }

      if (instance && settings) {
        instance.updated(settings);
        // This was added for backwards compatability when using:
        // `$(this).modal('close');`
        // Examples have been updated to not show this.
        if (typeof instance[settings] === 'function') {
          instance[settings]();
          return;
        }

        if (settings.trigger === 'immediate') {
          instance.open();
        }
        return;
      }

      if (instance && !settings) {
        return;
      }

      instance = $.data(this, COMPONENT_NAME$N, new Modal(this, settings));
    });
  };

  /**
   * jQuery Component Wrapper for MonthView
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.monthview = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$q);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$q, new MonthView(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$P = 'multiselect';

  // Component Defaults
  var MULTISELECT_DEFAULTS = {
    closeOnSelect: false,
    empty: true,
    filterMode: 'contains',
    maxSelected: undefined,
    moveSelected: 'all',
    multiple: true,
    showEmptyGroupHeaders: false,
    showSelectAll: false,
    source: undefined
  };

  /**
   * The MultiSelect Component allows selecting multiple items from a list
   * @class MultiSelect
   * @constructor
   * @param {jQuery[]|HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   * @param {string} [settings.filterMode = 'contains']  The search mode to use, can be 'contains' or 'startsWith'
   * @param {number} [settings.maxSelected = null]  The max number of items which can be selected
   * @param {string} [settings.moveSelected = 'all']   Move selected options in each group to just underneath their corresponding group headers.
   * @param {boolean} [settings.showEmptyGroupHeaders = false]  If true groups with no items will still show the empty group header.
   * @param {boolean} [settings.showSelectAll = false]  Show the select all button and text .
   * @param {function} [settings.source]  The calback for ajax.
   */
  function MultiSelect(element, settings) {
    this.settings = utils.mergeSettings(element, settings, MULTISELECT_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  MultiSelect.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.build();
    },


    /**
     * @private
     * @returns {void}
     */
    build: function build() {
      this.element.dropdown(this.settings);
      this.dropdown = this.element.data('dropdown');

      return this;
    },


    /**
     * Enable the multiselect input
     * @returns {void}
     */
    enable: function enable() {
      this.dropdown.enable();
    },


    /**
    * Disable the multiselect input
    * @returns {void}
    */
    disable: function disable() {
      this.dropdown.disable();
    },


    /**
    * Trigger a rebuild due to settings change
    * @param {object} [settings] incoming settings
    * @returns {void}
    */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.build();
    },


    /**
     * Remove added markup and events
     * @returns {void}
     */
    destroy: function destroy() {
      this.dropdown.destroy();
      this.element.off();
      $.removeData(this.element[0], COMPONENT_NAME$P);
    }
  };

  /**
   * jQuery Component wrapper for Multiselect
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.multiselect = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$P);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$P, new MultiSelect(this, settings));
      }
    });
  };

  // Settings and Options
  var COMPONENT_NAME$Q = 'notification';

  var NOTIFICATION_DEFAULTS = {
    message: 'Hi! Im a notification message.',
    type: 'alert',
    parent: '.header',
    link: '#',
    linkText: 'Click here to view.'
  };

  /**
   * Notification - Shows a slide in notifcation banner on the top of the page.
   * @class Notification
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {string} [settings.message] The text message to show in the notification.
   * @param {string} [settings.type] The message type, this influences the icon and color, possible types are 'error', 'alert', 'info' and 'confirm'
   * @param {string} [settings.parent] The jQuery selector to find where to insert the message into (prepended). By default this will appear under the .header on the page.
   * @param {string} [settings.link] The url to use for the hyperlink
   * @param {string} [settings.linkText] The text to show in the hyperlink. Leave empty for no link.
   */
  function Notification(element, settings) {
    this.settings = utils.mergeSettings(element, settings, NOTIFICATION_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Notification.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @returns {object} The Notification prototype, useful for chaining.
     */
    init: function init() {
      return this.build().handleEvents();
    },


    /**
     * Add any needed markup to the component.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    build: function build() {
      this.notificationEl = document.createElement('div');
      this.notificationEl.classList.add('notification', this.settings.type);
      this.notificationEl.innerHTML = '<svg class="icon icon-' + this.settings.type + '" focusable="false" aria-hidden="true" role="presentation">\n       <use xlink:href="#icon-' + this.settings.type + '"></use>\n    </svg>\n    <span class="notification-text">' + this.settings.message + '</span>\n    ' + (this.settings.linkText ? '<a class="notification-link" href="' + this.settings.link + '">' + this.settings.linkText + '</a>' : '') + '\n    <button type="text" class="notification-close"><svg class="icon" focusable="false" aria-hidden="true" role="presentation">\n       <use xlink:href="#icon-close"></use>\n    </svg><span class="audible">' + Locale.translate('Close') + '</span></button>';

      var parentEl = document.querySelector(this.settings.parent);

      parentEl.parentNode.insertBefore(this.notificationEl, parentEl.nextSibling);
      $(this.notificationEl).animateOpen({ distance: 40 });
      return this;
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.off('updated.' + COMPONENT_NAME$Q).on('updated.' + COMPONENT_NAME$Q, function () {
        self.updated();
      });

      $(this.notificationEl).off('click.' + COMPONENT_NAME$Q).on('click.' + COMPONENT_NAME$Q, '.notification-close', function () {
        self.destroy();
      });

      return this;
    },


    /**
     * Handle updated settings and values.
     * @param {object} [settings] incoming settings
     * @returns {object} [description]
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, NOTIFICATION_DEFAULTS);
      }

      return this.teardown().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$Q);
      this.element.off('click.' + COMPONENT_NAME$Q, '.notification-close');
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @private
     */
    destroy: function destroy() {
      if (this.notificationEl && this.notificationEl.parentNode) {
        this.notificationEl.parentNode.removeChild(this.notificationEl);
      }

      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$Q);
    }
  };

  /**
   * jQuery Component Wrapper for notification
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.notification = function (settings) {
    return this.each(function () {
      $.data(this, COMPONENT_NAME$Q, new Notification(this, settings));
    });
  };

  // Component Name
  var COMPONENT_NAME$R = 'progress';

  // Default Progress Options
  var PROGRESS_DEFAULTS = {};

  /**
  * A list of items with add/remove/delete and sort functionality.
  * @class Progress
  * @constructor
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  */
  function Progress(element, settings) {
    this.settings = utils.mergeSettings(element, settings, PROGRESS_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Actual Progress Code
  Progress.prototype = {

    /**
     * Init this component.
     * @private
     */
    init: function init() {
      var _this = this;

      this.update();

      this.element.off('updated.progress').on('updated.progress', function (e) {
        e.stopPropagation();
        _this.update();
      });
    },


    /**
     * Update the aria on this component
     * @private
     * @param  {string} value The progress value.
     */
    updateAria: function updateAria(value) {
      this.element.attr({ role: 'progressbar', 'aria-valuenow': value, 'aria-valuemax': '100' });

      var container = this.element.parent();
      if (container.data('tooltip')) {
        container.data('tooltip').content = value + '%';
      } else {
        container[0].setAttribute('title', value + '%');
        container.tooltip();
      }
    },


    /**
     * Unbind all events.
     * @private
     */
    unbind: function unbind() {
      this.element.off('updated.progress');
    },


    /**
    * Update the progress bar.
    * @param {string} value  The percent value to use to fill. 0-100
    * @returns {void}
    */
    update: function update(value) {
      var perc = this.element.attr('data-value');

      if (value) {
        perc = value;
        this.element.attr('data-value', value);
      }

      this.element[0].style.width = perc + '%';
      this.updateAria(perc);
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, PROGRESS_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
    * Teardown and remove any added markup and events.
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$R);
    }
  };

  /**
   * jQuery Component Wrapper for Progress
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.progress = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$R);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$R, new Progress(this, settings));
      }
    });
  };

  // jQuery Components

  // Component Name
  var COMPONENT_NAME$S = 'popdown';

  /**
   * The PopDown Component can be used to open an animated popdown from a button. This may in the future
   * be derecated to one thing. Popup vs Popdown vs Tooltip.
   * @class Popdown
   * @deprecated
   * @param {object} element The component element.
   * @param {object} [settings] The component settings.
   * @property {boolean} [settings.keepOpen = false] If true, will keep the Popdown open after clicking out until the Trigger
   * element is clicked, or until another pop-open element is opened.
   * @property {jQuery[]} [settings.trigger] If defined, provides a way to place the popdown against an alternate element.
  */
  var POPDOWN_DEFAULTS = {
    keepOpen: false,
    trigger: undefined
  };

  function Popdown(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, POPDOWN_DEFAULTS);
    this.init();
  }

  Popdown.prototype = {
    init: function init() {
      return this.setup().build().handleEvents();
    },
    setup: function setup() {
      var self = this;
      this.popdown = $();

      // Setup the proper trigger element to use
      this.trigger = this.element;
      if (this.settings.trigger instanceof $ || DOM.isElement(this.settings.trigger)) {
        this.trigger = $(this.settings.trigger);
      }
      // Force-change the trigger element in some specific scenarios
      if (this.trigger.is('.dropdown, .multiselect')) {
        this.trigger = $('#' + this.element.attr('id') + '-shdo');
      }

      // Find the correct element to use as the popdown's view.
      function tryPopdownElement(elem) {
        if (!elem) {
          return false;
        }

        if (typeof elem === 'string') {
          if (!elem.match('#') || elem.indexOf('#') !== 0) {
            elem = '#' + elem;
          }
          elem = $(elem);
        }

        if (elem.length) {
          self.popdown = elem;
          return true;
        }

        return false;
      }

      var popdownElem = tryPopdownElement(this.trigger.attr('data-popdown'));
      if (!popdownElem) {
        tryPopdownElement(this.trigger.next('.popdown'));
      }

      // Setup an ID for this popdown if it doesn't already have one
      this.id = this.popdown.attr('id');
      if (!this.id) {
        this.id = 'popdown-' + $('body').find('.popdown').index(this.popdown);
        this.popdown.attr('id', this.id);
      }

      return this;
    },
    build: function build() {
      // Ensure the popdown window is a popdown, and remove any hidden classes from it.
      this.popdown.addClass('popdown').removeClass('hidden');

      // Wrap the contents inside for spacing purposes
      var contents = this.popdown.children('.popdown-contents');
      if (!contents.length) {
        this.popdown.children().wrap('<div class="popdown-contents"></div>');
      }

      // Add the arrow markup if it doesn't already exist
      this.arrow = $('<div class="arrow"></div>').prependTo(this.popdown);

      this.place();

      // Expand if necessary
      var ariaExpanded = this.trigger.attr('aria-expanded');
      if (!ariaExpanded || ariaExpanded === undefined) {
        this.trigger.attr('aria-expanded', '');
      }
      if (ariaExpanded === 'true') {
        this.open();
      }

      // aria-controls for the trigger element
      if (this.trigger) {
        this.trigger[0].setAttribute('aria-controls', this.id);
      }
      return this;
    },
    handleEvents: function handleEvents() {
      var self = this;

      this.trigger.on('click.popdown', function () {
        self.toggle();
      }).on('updated.popdown', function () {
        self.updated();
      });

      return this;
    },
    hasValidTriggerSetting: function hasValidTriggerSetting() {
      return this.settings.trigger instanceof $ || DOM.isElement(this.settings.trigger);
    },


    /**
     * Detects whether or not the Popdown has focus.
     * @private
     * @returns {boolean} whether or not the element is currently focused.
     */
    hasFocus: function hasFocus() {
      var active = document.activeElement;
      if (this.trigger.is(active)) {
        return true;
      }
      if ($.contains(this.popdown[0], active)) {
        return true;
      }

      return false;
    },


    /**
     * Determines whether or not the popdown is open.
     * @returns {boolean} returns current state.
     */
    isOpen: function isOpen() {
      return this.trigger.attr('aria-expanded') === 'true';
    },


    /**
     * Open the popdown.
     */
    open: function open() {
      if (this.isAnimating) {
        return;
      }

      var self = this;
      var setFocusinEvent = false;

      this.isAnimating = true;
      this.trigger.attr('aria-expanded', 'true');
      this.position();
      this.popdown.addClass('visible');

      // Setup events that happen on open
      // Needs to be on a timer to prevent automatic closing of popdown.
      setTimeout(function () {
        $('body').on('resize.popdown', function () {
          if (!self.hasFocus()) {
            self.close();
          }
        });

        // Only allow $(document).click() to close the Popdown if `keepOpen` isn't set.
        if (!self.settings.keepOpen) {
          $(document).on('click.popdown', function () {
            if (!self.hasFocus()) {
              self.close();
            }
          });

          // When focusing in on other important page elements, this Popdown instance will check to
          // see if it contains those elements, and will close if it doesn't.
          if (!setFocusinEvent) {
            setFocusinEvent = true;
            $(document).on('focusin.popdown', function () {
              if (!self.hasFocus()) {
                self.close();
              }
            });
          }
        }

        self.isAnimating = false;
      }, 400);
    },


    /**
     * Close the popdown.
     */
    close: function close() {
      if (this.isAnimating) {
        return;
      }

      var self = this;
      this.isAnimating = true;
      this.trigger.attr('aria-expanded', 'false');
      this.popdown.removeClass('visible');

      // Turn off events
      this.popdown.off('focusin.popdown');
      $('body').off('resize.popdown');
      $(document).off('click.popdown focusin.popdown');

      // Sets the element to "display: none" to prevent interactions while hidden.
      setTimeout(function () {
        self.popdown[0].style.display = 'none';
        self.isAnimating = false;
      }, 400);
    },


    /**
     * Toggle the popdown.
     */
    toggle: function toggle() {
      if (this.isOpen()) {
        this.close();
        return;
      }
      this.open();
    },


    /**
     * Detaches Popdown Element and places at the body tag root, or at the root of the nearest scrollable parent.
     * @private
     */
    place: function place() {
      this.scrollparent = $('body');
      this.popdown.detach().appendTo(this.scrollparent);
    },


    /**
     * Set the right popdown position.
     * @private
     */
    position: function position() {
      var parent = {
        offset: {
          left: 0,
          top: 0
        },
        scrollDistance: {
          left: 0,
          top: 0
        }
      };
      var winH = window.innerHeight + $(document).scrollTop();
      // subtract 2 from the window width to account for the tooltips
      // resizing themselves to fit within the CSS overflow boundary.
      var winW = window.innerWidth - 2 + $(document).scrollLeft();

      // Reset adjustments to panel and arrow
      this.popdown.removeAttr('style');
      this.arrow.removeAttr('style');

      // Add/subtract offsets if a scrollable parent element is involved
      if (this.scrollparent.length) {
        parent.offset = this.scrollparent.offset();
        parent.scrollDistance.top = this.scrollparent.scrollTop();
        parent.scrollDistance.left = this.scrollparent.scrollLeft();
        winH -= parent.offset.top + parent.scrollDistance.top;
        winW -= parent.offset.left + parent.scrollDistance.left;
      }

      var adjustX = false;
      var adjustY = false;
      var t = this.trigger;
      var to = t.offset(); // Trigger offset
      var arrowHeight = 11;
      var XoffsetFromTrigger = 0;
      var YoffsetFromTrigger = 0;
      var po = void 0; // Popover offset

      // Place the popdown below to start
      this.popdown.addClass('bottom');

      this.popdown[0].style.left = to.left + 'px';
      this.popdown[0].style.top = to.top + t.outerHeight(true) + arrowHeight + 'px';

      this.arrow[0].style.left = t.outerWidth(true) / 2 + 'px';
      this.arrow[0].style.top = 0 - arrowHeight + 'px';

      // Get the newly-set values for the popdown's offset
      po = this.popdown.offset();

      // Get deltas for popdown position if the button is off either X edge
      if (po.left < 0) {
        // Checking the left edge
        adjustX = true;
        XoffsetFromTrigger = 0 - po.left;
      }
      var rightEdgePos = po.left + this.popdown.outerWidth(true);
      if (rightEdgePos > winW) {
        // Checking the right edge
        adjustX = true;
        XoffsetFromTrigger = rightEdgePos - winW + (Locale.isRTL() ? 20 : 0);
      }

      if (adjustX) {
        // Adjust the X position based on the deltas
        this.popdown[0].style.left = po.left + XoffsetFromTrigger * -1 + 'px';

        var popdownRect = this.popdown[0].getBoundingClientRect();
        var triggerRect = t[0].getBoundingClientRect();
        var deltaRightEdge = popdownRect.right - triggerRect.right + 10;

        this.arrow[0].style.left = 'auto';
        this.arrow[0].style.right = deltaRightEdge + 'px';

        // Get the newly set values
        po = this.popdown.offset();
      }

      // Get the deltas for popdown position if the button is off either Y edge
      if (po.top < 0) {
        // Checking top edge
        adjustY = true;
        YoffsetFromTrigger = 0 - po.top;
      }
      var bottomEdgePos = po.top + this.popdown.outerHeight(true);
      if (bottomEdgePos > winH) {
        // Checking the bottom edge
        adjustY = true;
        YoffsetFromTrigger = bottomEdgePos - winH;
      }

      // Remove the arrow if we need to adjust this, since it won't line up anymore
      if (adjustY) {
        this.arrow[0].style.display = 'none';

        // Adjust the Y position based on the deltas
        this.popdown[0].style.top = po.top + YoffsetFromTrigger * -1 + 'px';
        this.arrow[0].style.top = parseInt(this.arrow[0].style.top, 10) - YoffsetFromTrigger * -1 + 'px';

        // Get the values again
        po = this.popdown.offset();
      }

      // One last check of the Y edges.  At this point, if either edge is out of bounds, we need to
      // shrink the height of the popdown, as it's too tall for the viewport.
      if (po.top < 0 || po.top + this.popdown.outerHeight(true) > winH) {
        this.popdown[0].style.top = 0;
        po = this.popdown.offset();

        bottomEdgePos = po.top + this.popdown.outerHeight(true);
        this.popdown[0].style.height = parseInt(this.popdown[0].style.height, 10) - (bottomEdgePos - winH) + 'px';
      }
    },


    /**
     * Update the popdown and refresh with new settings
     * @param  {object} settings The new settings
     * @returns {object} The component api.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      if (this.hasValidTriggerSetting()) {
        this.trigger = $(this.settings.trigger);
      }

      return this;
    },


    /**
     * Release Events
     * @private
     * @returns {object} The component api.
     */
    teardown: function teardown() {
      if (this.isOpen()) {
        this.close();
      }

      this.trigger.off('updated.popdown click.popdown').removeAttr('aria-controls').removeAttr('aria-expanded');

      if (this.originalParent && this.originalParent.length) {
        this.popdown.detach().appendTo(this.originalParent);
      }

      this.arrow.remove();

      return this;
    },


    /**
     * Teardown - Remove added markup and events
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$S);
    }
  };

  /**
   * jQuery component wrapper for Popdown
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery selector containing all elements
   */
  $.fn.popdown = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$S);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$S, new Popdown(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$T = 'rating';

  // Default Rating Options
  var RATING_DEFAULTS = {};

  /**
   * @class Rating
   * @constructor
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   */
  function Rating(element, settings) {
    this.settings = utils.mergeSettings(element, settings, RATING_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Actual Rating Code
  Rating.prototype = {
    init: function init() {
      this.handleEvents();
      this.allInputs = this.element.find('input');
      this.readonly();
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var inputs = $('input', this.element);

      var _loop = function _loop(i, l) {
        $(inputs[i]).on('change.' + COMPONENT_NAME$T, function () {
          if (!_this.element.hasClass('is-readonly')) {
            _this.val(i + 1);
          }
        });
      };

      for (var i = 0, l = inputs.length; i < l; i++) {
        _loop(i, l);
      }
    },


    /**
     * Set the value
     * @private
     * @param {number} value to pass in.
     * @returns {number} current value
     */
    val: function val(value) {
      if (value === '' || isNaN(value) || math.sign(value) === -1) {
        return this.currentValue;
      }

      this.currentValue = parseFloat(value, 10);
      var chkIdx = Math.floor(this.currentValue);

      for (var i = 0, l = this.allInputs.length; i < l; i++) {
        var input = $(this.allInputs[i]);
        var svgSelector = input.parent().is('.inline') ? 'svg' : 'label';

        if (i < value) {
          input.addClass('is-filled').removeClass('is-half');
        } else {
          input.removeClass('is-filled').removeClass('is-half').prop('checked', false);
        }

        // Handle Half Star
        input.next(svgSelector).find('svg').changeIcon('star-filled');

        if (i + 1 === chkIdx) {
          input.prop('checked', true);
        }

        if (chkIdx !== this.currentValue && i === chkIdx) {
          input.addClass('is-half').next(svgSelector).find('svg').changeIcon('star-half');
        }
      }
      if (chkIdx <= 0 && value > 0) {
        $(this.allInputs[0]).prop('checked', true);
      }

      return this.currentValue;
    },


    /**
    * Set component to readonly.
    * @returns {void}
    */
    readonly: function readonly() {
      var elem = $(this.element);
      if (elem.hasClass('is-readonly')) {
        elem.find('input').attr('disabled', '');
      }
    },


    /**
    * Set component to enable.
    * @returns {void}
    */
    enable: function enable() {
      var elem = $(this.element);
      elem.removeClass('is-readonly').find('input').removeAttr('disabled');
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.element.find('input').off('change.' + COMPONENT_NAME$T);
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, RATING_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
    * Destroy and remove added markup, all events
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$T);
    }
  };

  /**
   * jQuery Component Wrapper for Rating
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.rating = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$T);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$T, new Rating(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$U = 'signin';

  // Default SignIn Options
  var SIGNIN_DEFAULTS = {};

  /**
  * The sign in page component.
  * @class SignIn
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  */
  function SignIn(element, settings) {
    this.settings = utils.mergeSettings(element, settings, SIGNIN_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  SignIn.prototype = {
    init: function init() {
      this.handleKeys();
    },


    /**
     * Checks a keyboard event for a CAPS LOCK modifier.
     * @private
     * @param {object} e jQuery.Event
     * @returns {boolean} true if caps lock
     */
    isCapslock: function isCapslock(e) {
      e = e || window.event;
      var charCode = false;
      var shifton = false;

      if (e.which) {
        charCode = e.which;
      } else if (e.keyCode) {
        charCode = e.keyCode;
      }

      if (e.shiftKey) {
        shifton = e.shiftKey;
      } else if (e.modifiers) {
        shifton = !!(e.modifiers & 4); // eslint-disable-line
      }

      if (charCode >= 97 && charCode <= 122 && shifton) {
        return true;
      }
      if (charCode >= 65 && charCode <= 90 && !shifton) {
        return true;
      }
      return false;
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      $('body').off('keypress.signin blur.signin change.signin');
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, SIGNIN_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$U);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleKeys: function handleKeys() {
      var self = this;
      var cssIcon = $.createIconElement({ classes: 'icon-capslock', icon: 'capslock' });

      // Disable default [caps lock on] popup in IE
      document.msCapsLockWarningOff = true;

      this.element.on('keypress.signin', '[type="password"]', function (e) {
        var field = $(this);
        var fieldParent = field.parent('.field');
        var iconCapslock = $('.icon-capslock', fieldParent);

        if (self.isCapslock(e) && !field.hasClass('error')) {
          if (!iconCapslock.length) {
            fieldParent.append(cssIcon);
            $('body').toast({ audibleOnly: true, message: Locale.translate('CapsLockOn') });
          }
        } else {
          iconCapslock.remove();
        }
      }).on('blur.signin change.signin', '[type="password"]', function () {
        var field = $(this);
        var fieldParent = field.closest('.field');
        var iconCapslock = $('.icon-capslock', fieldParent);

        setTimeout(function () {
          if (iconCapslock && iconCapslock.length) {
            if (field.hasClass('error')) {
              iconCapslock.remove();
            } else {
              fieldParent.append(cssIcon);
            }
          }
        }, 150);
      });
    }
  };

  /**
   * jQuery Component Wrapper for SignIn
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.signin = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$U);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$U, new SignIn(this, settings));
      }
    });
  };

  /* eslint-disable no-underscore-dangle */

  // Component Name
  var COMPONENT_NAME$V = 'slider';

  // The Component Defaults
  var SLIDER_DEFAULTS = {
    value: [50],
    min: 0,
    max: 100,
    range: false,
    step: undefined,
    ticks: [],
    tooltipContent: undefined,
    persistTooltip: false
  };

  /**
   * Touch Enabled/Responsive and Accessible Slider Control
   * @class Slider
   * @param {jQuery[]|HTMLElement} element The DOM element
   * @param {object} [settings] incoming settings
   * @param {array} [settings.value = [50]] An array with the slider values. Or one if a single value slider.
   * @param {number} [settings.min = 0] The minimum slider value.
   * @param {number} [settings.max = 100] The maximum slider value.
   * @param {boolean} [settings.range = false] If true a range slider with two selectors is formed.
   * @param {undefined|Number} [settings.step] If added will be the number of slider steps to use.
   * @param {array} [settings.ticks = []] An array of the ticks to use for the steps
   * @param {undefined|Array} [settings.tooltipContent] Special customizable tooltip content.
   * @param {boolean} [settings.persistTooltip = false] If true the tooltip will stay visible.
   */
  function Slider(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, SLIDER_DEFAULTS);
    this.init();
  }

  // Check if is an integer
  function isInt(n) {
    return n % 1 === 0;
  }

  // Round a non-integer to an integer closest to the nearest increment/decrement.
  // If no increment is provided or the increment is 0, only round to the nearest whole number.
  function roundToIncrement(number, increment) {
    if (!increment || isNaN(increment) || increment === 0) {
      increment = 1;
    }
    return Math.round(number / increment) * increment;
  }

  // Get the distance between two points.
  // PointA & PointB are both arrays containing X and Y coordinates of two points.
  // Distance Formula:  http://www.purplemath.com/modules/distform.htm
  function getDistance(pointA, pointB) {
    var aX = pointA[0];
    var aY = pointA[1];
    var bX = pointB[0];
    var bY = pointB[1];

    return Math.sqrt(Math.pow(bX - aX, 2) + Math.pow(bY - aY, 2));
  }

  // Actual Plugin Code
  Slider.prototype = {

    /**
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      return this.buildSettings().addMarkup().bindEvents();
    },


    /**
     * Handles Data Attribute settings, some markup settings
     * @private
     * @returns {this} component instance
     */
    buildSettings: function buildSettings() {
      var self = this;

      // Add "is-disabled" css class to closest ".field" if element is disabled
      if (this.element.is(':disabled')) {
        this.element.closest('.field').addClass('is-disabled');
      }

      if (!this.settings) {
        this.settings = {};
      }
      this.settings.value = this.element.attr('value') !== undefined ? this.element.attr('value') : this.settings.value;
      this.settings.min = this.element.attr('min') !== undefined ? parseInt(this.element.attr('min'), 10) : this.settings.min;
      this.settings.max = this.element.attr('max') !== undefined ? parseInt(this.element.attr('max'), 10) : this.settings.max;
      this.settings.range = this.element.attr('data-range') !== undefined ? this.element.attr('data-range') === 'true' : this.settings.range;
      this.settings.step = !isNaN(this.element.attr('step')) ? Number(this.element.attr('step')) : this.settings.step;

      if (this.settings.value === '') {
        this.settings.value = this.settings.min;
      }

      // build tick list
      var parsedTicks = void 0;
      if (this.element.attr('data-ticks') !== undefined) {
        try {
          parsedTicks = JSON.parse(self.element.attr('data-ticks'));
        } catch (e) {
          parsedTicks = [];
        }

        if ($.isArray(parsedTicks)) {
          this.settings.ticks = parsedTicks;
        }
      }

      // build tooltip content
      var isTooltipPersist = this.element.attr('data-tooltip-persist') === 'true' || this.element.attr('data-tooltip-persist') === true;
      this.settings.persistTooltip = this.element.attr('data-tooltip-persist') !== undefined ? isTooltipPersist : this.settings.persistTooltip;
      this.settings.tooltip = this.settings.tooltipContent;
      if (this.element.attr('data-tooltip-content') !== undefined) {
        try {
          self.settings.tooltip = JSON.parse(self.element.attr('data-tooltip-content'));
        } catch (e) {
          self.settings.tooltip = ['', ''];
        }
      }
      if (typeof this.settings.tooltip === 'string') {
        if (this.settings.tooltip.indexOf(',') === -1) {
          this.settings.tooltip = [this.settings.tooltip, ''];
        } else {
          var strings = this.settings.tooltip.split(',');
          this.settings.tooltip = [strings[0]];
          this.settings.tooltip.push(strings[1] ? strings[1] : '');
        }
      }
      if (this.settings.tooltip && this.settings.tooltip.length === 1) {
        this.settings.tooltip.push('');
      }

      // Build ticks.  All sliders have a tick for minimum and maximum by default.
      // Some will be provided as extra.
      this.ticks = [];
      var minTick = {
        value: this.settings.min,
        description: self.getModifiedTextValue(this.settings.min)
      };
      var maxTick = {
        value: this.settings.max,
        description: self.getModifiedTextValue(this.settings.max)
      };

      if (!this.settings.ticks) {
        this.ticks.push(minTick, maxTick);
      } else {
        // Check the type of the data-ticks.  If it's not a complete array
        // and doesn't have at least one option, ignore it.
        var ticks = self.settings.ticks || [];

        if ($.isArray(ticks) && ticks.length > 0) {
          // Filter through the incoming ticks to figure out if any have been defined
          // That match the values of min and max.
          var equalsMin = ticks.filter(function (obj) {
            return obj.value === self.settings.min;
          });
          var equalsMax = ticks.filter(function (obj) {
            return obj.value === self.settings.max;
          });

          // Overwrite description and color for min/max if they've been found.
          if (equalsMin.length > 0) {
            minTick.description = equalsMin[0].description;
            minTick.color = equalsMin[0].color;
            ticks = $.grep(ticks, function (val) {
              return val !== equalsMin[0];
            });
          }
          if (equalsMax.length > 0) {
            maxTick.description = equalsMax[0].description;
            maxTick.color = equalsMax[0].color;
            ticks = $.grep(ticks, function (val) {
              return val !== equalsMax[0];
            });
          }
        }

        // Push the values of all ticks out to the ticks array
        self.ticks.push(minTick);
        for (var i = 0; i < ticks.length; i++) {
          var tick = {};
          if (ticks[i].value !== undefined) {
            tick.value = ticks[i].value;
            tick.description = ticks[i].description !== undefined ? ticks[i].description : '';
            tick.color = ticks[i].color;
            self.ticks.push(tick);
          }
        }
        self.ticks.push(maxTick);
      }

      // configure the slider to deal with an array of values, and normalize the
      // values to make sure they are numbers.
      if ($.isArray(this.settings.value)) {
        this.settings.value[0] = isNaN(this.settings.value[0]) ? (this.settings.min + this.settings.max) / 2 : parseInt(this.settings.value[0], 10);
      } else if (typeof this.settings.value === 'number') {
        this.settings.value = [this.settings.value];
      } else if (this.settings.value.indexOf(',') === -1) {
        // String
        this.settings.value = [isNaN(this.settings.value) ? (this.settings.min + this.settings.max) / 2 : parseInt(this.settings.value, 10)];
      } else {
        var vals = this.settings.value.split(',');
        vals[0] = isNaN(vals[0]) ? this.settings.min : parseInt(vals[0], 10);
        vals[1] = isNaN(vals[1]) ? this.settings.max : parseInt(vals[1], 10);
        this.settings.value = vals;
      }

      // Add a second value to the array if we're dealing with a range.
      if (this.settings.range && !this.settings.value[1]) {
        this.settings.value.push(this.settings.max);
      }

      return this;
    },


    /**
     * Adds pseudo-markup that helps build the component
     * @private
     * @returns {this} component instance
     */
    addMarkup: function addMarkup() {
      var self = this;
      var isVertical = false;

      if (self.element[0].tagName !== 'INPUT') {
        throw new Error('Element with ID "' + self.element.id + '" cannot invoke a slider;  it\'s not an Input element.');
      }

      // store values and attributes on the original element
      self.originalElement = {
        type: self.element.attr('type')
      };

      // Hide the input element
      self.element.attr('type', 'hidden');

      // Build the slider controls
      self.wrapper = $('<div class="slider-wrapper"></div>').attr('id', self.element.attr('id') + '-slider').insertAfter(self.element);
      self.hitarea = $('<div class="slider-hit-area"></div>').appendTo(self.wrapper);
      self.range = $('<div class="slider-range"></div>').appendTo(self.wrapper);

      // Set to a vertical slider if the class exists on the input
      if (this.element.hasClass('vertical')) {
        this.wrapper.addClass('vertical');
        isVertical = true;
      }

      // Set RTL
      this.isRtlHorizontal = Locale.isRTL() && !isVertical;
      this.isRtlVertical = Locale.isRTL() && isVertical;

      // Retain any width or height size properties from the original range
      // element onto the Pseudo-markup
      var style = this.element.attr('style');
      if (style) {
        if (style.match(/min-height/)) {
          this.wrapper[0].style.minHeight = this.element[0].style.minHeight;
          style = style.replace('min-height', '');
        }
        if (style.match(/height/)) {
          this.wrapper[0].style.height = this.element[0].style.height;
        }
        if (style.match(/min-width/)) {
          this.wrapper[0].style.minWidth = this.element[0].style.minWidth;
          style = style.replace('min-width', '');
        }
        if (style.match(/width/)) {
          this.wrapper[0].style.width = this.element[0].style.width;
        }
      }

      // Handles
      self.handles = [];
      var labelText = self.element.prev('label').text();
      var handleLower = $('<div class="slider-handle' + (self.settings.range ? ' lower' : '') + '" tabindex="0"></div>').attr('aria-label', (self.settings.range ? Locale.translate('SliderMinimumHandle') : Locale.translate('SliderHandle')) + ' ' + labelText);
      self.handles.push(handleLower);
      if (self.settings.range) {
        var handleHigher = $('<div class="slider-handle higher" tabindex="0"></div>').attr('aria-label', Locale.translate('SliderMaximumHandle') + ' ' + labelText);
        self.handles.push(handleHigher);
      }
      $.each(self.handles, function (i, handle) {
        // Add WAI-ARIA to the handles
        handle.attr({
          role: 'slider',
          'aria-orientation': isVertical ? 'vertical' : 'horizontal',
          'aria-valuemin': self.settings.min,
          'aria-valuemax': self.settings.max
        }).hideFocus();
        handle.appendTo(self.wrapper);
      });

      function positionTick(tick) {
        var convertValueToPercentage = self.isRtlHorizontal ? 100 - self.convertValueToPercentage(tick.value) : self.convertValueToPercentage(tick.value);
        var pos = 'calc(' + convertValueToPercentage + '% - 4px)';

        tick.element = $('<div class="tick" data-value="' + tick.value + '"></div>');
        tick.label = $('<span class="label">' + tick.description + '</span>');
        tick.element[0].style[isVertical ? 'bottom' : 'left'] = pos;
        tick.element.append(tick.label);
        self.wrapper.append(tick.element);

        if (isVertical) {
          return;
        }
        tick.label[0].style.left = -(tick.label.outerWidth() / 2 - tick.element.width() / 2) + 'px';
      }

      // Ticks
      self.ticks.forEach(function (tick) {
        positionTick(tick);
      });

      self.value(self.settings.value);
      self.updateRange();

      // Tooltip on handle needs to update later
      $.each(self.handles, function (i, handle) {
        if (self.settings.tooltip) {
          handle.tooltip({
            content: function content() {
              return '' + self.getModifiedTextValue(Math.floor(self.value()[i]));
            },

            placement: isVertical ? 'right' : 'bottom',
            trigger: 'focus',
            keepOpen: self.settings.persistTooltip
          });
          handle.removeAttr('aria-describedby');
        }
      });

      if (this.element.prop('readonly') === true) {
        this.readonly();
      } else if (this.element.prop('disabled') === true) {
        this.disable();
      }

      return self;
    },


    /**
     * User is interacting with the Slider Range (not the handle or ticks)
     * @private
     * @param {jQuery.Event} e jQuery `click` event
     * @returns {void}
     */
    handleRangeClick: function handleRangeClick(e) {
      e.preventDefault();
      if (this.isDisabled()) {
        return;
      }

      var self = this;
      var isVertical = this.wrapper.hasClass('vertical');
      var pageX = e.originalEvent.type !== 'click' ? e.originalEvent.changedTouches[0].pageX : e.pageX;
      var pageY = e.originalEvent.type !== 'click' ? e.originalEvent.changedTouches[0].pageY : e.pageY;
      var mouseX = pageX - self.wrapper.offset().left - $(document).scrollLeft();
      var mouseY = pageY - self.wrapper.offset().top - $(document).scrollTop();
      var clickCoords = [mouseX, mouseY];
      var fhX = self.handles[0].offset().left + self.handles[0].width() / 2 - self.wrapper.offset().left - $(document).scrollLeft();
      var fhY = self.handles[0].offset().top + self.handles[0].height() / 2 - self.wrapper.offset().top - $(document).scrollTop();
      var firstHandleCoords = [fhX, fhY];
      var shX = void 0;
      var shY = void 0;
      var secondHandleCoords = void 0;
      var oldVals = self.value();
      var dLower = getDistance(clickCoords, firstHandleCoords);
      var dHigher = void 0;
      var targetOldVal = oldVals[0];
      var targetHandle = self.handles[0];

      targetHandle.addClass('hide-focus');

      function conversion() {
        if (isVertical) {
          var wh = self.wrapper.height();
          return (wh - mouseY) / wh * 100;
        }
        return mouseX / self.wrapper.width() * 100;
      }

      // Convert the coordinates of the mouse click to a value
      var val = conversion();
      var rangeVal = self.convertPercentageToValue(val);

      // If the slider is a range, we may use the second handle instead of the first
      if (self.handles[1]) {
        shX = self.handles[1].offset().left + self.handles[1].width() / 2 - self.wrapper.offset().left - $(document).scrollLeft();
        shY = self.handles[1].offset().top + self.handles[1].height() / 2 - self.wrapper.offset().top - $(document).scrollTop();
        secondHandleCoords = [shX, shY];
        dHigher = getDistance(clickCoords, secondHandleCoords);

        if (dLower > dHigher) {
          self.value([undefined, rangeVal]);
          targetHandle = self.handles[1];
          targetOldVal = oldVals[1];
        } else {
          self.value([rangeVal]);
        }
      } else {
        self.value([rangeVal]);
      }

      self.checkHandleDifference(targetHandle, targetOldVal, rangeVal);

      var moveBy = self.settings.step ? self.settings.step : 0;
      if (rangeVal < targetOldVal) {
        self.decreaseValue(e, targetHandle, rangeVal, moveBy);
      } else {
        self.increaseValue(e, targetHandle, rangeVal, moveBy);
      }

      // Tooltip repositioner will focus the handle after positioning occurs, but if
      // we are clicking a tick on a slider with no tooltip, we need to focus it manually.
      if (!self.settings.tooltip) {
        targetHandle.focus();
      }
    },


    /**
     * Activates one of the slider handles
     * @private
     * @param {jQuery[]} handle element representing a slider handle
     */
    activateHandle: function activateHandle(handle) {
      handle.addClass('is-active');
    },


    /**
     * Deactivates one of the slider handles
     * @private
     * @param {jQuery[]} handle element representing a slider handle
     */
    deactivateHandle: function deactivateHandle(handle) {
      handle.removeClass('is-active');
    },


    /**
     * Enables the ability to drag one of the slider handles.
     * @private
     * @param {jQuery[]} handle element representing a slider handle
     */
    enableHandleDrag: function enableHandleDrag(handle) {
      if (this.isDisabled()) {
        return;
      }

      var self = this;
      var draggableOptions = {
        containment: 'parent',
        axis: this.isVertical() ? 'y' : 'x',
        clone: false
      };

      function updateHandleFromDraggable(e, thisHandle, args) {
        if (self.isDisabled()) {
          return;
        }

        function conversion() {
          if (self.isVertical()) {
            var wh = self.wrapper.height();
            // Vertical Slider accounts for limits set on the height by SoHo Xi Drag.js
            var adjustedHeight = wh - thisHandle.outerHeight();

            return (adjustedHeight - args.top) / adjustedHeight * 100;
          }
          return args.left / (self.wrapper.width() - thisHandle.outerWidth()) * 100;
        }

        var val = conversion();
        var rangeVal = self.convertPercentageToValue(val);

        // Ranged values need to check to make sure that the higher-value handle
        // doesn't drawindowg past the lower-value handle, and vice-versa.
        if (self.settings.range) {
          var originalVal = self.value();
          if (thisHandle.hasClass('higher') && rangeVal <= originalVal[0]) {
            rangeVal = originalVal[0];
          }
          if (thisHandle.hasClass('lower') && rangeVal >= originalVal[1]) {
            rangeVal = originalVal[1];
          }
        }

        // Round the value to the nearest step, if the step is defined
        if (self.settings.step) {
          rangeVal = Math.round(rangeVal / self.settings.step) * self.settings.step;
        }

        /**
        * Fires while the slider is being slid.
        * @event sliding
        * @memberof Slider
        * @property {object} event The jquery event object
        * @property {object} args Extra event information.
        * @property {HTMLElement} args.handle The slider handle DOM element.
        * @property {number} args.value The current range value.
        */
        if (!e.defaultPrevented) {
          self.value(thisHandle.hasClass('higher') ? [undefined, rangeVal] : [rangeVal]);
          self.updateRange();
          self.updateTooltip(thisHandle);
          self.element.trigger('sliding', thisHandle, rangeVal);
        }
      }

      // Add/Remove Classes for canceling animation of handles on the draggable's events.
      /**
      * Fires while the slider is being slid.
      * @event slidestart
      * @memberof Slider
      * @property {object} event The jquery event object
      * @property {object} args Extra event information.
      * @property {HTMLElement} args.handle The slider handle DOM element.
      */
      /**
       * Fires while the slider is being slid.
       * @event slidestop
       * @memberof Slider
       * @property {object} event The jquery event object
       * @property {object} args Extra event information.
       * @property {HTMLElement} args.handle The slider handle DOM element.
       */
      handle.drag(draggableOptions).on('drag.slider', function (e, args) {
        updateHandleFromDraggable(e, $(e.currentTarget), args);
      }).on('dragstart', function () {
        $(this).addClass('is-dragging');
        self.range.addClass('is-dragging');
        self.element.trigger('slidestart', handle);
      }).on('dragend', function () {
        $(this).removeClass('is-dragging');
        self.range.removeClass('is-dragging');
        self.element.trigger('slidestop', handle);
      });
    },


    /**
     * Disables the dragging of a handle.
     * @private
     * @param {jQuery[]} handle element representing a slider handle
     */
    disableHandleDrag: function disableHandleDrag(handle) {
      handle.off('drag.slider dragstart dragend');

      this.range.removeClass('is-dragging');
      handle.removeClass('is-dragging');

      var dragAPI = handle.data('drag');
      if (dragAPI) {
        dragAPI.destroy();
      }
    },


    /**
     * @private
     * @param {number} value pixel value
     * @returns {number} representing a percentage
     */
    convertValueToPercentage: function convertValueToPercentage(value) {
      return (value - this.settings.min) / (this.settings.max - this.settings.min) * 100;
    },


    /**
     * @private
     * @param {number} percentage percentage value
     * @returns {number} representing a pixel value
     */
    convertPercentageToValue: function convertPercentageToValue(percentage) {
      var val = percentage / 100 * (this.settings.max - this.settings.min) + this.settings.min;
      return this.isRtlHorizontal ? this.settings.max - val + this.settings.min : val;
    },


    /**
     * Gets a 10% increment/decrement as a value within the range of minimum and maximum values.
     * @returns {number} nearest 10% increment
     */
    getIncrement: function getIncrement() {
      var increment = 0.1 * (this.settings.max - this.settings.min);
      if (this.settings.step !== undefined && increment <= this.settings.step) {
        increment = this.settings.step;
      }
      return increment;
    },


    /**
     * Handles Slider Component's keystrokes
     * @private
     * @param {jQuery.Event} e jQuery `keydown` event
     * @param {this} self reference to this component instance
     */
    handleKeys: function handleKeys(e, self) {
      if (self.isDisabled()) {
        return;
      }

      var key = e.which;
      var handle = $(e.currentTarget);

      handle.removeClass('hide-focus');

      // If the keycode got this far, it's an arrow key, Page Up, Page Down, HOME, or END.
      switch (key) {
        case 33:
          // Page Up increases the value by 10%
          self.increaseValue(e, handle, undefined, this.getIncrement());
          break;
        case 34:
          // Page Down decreases the value by 10%
          self.decreaseValue(e, handle, undefined, this.getIncrement());
          break;
        case 35:
          // End key sets the handle to its maximum possible value
          self.increaseValue(e, handle, this.settings.max);
          break;
        case 36:
          // Home key sets the handle to its lowest
          // (either minimum value or as low as the "lower" handle)
          self.decreaseValue(e, handle, this.settings.min);
          break;
        case 38:case 39:
          // Right and Up increase the spinbox value
          if (self.isRtlHorizontal && key === 39) {
            self.decreaseValue(e, handle);
          } else {
            self.increaseValue(e, handle);
          }
          break;
        case 37:case 40:
          // Left and Down decrease the spinbox value
          if (self.isRtlHorizontal && key === 37) {
            self.increaseValue(e, handle);
          } else {
            self.decreaseValue(e, handle);
          }
          break;
        default:
          break;
      }
    },


    /**
     * Increases the value of one of the slider handles, accounting for step value, percentage, etc.
     * Also visually updates the handle on the visual part of the slider.
     * @param {jQuery.Event} e jQuery `click` or `keydown` event.
     * @param {jQuery[]} handle represents a slider handle element.
     * @param {number} [value] - target value - will be automatically determined if not passed.
     * @param {number} [increment] - an integer that will be used as the amount to increment.
     */
    increaseValue: function increaseValue(e, handle, value, increment) {
      e.preventDefault();
      clearTimeout(handle.data('animationTimeout'));

      var val = this.value().slice(0);
      var incrementBy = increment !== undefined ? increment : this.settings.step !== undefined ? this.settings.step : 1; //eslint-disable-line
      var testVal = void 0;
      var updatedVal = void 0;
      var finalVal = void 0;

      if (handle.hasClass('higher')) {
        testVal = value !== undefined ? value : val[1];
        incrementBy = isInt(testVal) ? incrementBy : isNaN(testVal % incrementBy) ? 0 : testVal % incrementBy; //eslint-disable-line
        updatedVal = testVal + incrementBy < this.settings.max ? testVal + incrementBy : this.settings.max;
        finalVal = updatedVal % incrementBy ? updatedVal : roundToIncrement(updatedVal, incrementBy);
        this.value([undefined, finalVal]);
      } else {
        testVal = value !== undefined ? value : val[0];
        var maxValue = val[1] === undefined ? this.settings.max : val[1];
        incrementBy = isInt(testVal) ? incrementBy : isNaN(testVal % incrementBy) ? 0 : incrementBy - testVal % incrementBy; //eslint-disable-line
        updatedVal = testVal + incrementBy < maxValue ? testVal + incrementBy : maxValue;
        finalVal = updatedVal % incrementBy ? updatedVal : roundToIncrement(updatedVal, incrementBy);
        this.value([finalVal]);
      }
      this.checkHandleDifference(handle, testVal, finalVal);
      this.updateRange();
      this.updateTooltip(handle);
    },


    /**
     * Decreases the value of one of the slider handles, accounting for step value, percentage, etc.
     * Also visually updates the handle on the visual part of the slider.
     * @param {jQuery.Event} e jQuery `click` or `keydown` event.
     * @param {jQuery[]} handle element representing a slider handle.
     * @param {number} [value] - target value - will be automatically determined if not passed.
     * @param {number} [decrement] - an integer that will be used as the amount to decrement.
     */
    decreaseValue: function decreaseValue(e, handle, value, decrement) {
      e.preventDefault();
      clearTimeout(handle.data('animationTimeout'));

      var val = this.value();
      var decrementBy = decrement !== undefined ? decrement : this.settings.step !== undefined ? this.settings.step : 1; //eslint-disable-line
      var testVal = void 0;
      var updatedVal = void 0;
      var finalVal = void 0;

      if (handle.hasClass('higher')) {
        testVal = value !== undefined ? value : val[1];
        var minValue = val[0] === undefined ? this.settings.min : val[0];
        decrementBy = isInt(testVal) ? decrementBy : isNaN(testVal % decrementBy) ? 0 : decrementBy - testVal % decrementBy; //eslint-disable-line
        updatedVal = testVal - decrementBy > minValue ? testVal - decrementBy : minValue;
        finalVal = updatedVal % decrementBy ? updatedVal : roundToIncrement(updatedVal, decrementBy);
        this.value([undefined, finalVal]);
      } else {
        testVal = value !== undefined ? value : val[0];
        decrementBy = isInt(testVal) ? decrementBy : isNaN(testVal % decrementBy) ? 0 : testVal % decrementBy; //eslint-disable-line
        updatedVal = testVal - decrementBy > this.settings.min ? testVal - decrementBy : this.settings.min;
        finalVal = updatedVal % decrementBy ? updatedVal : roundToIncrement(updatedVal, decrementBy);
        this.value([finalVal]);
      }
      this.checkHandleDifference(handle, testVal, finalVal);
      this.updateRange();
      this.updateTooltip(handle);
    },


    /**
     * Changes the position of the bar and handles based on their values.
     * @private
     */
    updateRange: function updateRange() {
      var self = this;
      var newVal = this.value();
      var percentages = [];
      var color = this.getColorClosestToValue();
      var isVertical = self.wrapper.hasClass('vertical');

      for (var i = 0; i < this.ticks.length; i++) {
        var condition = !this.settings.range ? this.ticks[i].value <= newVal[0] : newVal[0] < this.ticks[i].value && this.ticks[i].value <= newVal[1];

        if (condition) {
          this.ticks[i].element.addClass('complete');
          if (color) {
            this.ticks[i].element[0].style.backgroundColor = color;
            this.ticks[i].element.addClass('inherit');
          }
        } else {
          this.ticks[i].element.removeClass('complete');
          if (color) {
            this.ticks[i].element[0].style.backgroundColor = '';
            this.ticks[i].element.removeClass('inherit');
          }
        }
      }

      if (color) {
        this.range[0].style.backgroundColor = color;
        $.each(this.handles, function (i, handle) {
          handle[0].style.backgroundColor = color;
          handle[0].style.borderColor = color;
        });
      }

      // Remove any text colors that already existed.
      $.each(self.ticks, function (i) {
        self.ticks[i].label[0].style.color = '';
      });

      // Convert the stored values from ranged to percentage
      percentages[0] = this.convertValueToPercentage(newVal[0]);
      if (newVal[1] !== undefined) {
        percentages[1] = this.convertValueToPercentage(newVal[1]);
      }

      function getPosAttrs() {
        if (isVertical) {
          return ['bottom', 'top'];
        }
        if (self.isRtlHorizontal) {
          return ['right', 'left'];
        }
        return ['left', 'right'];
      }

      var posAttrs = getPosAttrs();
      var cssProps = {};

      // If no arguments are provided, update both handles with the latest stored values.
      if (!this.handles[1]) {
        cssProps[posAttrs[0]] = '0%';
        cssProps[posAttrs[1]] = 100 - percentages[0] + '%';
      } else {
        cssProps[posAttrs[0]] = percentages[0] + '%';
        cssProps[posAttrs[1]] = 100 - percentages[1] + '%';
      }
      this.range.css(cssProps);

      function positionHandle(handle, percentage) {
        var basePosition = isVertical ? posAttrs[1] : posAttrs[0];
        var realPercentage = isVertical ? 100 - percentage : percentage;

        handle.css(basePosition, 'calc(' + realPercentage + '% - ' + handle.outerWidth() / 2 + 'px)');
      }

      if (this.handles[0].hasClass('is-animated')) {
        this.handles[0].data('animationTimeout', setTimeout(function () {
          self.handles[0].removeClass('is-animated').trigger('slide-animation-end');
          self.range.removeClass('is-animated');
        }, 201));
      }
      positionHandle(this.handles[0], percentages[0]);

      if (this.handles[1]) {
        if (this.handles[1].hasClass('is-animated')) {
          this.handles[1].data('animationTimeout', setTimeout(function () {
            self.handles[1].removeClass('is-animated').trigger('slide-animation-end');
            self.range.removeClass('is-animated');
          }, 201));
        }
        positionHandle(this.handles[1], percentages[1]);

        // update the 'aria-valuemin' attribute on the Max handle, and the 'aria-valuemax'
        // attribute on the Min handle for better screen reading compatability
        this.handles[0].attr('aria-valuemax', newVal[1]);
        this.handles[1].attr('aria-valuemin', newVal[0]);
      }
    },


    /**
     * Allows a handle to animate to a new position if the difference in value is greater
     *  than 3% of the size of the range.
     * @private
     * @param {jQuery[]} handle element representing a slider handle
     * @param {number} originalVal the value before it was modified
     * @param {number} updatedVal the target value
     */
    checkHandleDifference: function checkHandleDifference(handle, originalVal, updatedVal) {
      // IE9 doesn't support animation so return immediately.
      if ($('html').hasClass('ie9')) {
        return;
      }
      var origPercent = this.convertValueToPercentage(originalVal);
      var updatedPercent = this.convertValueToPercentage(updatedVal);

      if (Math.abs(origPercent - updatedPercent) > 3) {
        handle.addClass('is-animated');
        this.range.addClass('is-animated');
      }
    },


    /**
     * If tooltips are active, updates the current placement and content of the Tooltip.
     * If no handle argument is passed, this method simply hides both handles' tooltips.
     * @param {jQuery[]} [handle] element representing a slider handle.
     */
    updateTooltip: function updateTooltip(handle) {
      if (!this.settings.tooltip) {
        return;
      }

      if (!handle) {
        var tooltipLow = this.handles[0].data('tooltip');
        var tooltipHigh = void 0;

        if (this.handles[1]) {
          tooltipHigh = this.handles[1].data('tooltip');
        }

        tooltipLow.hide();
        if (tooltipHigh) {
          tooltipHigh.hide();
        }

        return;
      }

      var tooltip = handle.data('tooltip');

      function update() {
        tooltip.position();
        handle.focus();
      }

      // NOTE: This is a bit hacky because it depends on the setTimeout() method for
      // animation that is triggered inside the self.updateRange() method to have not
      // fired yet.  If you put a breakpoint anywhere in there you may see strange
      // results with animation.
      if (handle.hasClass('is-animated')) {
        tooltip.hide();
        handle.one('slide-animation-end', function () {
          update();
        });
      } else {
        update();
      }
    },


    /**
     * Gets a string-based hex value for the closest tick's defined color.
     * @private
     * @returns {string} hex value representing a color
     */
    getColorClosestToValue: function getColorClosestToValue() {
      var currentTheme = exports.theme;
      var preColors = {
        light: {
          default: '#000000',
          'very-poor': '#a13030',
          poor: '#d66221',
          adequate: '#f2bc41',
          good: '#9cce7c',
          'very-good': '#76b051',
          superior: '#488421'
        },
        dark: {
          default: '#ffffff',
          'very-poor': '#a13030',
          poor: '#d66221',
          adequate: '#f2bc41',
          good: '#9cce7c',
          'very-good': '#76b051',
          superior: '#488421'
        },
        'high-contrast': {
          default: '#000000',
          'very-poor': '#a13030',
          poor: '#d66221',
          adequate: '#e4882b',
          good: '#76b051',
          'very-good': '#56932e',
          superior: '#397514'
        }
      };

      var themeColors = preColors[currentTheme];
      var val = this.value()[0];
      var highestTickColor = void 0;
      var c = void 0;

      for (var i = 0; i < this.ticks.length; i++) {
        c = this.ticks[i].color;
        if (c && val >= this.ticks[i].value) {
          highestTickColor = c;
          highestTickColor = c.indexOf('#') > -1 ? c : themeColors[c] || themeColors.default;
        }
      }

      return highestTickColor;
    },


    /**
     * External Facing Function to set the value. Works as percent for now but need it on ticks.
     * NOTE:  Does not visually update the range.  Use _setValue()_ to do both in one swoop.
     * @param {number} minVal the smaller handle's value
     * @param {number} [maxVal] the larger handle's value, if applicable
     * @returns {array} both currently set handle values
     */
    value: function value(minVal, maxVal) {
      var self = this;

      // if both options are absent, act as a getter and return the current value
      if (minVal === undefined && maxVal === undefined) {
        return self._value;
      }

      // if an array is passed as the first argument, break it apart
      if (minVal && $.isArray(minVal)) {
        if (minVal[1] !== undefined) {
          maxVal = minVal[1];
        }
        minVal = minVal[0];
      }

      // set the values back to the existing one if they aren't passed.
      if (minVal === undefined && $.isArray(self._value) && self._value[0] !== undefined) {
        minVal = self._value[0];
      }
      if (maxVal === undefined && $.isArray(self._value) && self._value[1] !== undefined) {
        maxVal = self._value[1];
      }

      // set the internal value and the element's retrievable value.
      self._value = [minVal, maxVal];
      self.element.val(maxVal !== undefined ? self._value : self._value[0]);
      $.each(self.handles, function (i, handle) {
        var value = self._value[i];
        var valueText = self.getModifiedTextValue(value);

        $.each(self.ticks, function (a, tick) {
          if (tick.value === value) {
            valueText = tick.description;
          }
        });

        handle.attr({
          'aria-valuenow': self._value[i],
          'aria-valuetext': valueText
        });
      });

      self.element.trigger('change');
      return self._value;
    },


    /**
     * Returns a value with prefixed/suffixed text content.
     * Used by the tooltip and default ticks to get potential identifiers like $ and %.
     * @private
     * @param {string} content the original tooltip content
     * @returns {string} prepended/appended text that will be displayed inside the tooltip
     */
    getModifiedTextValue: function getModifiedTextValue(content) {
      if (!this.settings.tooltip) {
        return content;
      }
      return this.settings.tooltip[0] + content + this.settings.tooltip[1];
    },


    /**
     * Enables the slider instance.
     * @returns {this} component instance
     */
    enable: function enable() {
      this.element.prop('disabled', false);
      this.element.prop('readonly', false);
      this.wrapper.removeClass('is-readonly');
      this.wrapper.removeClass('is-disabled');

      var self = this;
      $.each(this.handles, function (i, handle) {
        self.enableHandleDrag(handle);
      });

      return this;
    },


    /**
     * Disables the slider instance.
     * @returns {this} component instance
     */
    disable: function disable() {
      this.element.prop('disabled', true);
      this.element.prop('readonly', false);
      this.wrapper.removeClass('is-readonly');
      this.wrapper.addClass('is-disabled');

      var self = this;
      $.each(this.handles, function (i, handle) {
        self.disableHandleDrag(handle);
      });

      return this;
    },


    /**
     * Sets the slider in a readonly state
     * @returns {this} component instance
     */
    readonly: function readonly() {
      var _this = this;

      this.element.prop('disabled', true);
      this.element.prop('readonly', true);
      this.wrapper.removeClass('is-disabled');
      this.wrapper.addClass('is-readonly');

      $.each(this.handles, function (i, handle) {
        _this.disableHandleDrag(handle);
      });

      return this;
    },


    /**
     * Detects whether or not this slider is disabled
     * @returns {boolean} whether or not this slider is disabled
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
     * Detects whether or not this slider is vertical
     * @returns {boolean} whether or not this slider is vertical
     */
    isVertical: function isVertical() {
      return this.wrapper.hasClass('vertical');
    },


    /**
     * Externally-facing function that updates the current values and correctly
     * animates the range handles, if applicable.
     * @param {number} lowVal the value for the lower slider handle.
     * @param {number} [highVal] the value for the upper slider handle, if applicable.
     * @returns {array} the newly set values
     */
    setValue: function setValue(lowVal, highVal) {
      var oldVals = this.value();

      this.checkHandleDifference(this.handles[0], oldVals[0], lowVal);
      if (this.handles[1]) {
        this.checkHandleDifference(this.handles[1], oldVals[1], highVal);
      }

      var vals = this.value(lowVal, highVal);
      this.updateRange();
      this.updateTooltip();

      return vals;
    },


    /**
     * replaced with `setValue()`
     * @private
     * @deprecated in v4.2.0
     * @param {number} lowVal the value for the lower slider handle.
     * @param {number} [highVal] the value for the upper slider handle, if applicable.
     * @returns {array} the newly set values
     */
    refresh: function refresh(lowVal, highVal) {
      return this.setValue(lowVal, highVal);
    },


    /**
     * Updates the slider instance after a settings change.
     * Settings and markup are complicated in the slider so we just destroy and re-invoke it
     * with fresh settings.
     * @param {object|function} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.element.removeAttr('value');
      return this.teardown().init();
    },


    /**
     * Removes the events and pseudo-markup created by the slider
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      var self = this;
      $.each(self.handles, function (i, handle) {
        self.disableHandleDrag(handle);
        handle.off('mousedown.slider click.slider blur.slider keydown.slider keyup.slider');
      });
      this.wrapper.off('click.slider touchend.slider touchcancel.slider').remove();
      this.element.attr('type', this.originalElement.type);

      return this;
    },


    /**
     * Destroys the slider component instance and unlinks it from its base element.
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$V);
    },


    /**
     * Handle component events.
     * @private
     * @returns {void}
     */
    bindEvents: function bindEvents() {
      var self = this;

      $.each(self.handles, function (i, handle) {
        handle.on('mousedown.slider', function () {
          if (self.isDisabled()) {
            return;
          }
          $(this).focus();
        }).on('click.slider', function (e) {
          e.preventDefault(); // Prevent from jumping to top.
        }).on('keydown.slider', function (e) {
          self.activateHandle(handle);
          self.handleKeys(e, self);
        }).on('keyup.slider blur.slider', function () {
          self.deactivateHandle(handle);
        });

        self.enableHandleDrag(handle);
      });

      self.wrapper.on('click.slider touchend.slider touchcancel.slider', function (e) {
        self.handleRangeClick(e);
      });

      // Slider Control listens to 'updated' trigger on its base element to update values
      self.element.on('updated.slider', function () {
        self.updated();
      });

      return self;
    }
  };

  /**
   * jQuery Component Wrapper for Slider
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.slider = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$V);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$V, new Slider(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$W = 'spinbox';

  // Component Defaults
  var SPINBOX_DEFAULTS = {
    autocorrectOnBlur: false,
    min: -2147483647,
    max: 2147483647,
    step: null,
    validateOnInput: true
  };

  /**
   * The Spinbox component provides easy access to modification of a numeric input field.
   * @class Spinbox
   * @constructor
   * @param {jQuery[]|HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   * @param {boolean} [settings.autocorrectOnBlur = false] If true the input will adjust to the nearest step on blur.
   * @param {Number} [settings.min = -2147483647] if defined, provides a minimum numeric limit
   * @param {Number} [settings.max = 2147483647]  if defined, provides a maximum numeric limit
   * @param {null|Number} [settings.step = null]  if defined, increases or decreases the spinbox value
   *  by a specific interval whenever the control buttons are used.
   * @param {boolean} [settings.validateOnInput = true]  If set to false, will only automatically correct
   *  the spinbox value after the spinbox has lost focus.
   */
  function Spinbox(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, SPINBOX_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Spinbox.prototype = {

    /**
     * @private
     */
    init: function init() {
      this.inlineLabel = this.element.closest('label');
      this.inlineLabelText = this.inlineLabel.find('.label-text');
      this.isInlineLabel = this.element.parent().is('.inline');
      this.isWrapped = this.element.parent().is('.spinbox-wrapper');

      this.setInitialValue().addMarkup().bindEvents().setWidth();
    },


    /**
     * Sets the width of the spinbox input field.
     * @private
     * @returns {this} component instance
     */
    setWidth: function setWidth() {
      var style = this.element[0].style;

      if (style.width) {
        this.element.parent()[0].style.width = parseInt(style.width, 10) + this.element.parent().find('.down').outerWidth() * 2 + 'px';
      }

      return this;
    },


    /**
     * Sanitize the initial value of the input field.
     * @private
     * @returns {this} component instance
     */
    setInitialValue: function setInitialValue() {
      var self = this;
      var val = self.checkForNumeric(self.element.val());

      this.element.val(val);
      // If using Dirty Tracking, reset the "original" value of the dirty tracker to the current value
      // of the input, since it may have changed after re-invoking the input field.
      if (this.element.attr('data-trackdirty')) {
        this.element.data('original', val);
      }

      // allow numeric input on iOS
      var iOS = /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
      if (iOS) {
        this.element.attr('pattern', '\\d*');
      }

      if (this.element.attr('max')) {
        this.settings.max = this.element.attr('max');
      } else if (this.settings.max) {
        this.element.attr('max', this.settings.max);
      }

      if (this.element.attr('step')) {
        this.settings.max = this.element.attr('step');
      } else if (this.settings.step) {
        this.element.attr('step', this.settings.step);
      }

      if (this.element.attr('min')) {
        this.settings.max = this.element.attr('min');
      } else if (this.settings.min) {
        this.element.attr('min', this.settings.min);
      }

      return this;
    },


    /**
     * Appends extra control markup to a Spinbox field.
     * @private
     * @returns {this} component instance
     */
    addMarkup: function addMarkup() {
      var self = this;
      if (this.isInlineLabel) {
        this.inlineLabel.addClass('spinbox-wrapper');
      } else if (!this.isWrapped) {
        var spinboxWrapper = '<span class="spinbox-wrapper"></span>';
        if (this.element.is('.field-options')) {
          var field = this.element.closest('.field');
          var fieldOptionsTrigger = field.find('.btn-actions');

          this.element.add(fieldOptionsTrigger).add(fieldOptionsTrigger.next('.popupmenu')).wrapAll(spinboxWrapper);
        } else {
          this.element.wrap(spinboxWrapper);
        }
      }

      this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

      if (this.isWrapped) {
        this.buttons = {
          down: this.element.parent().find('.down').button(),
          up: this.element.parent().find('.up').button()
        };

        if (this.isTouch) {
          this.buttons.down.attr('aria-hidden', 'true');
          this.buttons.up.attr('aria-hidden', 'true');
        }
      }

      if (!this.buttons) {
        this.buttons = {
          down: $('<span ' + (this.isTouch ? '' : 'aria-hidden="true"') + ' class="spinbox-control down">-</span>').insertBefore(this.element).button(),
          up: $('<span ' + (this.isTouch ? '' : 'aria-hidden="true"') + ' class="spinbox-control up">+</span>').insertAfter(this.element).button()
        };
      }

      // Figure out minimum/maximum and data-masking attributes.  The user can provide the spinbox
      // plugin either the min/max or the mask, and the plugin will automatically figure out how to
      // use them.
      var min = this.element.attr('min');
      var max = this.element.attr('max');
      var mask = this.element.attr('data-mask');
      var maskValue = '';
      var attributes = {
        role: 'spinbutton'
      };
      var i = 0;

      // Define a default Max value if none of these attributes exist, to ensure the mask plugin will
      // work correctly.  Cannot define a Min value here because the plugin must be able to invoke
      // itself with a NULL value.
      if (!min && !max && !mask) {
        max = '9999999';
      }

      // If a mask doesn't exist, but min and max values do exist, create a mask that reflects
      // those min/max values
      if ((min || max) && !mask) {
        var newMask = '';
        var tempMin = min || '';
        var tempMax = max || '';
        var longerVal = tempMin.length > tempMax.length ? tempMin : tempMax;
        i = 0;

        while (i <= longerVal.length) {
          newMask += '#';
          i++;
        }

        // Add a negative symbol to the mask if it exists within the longer value.
        if (tempMin.indexOf('-') !== -1 || tempMax.indexOf('-') !== -1) {
          newMask = '-' + newMask.substring(0, newMask.length - 1);
        }

        attributes['data-mask'] = newMask;
        mask = newMask;
      }

      // If a "data-mask" attribute is already defined, use it to determine missing values
      // for min/max, if they don't already exist.
      var maskSize = mask.length;

      i = 0;
      while (i <= maskSize) {
        maskValue += '9';
        i++;
      }

      // If no negative symbol exists in the mask, the minimum value must be zero.
      if (mask.indexOf('-') === -1) {
        attributes.min = min || 0;
        attributes.max = max || maskValue;
      } else {
        attributes.min = min || maskValue;
        attributes.max = max || maskValue.substring(0, maskValue.length - 1);
      }

      if (!this.element.attr('data-mask-mode') || this.element.attr('data-mask-mode') !== 'number') {
        attributes['data-mask-mode'] = 'number';
      }

      // Destroy the Mask Plugin if it's already been invoked.  We will reinvoke it later
      // on during initialization.  Check to make sure its the actual Mask plugin object,
      // and not the "data-mask" pattern string.
      if (this.element.data('mask') && _typeof(this.element.data('mask')) === 'object') {
        this.element.data('mask').destroy();
      }

      // Add Aria Properties for valuemin/valuemax
      attributes['aria-valuemin'] = min || 0;
      attributes['aria-valuemax'] = max || 0;
      this.element.attr(attributes);

      // Set an initial "aria-valuenow" value.
      this.updateAria(self.element.val());

      // Invoke the mask plugin
      this.element.mask();

      // Disable in full if the settings have determined we need to disable on init.
      if (this.isDisabled()) {
        this.disable();
      }

      if (this.element.attr('readonly')) {
        this.readonly();
      }

      return this;
    },


    /**
     * Enables Long Pressing one of the Spinbox control buttons.
     * @private
     * @param {jQuery.Event} e jQuery `touchstart` or `mousedown` events
     * @param {Spinbox} self this component instance
     * @returns {void}
     */
    enableLongPress: function enableLongPress(e, self) {
      self.addButtonStyle(e);
      self.longPressInterval = setInterval(function () {
        if ($(e.currentTarget).is(':hover')) {
          self.handleClick(e);
        }
      }, 140);
    },


    /**
     * Disables Long Pressing one of the Spinbox control buttons.
     * @private
     * @param {jQuery.Event} e jQuery `touchend` or `mouseup` events
     * @param {Spinbox} self this component instance
     * @returns {void}
     */
    disableLongPress: function disableLongPress(e, self) {
      self.removeButtonStyle(e);
      clearInterval(self.longPressInterval);
      self.longPressInterval = null;
    },


    /**
     * Event handler for 'click' events
     * @private
     * @param {jQuery.Event} e jQuery `click` event
     * @returns {void}
     */
    handleClick: function handleClick(e) {
      if (this.isDisabled() || e.which !== 1 || this.isReadonly()) {
        return;
      }
      var target = $(e.currentTarget);
      if (target.hasClass('up')) {
        this.increaseValue();
      } else {
        this.decreaseValue();
      }

      if (!this.isTouch) {
        this.element.focus();
      } else {
        target.focus();
      }
    },


    /**
     * Event handler for 'keydown' events
     * @private
     * @param {jQuery.Event} e jQuery `keydown` event
     * @param {Spinbox} self component instance
     */
    handleKeyDown: function handleKeyDown(e, self) {
      var key = e.which;
      var validKeycodes = [35, 36, 37, 38, 39, 40];

      if ($.inArray(key, validKeycodes) === -1) {
        return;
      }

      if (this.isReadonly()) {
        return;
      }

      // If the keycode got this far, it's an arrow key, HOME, or END.
      switch (key) {
        case 35:
          // End key sets the spinbox to its minimum value
          if (self.element.attr('min')) {
            self.element.val(self.element.attr('min'));
          }
          break;
        case 36:
          // Home key sets the spinbox to its maximum value
          if (self.element.attr('max')) {
            self.element.val(self.element.attr('max'));
          }
          break;
        case 38:
          // Up increases the spinbox value
          self.addButtonStyle(self.buttons.up);
          self.increaseValue();
          break;
        case 40:
          // Down decreases the spinbox value
          self.addButtonStyle(self.buttons.down);
          self.decreaseValue();
          break;
        default:
          break;
      }
    },


    /**
     * Event handler for 'keypress' events
     * TODO: Deprecate in 4.4.0
     * @private
     * @param {jQuery.Event} e jQuery `keypress` event
     * @param {Spinbox} self component instance
     * @returns {void}
     */
    handleKeyPress: function handleKeyPress(e, self) {
      var key = e.which;

      // NOTE:
      if (key < 48 || key > 57 && key < 96 || key > 105) {
        return undefined;
      }

      return this.handleInput(e, self);
    },


    /**
     * Event handler for the 'input' event
     * @private
     * @param {jQuery.Event} e jQuery `input` event
     * @param {Spinbox} self this component instance
     * @returns {void}
     */
    handleInput: function handleInput(e, self) {
      if (self.isDisabled() || this.isReadonly()) {
        return undefined;
      }

      // If we're only auto-correcting on blur, don't continue.
      if (this.settings.autocorrectOnBlur) {
        return undefined;
      }

      return this.correctValue(e);
    },


    /**
     * Event handler for 'keyup' events
     * @private
     * @param {jQuery.Event} e jQuery `input` event
     * @param {Spinbox} self this component instance
     * @returns {void}
     */
    handleKeyup: function handleKeyup(e, self) {
      if (self.isDisabled() || this.isReadonly()) {
        return;
      }
      var key = e.which;

      // Spinbox Control Button styles are added/removed on keyup.
      switch (key) {
        case 38:case 39:
          if (Locale.isRTL() && key === 39) {
            self.removeButtonStyle(self.buttons.down);
          } else {
            self.removeButtonStyle(self.buttons.up);
          }
          break;
        case 37:case 40:
          if (Locale.isRTL() && key === 39) {
            self.removeButtonStyle(self.buttons.up);
          } else {
            self.removeButtonStyle(self.buttons.down);
          }
          break;
        default:
          break;
      }

      self.updateAria(self.element.val());
    },


    /**
     * Change a newly pasted value to this element's min or max values, if the pasted
     * value goes beyond either of those limits.  Listens to an event emitted by the
     * Mask plugin after pasted content is handled.
     * @private
     * @param {Spinbox} self this component instance
     * @returns {void}
     */
    handleAfterPaste: function handleAfterPaste(self) {
      var min = Number(self.element.attr('min'));
      var max = Number(self.element.attr('max'));
      var val = Number(self.element.val());

      if (val < min) {
        val = min;
      }
      if (val > max) {
        val = max;
      }

      self.updateVal(val);
    },


    /**
     * Fixes a value that may have been entered programmatically, or by paste,
     * if it goes out of the range boundaries.
     * @private
     * @param {jQuery.Event} e jQuery `input` event
     * @returns {void}
     */
    correctValue: function correctValue(e) {
      var num = Number(this.element.val());
      var min = this.element.attr('min');
      var max = this.element.attr('max');

      if (num < min) {
        if (e) {
          e.preventDefault();
        }
        return this.updateVal(min);
      }
      if (num > max) {
        if (e) {
          e.preventDefault();
        }
        return this.updateVal(max);
      }
      return undefined;
    },


    /**
     * Increases the value of the Spinbox field, constrained by the step interval and maximum limit.
     * @returns {void}
     */
    increaseValue: function increaseValue() {
      var max = this.element.attr('max');
      var val = this.checkForNumeric(this.element.val()) + Number(this.element.attr('step') || 1);

      if (max && val > max) {
        return this.updateVal(max);
      }
      return this.updateVal(val);
    },


    /**
     * Decreases the value of the Spinbox field, constrained by the step interval and minimum limit.
     * @returns {void}
     */
    decreaseValue: function decreaseValue() {
      var min = this.element.attr('min');
      var val = this.checkForNumeric(this.element.val()) - Number(this.element.attr('step') || 1);

      if (min && val < min) {
        return this.updateVal(min);
      }
      return this.updateVal(val);
    },


    /**
     * Sets a new spinbox value and focuses the spinbox.
     * @param {Number|String} newVal the value to set on the spinbox
     * @returns {void}
     */
    updateVal: function updateVal(newVal) {
      this.element.val(newVal).trigger('change');
      this.updateAria(newVal);
      this.element.focus();
    },


    /**
     * Sanitizes the value of the input field to an integer if it isn't already established.
     * @private
     * @param {Number|String} val will be converted to a number if it's a string.
     * @returns {number} a numeric version of the value provided, or a corrected value.
     */
    checkForNumeric: function checkForNumeric(val) {
      // Allow for NULL
      if (val === '') {
        return val;
      }
      if ($.isNumeric(val)) {
        return Number(val);
      }
      val = parseInt(val, 10);
      if ($.isNumeric(val)) {
        return Number(val);
      }
      // Zero out the value if a number can't be made out of it.
      return 0;
    },


    /**
     * Updates the "aria-valuenow" property on the spinbox element if the value is currently set
     * @private
     * @param {number} val the new value to be set on the spinbox
     * @returns {void}
     */
    updateAria: function updateAria(val) {
      var min = this.element.attr('min');
      var max = this.element.attr('max');

      val = this.checkForNumeric(val);
      this.element[0].setAttribute('aria-valuenow', val || '0');

      // Toggle min/max buttons
      this.setIsDisabled(this.buttons.up, val !== '' && max && val >= max ? 'disable' : 'enable');
      this.setIsDisabled(this.buttons.down, val !== '' && min && val <= min ? 'disable' : 'enable');
    },


    /**
     * Adds a "pressed-in" styling for one of the spinner buttons.
     * @private
     * @param {jQuery.Event|jQuery[]} e either an incoming event, or a button element to be acted on
     * @returns {void}
     */
    addButtonStyle: function addButtonStyle(e) {
      if (this.isDisabled() || this.isReadonly()) {
        return;
      }
      var target = e;
      if (e.currentTarget) {
        target = $(e.currentTarget);
      }
      target.addClass('is-active');
    },


    /**
     * Removes "pressed-in" styling for one of the spinner buttons
     * @private
     * @param {jQuery.Event|jQuery[]} e either an incoming event, or a button element to be acted on
     * @returns {void}
     */
    removeButtonStyle: function removeButtonStyle(e) {
      if (this.isDisabled() || this.isReadonly()) {
        return;
      }
      var target = e;
      if (e.currentTarget) {
        target = $(e.currentTarget);
      }
      target.removeClass('is-active');
    },


    /**
     * Enables the Spinbox
     * @returns {void}
     */
    enable: function enable() {
      this.element.prop('disabled', false);
      this.element.parent('.spinbox-wrapper').removeClass('is-disabled is-readonly');
    },


    /**
     * Disables the Spinbox
     * @returns {void}
     */
    disable: function disable() {
      this.element.prop('disabled', true);
      this.element.parent('.spinbox-wrapper').addClass('is-disabled');
    },


    /**
     * Makes the Spinbox readonly
     * @returns {void}
     */
    readonly: function readonly() {
      this.element.prop('readonly', true);
      this.element.parent('.spinbox-wrapper').addClass('is-readonly');
    },


    /**
     * Checks if the Spinbox is readonly
     * @returns {void}
     */
    isReadonly: function isReadonly() {
      return this.element.prop('readonly');
    },


    /**
     * Determines whether or not the spinbox is disabled.
     * @returns {boolean} whether or not the spinbox is disabled.
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
     * Toggle whther or not the component is disabled.
     * @private
     * @param {jQuery[]} button the button element to be disabled
     * @param {booelan} [isDisabled] whether or not to force a change to the button's state.
     * @returns {void}
     */
    setIsDisabled: function setIsDisabled(button, isDisabled) {
      isDisabled = isDisabled === undefined ? true : !(!isDisabled || isDisabled === 'enable');

      button[isDisabled ? 'addClass' : 'removeClass']('is-disabled');
    },


    /**
     * Updated
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }
      return this;
    },


    /**
     * Teardown
     * @returns {void}
     */
    destroy: function destroy() {
      var mask = this.element.data('mask');
      if (mask && typeof mask.destroy === 'function') {
        mask.destroy();
      }

      for (var button in this.buttons) {
        // eslint-disable-line
        var buttonAPI = $(button).data('button');

        if (buttonAPI) {
          buttonAPI.destroy();
        }
      }

      this.buttons.up.off('click.spinbox mousedown.spinbox');
      this.buttons.up.remove();
      this.buttons.down.off('click.spinbox mousedown.spinbox');
      this.buttons.down.remove();
      this.element.off('focus.spinbox blur.spinbox keydown.spinbox keyup.spinbox');
      this.element.unwrap();
      $.removeData(this.element[0], COMPONENT_NAME$W);
    },


    /**
    *  Fires when the input gains focus.
    * @event focus
    * @memberof Spinbox
    * @property {object} event - The jquery event object
    */
    /**
     * Fires when the input looses focus.
     * @event blur
     * @memberof Spinbox
     * @property {object} event - The jquery event object
     */
    /**
      * Fires when a key is pressed down.
      * @event keydown
      * @memberof Spinbox
      * @property {object} event - The jquery event object
    */
    /**
      * Fires when a key is pressed.
      * @event keypress
      * @memberof Spinbox
      * @property {object} event - The jquery event object
    */
    /**
      * Fires when a key is pressed up.
      * @event keyup
      * @memberof Spinbox
      * @property {object} event - The jquery event object
    */
    /**
      * Fires after input is pasted in.
      * @event afterpaste
      * @memberof Spinbox
      * @property {object} event - The jquery event object
    */

    /**
     * Sets up event handlers for this control and its sub-elements
     * @private
     * @returns {void}
     */
    bindEvents: function bindEvents() {
      var self = this;
      var preventClick = false;

      // Main Spinbox Input
      this.element.on('focus.spinbox', function () {
        self.element.parent('.spinbox-wrapper').addClass('is-focused');
      }).on('blur.spinbox', function () {
        self.element.parent('.spinbox-wrapper').removeClass('is-focused');
        if (self.settings.autocorrectOnBlur) {
          self.correctValue();
        }
      }).on('keydown.spinbox', function (e) {
        self.handleKeyDown(e, self);
      }).on('input.spinbox', function (e) {
        self.handleInput(e, self);
      }).on('keyup.spinbox', function (e) {
        self.handleKeyup(e, self);
      }).on('afterpaste.mask', function () {
        self.handleAfterPaste(self);
      });

      // Up and Down Buttons
      var buttons = this.buttons.up.add(this.buttons.down[0]);
      buttons.on('touchstart.spinbox mousedown.spinbox', function (e) {
        if (e.which === 1) {
          if (!preventClick) {
            self.handleClick(e);
          }

          if (self.isTouch) {
            return;
          }

          preventClick = true;
          self.enableLongPress(e, self);

          $(document).one('mouseup', function () {
            self.disableLongPress(e, self);
            preventClick = false;
            self.element.focus();
          });

          // Stop MouseDown From Running
          if (this.isTouch) {
            e.preventDefault();
            e.stopPropagation();
          }
        }
      });

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Spinbox
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.spinbox = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$W);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$W, new Spinbox(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$X = 'splitter';

  // Default Splitter Options
  var SPLITTER_DEFAULTS = {
    axis: 'x',
    side: 'left', // or right
    resize: 'immediate',
    containment: null, // document or parent
    save: true,
    maxWidth: {
      left: 'auto',
      right: 'auto'
    }
  };

  /**
  * Splitter Component
  * @class Splitter
  * @constructor
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  * @param {string} [settings.axis = 'x'] The axis on which to split x or y
  * @param {string} [settings.side = 'left'] Which side to dock to 'left' or 'right'.
  * @param {string} [settings.resize = 'immediate'] When to resize, during the drag 'immediate' or 'end'
  * @param {HTMLElement|jQuery[]} [settings.containment = null] When to stop the splitter, this can be document, or a parent element
  * @param {boolean} [settings.save = true] If true the split size will automatically be saved for next time
  * @param {object} [settings.maxWidth = {left: 'auto', right: 'auto'}] Ability to stop dragging at a max left or right size.
  */
  function Splitter(element, settings) {
    this.settings = utils.mergeSettings(element, settings, SPLITTER_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Splitter.prototype = {

    /**
     * Do other init (change/normalize settings, load externals, etc)
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      return this.build().handleEvents();
    },


    /**
     * Build the Control and Events
     * @private
     * @returns {void}
     */
    build: function build() {
      var self = this;
      var s = this.settings;
      var splitter = this.element;
      var parent = splitter.parent();
      var direction = s.axis === 'x' ? 'left' : 'top';
      var thisSide = parent.is('.content') ? parent.parent() : parent;
      var defaultOffset = 299;
      var w = parent.width();
      var parentHeight = void 0;

      setTimeout(function () {
        parentHeight = parent.height();
      }, 0);

      this.docBody = $('body');
      this.isSplitterRightSide = splitter.is('.splitter-right') || s.axis === 'x' && s.side === 'right';
      this.isSplitterHorizontal = splitter.is('.splitter-horizontal') || s.axis === 'y';
      s.uniqueId = utils.uniqueId(this.element, 'splitter');

      if (this.isSplitterRightSide) {
        var thisPrev = thisSide.prev();
        if (thisPrev.is('.main')) {
          this.leftSide = thisPrev;
          w = thisSide.parent().outerWidth() - w;
        } else {
          this.leftSide = thisSide;
          splitter.addClass('splitter-right');
        }

        thisSide.addClass('is-right-side').next().addClass('flex-grow-shrink is-right-side').parent().addClass('splitter-container');

        if (s.collapseButton) {
          var savedOffset = 0;
          var $splitterButton = $('<button type="button" class="splitter-btn" id="splitter-collapse-btn" title="Collapse"><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-double-chevron"></use></svg></button>');
          $splitterButton.appendTo(splitter);
          if (splitter[0].offsetLeft > 10) {
            $('#splitter-collapse-btn').addClass('rotate');
          }
          $('#splitter-collapse-btn').click(function () {
            if (savedOffset <= 0) {
              if (splitter[0].offsetLeft <= 10) {
                self.splitTo(defaultOffset, parentHeight);
                $(this).addClass('rotate');
              } else {
                savedOffset = splitter[0].offsetLeft;
                self.splitTo(0, parentHeight);
                $(this).removeClass('rotate');
              }
            } else if (splitter[0].offsetLeft > 10) {
              savedOffset = splitter[0].offsetLeft;
              self.splitTo(0, parentHeight);
              $(this).removeClass('rotate');
            } else {
              self.splitTo(savedOffset, parentHeight);
              $(this).addClass('rotate');
              savedOffset = 0;
            }
          });
        }
      } else if (this.isSplitterHorizontal) {
        this.topPanel = splitter.prev();
        w = this.topPanel.height();

        parent.addClass('splitter-container is-horizontal');
        splitter.next().addClass('flex-grow-shrink');
        splitter.addClass('splitter-horizontal');
      } else {
        this.rightSide = thisSide;
        this.leftSide = thisSide.prev().parent();

        thisSide.prev().addClass('flex-grow-shrink').parent().addClass('splitter-container');
      }

      // Restore from local storage
      if (localStorage && s.save && !isNaN(parseInt(localStorage[s.uniqueId], 10))) {
        w = localStorage[s.uniqueId];
      }

      w = parseInt(w, 10);

      if (this.isSplitterHorizontal) {
        splitter[0].style.top = w + 'px';
      } else {
        splitter[0].style.top = 0;
      }

      this.splitTo(w, parentHeight);

      // Add the Splitter Events
      this.documentWidth = 0;

      this.element.drag({
        axis: s.axis,
        containment: s.containment || s.axis === 'x' ? 'document' : 'parent',
        containmentOffset: { left: 20, top: 0 }
      }).on('dragstart.splitter', function () {
        var iframes = $('iframe');
        self.documentWidth = $(document).width();

        if (iframes.length > 0) {
          for (var i = 0, l = iframes.length; i < l; i++) {
            var frame = $(iframes[i]);
            // eslint-disable-next-line
            var width = parseInt(getComputedStyle(frame.parent()[0]).width, 10) - 40 + 'px';
            var overlay = $('<div class="overlay splitter-overlay"></div>');
            overlay.css('width', width);
            frame.before(overlay);
          }
        }
      }).on('dragend.splitter', function (e, args) {
        $('.overlay').remove();

        if (s.collapseButton) {
          if (args[direction] <= 10) {
            $('#splitter-collapse-btn').removeClass('rotate');
          } else {
            $('#splitter-collapse-btn').addClass('rotate');
          }
        }

        if (s.resize === 'end') {
          self.splitTo(args[direction], parentHeight);
        }
      }).on('drag.splitter', function (e, args) {
        if (args.left <= 0) {
          return false;
        }
        if (s.resize === 'immediate') {
          self.splitTo(args[direction], parentHeight);
        }
        return true;
      });

      // Horizontal Splitter
      if (s.axis === 'y') {
        this.element.addClass('splitter-horizontal');
      }

      // Aria
      this.element.attr({ 'aria-dropeffect': 'move', tabindex: '0', 'aria-grabbed': 'false' });

      return this;
    },


    /**
     * Toggle selection
     * @private
     * @returns {void}
     */
    toggleSelection: function toggleSelection() {
      this.element.toggleClass('is-dragging');
    },


    /**
     * Resize the panel vertically
     * @private
     * @param {object} splitter element.
     * @param {number} top value.
     * @param {number} parentHeight value.
     * @returns {void}
     */
    resizeTop: function resizeTop(splitter, top, parentHeight) {
      if (top > parentHeight || top < 0) {
        top = parseInt(parentHeight, 10) / 2;
      }

      this.topPanel[0].style.height = top + 'px';
    },


    /**
     * Resize the panel to the Left
     * @private
     * @param {object} splitter element.
     * @param {number} leftArg value.
     * @returns {void}
     */
    resizeLeft: function resizeLeft(splitter, leftArg) {
      var left = this.leftSide.outerWidth() - leftArg;

      // Adjust Left and Right Side
      this.rightSide[0].style.width = left + 'px';

      // Reset the Width
      splitter[0].style.left = '';
    },


    /**
     * Resize the panel to the Right
     * @private
     * @param {object} splitter element.
     * @param {number} w - width value.
     * @returns {void}
     */
    resizeRight: function resizeRight(splitter, w) {
      // Adjust Left and Right Side
      this.leftSide[0].style.width = w + 'px';
      splitter[0].style.left = w - 1 + 'px';
    },


    /**
     * Split to
     * @private
     * @param {number} split value.
     * @param {number} parentHeight value.
     * @returns {void}
     */
    splitTo: function splitTo(split, parentHeight) {
      var self = this;
      var s = this.settings;
      var splitter = this.element;

      if (this.isSplitterRightSide) {
        if (split > s.maxWidth.right) {
          split = s.maxWidth.right;
        }
        this.resizeRight(splitter, split);
      } else if (this.isSplitterHorizontal) {
        this.resizeTop(splitter, split, parentHeight);
      } else {
        if (split > s.maxWidth.left) {
          split = s.maxWidth.left;
        }
        this.resizeLeft(splitter, split);
      }

      /**
      * Fires when after the split occurs. Allowing you to sync any ui.
      * @event split
      * @memberof Splitter
      * @property {object} event The jquery event object
      * @property {number} split value
      */
      this.element.trigger('split', [split]);
      this.docBody.triggerHandler('resize', [self]);

      // Save to local storage
      if (localStorage) {
        localStorage[this.settings.uniqueId] = split;
      }

      this.split = split;
      this.parentHeight = parentHeight;
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.element.off('updated.' + COMPONENT_NAME$X);
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, SPLITTER_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
    * Destroy and remove added markup, all events
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$X);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element
      /**
      * Fires when the component updates.
      *
      * @event updated
      * @memberof Splitter
      * @type {object}
      * @property {object} event - The jquery event object
      */
      .on('updated.' + COMPONENT_NAME$X, function () {
        _this.updated();
      })

      /**
      * Fires when a key is pressed while the component is focused.
      *
      * @event keydown
      * @memberof Splitter
      * @type {object}
      * @property {object} event - The jquery event object
      */
      .on('keydown.' + COMPONENT_NAME$X, function (e) {
        // Space will toggle selection
        if (e.which === 32) {
          _this.toggleSelection();
          e.preventDefault();
        }

        if (e.which === 37) {
          _this.splitTo(_this.split - 15, _this.parentHeight);
        }

        if (e.which === 39) {
          _this.splitTo(_this.split + 15, _this.parentHeight);
        }
      });

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Splitter
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.splitter = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$X);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$X, new Splitter(this, settings));
      }
    });
  };

  // The name of this component
  var COMPONENT_NAME$Y = 'swaplist';

  // The Component Defaults
  var SWAPLIST_DEFAULTS = {
    // Searchable
    searchable: false,

    // Datasets
    available: null,
    selected: null,
    additional: null,

    // Main containers
    availableClass: '.available',
    selectedClass: '.selected',
    additionalClass: '.full-access',

    // Action buttons
    availableBtn: '.btn-moveto-selected',
    selectedBtnLeft: '.btn-moveto-left',
    selectedBtnRight: '.btn-moveto-right',
    additionalBtn: '.btn-moveto-selected',

    draggable: {
      available: true,
      selected: true,
      additional: true
    },

    // Template HTML
    template: '' + '<ul data-swap-handle=".handle">' + '{{#dataset}}' + '{{#text}}' + '<li' + '{{#value}} data-value="{{value}}"{{/value}}' + '{{#selected}} selected="selected"{{/selected}}' + '{{#disabled}} class="is-disabled"{{/disabled}}' + '>' + '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>' + '<div class="swaplist-item-content"><p>{{text}}</p></div>' + '</li>' + '{{/text}}' + '{{/dataset}}' + '</ul>'
  };

  /**
  * The SwapList Component creates a list of options that can be picked and organized.
  * @class SwapList
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {boolean} [settings.searchable = false] If true, associates itself with a Searchfield/Autocomplete
  *  and allows itself to be filtered
  * @param {array} [settings.available] An array containing items for the available bucket.
  * @param {array} [settings.selected] An array containing items for the selected bucket.
  * @param {array} [settings.additional] An array containing items for the additional bucket.
  * @param {string} [settings.availableClass = '.available'] A class name linking the available root element.
  * @param {string} [settings.selectedClass = '.selected'] A class name linking the selected root element.
  * @param {string} [settings.additionalClass = '.full-access'] A class name linking the additional root element.
  * @param {string} [settings.availableBtn = '.btn-moveto-selected'] A class name linking the available button element.
  * @param {string} [settings.selectedBtnLeft = '.btn-moveto-left'] A class name linking the move left button element.
  * @param {string} [settings.selectedBtnRight = '.btn-moveto-right'] A class name linking the move right button element.
  * @param {string} [settings.additionalBtn = '.btn-moveto-selected'] A class name linking the additional button element.
  * @param {string} [settings.template] An Html String with the mustache template for the view.
  * @param {object} [settings.draggable] An object containing boolean key/value to make container/s
  *  disable for dragging and moving items. Supported keys with draggable are "available",
  *  "selected", "additional".
  */
  function SwapList(element, settings) {
    this.settings = utils.mergeSettings(element, settings, SWAPLIST_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // SwapList Methods
  SwapList.prototype = {
    init: function init() {
      var _this = this;

      var s = this.settings;
      s.draggable = $.extend(true, SWAPLIST_DEFAULTS.draggable, s.draggable);
      this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      this.isAdditional = $(s.additionalClass + ' .listview', this.element).length > 0;

      if (this.isTouch) {
        this.element.addClass('is-touch');
      }
      this.loadListview();
      this.initDataset();
      this.setElements();
      this.isMultiSelectClass();

      setTimeout(function () {
        // Wait for Listview availability
        _this.makeDraggable();
        _this.handleEvents();
        _this.initSelected(s.availableClass);
        _this.initSelected(s.additionalClass);
      }, 0);
    },


    /**
     * Load listview
     * @private
     */
    loadListview: function loadListview() {
      var s = this.settings;
      var containers = [{ dataset: s.available, class: s.availableClass, draggable: s.draggable.available }, { dataset: s.selected, class: s.selectedClass, draggable: s.draggable.selected }, { dataset: s.additional, class: s.additionalClass, draggable: s.draggable.additional }];

      for (var i = 0, l = containers.length; i < l; i++) {
        var c = containers[i];
        var lv = $(c.class + ' .listview', this.element);
        var list = lv.data('listview');
        var options = { selectable: 'multiple', showCheckboxes: false };
        var isSearchable = (s.searchable === true || s.searchable === 'true') && $(c.class + ' .searchfield', this.element).length > 0;

        if (isSearchable) {
          options.searchable = true;
        }

        // Initialize listview
        if (!c.dataset && lv.length && $('li', lv).length) {
          lv.listview(options);
        } else if (lv.length) {
          // Remove any previous listview instance
          if (list) {
            list.destroy();
          }
          options.template = s.template;
          options.dataset = c.dataset || [];

          if (options.dataset.length === 0) {
            options.forceToRenderOnEmptyDs = true;
          }
          lv.listview(options);
        }

        // Add css class('is-not-droppable') to ul in this container
        if (!c.draggable) {
          $('ul', lv).addClass('is-not-droppable');
        }
      }
    },


    /**
     * Set elements
     * @private
     */
    setElements: function setElements() {
      var s = this.settings;
      var disabledBtnStr = '';

      this.offset = null;

      this.containers = $(s.availableClass + ',' + s.selectedClass + ',' + s.additionalClass, this.element);

      this.actionButtons = $(s.availableBtn + ',' + s.additionalBtn + ',' + s.selectedBtnLeft + ',' + s.selectedBtnRight, this.element);

      this.selectedButtons = $(s.selectedBtnLeft + ',' + s.selectedBtnRight, this.element);

      this.tabButtonsStr = s.availableBtn + ' ' + s.additionalBtn + ' ' + (this.selectedButtons.length > 1 ? s.selectedBtnRight : s.selectedBtnLeft);

      this.dragElements = 'ul:not(.is-not-droppable), ul:not(.is-not-droppable) li:not(.is-disabled)';
      this.dragStart = 'dragstart.swaplist touchstart.swaplist gesturestart.swaplist';
      this.dragEnterWhileDragging = 'dragenter.swaplist';
      this.dragOverWhileDragging = 'dragover.swaplist touchmove.swaplist gesturechange.swaplist';
      this.dragEnd = 'dragend.swaplist touchend.swaplist touchcancel.swaplist gestureend.swaplist';

      this.selections = {
        items: [],
        owner: null,
        related: null,
        droptarget: null,
        isInSelection: null,
        isHandle: null,
        placeholder: null,
        placeholderTouch: null,
        dragged: null,
        draggedIndex: null
      };

      // Dragging time placeholder
      s.numOfSelectionsClass = 'num-of-selections';
      s.itemContentClass = 'swaplist-item-content';
      s.itemContentTempl = $('<div><p><span class="' + s.numOfSelectionsClass + '">###</span> ' + (Locale ? Locale.translate('ItemsSelected') : ' Items Selected ') + '</p><div/>');

      // Make top buttons disable if not draggable
      if (!s.draggable.available) {
        disabledBtnStr = s.availableClass + ' ' + s.availableBtn + ',' + s.selectedBtnLeft;
        $(disabledBtnStr, this.element).prop('disabled', true);
      }
      if (!s.draggable.selected) {
        disabledBtnStr = s.selectedBtnLeft + ',' + s.selectedBtnRight;
        if (!s.draggable.available) {
          disabledBtnStr += ',' + s.additionalClass + ' ' + s.additionalBtn;
        }
        if (!this.isAdditional || !s.draggable.additional) {
          disabledBtnStr += ',' + s.availableClass + ' ' + s.availableBtn;
        }
        $(disabledBtnStr, this.element).prop('disabled', true);
        $(s.additionalClass + ' ' + s.additionalBtn, this.element).addClass('is-rotate');
      }
      if (!s.draggable.additional) {
        $(s.additionalClass + ' ' + s.additionalBtn + ',' + s.selectedBtnRight, this.element).prop('disabled', true);
      }
    },


    /**
     * When list is Empty force to add css class "is-multiselect"
     * @private
     */
    isMultiSelectClass: function isMultiSelectClass() {
      var s = this.settings;
      var containers = [s.availableClass, s.selectedClass, s.additionalClass];

      for (var i = 0, l = containers.length; i < l; i++) {
        var lv = $(containers[i] + ' .listview', this.element);
        if (!$('li', lv).length) {
          lv.addClass('is-multiselect');
        }
      }
    },


    /**
     * Initialize pre selected items
     * @private
     * @param {jQuery|HTMLElement} container container element
     * @returns {void}
     */
    initSelected: function initSelected(container) {
      container = this.isjQuery(container) ? container : $(container, this.element);
      if (container.length) {
        var list = $('.listview', container).data('listview');
        var selected = $('li[selected]', container);

        for (var i = 0, l = selected.length; i < l; i++) {
          var li = $(selected[i]);
          li.removeAttr('selected');
          list.select(li); // Select this item
        }
        this.moveElements(container, this.settings.selectedClass);
      }
    },


    /**
     * Move Elements
     * @private
     * @param {jQuery[]|HTMLElement} from beginning container
     * @param {jQuery[]|HTMLElement} to ending contaner
     * @returns {void}
     */
    moveElements: function moveElements(from, to) {
      if (to === null) {
        return;
      }

      from = typeof from !== 'string' ? from : $(from, this.element);
      to = typeof to !== 'string' ? to : $(to, this.element);
      var list = $('.listview', from).data('listview');

      this.clearSelections();
      this.selections.owner = from;
      this.selections.droptarget = to;

      if (this.isTouch) {
        if (list.selectedItems) {
          for (var i = 0, l = list.selectedItems.length; i < l; i++) {
            this.selections.items[i] = list.selectedItems[i].closest('li');
          }
        }
      } else {
        this.selections.items = list.selectedItems;
      }

      this.setSelectionsItems(this.selections.owner);
      this.unselectElements(list);

      if (this.selections.items.length) {
        this.selections.move = {
          items: this.selections.itemsData,
          from: this.getContainer(this.selections.itemsData)
        };
        var result = this.element.triggerHandler('beforeswap', [this.selections.move]);
        if (typeof result === 'boolean' && !result || typeof result === 'string' && result.toLowerCase() === 'false') {
          return;
        }

        var ul = $('ul', to);
        var currentSize = $('li', ul).length;
        var size = this.selections.items.length + currentSize;

        if (this.selections.items) {
          for (var _i = 0, _l = this.selections.items.length; _i < _l; _i++) {
            var val = $(this.selections.items[_i]);
            val.attr({ 'aria-posinset': currentSize + _i + 1, 'aria-setsize': size }).find('mark.highlight').contents().unwrap();
            ul.append(val);
          }
        }

        this.afterUpdate($('.listview', to).data('listview'));
        $('li:last-child', to).focus()
        // Fix: not sure why it added selected class and attribute on focus
        .removeAttr('aria-selected').removeClass('is-selected');
      }
    },


    /**
     * Get container info from given list items
     * @private
     * @param {Array} items to get container info.
     * @returns {Object} container info (jQuery container element, css-class)
     */
    getContainer: function getContainer(items) {
      var s = this.settings;

      if (_typeof(items[0]) === 'object' && items[0].node) {
        var container = items[0].node.closest('.card');
        var cssClass = '';

        if (container.is(s.availableClass)) {
          cssClass = s.availableClass;
        } else if (container.is(s.selectedClass)) {
          cssClass = s.selectedClass;
        } else if (container.is(s.additionalClass)) {
          cssClass = s.additionalClass;
        }
        return { container: container, class: cssClass };
      }
      return null;
    },


    /**
     * Un-select Elements
     * @private
     * @param {jQuery|HTMLElement} list the list
     */
    unselectElements: function unselectElements(list) {
      if (list.selectedItems) {
        for (var i = 0, l = list.selectedItems.length; i < l; i++) {
          list.select($(list.selectedItems[i]));
        }
      }
      if (list && list.element) {
        list.element.find('li').attr('aria-selected', false).removeClass('is-selected');
      }
    },


    /**
     * Detect browser support for drag-n-drop
     * @private
     * @returns {boolean} whether or not drag-n-drop is supported
     */
    isDragAndDropSupports: function isDragAndDropSupports() {
      var div = document.createElement('div');
      return 'draggable' in div || 'ondragstart' in div && 'ondrop' in div;
    },


    /**
     * Detect browser support for match-media
     * @private
     * @returns {boolean} whether or not matchMedia is supported in this browser
     */
    isMatchMediaSupports: function isMatchMediaSupports() {
      return typeof window.matchMedia !== 'undefined' || typeof window.msMatchMedia !== 'undefined';
    },


    /**
     * Detect browser viewport
     * @private
     * @returns {object} contains width and height
     */
    viewport: function viewport() {
      var e = window;
      var a = 'inner';
      if (!('innerWidth' in window)) {
        a = 'client';
        e = document.documentElement || document.body;
      }
      return { width: e[a + 'Width'], height: e[a + 'Height'] };
    },


    /**
     * Check given [max-width] is true/false
     * @private
     * @param {number} w the current page width
     * @returns {boolean} whether or not the max-width has been matched
     */
    isMaxWidth: function isMaxWidth(w) {
      return this.isMatchMediaSupports() && window.matchMedia('(max-width: ' + w + 'px)').matches || this.viewport().width <= w;
    },


    /**
     * Make Draggable
     * @private
     */
    makeDraggable: function makeDraggable() {
      var _this2 = this;

      var self = this;
      var ul = $('ul', this.element);

      if (this.isDragAndDropSupports) {
        // Use Handle if available
        this.handle = ul.first().attr('data-swap-handle');
        this.handle = $(this.handle, ul).length > 0 ? this.handle : null;
        // this.handle = (!this.isTouch && $(this.handle, ul).length > 0) ? this.handle : null;
        $(this.handle, ul).addClass('draggable').off('mousedown.swaplist touchstart.swaplist').on('mousedown.swaplist touchstart.swaplist', function () {
          _this2.selections.isHandle = true;
        }).off('mouseup.swaplist touchend.swaplist').on('mouseup.swaplist touchend.swaplist', function () {
          _this2.selections.isHandle = false;
        });

        this.targets = ul.attr({ 'aria-dropeffect': 'none' });

        this.items = $('li:not(.is-disabled)', this.element).not('a[href], img').off('selectstart.swaplist').on('selectstart.swaplist', function () {
          if (this.dragDrop) {
            this.dragDrop();
          } // ie9
          return false;
        }).end().attr({ draggable: true }).addClass(self.handle ? '' : 'draggable');
      }
    },


    /**
     * Get Element By Touch In List
     * @private
     * @param {jQuery|HTMLElement} list the list element
     * @param {number} x touch event's x coordinate
     * @param {number} y touch event's y coordinate
     * @returns {jQuery[]} component that was tapped
     */
    getElementByTouchInList: function getElementByTouchInList(list, x, y) {
      var returns = false;
      var listJq = $(list);

      for (var i = 0, l = listJq.length; i < l; i++) {
        var item = $(listJq[i]);
        var offset = item.offset();

        if (!(x <= offset.left || x >= offset.left + item.outerWidth() || y <= offset.top || y >= offset.top + item.outerHeight())) {
          returns = item;
        }
      }
      return returns;
    },


    /**
     * Drag touch element
     * @private
     * @param {jQuery.Event} e jquery-wrapped `touch` event
     * @param {jQuery[]} elm the element being dragged
     */
    draggTouchElement: function draggTouchElement(e, elm) {
      var orig = e.originalEvent.changedTouches[0];
      elm[0].style.top = orig.pageY - this.offset.y + 'px';
      elm[0].style.left = orig.pageX - this.offset.x + 'px';
    },


    /**
     * Shorctut for testing whether a modifier key is pressed
     * @private
     * @param {jQuery.Event} e the keypress event
     * @returns {boolean} whether or not a modifier key is pressed
     */
    hasModifier: function hasModifier(e) {
      return e.ctrlKey || e.metaKey || e.shiftKey;
    },


    /**
     * Applying dropeffect to the target containers
     * @private
     */
    addDropeffects: function addDropeffects() {
      if (this.targets) {
        for (var i = 0, l = this.targets.length; i < l; i++) {
          $(this.targets[i]).attr({ 'aria-dropeffect': 'move', tabindex: 0 });
        }
      }
      if (this.selections && this.selections.items) {
        for (var _i2 = 0, _l2 = this.selections.items.length; _i2 < _l2; _i2++) {
          $(this.selections.items[_i2]).attr({ 'aria-grabbed': true, tabindex: 0 });
        }
      }
    },


    /**
     * Removing dropeffect from the target containers
     * @private
     */
    clearDropeffects: function clearDropeffects() {
      this.targets.attr({ 'aria-dropeffect': 'none' }).removeAttr('tabindex');
      if (this.selections && this.selections.items) {
        for (var i = 0, l = this.selections.items.length; i < l; i++) {
          var val = $(this.selections.items[i]);
          val.removeAttr('aria-grabbed' + (!val.is(':focus') ? ' tabindex' : ''));
        }
      }
    },


    /**
     * Clear selections
     * @private
     */
    clearSelections: function clearSelections() {
      this.selections.items = [];
      this.selections.itemsData = [];
      this.selections.owner = null;
      this.selections.related = null;
      this.selections.droptarget = null;
      this.selections.isInSelection = null;
      this.selections.dragged = null;
      this.selections.placeholder = null;
      this.selections.placeholderTouch = null;
      $('ul, li', this.element).removeClass('over');
      $('#sl-placeholder-container, #sl-placeholder-touch, #sl-placeholder-touch2, #sl-placeholder').remove();
    },


    /**
     * Set selections items
     * @private
     * @param {jQuery[]|HTMLElement} container the container element
     */
    setSelectionsItems: function setSelectionsItems(container) {
      container = this.isjQuery(container) ? container : $(container, this.element);
      var nodes = $('.listview li', container);
      var dataList = this.getDataList(container);

      for (var i = 0, l = nodes.length; i < l; i++) {
        if ($(nodes[i]).is('.is-selected')) {
          this.selections.itemsData.push(dataList[i]);
        }
      }
    },


    /**
     * Init dataset
     * @private
     */
    initDataset: function initDataset() {
      var s = this.settings;
      var containers = [{ type: 'available', dataset: s.available, class: s.availableClass }, { type: 'selected', dataset: s.selected, class: s.selectedClass }, { type: 'additional', dataset: s.additional, class: s.additionalClass }];

      this.dataset = { available: [], selected: [] };
      if (this.isAdditional) {
        this.dataset.additional = [];
      }

      for (var i = 0, l = containers.length; i < l; i++) {
        var c = containers[i];
        var nodes = $(c.class + ' .listview li', this.element);

        for (var nodeIndex = 0, l2 = nodes.length; nodeIndex < l2; nodeIndex++) {
          var data = void 0;
          var value = void 0;
          var li = $(nodes[nodeIndex]);
          if (c.dataset) {
            // Make sure it's not reference pointer to data object, make copy of data
            data = JSON.parse(JSON.stringify(c.dataset[nodeIndex]));
            delete data.selected;
          } else {
            data = { text: $.trim($('.swaplist-item-content', li).text()) };
            value = li.attr('data-value');
            if (value) {
              data.value = value;
            }
          }
          if (this.dataset[c.type]) {
            data.node = li;
            this.dataset[c.type].push(data);
          }
        }
      }
    },


    /**
     * Get data list
     * @private
     * @param {jQuery[]|HTMLElement} container the container element
     * @returns {object|array} the subset of the dataset desired
     */
    getDataList: function getDataList(container) {
      var s = this.settings;
      var d = this.dataset;
      container = this.isjQuery(container) ? container : $(container, this.element);

      if (container.is(s.additionalClass)) {
        return d.additional;
      }
      if (container.is(s.selectedClass)) {
        return d.selected;
      }
      if (container.is(s.availableClass)) {
        return d.available;
      }
      return [];
    },


    /**
     * Move an array element position
     * @private
     * @param {array} arr target array to manipulate
     * @param {number} from index to pull from
     * @param {number} to index to move to
     */
    arrayIndexMove: function arrayIndexMove(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
    },


    /**
     * Sync dataset
     * @private
     * @param {jQuery[]} owner element that currently contains the dataset
     * @param {jQuery[]} droptarget element that will receive the dataset
     */
    syncDataset: function syncDataset(owner, droptarget) {
      var droptargetNodes = $('.listview li', droptarget);
      var ownerDataList = this.getDataList(owner);
      var dtDataList = this.getDataList(droptarget);

      for (var i = 0, l = this.selections.items.length; i < l; i++) {
        var item = this.selections.items[i];
        for (var dtIndex = 0, l2 = droptargetNodes.length; dtIndex < l2; dtIndex++) {
          if ($(droptargetNodes[dtIndex]).is(item)) {
            for (var ownerIndex = 0, l3 = ownerDataList.length; ownerIndex < l3; ownerIndex++) {
              var ownerItem = ownerDataList[ownerIndex];
              if (ownerItem.node && ownerItem.node.is(item)) {
                dtDataList.push(ownerItem);
                ownerDataList.splice(ownerIndex, 1);
                this.arrayIndexMove(dtDataList, dtDataList.length - 1, dtIndex);
                break;
              }
            }
          }
        }
      }
    },


    /**
     * Check if a object is jQuery object
     * @private
     * @param {object} obj the object being checked
     * @returns {boolean} whether or not the object is a jQuery selector
     */
    isjQuery: function isjQuery(obj) {
      return obj && (obj instanceof jQuery || obj.constructor.prototype.jquery);
    },


    /**
     * Update attributes
     * @private
     * @param {jQuery[]} list the target element to update
     */
    updateAttributes: function updateAttributes(list) {
      var items = $('li', list);

      for (var i = 0, l = items.length; i < l; i++) {
        $(items[i]).attr({ 'aria-posinset': i + 1, 'aria-setsize': l });
      }
    },


    /**
     * After update
     * @private
     * @param {jQuery[]} list the target element to change after an update
     */
    afterUpdate: function afterUpdate(list) {
      var _this3 = this;

      setTimeout(function () {
        if (list) {
          if (_this3.selections.placeholder) {
            list.select(_this3.selections.placeholder);
            _this3.selections.placeholder.focus();
          }
          _this3.unselectElements(list);
          _this3.syncDataset(_this3.selections.owner, _this3.selections.droptarget);
          _this3.updateAttributes($('.listview', _this3.selections.owner));
          _this3.updateAttributes($('.listview', _this3.selections.droptarget));
          if (_this3.selections.items.length) {
            _this3.selections.move = $.extend(true, _this3.selections.move, {
              to: _this3.getContainer(_this3.selections.itemsData)
            });
            /**
            * Fires when any bucket has its content changed.
            * @event swapupdate
            * @memberof SwapList
            * @type {object}
            * @property {object} event - The jquery event object
            * @property {array} items - List of items data
            */
            _this3.element.triggerHandler('swapupdate', [_this3.selections.move]);
          }
        }
        _this3.clearDropeffects();
        _this3.clearSelections();
        _this3.items.removeClass('is-dragging is-dragging-touch');
      }, 100);
    },


    /**
     * Get items from provided container
     * @private
     * @param {jQuery[]|HTMLElement} container the container being checked
     * @returns {object|array} dataset
     */
    getItems: function getItems(container) {
      container = this.isjQuery(container) ? container : $(container, this.element);
      return this.getDataList(container);
    },


    /**
     * Get the current representative dataset with only the available elements in it.
     * @returns {object|array} dataset
     */
    getAvailable: function getAvailable() {
      return this.getDataList(this.settings.availableClass);
    },


    /**
     * Get the current representative dataset with only the selected elements in it.
     * @returns {object|array} dataset
     */
    getSelected: function getSelected() {
      return this.getDataList(this.settings.selectedClass);
    },


    /**
     * Get the current representative dataset with only the additional elements in it.
     * @returns {object|array} dataset
     */
    getAdditional: function getAdditional() {
      return this.getDataList(this.settings.additionalClass);
    },


    /**
     * Make selected if dragged element was not selected
     * @private
     * @param {object} list the list to manipulate
     * @param {jQuery[]} target the target to give a "selected" state
     * @returns {boolean} whether or not an item was made selected
     */
    draggedMakeSelected: function draggedMakeSelected(list, target) {
      var isInSelection = false;
      if (!this.selections.isInSelection) {
        // Check if dragged element was selected or not
        if (list.selectedItems) {
          for (var i = 0, l = list.selectedItems.length; i < l; i++) {
            if (target.is(list.selectedItems[i])) {
              isInSelection = true;
              return false;
            }
          }
        }
        if (!isInSelection) {
          list.select(target); // Make selected
          this.selections.isInSelection = true;
        }
      }
      return true;
    },


    /**
     * Updates the internal datasets and refresh the ui.
     * @param {object} ds The updated dataset(s) of the form.
     *  `{available: [], selected: [], additional: []}`
     * @returns {void}
     */
    updateDataset: function updateDataset(ds) {
      var s = this.settings;
      var containers = [{ type: 'available', dataset: ds.available, class: s.availableClass }, { type: 'selected', dataset: ds.selected, class: s.selectedClass }, { type: 'additional', dataset: ds.additional, class: s.additionalClass }];

      for (var i = 0, l = containers.length; i < l; i++) {
        var c = containers[i];
        var lv = $(c.class + ' .listview', this.element);
        var api = lv.data('listview');

        if (api) {
          api.deselectItemsBetweenIndexes([0, $('li', lv).length - 1]);
          s[c.type] = c.dataset || [];
          api.loadData(s[c.type]);
        }
      }

      this.initDataset();
      this.makeDraggable();
      this.initSelected(s.availableClass);
      this.initSelected(s.additionalClass);
    },


    /**
     * Removes event bindings from the swaplist instance.
     * @private
     * @returns {this} component instance
     */
    unbind: function unbind() {
      this.actionButtons.off('click.swaplist');
      this.containers.off('keydown.swaplist');
      this.selectedButtons.off('keydown.swaplist');
      this.element.off(this.dragStart + ' ' + this.dragEnterWhileDragging + ' ' + this.dragOverWhileDragging + ' ' + this.dragEnd, this.dragElements);

      $('#sl-placeholder-container, #sl-placeholder-touch, #sl-placeholder-touch2, #sl-placeholder').remove();
      return this;
    },


    /**
     * Updates this instance of the swaplist component with new settings.
     * @private
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, SWAPLIST_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroys this instance of the swaplist component and removes its link to its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$Y);
    },


    // Handle Events
    handleEvents: function handleEvents() {
      var self = this;
      var settings = self.settings;
      var selections = self.selections;

      // TOP BUTTONS =============================================================================
      self.actionButtons.off('click.swaplist').on('click.swaplist', function () {
        var actionButton = $(this);
        var container = actionButton.closest('.card'); // Current list clicked from

        var moveTo = null;

        if (container.is(settings.availableClass)) {
          // Move from Available to Selected or Additional
          if (settings.draggable.selected) {
            moveTo = settings.selectedClass;
          } else {
            moveTo = self.isAdditional && settings.draggable.additional ? settings.additionalClass : null;
          }
          self.moveElements(settings.availableClass, moveTo);
        } else if (container.is(settings.additionalClass)) {
          // Move from Additional to Selected or Available
          if (settings.draggable.selected) {
            moveTo = settings.selectedClass;
          } else {
            moveTo = settings.draggable.available ? settings.availableClass : null;
          }
          self.moveElements(settings.additionalClass, moveTo);
        } else if (container.is(settings.selectedClass)) {
          // Move from Selected
          if (actionButton.is(settings.selectedBtnLeft)) {
            // to Available
            self.moveElements(settings.selectedClass, settings.availableClass);
          } else if (actionButton.is(settings.selectedBtnRight)) {
            // to Additional
            self.moveElements(settings.selectedClass, settings.additionalClass);
          }
        }
      });

      // KEYSTROKE ===============================================================================
      // Keydown event to implement selections
      self.containers.on('keydown.swaplist', function (e) {
        var container = $(this);
        e = e || window.event;
        if (e.keyCode === 77 && self.hasModifier(e)) {
          // Modifier + M
          if (!container.is(settings.selectedClass) || container.is(settings.selectedClass) && self.selectedButtons.length === 1) {
            container.find(self.actionButtons).trigger('click.swaplist');
          } else {
            self.selectedButtons.first().focus();
          }
          e.preventDefault();
        }
      });

      // Keydown event to handle selected container
      self.selectedButtons.on('keydown.swaplist', function (e) {
        var btn = $(this);
        var index = void 0;
        var move = void 0;
        e = e || window.event;
        if (e.keyCode === 13 || e.keyCode === 32) {
          // Enter or Space
          btn.trigger('click.swaplist');
          e.preventDefault();
        }
        // Left or Right arrow
        if ((e.keyCode === 37 || e.keyCode === 39) && self.selectedButtons.length > 1) {
          index = self.selectedButtons.index(this);
          if (e.keyCode === 37) {
            move = index > 0 ? index - 1 : self.selectedButtons.length - 1;
          } else {
            move = index < self.selectedButtons.length - 1 ? index + 1 : 0;
          }
          self.selectedButtons[move].focus();
        }
      });

      self.element.on('keydown.swaplist', self.tabButtonsStr, function (e) {
        var btn = $(this);
        var keyCode = e.keyCode || e.which;

        if (keyCode === 9 && !e.shiftKey) {
          // Tab key
          $('li:first-child', btn.closest('.card')).focus();
          e.preventDefault();
        }
      });

      // DRAGGABLE ===============================================================================
      self.element.on('mousedown.swaplist', self.dragElements, function (e) {
        if (self.handle) {
          var target = $(e.target).closest('li');
          target.attr({ draggable: $(e.target).is('.draggable') });
        }
        e.stopPropagation();
      })
      // Dragstart - initiate dragging
      .on(self.dragStart, self.dragElements, function (e) {
        e.stopImmediatePropagation();
        if (self.handle && !selections.isHandle) {
          e.stopPropagation();
          return;
        }
        var rect = void 0;
        var touch = void 0;
        var placeholderContainer = void 0;
        var target = $(e.target).closest('li');
        var list = $('.listview', target.closest('.card')).data('listview');

        // Not in draging area
        if (!list) {
          return;
        }

        if (!self.isTouch) {
          self.draggedMakeSelected(list, target);
        }

        self.clearSelections(); // Clear selection before fill

        selections.owner = target.closest('.card');
        selections.dragged = target;
        selections.draggedIndex = target.index();
        selections.placeholder = target.clone(true);
        selections.placeholder.attr('id', 'sl-placeholder');

        self.setSelectionsItems(selections.owner);

        selections.items = list.selectedItems;

        self.selections.move = {
          items: self.selections.itemsData,
          from: self.getContainer(self.selections.itemsData)
        };

        /**
          * Fires before moving an element allowing you to access the draggable item.
          * @event beforeswap
          * @memberof SwapList
          * @type {object}
          * @property {object} event - The jquery event object
          * @property {array} items - List of selected items data
          */
        var result = self.element.triggerHandler('beforeswap', [self.selections.move]);
        if (typeof result === 'boolean' && !result || typeof result === 'string' && result.toLowerCase() === 'false') {
          selections.dragged = null;
          return;
        }

        $('.' + settings.numOfSelectionsClass, settings.itemContentTempl).html(selections.items.length);
        self.addDropeffects();

        if (!self.isTouch) {
          selections.dragged.addClass('is-dragging');
          e.originalEvent.dataTransfer.setData('text', '');

          if (selections.items.length > 1) {
            $('.' + settings.itemContentClass, selections.dragged).html(settings.itemContentTempl.html());
          }
        } else {
          rect = target[0].getBoundingClientRect();
          touch = e.originalEvent.changedTouches[0];

          // Save offset
          self.offset = {
            x: touch.pageX - rect.left,
            y: touch.pageY - rect.top
          };

          for (var i = 0, l = self.containers.length; i < l; i++) {
            self.containers[i].style.zIndex = '1';
          }
          selections.placeholderTouch = selections.dragged.clone(true);

          if (selections.items.length > 1 && !$('#sl-placeholder-touch2').length) {
            selections.dragged.clone().addClass('is-dragging-touch').attr('id', 'sl-placeholder-touch2').insertBefore(selections.dragged).hide();
          }
          selections.placeholderTouch.attr('id', 'sl-placeholder-touch').removeClass('is-selected').hide();

          // Mobile view with three container(available, selected, additional) prepend to parent
          placeholderContainer = self.element.is('.one-third') && self.isMaxWidth(766) ? self.element.parent() : self.element;
          placeholderContainer.prepend('<ul id="sl-placeholder-container"></ul>');

          $('#sl-placeholder-container').append(selections.placeholderTouch);
          $('#sl-placeholder-container')[0].style.width = selections.owner.width() + 'px';
          $('#sl-placeholder-touch')[0].style.width = selections.owner.width() + 'px';

          self.draggTouchElement(e, selections.placeholderTouch);
        }
        e.stopPropagation();
      })

      // Dragenter - set that related/droptarget
      .on(self.dragEnterWhileDragging, self.dragElements, function (e) {
        if (!selections.dragged) {
          return;
        }
        self.element.triggerHandler('draggingswap', [selections.move]);
        selections.related = e.target;
        $('ul, li', self.element).removeClass('over');
        $(e.target).closest('ul, li').addClass('over');
        selections.droptarget = $(selections.related).closest('.card');
        $('[aria-grabbed="true"]', self.element).not(selections.dragged).slideUp();
        e.stopPropagation();
      })

      // Dragover - allow the drag by preventing default, for touch set related/droptarget
      .on(self.dragOverWhileDragging, self.dragElements, function (e) {
        if (!selections.dragged) {
          return;
        }
        var touch = void 0;
        var overItem = $(this);
        var list = $('.listview', selections.dragged.closest('.card')).data('listview');

        if (self.isTouch) {
          if (!!self.handle && !selections.isHandle) {
            return;
          }

          if (!selections.isInSelection) {
            self.draggedMakeSelected(list, selections.dragged);
            selections.items = list.selectedItems;
            $('.' + settings.numOfSelectionsClass, settings.itemContentTempl).html(selections.items.length);
          }

          touch = e.originalEvent.touches[0];
          overItem = self.getElementByTouchInList($('ul, li', self.element), touch.pageX, touch.pageY) || overItem;

          selections.dragged.addClass('is-dragging');
          selections.placeholderTouch.addClass('is-dragging is-dragging-touch');
          selections.placeholderTouch.show();

          $('[aria-grabbed="true"]', self.element).not(selections.dragged).not(selections.placeholderTouch).not('#sl-placeholder-touch2').slideUp();

          if (selections.items.length > 1) {
            $('.' + settings.itemContentClass, selections.placeholderTouch.add('#sl-placeholder-touch2')).html(settings.itemContentTempl.html());

            $('#sl-placeholder-touch2').show();
            selections.dragged.hide();
          }
          self.draggTouchElement(e, selections.placeholderTouch);

          self.element.triggerHandler('draggingswap', [selections.move]);
          selections.related = overItem;
          $('ul, li', this.element).removeClass('over');
          overItem.closest('ul, li').addClass('over');
          selections.droptarget = selections.related.closest('.card');
        }
        e.preventDefault();
        e.stopPropagation();
      })

      // Dragend - implement items being validly dropped into targets
      .on(self.dragEnd, self.dragElements, function (e) {
        if (!selections.dragged) {
          return;
        }
        var related = $(selections.related).closest('li');
        var ul = $('ul', selections.droptarget);
        var currentSize = $('li', ul).length;
        var size = selections.items.length + currentSize;

        self.unselectElements($('.listview', selections.owner).data('listview'));

        $.each(selections.items, function (index, val) {
          val = $(val);
          val.find('mark.highlight').contents().unwrap();
          if (currentSize && !$(selections.related).is('ul')) {
            var isLess = related.index() < selections.draggedIndex;
            var el = isLess ? val : $(selections.items[selections.items.length - 1 - index]);
            var posinset = related.index() + (isLess ? index + 1 : index + 2);

            val.attr({ 'aria-posinset': posinset, 'aria-setsize': size });
            related[isLess ? 'before' : 'after'](el);
          } else {
            val.attr({ 'aria-posinset': currentSize + index + 1, 'aria-setsize': size });
            ul.append(val);
          }
          val.focus();
        });

        if (selections.items.length > 1) {
          $('.' + settings.itemContentClass, selections.dragged).html($('.' + settings.itemContentClass, selections.placeholder).html());
          if (self.isTouch) {
            selections.dragged.show();
          }
        }

        if (self.isTouch) {
          for (var i = 0, l = self.containers.length; i < l; i++) {
            self.containers[i].style.zIndex = '';
          }
        }

        selections.isHandle = null;
        $('[aria-grabbed="true"]', self.element).show();
        self.afterUpdate($('.listview', selections.droptarget).data('listview'));
        e.preventDefault();
        e.stopPropagation();
      });
    } // END: Handle Events ---------------------------------------------------------------------

  };

  /**
   * jQuery Component Wrapper for SwapList
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.swaplist = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$Y);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$Y, new SwapList(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$Z = 'scrollaction';

  // Default ScrollAction Options
  var SCROLLACTION_DEFAULTS = {
    scrollActionTarget: '.js-scroll-target', // The element to add a class to based on scrolling logic
    classToAdd: 'scrolled-down' // The class added to the target element
  };

  /**
  * A component that applies a class based on scroll direction
  * @class ScrollAction
  * @param {string} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [scrollActionTarget='.js-scroll-target'] The selector of the element to add the class to.
  * @param {string} [classToAdd ='scrolled-down'] The class name to use when toggling.
  */
  function ScrollAction(element, settings) {
    this.settings = utils.mergeSettings(element, settings, SCROLLACTION_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // ScrollAction Methods
  ScrollAction.prototype = {
    init: function init() {
      this.handleEvents();
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      var s = this.settings;
      this.element.off('scroll.scrollaction');
      if (s) {
        $(s.scrollActionTarget).removeClass(s.classToAdd);
      }
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, SCROLLACTION_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$Z);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var s = this.settings;
      this.lastScrollTop = 0;

      this.element.on('scroll.scrollaction', function () {
        var scrollTop = _this.element.scrollTop();

        if (scrollTop > _this.lastScrollTop) {
          $(s.scrollActionTarget).addClass(s.classToAdd);
        } else {
          $(s.scrollActionTarget).removeClass(s.classToAdd);
        }

        _this.lastScrollTop = scrollTop;
      });
    }
  };

  /**
   * jQuery Component Wrapper for ScrollAction
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.scrollaction = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$Z);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$Z, new ScrollAction(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$_ = 'stepchart';

  // Default component options
  var DEFAULT_STEPCHART_OPTIONS = {
    steps: null,
    completed: null,
    inProgress: null,
    iconType: null,
    completedText: null,
    extraText: '',
    completedColor: null,
    allCompletedColor: null,
    inProgressColor: null
  };

  /**
   * The Step Chart Component is displays visual info on step completion.
   * @class StepChart
   * @constructor
   * @param {jQuery[]|HTMLElement} element The base element
   * @param {object} [settings] incoming settings
   * @param {number} [settings.steps = null] The number of steps to show.
   * @param {number} [settings.completed = null] The number of steps complete (linear).
   * @param {number} [settings.inProgress = null] The number of the in progress step (linear).
   * @param {boolean} [settings.iconType = null] The icon to display fx. 'icon-error', 'icon-confirm'
   * @param {string} [settings.completedText = null] The completed text or uses a localized 'N of N Steps complete'.
   *  You can use {0} and {1} to replace n of n in the string.
   * @param {boolean} [settings.extraText = ''] The additional text to show on the right. Defaults to none. You
   *  can use {0} to replace with the steps remaining count and {1} to replace the number of steps.
   * @param {string} [settings.completedColor = null] The color to show completed steps. Defaults to primary color.
   * @param {string} [settings.allCompletedColor = null] The color to steps when all are completed. Defaults to primary color.
   * @param {string} i[settings.nProgressColor The color to show in-progress steps. Defaults to ruby02.
   */
  function StepChart(element, settings) {
    return this.init(element, settings);
  }

  StepChart.prototype = {

    /**
     * Initialize and render the chart
     * @private
     * @param {jQuery[]|HTMLElement} element The base element
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    init: function init(element, settings) {
      if (!this.element && element instanceof HTMLElement) {
        this.element = $(element);
      }

      if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object' || this.settings === undefined) {
        var previousSettings = this.settings || DEFAULT_STEPCHART_OPTIONS;
        this.settings = utils.mergeSettings(this.element[0], settings, previousSettings);
      }

      return this.render();
    },


    /**
     * Initialize and render the from the options
     * @private
     * @returns {this} component instance
     */
    render: function render() {
      var container = $('<div class="step-chart-steps"></div>');
      var icon = '\n      <svg class="icon {icon-name}" focusable="false" aria-hidden="true" role="presentation">\n        <use xlink:href="#icon-confirm"></use>\n      </svg>\n    ';

      var isEmpty = this.settings.completed === null && this.settings.steps === null;
      if (isEmpty) {
        this.settings.completed = 0;
        this.settings.steps = 1;
      }

      if (this.element.attr('data-options')) {
        this.settings = utils.parseSettings(this.element);
      }

      if (this.element.children().length > 0) {
        return this;
      }

      for (var i = 0; i < this.settings.steps; i++) {
        var step = $('<div class="step-chart-step"></div>');

        // Set up ticks
        if (i < this.settings.completed) {
          step.addClass('is-complete');

          if (this.settings.completedColor) {
            step.css('background-color', this.settings.completedColor);
          }
        }

        if (i === this.settings.inProgress - 1) {
          step.addClass('is-inprogress');

          if (this.settings.inProgressColor) {
            step.css('background-color', this.settings.inProgressColor);
          }
        }

        container.append(step);
      }

      // Set up labels and alerts
      var completedText = this.settings.completedText || Locale.translate('StepsCompleted');
      completedText = completedText.replace('{0}', this.settings.completed);
      completedText = completedText.replace('{1}', this.settings.steps);

      if (isEmpty) {
        completedText = Locale ? Locale.translate('NoData') : 'No Data Available';
      }
      var label = $('<span class="step-chart-label">' + completedText + '</span>');

      if (this.settings.steps === this.settings.completed) {
        container.addClass('is-complete');
        label.append(icon.replace('{icon-name}', 'icon-confirm'));
      }

      if (this.settings.iconType) {
        label.append(icon.replace('{icon-name}', this.settings.iconType));
      }

      if (this.settings.extraText) {
        var extraText = this.settings.extraText;
        extraText = extraText === '{0} Days Remaining' ? Locale.translate('DaysRemaining') : extraText;
        extraText = extraText === '{1} Days Overdue' ? Locale.translate('DaysOverdue') : extraText;
        extraText = extraText.replace('{0}', this.settings.steps - this.settings.completed);
        extraText = extraText.replace('{1}', this.settings.completed);
        label.append('<span class="step-chart-label-small">' + extraText + '</span>');
      }

      this.element.append(label, container);

      // Adjust completed color
      if (this.settings.steps === this.settings.completed && this.settings.allCompletedColor) {
        container.find('.step-chart-step').css('background-color', this.settings.allCompletedColor);
        label.find('.icon').attr('style', 'fill: ' + this.settings.allCompletedColor + '!important');
      }

      return this;
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      this.element.empty();

      return this.render();
    },


    /**
     * Tear down and remove.
     * @returns {this} component instance
     */
    destroy: function destroy() {
      this.element.empty();
      this.settings = null;
      $.removeData(this.element[0], COMPONENT_NAME$_);

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for StepChart
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.stepchart = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$_);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$_, new StepChart(this, settings));
        instance.destroy = function destroy() {
          this.teardown();
          $.removeData(this, COMPONENT_NAME$_);
        };
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$10 = 'tabs';

  // Types of possible Tab containers
  var tabContainerTypes = ['horizontal', 'vertical', 'module-tabs', 'header-tabs'];

  /**
   * @class Tabs
   * @constructor
   * @param {HTMLElement|jQuery[]} element the base element for this component
   * @param {object} settings incoming settings
   *
   * @param {boolean} [settings.addTabButton=false] If set to true, creates a button at the end
   * of the tab list that can be used to add an empty tab and panel
   * @param {function} [settings.addTabButtonCallback=null] if defined as a function, will
   * be used in-place of the default Tab Adding method
   * @param {boolean} [settings.appMenuTrigger=false] If set to true, will force an App Menu
   * trigger to be present on Non-Vertical Tabs implementatations.
   * @param {string} [settings.appMenuTriggerText] If defined, replaces the default "Menu" text used
   * in the app menu trigger.
   * @param {object} [settings.ajaxOptions] if defined, will be used by any internal
   * Tabs AJAX calls as the desired request settings.
   * @param {function} [settings.beforeActivate] If defined as a function, fires
   * this before a tab is activated to allow a possible "veto" of the tab swap (SOHO-5250).
   * @param {string|jQuery} [settings.containerElement=null] Defines a separate element
   * to be used for containing the tab panels.  Defaults to a `.tab-panel-container`
   * element that is created if it doesn't already exist.
   * @param {boolean} [settings.changeTabOnHashChange=false] If true, will change the selected
   * tab on invocation based on the URL that exists after the hash.
   * @param {function} [settings.hashChangeCallback=null] If defined as a function,
   * provides an external method for adjusting the current page hash used by these tabs.
   * @param {boolean} [settings.lazyLoad=true] if true, when using full URLs in tab HREFs,
   * or when using Ajax calls, tabs will be loaded as needed instead of the markup
   * all being established at once.
   * @param {boolean} [settings.moduleTabsTooltips=false] if true, will display a tooltip on
   * Module Tabs with cut-off text content.
   * @param {function} [settings.source=null] If defined, will serve as a way of pulling
   * in external content to fill tabs.
   * @param {object} [settings.sourceArguments={}] If a source method is defined, this
   * flexible object can be passed into the source method, and augmented with
   * parameters specific to the implementation.
   * @param {boolean} [settings.tabCounts=false] If true, Displays a modifiable count above each tab.
   * @param {boolean} [settings.verticalResponsive=false] If Vertical Tabs & true, will automatically
   * switch to Horizontal Tabs on smaller breakpoints.
   */
  var TABS_DEFAULTS = {
    addTabButton: false,
    addTabButtonCallback: null,
    appMenuTrigger: false,
    appMenuTriggerText: undefined,
    ajaxOptions: null,
    beforeActivate: undefined,
    containerElement: null,
    changeTabOnHashChange: false,
    hashChangeCallback: null,
    lazyLoad: true,
    moduleTabsTooltips: false,
    source: null,
    sourceArguments: {},
    tabCounts: false,
    verticalResponsive: false
  };

  function Tabs(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, TABS_DEFAULTS);
    this.init();
  }

  Tabs.prototype = {

    /**
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      return this.setup().build().setupEvents();
    },


    /**
     * @private
     * @returns {this} component instance
     */
    setup: function setup() {
      // Used by the $(body).resize event to correctly identify the tabs container element
      this.tabsIndex = $('.tab-container').index(this.element);
      return this;
    },


    /**
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      var _this = this;

      var self = this;
      var tabPanelContainer = void 0;
      var moveTabPanelContainer = false;

      // Check for a tab panel container immediately after the `.tab-container`
      // element (default as of IDS Enterprise 4.3.0)
      tabPanelContainer = this.element.next('.tab-panel-container');

      // Auto-detect and move existing tab-panel containers in key areas, if applicable.
      // Check inside the container first
      if (!tabPanelContainer.length) {
        tabPanelContainer = this.element.children('.tab-panel-container');

        if (!this.isVerticalTabs()) {
          moveTabPanelContainer = true;
        }
      }

      // Special case for Header Tabs, find the page container and use that as the container
      var bodyPageContainer = $('body > .page-container, .application-menu + .page-container');
      if (this.element.closest('.header').length > 0 && bodyPageContainer.length) {
        tabPanelContainer = bodyPageContainer;
      }

      // Special case for Module Tabs, where it's possible for layout reasons for there to be
      // an application menu element adjacent between the Tab list and the Tab Panel container
      if (this.element.next('.application-menu').length) {
        tabPanelContainer = this.element.next().next('.page-container');
        moveTabPanelContainer = false;
      }

      // Defining `this.settings.containerElement` ultimately overrides any internal
      // changes to the tab panel container.
      if (this.settings.containerElement && $(this.settings.containerElement).length) {
        tabPanelContainer = $(this.settings.containerElement);
        moveTabPanelContainer = false;
      }

      // If a `.tab-panel-container` still doesn't exist, create one.
      if (!tabPanelContainer || !tabPanelContainer.length) {
        tabPanelContainer = $('<div class="tab-panel-container"></div>');
        moveTabPanelContainer = true;
      }

      if (!tabPanelContainer[0].classList.contains('tab-panel-container')) {
        tabPanelContainer[0].classList.add('tab-panel-container');
      }
      if (moveTabPanelContainer) {
        tabPanelContainer.insertAfter(this.element);
      }

      this.container = tabPanelContainer;

      // Detect the existence of a "tab-list-container" element, if applicable.
      // Tab List containers are optional for all tab container types, but mandatory for
      // Composite Form tabs.
      var tablistContainer = this.element.children('.tab-list-container');
      if (!tablistContainer.length && this.isScrollableTabs()) {
        tablistContainer = $('<div class="tab-list-container"></div>').prependTo(this.element);
      }
      if (tablistContainer.length) {
        this.tablistContainer = tablistContainer;
      }

      // Add a default tabs class of "horizontal" if it doesn't already exist
      var noClass = true;
      var closestHeader = this.element.closest('.header');
      tabContainerTypes.forEach(function (val, i) {
        if (_this.element.hasClass(tabContainerTypes[i])) {
          noClass = false;
        }
      });
      if (noClass) {
        if (closestHeader.length) {
          self.element.addClass('header-tabs');
        } else {
          self.element.addClass('horizontal');
        }
      }

      // Build Tab Counts
      if (self.settings.tabCounts) {
        self.element.addClass('has-counts');
      }

      // Attach Tablist role and class to the tab headers container
      this.tablist = this.element.children('.tab-list');
      if (!this.tablist.length) {
        // If we have a `.tab-list-container` element, check that before creating markup
        if (this.tablistContainer) {
          this.tablist = this.tablistContainer.children('.tab-list');
        }

        // Create and append the `.tab-list` if it still doesn't exist.
        if (!this.tablist.length) {
          this.tablist = $('<ul class="tab-list"></ul>');
          if (this.tablistContainer) {
            this.tablist.appendTo(this.tablistContainer);
          } else {
            this.tablist.appendTo(this.element);
          }
        }
      }

      // Double-check that the `.tab-list-container` actually contains the `.tab-list`.
      // Move it if necessary.
      if (this.tablistContainer) {
        if (!this.tablist.parent().is(this.tablistContainer)) {
          this.tablistContainer.append(this.tablist);
        }

        this.tablistContainer.on('mousewheel.tabs', function (e) {
          if (e.deltaY) {
            this.scrollLeft += e.deltaY;
          }
        });
      }

      self.tablist.attr({
        class: 'tab-list',
        role: 'tablist',
        'aria-multiselectable': 'false'
      });

      // Conditionally Change layout classes if veritcal tabs is in responsive
      // mode, and breakpoints match.
      this.checkResponsive(false);

      // Handle Focus State, Animated Bar, More Button, Add Tabs Button, and
      // App Menu Button.
      this.renderHelperMarkup();

      // for each item in the tabsList...
      self.anchors = self.tablist.children('li:not(.separator)').children('a');
      self.anchors.each(function prepareAnchor() {
        var a = $(this);
        a.attr({ role: 'tab', 'aria-expanded': 'false', 'aria-selected': 'false', tabindex: '-1' }).parent().attr('role', 'presentation').addClass('tab');

        if (a.parent().hasClass('dismissible') && !a.parent().children('.icon').length) {
          $.createIconElement({ icon: 'close', classes: 'icon close' }).insertAfter(a);
        }

        // Find and configure dropdown tabs
        var dd = a.nextAll('ul').first();
        if (dd.length > 0) {
          dd.addClass('dropdown-tab');
          var li = a.parent();

          li.addClass('has-popupmenu').popupmenu({
            menu: dd,
            trigger: 'click',
            attachToBody: true
          });

          a.removeAttr('role').removeAttr('aria-expanded').removeAttr('aria-selected');

          if (!a.parent().children('.icon.icon-more').length) {
            $.createIconElement({ classes: 'icon-more', icon: 'dropdown' }).insertAfter(a);
          }
        }

        if (self.settings.tabCounts && $(this).find('.count').length === 0) {
          $(this).prepend('<span class="count">0 </span>');
        }

        // Make it possible for Module Tabs to display a tooltip containing their contents
        // if the contents are cut off by ellipsis.
        if (self.settings.moduleTabsTooltips) {
          a.on('beforeshow.toolbar', function () {
            return a.data('cutoffTitle') === 'yes';
          }).tooltip({
            content: '' + a.text().trim()
          });
        }
      });

      // Build/manage tab panels
      function associateAnchorWithPanel() {
        var a = $(this);
        var li = a.parent();
        var popup = li.data('popupmenu');
        var panel = void 0;

        // Associated the current one
        var href = a.attr('href');

        if (href.substr(0, 1) !== '#') {
          // is an outbound Link
          return;
        }

        if (href.substr(0, 2) === '#/') {
          // uses angular LocationStrategy
          // Just to find the panel but these are handled by angular
          href = href.replace('#/', '#');
        }

        if (href !== undefined && href !== '#') {
          panel = $(href);

          if (li.is(':not(.has-popupmenu)') && !panel.length) {
            return;
          }

          a.data('panel-link', panel);
          panel.data('tab-link', a);
          self.panels = self.panels.add(panel);
        }

        // If dropdown tab, add the contents of the dropdown
        // NOTE: popupmenu items that represent dropdown tabs shouldn't have children,
        // so they aren't accounted for here.
        if (popup) {
          popup.menu.children('li').each(function () {
            var popupLi = $(this);
            var popupA = popupLi.children('a');
            var popupHref = popupA.attr('href');
            var popupPanel = $(popupHref);

            popupA.data('panel-link', popupPanel);
            popupPanel.data('tab-link', popupA);

            self.panels = self.panels.add(popupPanel);
            self.anchors = self.anchors.add(popupA);

            if (!popupLi.hasClass('dismissible')) {
              return;
            }

            var popupIcon = popupLi.children('.icon');
            if (!popupIcon.length) {
              popupIcon = $.createIconElement({ icon: 'close', classes: 'icon close' });
            }
            popupIcon.detach().appendTo(popupA);
          }).on('click.popupmenu', '.icon', function iconClickHandler(e) {
            var popupIcon = $(this);
            var popupLi = popupIcon.closest('li');

            if (popupLi.is('.dismissible') && popupIcon.is('.icon')) {
              e.preventDefault();
              e.stopPropagation();
              self.closeDismissibleTab(popupLi.children('a').attr('href'));
            }
          });
        }
      }

      self.panels = $();
      self.anchors.each(associateAnchorWithPanel);
      self.panels.addClass('tab-panel').attr({ role: 'tabpanel' }).find('h3:first').attr('tabindex', '0');

      self.panels.appendTo(self.container);

      var excludes = ':not(.separator):not(.is-disabled):not(.is-hidden)';
      var tabs = this.tablist.children('li' + excludes);
      var selected = this.tablist.children('li.is-selected' + excludes);
      var selectedAnchor = selected.children('a');
      var hash = void 0;
      var matchingTabs = void 0;

      // Setup a hash for nested tab controls
      self.nestedTabControls = self.panels.find('.tab-container');

      if (tabs.length) {
        // If the hashChange setting is on, change the selected tab to the one referenced by the hash
        if (this.settings.changeTabOnHashChange) {
          hash = window.location.hash;
          if (hash && hash.length) {
            matchingTabs = tabs.find('a[href="' + hash + '"]');
            if (matchingTabs.length) {
              selected = matchingTabs.first().parent();
              selectedAnchor = selected.children('a');
            }
          }
        }

        // If there is no selected tab, try to find the first available tab (if there are any present)
        if (!selected.length) {
          selected = tabs.not('.add-tab-button, .application-menu-trigger').first();
          selectedAnchor = selected.children('a');
        }

        // If there are tabs present, activate the first one
        if (selected.length) {
          this.activate(selectedAnchor.attr('href'), selectedAnchor);
        }
      }

      if (this.isModuleTabs() && this.element.children('.toolbar').length) {
        this.element.addClass('has-toolbar');
      }

      this.setOverflow();

      this.positionFocusState(selectedAnchor);

      if (this.hasAnimatedBar()) {
        this.animatedBar.addClass('no-transition');
        this.focusBar(undefined, function () {
          setTimeout(function () {
            _this.animatedBar.removeClass('no-transition');
          }, 0);
        });
      }

      // Setup Edge Fades
      if (this.tablistContainer) {
        this.tablistContainer.on('scroll.tabs', function () {
          _this.renderEdgeFading();
        });
        this.renderEdgeFading();
      }

      return this;
    },


    /**
     * Adds/removes helper buttons and accessibility-centric markup, based on Tabs' configuration
     * Designed to be run at any point in the Tabs lifecycle.
     * @private
     * @returns {this} component instance
     */
    renderHelperMarkup: function renderHelperMarkup() {
      var auxilaryButtonLocation = this.tablistContainer || this.tablist;
      if (this.isModuleTabs()) {
        auxilaryButtonLocation = this.tablist;
      }

      this.focusState = this.element.find('.tab-focus-indicator');
      if (!this.focusState.length) {
        this.focusState = $('<div class="tab-focus-indicator" role="presentation"></div>').insertBefore(this.tablist);
      }

      // Animated Bar
      if (this.hasAnimatedBar()) {
        this.animatedBar = this.element.find('.animated-bar');
        if (!this.animatedBar.length) {
          this.animatedBar = $('<div class="animated-bar" role="presentation"></div>');
        }
        this.animatedBar.insertBefore(this.tablist);
      } else if (this.animatedBar && this.animatedBar.length) {
        this.animatedBar.off().remove();
        this.animatedBar = undefined;
      }

      // Add the markup for the "More" button if it doesn't exist.
      if (!this.moreButton) {
        this.moreButton = $();
      }

      if (!this.isVerticalTabs()) {
        if (!this.moreButton.length) {
          this.moreButton = auxilaryButtonLocation.next('.tab-more');
        }
        // If we still don't have a More Button, create one
        if (!this.moreButton.length) {
          this.moreButton = $('<div>').attr({ class: 'tab-more' });
          this.moreButton.append($('<span class="more-text">').text(Locale.translate('More')));
          this.moreButton.append($.createIconElement({ classes: 'icon-more', icon: 'dropdown' }));
        }

        // Append in the right place based on configuration
        auxilaryButtonLocation.after(this.moreButton);
      } else if (this.moreButton.length) {
        this.moreButton.off().remove();
        this.moreButton = $();
      }

      // Add the application menu Module Tab, if applicable
      var appMenuTrigger = this.tablist.find('.application-menu-trigger');
      if (this.settings.appMenuTrigger === true) {
        // Backwards Compatibility for the original Application Menu codepath.
        if (this.isModuleTabs()) {
          if (!appMenuTrigger.length) {
            appMenuTrigger = $('\n            <li class="tab application-menu-trigger">\n              <a href="#">\n                <span class="icon app-header">\n                  <span class="one"></span>\n                  <span class="two"></span>\n                  <span class="three"></span>\n                </span>\n                <span>' + (this.settings.appMenuTriggerText || Locale.translate('AppMenuTriggerText')) + '</span>\n              </a>\n            </li>\n          ');
            this.tablist.prepend(appMenuTrigger);
          }
        } else if (this.isVerticalTabs() && appMenuTrigger.length) {
          appMenuTrigger.off().remove();
        }
      } else if (appMenuTrigger.length) {
        if (this.isVerticalTabs()) {
          appMenuTrigger.off().remove();
        } else {
          this.tablist.prepend(appMenuTrigger);
        }
      }

      // Add Tab Button
      if (this.settings.addTabButton) {
        if (!this.addTabButton || !this.addTabButton.length) {
          this.addTabButton = $('\n          <div class="add-tab-button" tabindex="0" role="button">\n            <span aria-hidden="true" role="presentation">+</span>\n            <span class="audible">' + Locale.translate('AddNewTab') + '</span>\n          </div>\n        ');
          this.addTabButton.insertAfter(this.moreButton);
          this.element.addClass('has-add-button');
        }
      } else if (this.addTabButton && this.addTabButton.length) {
        this.addTabButton.remove();
        this.addTabButton = undefined;
        this.element.removeClass('has-add-button');
      }

      return this;
    },


    /**
     * Establishes the bound event listeners on all tabs elements
     * @private
     * @returns {this} component instance
     */
    setupEvents: function setupEvents() {
      var _this2 = this;

      var self = this;

      // Set animation bar if tabs under modal
      var modal = self.element.closest('.modal');
      if (modal.length) {
        modal.on('afteropen', function () {
          if (self.hasAnimatedBar()) {
            self.focusBar();
          }
        });
      }

      // Clicking the 'a' triggers the click on the 'li'
      function routeAnchorClick(e) {
        var a = $(e.currentTarget);

        if (this.wasTapped === true) {
          this.wasTapped = false;
          return;
        }

        if (e.type === 'touchend') {
          this.wasTapped = true;
        }

        if (a.attr('href').substr(0, 1) !== '#') {
          // is an outbound Link
          return;
        }
        e.preventDefault();
      }

      // Some tabs have icons that can be clicked and manipulated
      function handleIconClick(e) {
        var elem = $(this);
        if (elem.is('[disabled]') || elem.parent().hasClass('is-disabled')) {
          return;
        }

        var li = $(elem).parent();

        if (li.hasClass('dismissible')) {
          e.preventDefault();
          e.stopPropagation();
          self.closeDismissibleTab(li.children('a').attr('href'));
        }
      }

      function handleTabBlur() {
        $(this).parent().removeClass('is-focused');
      }

      // Any events bound to individual tabs (li) and their anchors (a) are bound
      // to the tablist element so that tabs can be added/removed/hidden/shown without
      // needing to change event bindings.
      this.tablist.on('mousedown.tabs', '> li', function (e) {
        self.handleAddFocusData(e, $(this));

        if ($(e.target).hasClass('close') && $(e.target).parent().hasClass('has-popupmenu')) {
          var menu = $(this).data('popupmenu').menu;
          var hrefs = [];
          $.each(menu[0].children, function (i, li) {
            hrefs.push(li.children[0].href);
          });
          self.closeDismissibleTabs(hrefs);
        }

        // let right click pass through
        if (e.which !== 3) {
          return self.handleTabClick(e, $(this));
        }
        return false;
      }).on('click.tabs', 'a', routeAnchorClick).on('click.tabs', '.icon', handleIconClick).on('focus.tabs', 'a', function (e) {
        return self.handleTabFocus(e, $(this));
      }).on('blur.tabs', 'a', handleTabBlur).on('keydown.tabs', 'a', function (e) {
        return _this2.handleTabKeyDown(e);
      });

      // Setup events on Dropdown Tabs
      function dropdownTabEvents(i, tab) {
        var li = $(tab);
        var a = li.children('a');
        var menu = li.data('popupmenu').menu;

        // Alt+Del or Alt+Backspace closes a dropdown tab item
        function closeDropdownMenuItem(e) {
          if (!e.altKey || !li.is('.dismissible')) {
            return;
          }

          self.closeDismissibleTab(a.attr('href'));
        }

        menu.on('keydown.popupmenu', 'a', function (e) {
          switch (e.which) {
            case 27:
              // escape
              li.addClass('is-selected');
              a.focus();
              break;
            case 8:
              // backspace (delete on Mac)
              closeDropdownMenuItem(e);
              break;
            case 46:
              // The actual delete key
              closeDropdownMenuItem(e);
              break;
            default:
              break;
          }
        });

        li.on('selected.tabs', function (e, anchor) {
          var popupLi = $(this);
          var href = $(anchor).attr('href');

          if (!self.activate(href, $(anchor))) {
            return false;
          }

          self.positionFocusState(a);

          if (self.hasAnimatedBar()) {
            self.focusBar(popupLi);
          }

          a.focus();
          self.scrollTabList(popupLi);

          popupLi.addClass('is-selected');
          return false;
        });
      }

      var ddTabs = self.tablist.find('li').filter('.has-popupmenu');
      ddTabs.each(dropdownTabEvents);

      function dismissibleTabEvents(i, tab) {
        var li = $(tab);
        var a = li.children('a');

        a.on('keydown.tabs', function (e) {
          self.handleDismissibleTabKeydown(e);
        });
      }

      var dismissible = self.tablist.find('li').filter('.dismissible');
      dismissible.each(dismissibleTabEvents);

      this.setupHelperMarkupEvents();

      this.panels.on('keydown.tabs', function (e) {
        self.handlePanelKeydown(e);
      });

      // Check whether or not all of the tabs + more button are de-focused.
      // If true, the focus-state and animated bar need to revert positions
      // back to the currently selected tab.
      this.element.on('focusout.tabs', function () {
        var noFocusedTabs = !$.contains(self.element[0], document.activeElement);
        var noPopupMenusOpen = self.tablist.children('.has-popupmenu.is-open').length === 0;

        if (noFocusedTabs && noPopupMenusOpen && !self.moreButton.is('.is-selected, .popup-is-open')) {
          self.hideFocusState();
        }
      }).on('updated.tabs', function (e, settings) {
        self.updated(settings);
      }).on('activated.tabs', function (e) {
        // Stop propagation of the activate event from going higher up into the DOM tree
        e.stopPropagation();
      }).on('add.tabs', function (e, newTabId, newTabOptions, newTabIndex) {
        self.add(newTabId, newTabOptions, newTabIndex);
      }).on('remove.tabs', function (e, tabId) {
        self.remove(tabId);
      });

      // Check to see if we need to add/remove the more button on resize
      $('body').on('resize.tabs' + this.tabsIndex, function () {
        self.handleResize();
      });
      self.handleResize(true);

      // Resize the tab to show the error
      $('.tab-panel input').on('error.tabs, valid.tabs', function () {
        var currentLi = $('.tab.is-selected');
        self.focusBar(currentLi);
      });

      return this;
    },


    /**
     * Adds events associated with elements that are re-renderable during the Tabs lifecycle
     * @private
     */
    setupHelperMarkupEvents: function setupHelperMarkupEvents() {
      var self = this;

      // Setup the "more" function
      this.moreButton.on('click.tabs', function (e) {
        self.handleMoreButtonClick(e);
      }).on('keydown.tabs', function (e) {
        self.handleMoreButtonKeydown(e);
      }).on('focus.tabs', function (e) {
        self.handleMoreButtonFocus(e);
      }).on('mousedown.tabs', function (e) {
        self.handleAddFocusData(e, $(this));
      });

      if (this.settings.addTabButton) {
        this.addTabButton.on('click.tabs', function () {
          self.handleAddButton();
        }).on('keydown.tabs', function (e) {
          self.handleAddButtonKeydown(e);
        }).on('focus.tabs', function (e) {
          self.handleAddButtonFocus(e);
        });
      }
    },


    /**
     * Removes events associated with elements that are re-renderable during the Tabs lifecycle
     * @private
     * @returns {this} component instance
     */
    removeHelperMarkupEvents: function removeHelperMarkupEvents() {
      if (this.moreButton && this.moreButton.length) {
        this.moreButton.off('click.tabs keydown.tabs focus.tabs mousedown.tabs');
      }

      if (this.addTabButton && this.addTabButton.length) {
        this.addTabButton.off('click.tabs keydown.tabs focus.tabs');
      }

      return this;
    },


    /**
     * Setup a mousedown event on tabs to determine in the focus handler whether
     * or a not a keystroked cause a change in focus, or a click.  Keystroke focus
     * changes cause different visual situations
     * @private
     * @param {$.Event} e incoming focus event
     * @param {jQuery[]} elem element
     * @returns {undefined}
     */
    handleAddFocusData: function handleAddFocusData(e, elem) {
      var tab = elem;
      if (tab.is('.is-disabled')) {
        e.preventDefault();
        return false;
      }

      if (!tab.is(this.moreButton)) {
        tab = tab.children('a');
      }

      this.hideFocusState();
      tab.data('focused-by-click', true);
      return true;
    },


    /**
     * Handler for Tab Click
     * @private
     * @param {jQuery.Event} e incoming click event
     * @param {jQuery[]} li list item representing the clicked tab
     * @returns {boolean|undefined} ? // TODO: why?
     */
    handleTabClick: function handleTabClick(e, li) {
      if (this.element.is('.is-disabled') || li && (li.is('.is-disabled') || li.is('.separator'))) {
        e.stopPropagation();
        e.preventDefault();
        return false;
      }

      var appMenuResult = this.handleAppMenuTabKeydown(e);
      if (!appMenuResult) {
        return true;
      }

      var a = li.children('a');
      a.data('focused-by-click', true);

      if (this.popupmenu && this.popupmenu.element.hasClass('is-open')) {
        this.popupmenu.close();
      }

      // Don't activate a dropdown tab.  Clicking triggers the Popupmenu Control attached.
      if (li.is('.has-popupmenu')) {
        this.positionFocusState(a);
        return true;
      }

      var href = a.attr('href');

      if (li.is('.add-tab-button')) {
        a = this.handleAddButton();
        li = a.parent();
        href = a.attr('href');
        this.element.trigger('tab-added', [a]);
      }

      // close tab on middle click
      if (e.which === 2) {
        if (li.is('.dismissible') && $(e.target).is('.close')) {
          this.closeDismissibleTab(href);
        }
        e.preventDefault();
        return true;
      }

      if (!this.activate(href, a)) {
        return true;
      }
      this.changeHash(href);

      this.focusState.removeClass('is-visible');

      a.focus();

      if (this.isScrollableTabs()) {
        this.scrollTabList(li);
      }

      // Hide these states
      this.focusBar(li);
      this.positionFocusState(a);

      if (this.settings.lazyLoad === true && this.isURL(href)) {
        return false;
      }

      return true;
    },


    /**
     * Handler for click events on the "More Tabs" popupmenu trigger
     * @private
     * @param {jQuery.event} e Event
     * @returns {boolean|undefined} ?
     */
    handleMoreButtonClick: function handleMoreButtonClick(e) {
      if (this.element.is('.is-disabled') || this.moreButton.is('.is-disabled')) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }

      this.moreButton.data('focused-by-click', true);

      if (!this.hasMoreButton()) {
        e.stopPropagation();
      }
      if (this.moreButton.hasClass('popup-is-open')) {
        this.popupmenu.close();
        this.moreButton.removeClass('popup-is-open');
      } else {
        this.buildPopupMenu();
      }

      this.hideFocusState();
      return true;
    },


    /**
     * Handler for click events on the "More Tabs" popupmenu trigger
     * @private
     * @param {jQuery.event} e Event
     * @param {jQuery[]} a represents an anchor tag
     * @returns {boolean|undefined} ?
     */
    handleTabFocus: function handleTabFocus(e, a) {
      if (this.element.is('.is-disabled')) {
        e.preventDefault();
        return false;
      }

      var li = a.parent();
      var dataFocusedClick = a.data('focused-by-click');
      var focusedByKeyboard = dataFocusedClick === undefined || dataFocusedClick && dataFocusedClick === false;

      $.removeData(a[0], 'focused-by-click');

      if (this.isTabOverflowed(li)) {
        this.buildPopupMenu(a.attr('href'));
        this.moreButton.addClass('is-focused');
        this.positionFocusState(this.moreButton);
      } else {
        li.addClass('is-focused');
        this.positionFocusState(a, focusedByKeyboard);
      }

      return true;
    },


    /**
     * Handler for focus events on the "More Tabs" popupmenu trigger
     * @private
     * @param {jQuery.event} e incoming focus event
     * @returns {void}
     */
    handleMoreButtonFocus: function handleMoreButtonFocus(e) {
      if (this.element.is('.is-disabled')) {
        e.preventDefault();
        return;
      }

      var dataFocusedClick = this.moreButton.data('focused-by-click');
      var focusedByKeyboard = dataFocusedClick && dataFocusedClick === false;

      $.removeData(this.moreButton[0], 'focused-by-click');

      this.focusState.removeClass('is-visible');
      this.positionFocusState(this.moreButton, focusedByKeyboard);
    },


    /**
     * Handler for keydown events on Tabs in the list
     * @private
     * @param {jQuery.event} e incoming keydown event
     * @returns {boolean|undefined} ?
     */
    handleTabKeyDown: function handleTabKeyDown(e) {
      if (this.element.is('.is-disabled')) {
        e.preventDefault();
        return false;
      }

      if (e.shiftKey || e.ctrlKey || e.metaKey || e.altKey && e.which !== 8) {
        return true;
      }

      var self = this;
      var passableKeys = [8, 13, 32];

      function isPassableKey() {
        return $.inArray(e.which, passableKeys) > -1;
      }

      if (e.which < 32 && !isPassableKey() || e.which > 46) {
        return true;
      }

      if (isPassableKey()) {
        var appMenuResult = this.handleAppMenuTabKeydown(e);
        if (!appMenuResult) {
          return true;
        }
      }

      function openMenu(oldHref) {
        e.preventDefault();
        // setTimeout is used to bypass triggering of the keyboard when
        // self.buildPopupMenu() is invoked.
        setTimeout(function () {
          self.buildPopupMenu(oldHref);
        }, 0);
      }

      var allExcludes = ':not(.separator):not(.is-disabled):not(:hidden)';
      var currentLi = $(e.currentTarget).parent();
      var currentA = currentLi.children('a');
      var targetLi = void 0;
      var tabs = self.tablist.children('li' + allExcludes);
      var isRTL = Locale.isRTL();

      function previousTab() {
        var i = tabs.index(currentLi) - 1;
        while (i > -1 && !targetLi) {
          if (tabs.eq(i).is(allExcludes)) {
            return tabs.eq(i);
          }
          i -= 1;
        }

        if (self.settings.addTabButton) {
          return self.addTabButton;
        }

        var last = self.tablist.children('li' + allExcludes).last();

        if (self.hasMoreButton() && self.isScrollableTabs()) {
          openMenu(last.find('a').attr('href'));
        }

        return last;
      }

      function nextTab() {
        var i = tabs.index(currentLi) + 1;
        while (i < tabs.length && !targetLi) {
          if (tabs.eq(i).is(allExcludes)) {
            return tabs.eq(i);
          }
          i++;
        }

        var first = self.tablist.children('li' + allExcludes).first();

        if (self.hasMoreButton() && self.isScrollableTabs()) {
          openMenu(first.find('a').attr('href'));
          return first;
        }

        if (self.settings.addTabButton) {
          return self.addTabButton;
        }
        return first;
      }

      function checkAngularClick() {
        if (currentA.attr('ng-click') || currentA.attr('data-ng-click')) {
          // Needed to fire the "Click" event in Angular situations
          currentA.click();
        }
      }

      function activate() {
        if (currentLi.hasClass('has-popupmenu')) {
          currentLi.data('popupmenu').open();
          return;
        }

        var href = currentA.attr('href');

        if (currentLi.is('.add-tab-button')) {
          currentA = self.handleAddButton();
          currentLi = currentA.parent();
          href = currentA.attr('href');
          self.element.trigger('tab-added', [currentA]);
        }

        if (!self.activate(href)) {
          return;
        }

        self.changeHash(href);
        self.focusBar(currentLi);
        checkAngularClick();
        currentA[0].focus();
        self.hideFocusState();

        // In the event that the activated tab is a full link that should be followed,
        // the keystroke events need to manually activate the link change.  Clicks are handled
        // automatically by the browser.
        self.handleOutboundLink(href);
      }

      switch (e.which) {
        case 8:
          if (e.altKey && currentLi.is('.dismissible')) {
            e.preventDefault();
            self.closeDismissibleTab(currentA.attr('href'));
          }
          return true;
        case 13:
          // Enter
          activate();
          return false;
        case 32:
          // Spacebar
          activate();
          return false;
        case 38:
          targetLi = previousTab();
          e.preventDefault();
          break;
        case 37:
          targetLi = isRTL ? nextTab() : previousTab();
          e.preventDefault();
          break;
        case 40:
          targetLi = nextTab();
          e.preventDefault();
          break;
        case 39:
          targetLi = isRTL ? previousTab() : nextTab();
          e.preventDefault();
          break;
        default:
          break;
      }

      if (targetLi) {
        var isAddTabButton = targetLi.is('.add-tab-button');
        var focusStateTarget = isAddTabButton ? targetLi : targetLi.children('a');

        // Use the matching option in the popup menu if the target is hidden by overflow.
        if (this.isTabOverflowed(targetLi)) {
          return openMenu(targetLi.children('a').attr('href'));
        }

        if (!isAddTabButton) {
          focusStateTarget.focus();
        } else {
          self.addTabButton.focus();
        }

        if (this.isScrollableTabs()) {
          this.scrollTabList(focusStateTarget);
        }

        self.positionFocusState(focusStateTarget, true);
      }

      return true;
    },


    /**
     * Handler for keydown events on Dismissible tabs
     * @private
     * @param {jQuery.event} e incoming keydown event
     * @returns {void}
     */
    handleDismissibleTabKeydown: function handleDismissibleTabKeydown(e) {
      var key = e.which;
      var tab = $(e.target);

      if (tab.is('a')) {
        tab = tab.parent();
      }

      if (e.altKey && key === 46) {
        // Alt + Del
        if (tab.children('a').is('[disabled]') || tab.hasClass('is-disabled')) {
          return;
        }

        e.preventDefault();
        this.closeDismissibleTab(tab.children('a').attr('href'));
      }
    },


    /**
     * Handler for keydown events on the "App Menu" tab (trigger button for the App Menu)
     * @private
     * @param {jQuery.event} e incoming keydown event
     * @returns {boolean} ?
     */
    handleAppMenuTabKeydown: function handleAppMenuTabKeydown(e) {
      var target = $(e.target);
      var li = target.parent();

      if (!(li.is('.application-menu-trigger') || target.is('.application-menu-trigger'))) {
        return true;
      }

      // If the tab is an application-menu trigger, open the app menu
      // Used by Module Tabs
      var menu = $('#application-menu');
      if (!menu.length) {
        return false;
      }

      e.preventDefault();

      this.hideFocusState();

      if (menu.hasClass('is-open')) {
        menu.trigger('close-applicationmenu');
        return false;
      }

      menu.trigger('open-applicationmenu');
      return false;
    },


    /**
     * Handler for keydown events on the "More Tabs" popupmenu trigger
     * @private
     * @param {jQuery.event} e incoming keydown event
     * @returns {boolean|undefined} ?
     */
    handleMoreButtonKeydown: function handleMoreButtonKeydown(e) {
      if (this.element.is('.is-disabled')) {
        e.preventDefault();
        return false;
      }

      var self = this;
      var isRTL = Locale.isRTL();

      function openMenu() {
        e.preventDefault();
        self.buildPopupMenu(self.tablist.find('.is-selected').children('a').attr('href'));
        self.positionFocusState(self.moreButton, true);
      }

      function lastTab() {
        e.preventDefault();
        self.findLastVisibleTab();
      }

      switch (e.which) {
        case 37:
          // left
          if (isRTL) {
            openMenu();
            break;
          }
          lastTab();
          break;
        case 38:
          // up
          lastTab();
          break;
        case 13: // enter
        case 32:
          // spacebar
          e.preventDefault();
          break;
        case 39:
          // right
          if (isRTL) {
            lastTab();
            break;
          }
          openMenu();
          break;
        case 40:
          // down
          openMenu();
          break;
        default:
          break;
      }

      return true;
    },


    /**
     * Handler for keydown events on the "More Tabs" popupmenu trigger
     * @private
     * @param {jQuery.event} e incoming keydown event
     * @returns {void}
     */
    handlePanelKeydown: function handlePanelKeydown(e) {
      var key = e.which;
      var panel = $(e.target);
      var a = this.anchors.filter('#' + panel.attr('id'));
      var tab = this.anchors.filter('#' + panel.attr('id')).parent();

      if (tab.is('.dismissible')) {
        // Close a Dismissible Tab
        if (e.altKey && key === 46) {
          // Alt + Delete
          e.preventDefault();
          return this.closeDismissibleTab(a.attr('href'));
        }
      }

      // Takes focus away from elements inside a Tab Panel and brings focus to its corresponding Tab
      if (e.ctrlKey && key === 38 && $.contains(document.activeElement, panel[0])) {
        // Ctrl + Up Arrow
        e.preventDefault();
        return this.activate(a.attr('href'), a);
      }

      return undefined;
    },


    /**
     * Handles the Add Tab button being clicked
     * @private
     * @returns {boolean|undefined} ?
     */
    handleAddButton: function handleAddButton() {
      var cb = this.settings.addTabButtonCallback;
      if (cb && typeof cb === 'function') {
        var newTabId = cb();
        return this.anchors.filter('[href="#' + newTabId + '"]');
      }

      function makeId() {
        var stringName = 'new-tab';
        var existing = $('[id^="' + stringName + '"]');

        if (!existing.length) {
          return stringName + '-0';
        }
        return stringName + '-' + existing.length;
      }

      function makeName(id) {
        var nameParts = id.toString().split('-');
        nameParts.forEach(function (val, i) {
          nameParts[i] = val.charAt(0).toUpperCase() + val.slice(1);
        });

        return nameParts.join(' ');
      }

      var newIndex = this.tablist.children().index(this.addTabButton);
      var newId = makeId();
      var newName = makeName(newId);
      var settings = {
        name: newName,
        content: '&nbsp;',
        isDismissible: true
      };

      if (newIndex < 0) {
        newIndex = this.tablist.find('li:not(.separator)').length;
      }

      // Allow the opportunity to pass in external settings for the new tab control
      var externalSettings = this.element.triggerHandler('before-tab-added', [newId, settings, newIndex]);
      if (!externalSettings) {
        this.add(newId, settings, newIndex);
        return this.anchors.filter('[href="#' + newId + '"]');
      }

      if (externalSettings.newId && externalSettings.newId.length && typeof externalSettings.newId === 'string') {
        newId = externalSettings.newId;
      }
      if (externalSettings.settings && _typeof(externalSettings.settings) === 'object') {
        settings = externalSettings.settings;
      }
      if (!isNaN(externalSettings.newIndex)) {
        newIndex = externalSettings.newIndex;
      }

      this.add(newId, settings, newIndex);
      return this.anchors.filter('[href="#' + newId + '"]');
    },


    /**
     * @private
     * @param {jQuery.Event} e incoming keydown event
     * @returns {undefined|boolean} ?
     */
    handleAddButtonKeydown: function handleAddButtonKeydown(e) {
      if (this.element.is('.is-disabled')) {
        e.preventDefault();
        return false;
      }

      var validKeys = [13, 32, 37, 38, 39, 40];
      var key = e.which;

      if (validKeys.indexOf(key) < 0) {
        return false;
      }

      var self = this;
      var isRTL = Locale.isRTL();
      var targetLi = void 0;
      var filter = 'li:not(.separator):not(.is-disabled):not(:hidden)';

      function openMenu() {
        e.preventDefault();
        targetLi = self.tablist.find(filter).last();

        if (self.isTabOverflowed(targetLi)) {
          // Open the spillover
          self.buildPopupMenu(targetLi.children('a').attr('href'));
          self.positionFocusState(self.moreButton, true);
        }
      }

      function firstTab() {
        targetLi = self.tablist.find(filter).first();
      }

      switch (key) {
        case 37:
          // left
          if (isRTL) {
            firstTab();
            break;
          }
          openMenu();
          break;
        case 38:
          // up
          openMenu();
          break;
        case 13: // enter
        case 32:
          // spacebar
          e.preventDefault();
          return this.handleAddButton();
        case 39:
          // right
          if (isRTL) {
            openMenu();
            break;
          }
          firstTab();
          break;
        case 40:
          // down
          firstTab();
          break;
        default:
          break;
      }

      targetLi.children('a').focus();
      return true;
    },


    /**
     * @private
     * @returns {void}
     */
    handleAddButtonFocus: function handleAddButtonFocus() {
      var tabs = this.tablist.find('li:not(.separator)');
      tabs.add(this.moreButton).removeClass('is-focused');

      this.addTabButton.addClass('is-focused');
      this.positionFocusState(this.addTabButton, true);
    },


    /**
     * @private
     * @param {boolean} ignoreResponsiveCheck if true, doesn't run `this.checkResponsive()`
     * @returns {void}
     */
    handleResize: function handleResize(ignoreResponsiveCheck) {
      if (!ignoreResponsiveCheck) {
        this.checkResponsive(true);
      }

      this.setOverflow();

      var selected = this.tablist.find('.is-selected');
      if (!selected.length || this.moreButton.is('.is-selected') || this.isTabOverflowed(selected)) {
        selected = this.moreButton;
      }

      if (!selected.length) {
        this.defocusBar();
        this.hideFocusState();
      } else {
        this.focusBar(selected);
        this.positionFocusState(selected);
      }

      this.handleVerticalTabResize();
      this.renderVisiblePanel();
      this.renderEdgeFading();
    },


    /**
     * Checks the window size to determine if a responsive-mode switch is needed.
     * @private
     * @returns {void}
     * @param  {boolean} handleRebuild Do a rebuild after handling.
     */
    checkResponsive: function checkResponsive(handleRebuild) {
      var self = this;
      var classList = self.element[0].classList;

      function rebuild() {
        self.removeHelperMarkupEvents();
        self.renderHelperMarkup();
        self.setupHelperMarkupEvents();
      }

      function makeResponsive() {
        if (!classList.contains('is-in-responsive-mode')) {
          classList.add('is-in-responsive-mode');
          classList.add('header-tabs');
          classList.add('alternate');
          classList.remove('vertical');
          if (handleRebuild) {
            rebuild();
          }
        }
      }

      function makeVertical() {
        if (classList.contains('is-in-responsive-mode')) {
          classList.add('vertical');
          classList.remove('is-in-responsive-mode');
          classList.remove('header-tabs');
          classList.remove('alternate');
          if (handleRebuild) {
            rebuild();
          }
        }
      }

      // Check for responsive mode for Vertical tabs
      if (this.isResponsiveVerticalTabs()) {
        if (breakpoints.isBelow('phone-to-tablet')) {
          makeResponsive();
        } else {
          makeVertical();
        }
      } else {
        makeVertical();
      }
    },


    /**
     * Causes a vertical tabs container to stretch to the height of its parent container
     * @private
     * @returns {void}
     */
    handleVerticalTabResize: function handleVerticalTabResize() {
      if (!this.isVerticalTabs()) {
        return;
      }

      // When tabs are full-size (part of a layout) CSS rules should handle this better
      // due to less strange sizing constraints.  JS resizing is necessary for nesting.
      if (!this.isNested() || this.isNestedInLayoutTabs() || this.isHidden()) {
        return;
      }

      var elemStyle = window.getComputedStyle(this.element[0]);
      var elemOuterHeight = elemStyle.getPropertyValue('height') + elemStyle.getPropertyValue('margin-top') + elemStyle.getPropertyValue('margin-bottom');

      this.tablist[0].style.height = elemOuterHeight;
    },


    /**
     * Changes the location in the browser address bar to force outbound links.
     * @param {string} href incoming href link
     * @param {boolean} useRelativePath don't prepend the full domain, port,
     * protocol, etc. to the HREF.
     * @returns {void}
     */
    handleOutboundLink: function handleOutboundLink(href, useRelativePath) {
      if (href.charAt(0) === '#') {
        return;
      }

      if (href.charAt(0) === '/' && (!useRelativePath || useRelativePath === false)) {
        href = window.location.origin + href;
      }

      window.location = href;
    },


    /**
     * Determines whether or not this tabset's tab list should display an animated selected state on a tab.
     * @returns {boolean} whether or not the animated selected state should display.
     */
    hasAnimatedBar: function hasAnimatedBar() {
      return !this.isModuleTabs() && !this.isVerticalTabs();
    },


    /**
     * Determines whether or not this tabset currently has a "More Tabs" spillover button.
     * @returns {boolean} whether or not the "More Tabs" button is currently displayed.
     */
    hasMoreButton: function hasMoreButton() {
      return this.element[0].classList.contains('has-more-button');
    },


    /**
     * Determines whether or not this normally "vertical" tabset is in an optional "horizontal" responsive mode
     * @returns {boolean} whether or not the responsive mode is active.
     */
    isInResponsiveMode: function isInResponsiveMode() {
      return this.element[0].classList.contains('is-in-responsive-mode');
    },


    /**
     * Determines whether or not this tabset is currently operating as Module Tabs
     * @returns {boolean} whether or not this is a Module tabset.
     */
    isModuleTabs: function isModuleTabs() {
      return this.element.hasClass('module-tabs');
    },


    /**
     * Determines whether or not this tabset is currently operating as Vertical Tabs
     * @returns {boolean} whether or not this is a Vertical tabset.
     */
    isVerticalTabs: function isVerticalTabs() {
      return this.element.hasClass('vertical');
    },


    /**
     * Determines whether or not this tabset is Vertical Tabs with a responsive, horizontal capability
     * @returns {boolean} whether or not this is a Vertical tabset.
     */
    isResponsiveVerticalTabs: function isResponsiveVerticalTabs() {
      return this.settings.verticalResponsive === true;
    },


    /**
     * Determines whether or not this tabset is currently operating as Header Tabs
     * @returns {boolean} whether or not this is a Header tabset.
     */
    isHeaderTabs: function isHeaderTabs() {
      return this.element.hasClass('header-tabs');
    },


    /**
     * Determines whether or not this tabset is showing tabs that allow for selection via horizontal scrolling.
     * @returns {boolean} whether or not horizontal scrolling is possible.
     */
    isScrollableTabs: function isScrollableTabs() {
      return !this.isModuleTabs() && !this.isVerticalTabs();
    },


    /**
     * Determines whether or not this tabset is currently hidden
     * @returns {boolean} whether or not this tabset is hidden.
     */
    isHidden: function isHidden() {
      return this.element.is(':hidden');
    },


    /**
     * Determines whether or not this tabset is nested inside a parent Tab Panel
     * @returns {boolean} whether or not this tabset is nested.
     */
    isNested: function isNested() {
      return this.element.closest('.tab-panel').length;
    },


    /**
     * Determines whether or not a particular tab panel is currently the active (displayed) tab panel
     * @param {string} href representing the HTML "id" attribute of a corresponding tab panel
     * @returns {boolean} whether or not the tab panel is active.
     */
    isActive: function isActive(href) {
      if (!href || !href.length || href.length === 1 && href.indexOf('#') < 1) {
        return false;
      }

      var panel = this.getPanel(href);
      return panel[0].classList.contains('can-show');
    },


    /**
     * Determines whether or not this tabset is nested inside a "Layout"-style of Tab container
     * @returns {boolean} whether or not this tabset is nested.
     */
    isNestedInLayoutTabs: function isNestedInLayoutTabs() {
      var nestedInModuleTabs = this.element.closest('.module-tabs').length;
      var nestedInHeaderTabs = this.element.closest('.header-tabs').length;
      var hasTabContainerClass = this.element.closest('.tab-panel-container').length;

      return nestedInModuleTabs > 0 || nestedInHeaderTabs > 0 || hasTabContainerClass > 0;
    },


    /**
     * Determines if an object is an HTML List Item representing a tab
     * @param {object} obj incoming object
     * @returns {boolean} whether or not the item is a tab
     */
    isTab: function isTab(obj) {
      return obj instanceof jQuery && obj.length && obj.is('li.tab');
    },


    /**
     * Determines if an object is an HTML Anchor Tag representing a tab's actionable element
     * @param {object} obj incoming object
     * @returns {boolean} whether or not the item is an anchor tag
     */
    isAnchor: function isAnchor(obj) {
      return obj instanceof jQuery && obj.length && obj.is('a');
    },


    /**
     * Gets a reference to an Anchor tag.
     * @param {string|jQuery} href either a string that can be used as a Tab ID, or an actual jQuery wrapped Anchor Tag.
     * @returns {jQuery} the Anchor tag
     */
    getAnchor: function getAnchor(href) {
      if (this.isAnchor(href)) {
        return href;
      }

      if (href.indexOf('#') === -1 && href.charAt(0) !== '/') {
        href = '#' + href;
      }

      return this.anchors.filter('[href="' + href + '"]');
    },


    /**
     * Gets a reference to a Tab panel.
     * @param {string|jQuery} href either a string that can be used as a Tab ID, or an actual jQuery wrapped Anchor Tag.
     * @returns {jQuery} the Anchor tag
     */
    getPanel: function getPanel(href) {
      if (this.isTab(href)) {
        href = href.children('a');
      }

      if (this.isAnchor(href)) {
        href = href.attr('href');
      }

      if (!href || href === '' || href === '#') {
        return $();
      }

      // uses angular LocationStrategy
      if (href.substr(0, 2) === '#/') {
        href = href.replace('#/', '#');
      }
      return this.panels.filter('[id="' + href.replace(/#/g, '') + '"]');
    },
    getMenuItem: function getMenuItem(href) {
      if (this.isAnchor(href)) {
        href = href.attr('href');
      }

      if (href.indexOf('#') === -1) {
        href = '#' + href;
      }
      return this.moreMenu.children().children().filter('[data-href="' + href + '"]').parent();
    },


    /**
     * Takes a tab ID and returns a jquery object containing the previous available tab
     * @param {string} tabId the tab ID
     * @returns {jQuery[]} jQuery-wrapped element reference for the tab
     */
    getPreviousTab: function getPreviousTab(tabId) {
      var tab = this.getTab(null, tabId);
      var filter = 'li:not(.separator):not(:hidden):not(.is-disabled)';
      var tabs = this.tablist.find(filter);
      var idx = tabs.index(tab);
      var target = tabs.eq(idx === 0 ? 1 : idx - 1);

      while (target.length && !target.is(filter)) {
        target = tabs.eq(tabs.index(target) - 1);
      }

      // Top-level Dropdown Tabs don't have an actual panel associated with them.
      // Get a Dropdown Tab's first child as the target.
      if (target.is('.has-popupmenu')) {
        var menuAPI = target.data('popupmenu');
        if (menuAPI) {
          target = menuAPI.menu.children('li').first();
        }
      }

      return target;
    },


    /**
     * Takes a tab ID and activates an adjacent available tab
     * @param {object} e event object
     * @param {string} tabId the tab ID
     */
    activateAdjacentTab: function activateAdjacentTab(e, tabId) {
      var tab = this.doGetTab(e, tabId);

      if (typeof e === 'string') {
        tabId = e;
      }

      if (tab.is('.is-selected')) {
        if (tab.prevAll('li.tab').not('.hidden').not('.is-disabled').length > 0) {
          this.select($(tab.prevAll('li.tab').not('.hidden').not('.is-disabled')[0]).find('a')[0].hash);
        } else if (tab.nextAll('li.tab').not('.hidden').length > 0) {
          this.select($(tab.nextAll('li.tab').not('.hidden').not('.is-disabled')[0]).find('a')[0].hash);
        }
      } else {
        this.select($(this.element.find('li.tab.is-selected')[0]).find('a')[0].hash);
      }
    },


    /**
     * Takes a tab ID and returns a jquery object containing the previous available tab
     * If an optional target Tab (li) is provided, use this to perform activation events
     * @param {string} tabId the tab ID
     * @param {jQuery[]} [target] a reference to the previous tab in the list (before this one)
     * @returns {jQuery[]} potentially-updated target
     */
    activatePreviousTab: function activatePreviousTab(tabId, target) {
      var tab = this.getTab(null, tabId);

      if (!target || !(target instanceof jQuery)) {
        target = this.getPreviousTab(tabId);
      }

      if (!target.length) {
        this.hideFocusState();
        this.defocusBar();
        return target;
      }

      var a = target.children('a');
      if (tab.is('.is-selected')) {
        if (!this.activate(a.attr('href'), a)) {
          return target;
        }
        a.focus();
      }
      this.positionFocusState(a);
      this.focusBar(target);

      return target;
    },


    /**
     * Determines whether or not a string has an outbound URL, instead of a hash (#) that would match up to a Tab ID.
     * @param {string} href a string that may or may not contain a URL
     * @returns {boolean} whether or not the incoming string is a URL
     */
    isURL: function isURL(href) {
      if (!href || href.indexOf('#') === 0) {
        return false;
      }

      return true;
    },


    /**
     * Causes a new tab panel to become active.  Will also trigger AJAX calls on unloaded tab panels, if necessary.
     * @param {string} href a string that either matches up to a Tab ID, or an outbound link to grab AJAX content from.
     * @param {object} anchor in addition to the ref the anchor object may be passed to avoid extra querying.
     * @returns {void}
     */
    activate: function activate(href, anchor) {
      var self = this;

      if (self.isURL(href)) {
        return this.callSource(href, anchor, true);
      }

      var a = self.getAnchor(href);
      var targetTab = a.parent();
      var targetPanel = self.getPanel(href);
      var targetPanelElem = targetPanel[0];
      var oldTab = self.anchors.parents().filter('.is-selected');
      var oldPanel = void 0;
      var selectedStateTarget = void 0;
      var activeStateTarget = void 0;

      // Avoid filter(:visible)
      for (var i = 0; i < self.panels.length; i++) {
        if (self.panels[i].classList.contains('is-visible')) {
          oldPanel = $(self.panels[i]);
        }
      }

      if (!oldPanel) {
        oldPanel = self.panels;
      }

      // NOTE: Breaking Change as of 4.3.3 - `beforeactivate` to `beforeactivated`
      // See SOHO-5994 for more details
      /**
       * Fires when an attempt at activating a tab is started
       *
       * @event beforeactivated
       * @memberof Tabs
       * @param {jQuery.Event} e event object
       * @param {jQuery} a the tab anchor attempting to activate
       */
      var isCancelled = self.element.trigger('beforeactivated', [a]);
      if (!isCancelled) {
        return false;
      }

      function completeActivate(vetoResult) {
        if (targetPanel.length < 1) {
          if (self.settings.source) {
            self.callSource(href, a);
            return true;
          }
        } else {
          oldPanel[0].classList.remove('can-show');
          oldPanel[0].classList.remove('is-visible');
          oldPanel.closeChildren();

          /**
           * Fires when a new tab has been activated
           *
           * @event activated
           * @memberof Tabs
           * @param {jQuery.Event} e event object
           * @param {jQuery} a the tab anchor attempting to activate
           */
          self.element.trigger('activated', [a]);

          targetPanelElem.classList.add('can-show');
          self.renderVisiblePanel();
          // trigger reflow as display property is none for animation
          // eslint-disable-next-line
          targetPanelElem.offsetHeight;

          targetPanel.one($.fn.transitionEndName() + '.tabs', function () {
            /**
             * Fires when a new tab has been completely activated, and the activation process is done
             *
             * @event afteractivated
             * @memberof Tabs
             * @param {jQuery.Event} e event object
             * @param {jQuery} a the tab anchor attempting to activate
             */
            self.element.trigger('afteractivated', [a]);
          });

          // Triggers the CSS Animation
          targetPanelElem.classList.add('is-visible');
        }

        // Update the currently-selected tab
        self.updateAria(a);
        oldTab.add(self.moreButton).removeClass('is-selected');
        if (targetTab[0]) {
          if (targetTab[0].classList.contains('tab')) {
            selectedStateTarget = targetTab;
            activeStateTarget = targetTab;
          }
        }

        var ddMenu = targetTab.parents('.popupmenu');
        var ddTab = void 0;

        if (ddMenu.length) {
          ddTab = ddMenu.data('trigger');
          if (ddTab.length) {
            selectedStateTarget = ddTab;
            activeStateTarget = ddTab;
          }
        }

        if (self.isTabOverflowed(activeStateTarget)) {
          activeStateTarget = self.moreButton;
          selectedStateTarget = self.moreButton;
        }
        self.focusBar(activeStateTarget);

        if (selectedStateTarget) {
          selectedStateTarget.addClass('is-selected');
        }

        // Fires a resize on any invoked child toolbars inside the tab panel.
        // Needed to fix issues with Toolbar alignment, since we can't properly detect
        // size on hidden elements.
        var childToolbars = targetPanel.find('.toolbar');
        if (childToolbars.length) {
          childToolbars.each(function () {
            var api = $(this).data('toolbar');
            if (api && typeof api.handleResize === 'function') {
              api.handleResize();
            }
          });
        }

        // Automatically refresh all icons inside Tab panels on activation.
        // See SOHO-7313
        utils.fixSVGIcons(targetPanel[0]);

        return vetoResult || false;
      }

      // Handle an optional, veto-able "beforeActivate" callback.
      if (this.settings.beforeActivate && typeof this.settings.beforeActivate === 'function') {
        return this.settings.beforeActivate(oldTab, targetTab, completeActivate);
      }

      // Otherwise, simply continue
      return completeActivate(true);
    },


    /**
     * Shows/Hides some tabsets' faded edges based on scrolling position, if applicable.
     * @private
     * @returns {undefined}
     */
    renderEdgeFading: function renderEdgeFading() {
      if (!this.isScrollableTabs() || !this.tablistContainer) {
        return;
      }

      var isRTL = Locale.isRTL();
      var tablistContainerElem = this.tablistContainer[0];
      var scrollLeft = tablistContainerElem.scrollLeft;
      var scrollWidth = tablistContainerElem.scrollWidth;
      var containerWidth = parseInt(window.getComputedStyle(tablistContainerElem).getPropertyValue('width'), 10);

      if (isRTL) {
        this.element[0].classList[scrollLeft > 0 ? 'add' : 'remove']('scrolled-left');
        this.element[0].classList[scrollWidth - scrollLeft <= containerWidth ? 'remove' : 'add']('scrolled-right');
      } else {
        this.element[0].classList[scrollLeft > 0 ? 'add' : 'remove']('scrolled-right');
        this.element[0].classList[scrollWidth - scrollLeft <= containerWidth ? 'remove' : 'add']('scrolled-left');
      }
    },


    /**
     * Calls an options-provided source method to fetch content that will be displayed inside a tab.
     * @param {string} href - string representing the target tab to load content under.
     * @param {object} anchor - Reference to the dom object anchor tag.
     * @param {boolean} isURL detects whether or not the URL is actually an external /
     * call, or an ID for an existing tab in the page.
     * @returns {boolean|$.Deferred} true if source call was successful, false for failure/ignore,
     * or a promise object that will fire callbacks in either "success" or "failure" scenarios.
     */
    callSource: function callSource(href, anchor, isURL) {
      var _this3 = this;

      if ((isURL === undefined || isURL === null || isURL === false) && !this.settings.source) {
        return false;
      }
      if (this.settings.lazyLoad !== true) {
        return false;
      }

      var sourceType = _typeof(this.settings.source);
      var response = function response(htmlContent) {
        if (htmlContent === undefined || htmlContent === null) {
          return;
        }

        htmlContent = xssUtils.sanitizeHTML(htmlContent);

        // Get a new random tab ID for this tab if one can't be derived from the URL string
        if (isURL) {
          var containerId = _this3.element[0].id || '';
          var id = utils.uniqueId(anchor, 'tab', containerId);

          href = '#' + id;
          // Replace the original URL on this anchor now that we've loaded content.
          anchor[0].setAttribute('href', href);
        }

        _this3.createTabPanel(href, htmlContent, true);
        _this3.activate(href);

        _this3.element.triggerHandler('complete'); // For Busy Indicator
        _this3.element.trigger('requestend', [href, htmlContent]);
      };

      this.container.triggerHandler('start'); // For Busy Indicator
      this.container.trigger('requeststart');

      function handleStringSource(url, options) {
        var opts = $.extend({ dataType: 'html' }, options, {
          url: url
        });

        var request = $.ajax(opts);
        request.done(response);
        return request;
      }

      if (isURL) {
        return handleStringSource(href, this.ajaxOptions);
      }

      // return _true_ from this source function on if we're just loading straight content
      // return a promise if you'd like to setup async handling.
      if (sourceType === 'function') {
        return this.settings.source(response, href, this.settings.sourceArguments);
      }

      if (sourceType === 'string') {
        // Attempt to resolve source as a URL string.  Make an $.ajax() call with the URL
        var safeHref = href.replace(/#/g, '');
        var sourceURL = this.settings.source.toString();
        var hasHref = sourceURL.indexOf(safeHref) > -1;

        if (!hasHref) {
          var param = 'tab=' + safeHref;
          var paramIndex = sourceURL.indexOf('?');
          var hashIndex = sourceURL.indexOf('#');
          var insertIndex = sourceURL.length;

          if (paramIndex < 0) {
            param = '?' + param;
            if (hashIndex > -1) {
              insertIndex = hashIndex + 1;
            }
          } else {
            param += '&';
            insertIndex = paramIndex + 1;
          }

          sourceURL = stringUtils.splice(sourceURL, insertIndex, 0, param);
        }

        return handleStringSource(sourceURL, this.ajaxOptions);
      }

      return false;
    },


    /**
     * @private
     */
    renderVisiblePanel: function renderVisiblePanel() {
      // Recalculate all components inside of the visible tab to adjust
      // widths/heights/display if necessary
      this.resizeNestedTabs();
      // TJM: Prioritizing performance fix.
      // this.panels.filter(':visible').handleResize();
    },


    /**
     *
     * Update the hash in the link.
     * @private
     * @param  {HTMLElement} href The Dom Element.
     * @returns {void}
     */
    changeHash: function changeHash(href) {
      if (!this.settings.changeTabOnHashChange) {
        return;
      }

      if (!href) {
        href = '';
      }

      href.replace(/#/g, '');

      var cb = this.settings.hashChangeCallback;
      if (cb && typeof cb === 'function') {
        cb(href);
      } else {
        window.location.hash = href;
      }

      /**
       * @event hash-change
       * @memberof Tabs
       * @param {jQuery.Event} e the jQuery event object
       * @param {string} href the new hash fragment for the URL
       */
      this.element.triggerHandler('hash-change', [href]);
    },


    /**
     * Updates the aria-related markup on all tab elements
     * @private
     * @param {jQuery} a the 'selected' tab anchor
     */
    updateAria: function updateAria(a) {
      if (!a) {
        return;
      }
      // hide old tabs
      this.anchors.attr({
        'aria-selected': 'false',
        'aria-expanded': 'false',
        tabindex: '-1'
      });
      this.moreButton.attr({
        tabindex: '-1'
      });

      // show current tab
      if (a.length && this.element.is(':not(.is-disabled)')) {
        a.parent().removeClass('is-selected');
        if (!this.isTabOverflowed(a.parent())) {
          a.attr({
            'aria-selected': 'true',
            'aria-expanded': 'true',
            tabindex: '0'
          }).parent().addClass('is-selected');
        } else {
          this.moreButton.attr({
            tabindex: '0'
          });
        }
      }
    },


    /**
     * Causes `handleResize()` to be fired on any Tab components that are nested inside of this tab component's panels.
     * @returns {void}
     */
    resizeNestedTabs: function resizeNestedTabs() {
      this.nestedTabControls.each(function (i, container) {
        var c = $(container);
        var api = c.data('tabs');

        if (api && api.handleResize && typeof api.handleResize === 'function') {
          api.handleResize(true);
        }
      });
    },


    /**
     * Adds a new tab into the list and properly binds all of its events
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @param {object} options incoming options for the new tab.
     * @param {string} [options.name] the text title of the new tab.
     * @param {boolean} [options.doActivate=false] if true, causes the newly-added tab to become activated and focused.
     * @param {boolean} [options.isDismissible=false] if true, causes the tab to become dismissible (closable) with an "X" button.
     * @param {boolean} [options.isDropdown=false] if true, causes the tab to become a dropdown tab.
     * @param {string} [options.content] representing HTML markup that will be added inside of the new tab panel.
     * @param {number} [atIndex] if defined, inserts the tab at a particular number index in the tab list.  Defaults to the last tab in the list.
     * @returns {this} component instance
     */
    add: function add(tabId, options, atIndex) {
      if (!tabId) {
        return this;
      }

      if (!options) {
        options = {};
      }

      var startFromZero = this.tablist.find('li').not('.application-menu-trigger, .add-tab-button').length === 0;

      // Sanitize
      tabId = '' + tabId.replace(/#/g, '');
      options.name = options.name ? options.name.toString() : '&nbsp;';
      options.isDismissible = options.isDismissible ? options.isDismissible === true : false;
      options.isDropdown = options.isDropdown ? options.isDropdown === true : false;

      function getObjectFromSelector(sourceString) {
        var contentType = typeof sourceString === 'undefined' ? 'undefined' : _typeof(sourceString);
        var hasId = void 0;

        switch (contentType) {
          case 'string':
            hasId = sourceString.match(/#/g);
            // Text Content or a Selector.
            if (hasId !== null) {
              var obj = $(sourceString);
              sourceString = obj.length ? obj : sourceString;
            }
            // do nothing if it's just a string of text.
            break;
          default:
            break;
        }
        return sourceString;
      }

      if (options.content) {
        options.content = getObjectFromSelector(options.content);
      }
      if (options.dropdown) {
        options.dropdown = getObjectFromSelector(options.dropdown);
      }

      // Build
      var tabHeaderMarkup = $('<li role="presentation" class="tab"></li>');
      var anchorMarkup = $('<a href="#' + tabId + '" role="tab" aria-expanded="false" aria-selected="false" tabindex="-1">' + options.name + '</a>');
      var tabContentMarkup = this.createTabPanel(tabId, options.content);

      tabHeaderMarkup.html(anchorMarkup);

      if (options.isDismissible) {
        tabHeaderMarkup.addClass('dismissible');
        tabHeaderMarkup.append($.createIconElement({ icon: 'close', classes: 'close icon' }));
      }

      if (this.settings.tabCounts) {
        anchorMarkup.prepend('<span class="count">0 </span>');
      }

      if (options.dropdown) ;

      function insertIntoTabset(self, targetIndex) {
        var method = void 0;
        var tabs = self.tablist.children('li');
        var nonSpecialTabs = tabs.not('.application-menu-trigger, .add-tab-button');
        var finalIndex = tabs.length - 1;

        if (!tabs.length) {
          tabHeaderMarkup.appendTo(self.tablist);
          tabContentMarkup.appendTo(self.container);
          return;
        }

        var addTabButton = tabs.filter('.add-tab-button');
        var appMenuTrigger = tabs.filter('.application-menu-trigger');

        // NOTE: Cannot simply do !targetIndex here because zero is a valid index
        if (targetIndex === undefined || targetIndex === null || isNaN(targetIndex)) {
          targetIndex = tabs.length;
        }

        function pastEndOfTabset(index) {
          return index > tabs.length - 1;
        }

        function atBeginningOfTabset(index) {
          return index <= 0;
        }

        if (tabs.length > nonSpecialTabs.length) {
          if (pastEndOfTabset(targetIndex) && addTabButton && addTabButton.length) {
            targetIndex -= 1;
          }

          if (atBeginningOfTabset(targetIndex) && appMenuTrigger && appMenuTrigger.length) {
            targetIndex += 1;
          }
        }

        var conditionInsertTabBefore = tabs.eq(targetIndex).length > 0;

        finalIndex = conditionInsertTabBefore ? targetIndex : finalIndex;

        method = 'insertAfter';
        if (conditionInsertTabBefore) {
          method = 'insertBefore';
        }

        tabHeaderMarkup[method](tabs.eq(finalIndex));
        tabContentMarkup.appendTo(self.container);
      }

      insertIntoTabset(this, atIndex);

      // Add each new part to their respective collections.
      this.panels = this.panels.add(tabContentMarkup);
      this.anchors = this.anchors.add(anchorMarkup);

      // Link the two items via data()
      anchorMarkup.data('panel-link', tabContentMarkup);
      tabContentMarkup.data('tab-link', anchorMarkup);
      // TODO: When Dropdown Tabs can be added/removed, add that here

      // Make it possible for Module Tabs to display a tooltip containing their contents
      // if the contents are cut off by ellipsis.
      if (this.settings.moduleTabsTooltips) {
        anchorMarkup.on('beforeshow.toolbar', function () {
          return anchorMarkup.data('cutoffTitle') === 'yes';
        }).tooltip({
          content: '' + anchorMarkup.text().trim()
        });
      }

      // Recalc tab width before detection of overflow
      if (this.isModuleTabs()) {
        this.adjustModuleTabs();
      }

      // Adjust tablist height
      this.setOverflow();

      // If started from zero, position the focus state/bar and activate the tab
      if (startFromZero) {
        this.positionFocusState(anchorMarkup);
        this.focusBar(tabHeaderMarkup);
        if (!this.activate(anchorMarkup.attr('href'))) {
          return this;
        }
        anchorMarkup.focus();
      }

      if (options.doActivate) {
        this.activate(anchorMarkup.attr('href'));
      }

      return this;
    },


    /**
     * Removes a tab from the list and cleans up properly
     * NOTE: Does not take advantage of _activatePreviousTab()_ due to specific needs
     * of selecting certain Tabs/Anchors at certain times.
     * @param {string} tabId tab ID that corresponds to a `.tab-panel` element's ID attribute
     * @param {boolean} disableBeforeClose whether or not tab closing can become veteoed
     * @returns {boolean|this} component instance
     */
    remove: function remove(tabId, disableBeforeClose) {
      var self = this;
      var targetLi = this.doGetTab(null, tabId);

      if (!targetLi || !targetLi.length) {
        return false;
      }

      var targetAnchor = targetLi.children('a');
      var targetPanel = this.getPanel(tabId);
      var hasTargetPanel = targetPanel && targetPanel.length;
      var targetLiIndex = this.tablist.children('li').index(targetLi);
      var notATab = '.application-menu-trigger, .separator, .is-disabled, :hidden';
      var prevLi = targetLi.prev();

      if (!disableBeforeClose) {
        var canClose = this.element.triggerHandler('beforeclose', [targetLi]);
        if (canClose === false) {
          return false;
        }
      }

      var wasSelected = false;
      if (targetLi.hasClass('is-selected')) {
        wasSelected = true;
      } else {
        prevLi = this.tablist.children('li').not(notATab).filter('.is-selected');
      }

      // Remove these from the collections
      if (hasTargetPanel) {
        this.panels = this.panels.not(targetPanel);
      }
      this.anchors = this.anchors.not(targetAnchor);

      // Destroy Anchor tooltips, if applicable
      if (this.settings.moduleTabsTooltips) {
        targetAnchor.off('beforeshow.toolbar').data('tooltip').destroy();
      }

      // Close Dropdown Tabs in a clean fashion
      var popupAPI = targetLi.data('popupmenu');
      if (targetLi.hasClass('has-popupmenu')) {
        if (popupAPI) {
          popupAPI.menu.children('li').each(function () {
            self.remove($(this).children('a').attr('href'));
          });
          popupAPI.destroy();
        }
      }

      // If this tab is inside of a Dropdown Tab's menu, detect if it was the last one
      // remaining, and if so, close the entire Dropdown Tab.
      // The actual check on these elements needs to be done AFTER the targetLi is removed
      // from a Dropdown Tab, to accurately check the number of list items remaining.
      // See: _isLastDropdownTabItem()_
      var parentMenu = targetLi.closest('.dropdown-tab');
      var trigger = parentMenu.data('trigger');

      // Kill associated events
      targetLi.off('click.tabs');
      targetAnchor.off('click.tabs focus.tabs keydown.tabs');

      // Remove Markup
      targetLi.remove();
      if (hasTargetPanel) {
        targetPanel.remove();
      }

      var menuItem = targetAnchor.data('moremenu-link');
      if (menuItem) {
        menuItem.parent().off().remove();
        $.removeData(targetAnchor[0], 'moremenu-link');
      }

      function isLastDropdownTabItem(menu) {
        return menu.length && menu.children('li:not(.separator)').length === 0;
      }
      if (isLastDropdownTabItem(parentMenu)) {
        prevLi = this.getPreviousTab(trigger);

        setTimeout(function () {
          self.remove(trigger);
        }, 1);
      }

      // Close dropdown tab's menu
      if (trigger && trigger.length) {
        trigger.data('popupmenu').close();
      }

      // Recalc tab width before detection of overflow
      if (this.isModuleTabs()) {
        this.adjustModuleTabs();
      }

      // Adjust tablist height
      this.setOverflow();

      /**
       * Fires when a tab is removed from the tabset
       *
       * @event close
       * @memberof Tabs
       * @param {jQuery.Event} e event object
       * @param {jQuery} targetLi the tab list item being closed
       */
      this.element.trigger('close', [targetLi]);

      // If any tabs are left in the list, set the first available tab as the currently selected one.
      var count = targetLiIndex - 1;
      while (count > -1) {
        count = -1;
        if (prevLi.is(notATab)) {
          prevLi = this.tablist.children('li').not(notATab)[0];
          count -= 1;
        }
      }

      // If we find nothing, search for ANY available tab
      if (!prevLi.length) {
        prevLi = this.tablist.children('li').not(notATab).first();
      }

      // If there's really nothing, kick on out and defocus everything.
      if (!prevLi.length) {
        this.hideFocusState();
        this.defocusBar();

        this.element.trigger('afterclose', [targetLi]);
        return this;
      }

      var a = prevLi.children('a');
      var activateTargetA = a;

      this.positionFocusState(a);

      if (wasSelected) {
        if (prevLi.is('.has-popupmenu') && prevLi.data('popupmenu')) {
          activateTargetA = prevLi.data('popupmenu').menu.children().first().children('a');
        }
        if (!this.activate(activateTargetA.attr('href'))) {
          return this;
        }
      }

      this.focusBar(prevLi);
      a.focus();

      /**
       * Fires after a tab is completely removed from the tabset, and the close process has completed.
       *
       * @event afterclose
       * @memberof Tabs
       * @param {jQuery.Event} e event object
       * @param {jQuery} targetLi the tab list item being closed
       */
      this.element.trigger('afterclose', [targetLi]);

      return this;
    },


    /**
     * Adds a new tab into the list and properly binds all of its events
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @param {string} [content] representing HTML markup that will be added inside of the new tab panel.
     * @param {boolean} [doInsert=false] if true, actually appends the new content to the tab panel.
     * @returns {this} component instance
     */
    createTabPanel: function createTabPanel(tabId, content, doInsert) {
      tabId = tabId.replace(/#/g, '');

      // If a jQuery-wrapped element is provided, actually append the element.
      // If content is text/string, simply inline it.
      var markup = $('<div id="' + tabId + '" class="tab-panel" role="tabpanel"></div>');
      if (content instanceof $) {
        content = content[0];
      }
      DOM.html(markup[0], content || '', '*');

      if (doInsert === true) {
        this.container.append(markup);
      }

      this.panels = this.panels.add(markup);

      return markup;
    },


    /**
     * @param {jQuery} tab the tab to be checked for popupmenu items.
     * @returns {jQuery[]} a list of avaiable popupmenu items
     */
    checkPopupMenuItems: function checkPopupMenuItems(tab) {
      function getRemainingMenuItems(popupAPI) {
        if (!popupAPI || !popupAPI.menu) {
          return $();
        }
        var menu = popupAPI.menu;
        var items = menu.children('li');

        if (!items.length) {
          popupAPI.destroy();
          return $();
        }
        return items;
      }

      if (tab.is('.has-popupmenu')) {
        return getRemainingMenuItems(tab.data('popupmenu'));
      }

      var ddTab = tab.closest('.dropdown-tab');
      if (!ddTab.length) {
        return $();
      }
      return getRemainingMenuItems(ddTab.data('popupmenu'));
    },


    // @private
    getTab: function getTab(e, tabId) {
      var self = this;
      var tab = $();

      function getTabFromEvent(ev) {
        var t = $(ev.currentTarget);
        if (t.is('.tab')) {
          return t;
        }
        if (t.closest('.tab').length) {
          return t.closest('.tab').first();
        }
        return null;
      }

      function getTabFromId(id) {
        if (!id || id === '' || id === '#') {
          return null;
        }

        if (id.indexOf('#') === -1) {
          id = '#' + id;
        }

        var anchor = self.anchors.filter('[href="' + id + '"]');
        if (!anchor.length) {
          return null;
        }

        return anchor.parent();
      }

      // TabId can also be a jQuery object containing a tab.
      if (tabId instanceof $ && tabId.length > 0) {
        if (tabId.is('a')) {
          return tabId.parent();
        }
        return tabId;
      }

      if (e) {
        return getTabFromEvent(e);
      } else if (tabId) {
        return getTabFromId(tabId);
      }

      return tab;
    },


    // @private
    doGetTab: function doGetTab(e, tabId) {
      if (!e && !tabId) {
        return $();
      }
      if (e && !(e instanceof $.Event) && typeof e !== 'string') {
        return $();
      }

      if (e) {
        if (typeof e !== 'string') {
          // jQuery Event
          return this.getTab(e);
        }
        return this.getTab(null, e); // String containing a selector
      }

      // Straight to the TabID
      return this.getTab(null, tabId);
    },


    /**
     * Hides a tab
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @returns {this} component instance
     */
    hide: function hide(e, tabId) {
      var tab = this.doGetTab(e, tabId);

      this.activateAdjacentTab(e, tabId);

      tab.addClass('hidden');
      this.focusBar();
      this.positionFocusState();
      return this;
    },


    /**
     * Shows a tab
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @returns {this} component instance
     */
    show: function show(e, tabId) {
      var tab = this.doGetTab(e, tabId);

      tab.removeClass('hidden');

      this.select($(this.element.find('li.tab.is-selected')[0]).find('a')[0].hash);

      this.focusBar();
      this.positionFocusState();
      return this;
    },


    /**
     * Disables an individual tab
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @returns {this} component instance
     */
    disableTab: function disableTab(e, tabId) {
      var tab = this.doGetTab(e, tabId);

      this.activateAdjacentTab(e, tabId);

      tab.addClass('is-disabled');
      this.focusBar();
      this.positionFocusState();
      return this;
    },


    /**
     * Enables an individual tab
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @returns {this} component instance
     */
    enableTab: function enableTab(e, tabId) {
      var tab = this.doGetTab(e, tabId);

      tab.removeClass('is-disabled');
      this.focusBar();
      this.positionFocusState();
      return this;
    },


    /**
     * Renames a tab and resets the focusable bar/animation.
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @param {string} name the new tab name
     * @returns {void}
     */
    rename: function rename(e, tabId, name) {
      // Backwards compatibility with 4.2.0
      if (e && typeof e === 'string') {
        name = tabId;
        tabId = e;
      }

      if (!name) {
        return;
      }

      var tab = this.doGetTab(e, tabId);
      var hasCounts = this.settings.tabCounts;
      var hasTooltip = this.settings.moduleTabsTooltips;
      var anchor = tab.children('a');
      var count = void 0;

      if (hasCounts) {
        count = anchor.find('.count').clone();
      }

      anchor.text(name.toString());

      if (hasCounts) {
        anchor.prepend(count);
      }

      if (hasTooltip) {
        anchor.data('tooltip').setContent(name.trim());
      }

      var doesTabExist = this.tablist.children('li').length < 2 ? tab : undefined;

      this.positionFocusState(doesTabExist);
      this.focusBar(doesTabExist);
    },


    /**
     * For tabs with counts, updates the count and resets the focusable bar/animation
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @param {number|string} count the new tab count
     * @returns {void}
     */
    updateCount: function updateCount(e, tabId, count) {
      // Backwards compatibility with 4.2.0
      if (e && typeof e === 'string') {
        count = tabId;
        tabId = e;
      }

      if (!this.settings.tabCounts || !count) {
        return;
      }

      var tab = this.doGetTab(e, tabId);

      tab.children('a').find('.count').text(count.toString() + ' ');

      var doesTabExist = this.tablist.children('li').length < 2 ? tab : undefined;

      this.positionFocusState(doesTabExist);
      this.focusBar(doesTabExist);
    },


    /**
     * returns the currently active tab
     * @returns {jQuery} the currently active tab anchor
     */
    getActiveTab: function getActiveTab() {
      var visible = this.panels.filter(':visible');
      return this.anchors.filter('[href="#' + visible.first().attr('id') + '"]');
    },


    /**
     * returns all visible tabs
     * @returns {jQuery[]} all visible tabs
     */
    getVisibleTabs: function getVisibleTabs() {
      var self = this;
      var tabHash = $();

      this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)').each(function tabOverflowIterator() {
        var tab = $(this);

        if (!self.isTabOverflowed(tab)) {
          tabHash = tabHash.add(tab);
        }
      });

      return tabHash;
    },


    /**
     * returns a list of all tabs that are currently in the "More..." overflow menu.
     * @returns {jQuery[]} all overflowed tabs
     */
    getOverflowTabs: function getOverflowTabs() {
      var self = this;
      var tabHash = $();

      this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)').each(function tabOverflowIterator() {
        var tab = $(this);

        if (self.isTabOverflowed(tab)) {
          tabHash = tabHash.add(tab);
        }
      });

      return tabHash;
    },


    /**
     * @private
     * @returns {void}
     */
    setOverflow: function setOverflow() {
      var self = this;
      var elem = this.element[0];
      var tablist = this.tablist[0];
      var HAS_MORE = 'has-more-button';
      var hasMoreIndex = this.hasMoreButton();
      var isScrollableTabs = this.isScrollableTabs();

      function checkModuleTabs() {
        if (self.isModuleTabs()) {
          self.adjustModuleTabs();
        }
      }

      // Recalc tab width before detection of overflow
      checkModuleTabs();

      var tablistStyle = void 0;
      var tablistHeight = void 0;
      var tablistContainerScrollWidth = void 0;
      var tablistContainerWidth = void 0;
      var overflowCondition = void 0;

      if (isScrollableTabs) {
        tablistContainerScrollWidth = this.tablistContainer[0].scrollWidth;
        tablistContainerWidth = this.tablistContainer[0].offsetWidth;
        overflowCondition = tablistContainerScrollWidth > tablistContainerWidth;
      } else {
        tablistStyle = window.getComputedStyle(tablist, null);
        tablistHeight = parseInt(tablistStyle.getPropertyValue('height'), 10) + 1; // +1 to fix an IE bug
        overflowCondition = tablist.scrollHeight > tablistHeight; // Normal tabs check the height
      }

      // Add "has-more-button" class if we need it, remove it if we don't
      // Always display the more button on Scrollable Tabs
      if (overflowCondition) {
        if (!hasMoreIndex) {
          elem.classList.add(HAS_MORE);
          checkModuleTabs();
        }
      } else if (hasMoreIndex) {
        elem.classList.remove(HAS_MORE);
        checkModuleTabs();
      }

      this.adjustSpilloverNumber();
    },


    /**
     * @private
     * @returns {void}
     */
    adjustModuleTabs: function adjustModuleTabs() {
      var self = this;
      var sizeableTabs = this.tablist.find('li:not(.separator):not(.application-menu-trigger):not(:hidden)');
      var appTrigger = this.tablist.find('.application-menu-trigger');
      var hasAppTrigger = appTrigger.length > 0;
      var tabContainerW = this.tablist.outerWidth();
      var defaultTabSize = 120;
      var visibleTabSize = 120;
      var appTriggerSize = hasAppTrigger ? appTrigger.outerWidth() : 0;

      // Remove overflowed tabs
      sizeableTabs.children('a').removeAttr('style');
      sizeableTabs.removeAttr('style').each(function () {
        var t = $(this);
        if (self.isTabOverflowed(t)) {
          sizeableTabs = sizeableTabs.not(t);
        }
      });

      // Resize the more button to fit the entire space if no tabs can show
      // Math: +101 is the padding of the <ul class="tab-list"> element
      if (!sizeableTabs.length) {
        visibleTabSize = tabContainerW - appTriggerSize + 101;
        this.moreButton[0].style.width = visibleTabSize + 'px';
        return;
      }
      var anchorStyle = window.getComputedStyle(sizeableTabs.eq(0).children()[0]);
      var anchorPadding = parseInt(anchorStyle.paddingLeft, 10) + parseInt(anchorStyle.paddingRight, 10);

      if (this.moreButton[0].hasAttribute('style')) {
        this.moreButton[0].removeAttribute('style');
      }

      // Math explanation:
      // Width of tab container - possible applcation menu trigger
      // Divided by number of visible tabs
      // (doesn't include app menu trigger which shouldn't change size).
      // Minus one (for the left-side border of each tab)
      visibleTabSize = (tabContainerW - appTriggerSize) / sizeableTabs.length - 1;

      if (visibleTabSize < defaultTabSize) {
        visibleTabSize = defaultTabSize;
      }

      var a = void 0;
      var prevWidth = void 0;
      var cutoff = 'no';

      for (var i = 0; i < sizeableTabs.length; i++) {
        a = sizeableTabs.eq(i).children('a');
        a[0].style.width = '';

        if (this.settings.moduleTabsTooltips === true) {
          cutoff = 'no';

          prevWidth = parseInt(window.getComputedStyle(sizeableTabs[i]).width, 10);

          if (prevWidth > visibleTabSize - anchorPadding) {
            cutoff = 'yes';
          }
          a.data('cutoffTitle', cutoff);
        }

        sizeableTabs[i].style.width = visibleTabSize + 'px';
        a[0].style.width = visibleTabSize + 'px';
      }

      this.adjustSpilloverNumber();
    },


    /**
     * @private
     * @returns {void}
     */
    adjustSpilloverNumber: function adjustSpilloverNumber() {
      var moreDiv = this.moreButton.find('.more-text');
      var tabs = this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)');
      var overflowedTabs = this.getOverflowTabs();

      if (tabs.length <= overflowedTabs.length) {
        moreDiv.text('' + Locale.translate('Tabs'));
      } else {
        moreDiv.text('' + Locale.translate('More'));
      }

      var countDiv = this.moreButton.find('.count');
      if (!countDiv.length) {
        countDiv = $('<span class="count"></span>');
        this.moreButton.children('span').first().prepend(countDiv);
      }

      countDiv.text(overflowedTabs.length + ' ');
    },


    /**
     * Selects a Tab
     * @param {string} href a string representing the HTML `id` attribute of the new tab panel.
     * @returns {void}
     */
    select: function select(href) {
      var modHref = href.replace(/#/g, '');
      var anchor = this.getAnchor(modHref);

      this.positionFocusState(undefined, false);
      this.focusBar(anchor.parent());

      if (!this.activate(anchor.attr('href'))) {
        return;
      }
      this.changeHash(modHref);

      anchor.focus();
    },


    /**
     * Builds tab popupmenu
     * @param {string} startingHref a string representing the HTML `href` attribute of the popupmenu item to be selected.
     * @returns {void}
     */
    buildPopupMenu: function buildPopupMenu(startingHref) {
      var self = this;
      if (self.popupmenu) {
        self.popupmenu.destroy();
        $('#tab-container-popupmenu').off('focus.popupmenu').remove();
        $(document).off('keydown.popupmenu');
      }

      // Build the new markup for the popupmenu if it doesn't exist.
      // Reset it if it does exist.
      var menuHtml = $('#tab-container-popupmenu');
      var shouldBeSelectable = '';
      if (this.isScrollableTabs()) {
        shouldBeSelectable = ' is-selectable';
      }

      if (menuHtml.length === 0) {
        menuHtml = $('<ul id="tab-container-popupmenu" class="tab-list-spillover' + shouldBeSelectable + '">').appendTo('body');
      } else {
        menuHtml.html('');
      }

      // Build menu options from overflowed tabs
      var tabs = self.tablist.children('li');
      var isRTL = Locale.isRTL();

      function buildMenuItem(item) {
        var $item = $(item);
        var $itemA = $item.children('a');

        if ($item.is(':hidden')) {
          return;
        }

        if (!self.isScrollableTabs() && !self.isTabOverflowed($item)) {
          return;
        }

        if ($item.is('.separator')) {
          $item.clone().appendTo(menuHtml);
          return;
        }

        var popupLi = $item.clone();
        var popupA = popupLi.children('a');

        popupLi[0].classList.remove('tab');
        if (popupLi[0].classList.contains('is-selected')) {
          popupLi[0].classList.remove('is-selected');
          if (self.isScrollableTabs()) {
            popupLi[0].classList.add('is-checked');
          }
        }

        popupLi[0].removeAttribute('style');

        popupLi.children('.icon').off().appendTo(popupA);
        popupLi.appendTo(menuHtml);

        // Link tab to its corresponding "More Tabs" menu option
        $item.data('moremenu-link', popupA);
        popupA.find('.icon-more').remove();

        // Link "More Tabs" menu option to its corresponding Tab.
        // Remove onclick methods from the popup <li> because they are called
        // on the "select" event in context of the original button
        popupA.data('original-tab', $itemA);
        popupA.onclick = undefined;

        if (!$item.is('.has-popupmenu')) {
          return;
        }

        // If this is a Dropdown Tab, clone its menu and add it to the "More Tabs" menu
        // As a submenu of the "popupLi".
        var submenu = $('#' + item.getAttribute('aria-controls'));
        var clone = submenu.clone();
        var cloneLis = clone.children('li');

        clone[0].classList.remove('has-popupmenu');

        cloneLis.each(function (i) {
          var li = $(this);
          var a = li.children('a');
          var originalLi = submenu.children('li').eq(i);
          var originalA = originalLi.children('a');

          a.data('original-tab', originalA);
          originalA.data('moremenu-link', a);
        });

        clone.insertAfter(popupA);
      }

      // Build spillover menu options
      for (var i = 0; i < tabs.length; i++) {
        buildMenuItem(tabs[i]);
      }

      self.tablist.children('li:not(.separator)').removeClass('is-focused');
      var xOffset = 1;
      if (!this.isScrollableTabs()) {
        xOffset = 3;
      }

      // Invoke the popup menu on the button.
      self.moreButton.popupmenu({
        autoFocus: false,
        attachToBody: true,
        menu: 'tab-container-popupmenu',
        trigger: 'immediate',
        offset: { x: xOffset }
      });
      self.moreButton.addClass('popup-is-open');
      self.popupmenu = self.moreButton.data('popupmenu');

      self.positionFocusState(self.moreButton);

      function closeMenu() {
        $(this).off('close.tabs selected.tabs');
        self.moreButton.removeClass('popup-is-open');
        self.positionFocusState(undefined);
        self.focusBar();
      }

      function selectMenuOption(e, anchor) {
        var href = anchor.attr('href');
        var id = href.substr(1, href.length);
        var tab = self.doGetTab(id) || $();
        var a = tab ? tab.children('a') : $();
        var originalTab = anchor.data('original-tab').parent();

        if (originalTab.is('.add-tab-button')) {
          a = self.handleAddButton();
          originalTab = a.parent();
          href = a.attr('href');
          self.element.trigger('tab-added', [a]);
        }

        self.activate(href);

        // Fire an onclick event associated with the original tab from the spillover menu
        if (tab.length && a.length && typeof a[0].onclick === 'function') {
          a[0].onclick.apply(a[0]);
        }

        // Focus the More Button
        // NOTE: If we switch the focusing-operations back to how they used to be
        // (blue bar moving around with the focus state)
        // remove the line below.
        self.moreButton.focus();

        self.scrollTabList(tab);
      }

      self.moreButton.on('close.tabs', closeMenu).on('selected.tabs', selectMenuOption);

      var menu = self.popupmenu.menu;

      function handleDestroy() {
        menu.off();
        self.hideFocusState();
        $('#tab-container-popupmenu').remove();
      }

      function handleDismissibleIconClick(e) {
        var icon = $(this);
        var li = icon.closest('li');

        if (!li.is('.dismissible') || !icon.is('.close')) {
          return;
        }

        e.preventDefault();
        e.stopPropagation();
        self.closeDismissibleTab(li.children('a').attr('href'));
        self.popupmenu.close();
      }

      menu.on('destroy.popupmenu', handleDestroy).on('touchend.popupmenu touchcancel.popupmenu', '.icon', handleDismissibleIconClick).on('click.popupmenu', '.icon', handleDismissibleIconClick);

      // If the optional startingIndex is provided, focus the popupmenu on the matching item.
      // Otherwise, focus the first item in the list.
      if (startingHref) {
        self.popupmenu.highlight(menu.find('a[href="' + startingHref + '"]'));
      } else if (self.tablist.children('.is-selected').length > 0) {
        self.popupmenu.highlight(menu.find('a[href="' + self.tablist.children('.is-selected').children('a').attr('href') + '"]'));
      } else {
        self.popupmenu.highlight(menu.find('li:first-child > a'));
      }

      // Overrides a similar method in the popupmenu code that controls escaping of
      // this menu when pressing certain keys.  We override this here so that the
      // controls act in a manner as if all tabs are still visible (for accessiblity
      // reasons), meaning you can use left and right to navigate the popup menu options
      // as if they were tabs.
      $(document).bindFirst('keydown.popupmenu', function (e) {
        var key = e.which;
        var currentMenuItem = $(e.target);

        function isFocusedElement() {
          return this === document.activeElement;
        }

        function prevMenuItem() {
          // If the first item in the popup menu is already focused, close the menu and focus
          // on the last visible item in the tabs list.
          var first = menu.find('li:first-child > a');
          if (first.filter(isFocusedElement).length > 0) {
            e.preventDefault();
            $(document).off(e);
            self.popupmenu.close();
            self.findLastVisibleTab();
          }
        }

        function nextMenuItem() {
          // If the last item in the popup menu is already focused, close the menu and focus
          // on the first visible item in the tabs list.
          var last = menu.find('li:last-child > a');
          if (last.filter(isFocusedElement).length > 0 && last.parent().is(':not(.submenu)')) {
            e.preventDefault();
            $(document).off(e);
            self.popupmenu.close();

            if (self.settings.addTabButton) {
              self.addTabButton.focus();
              return;
            }
            self.focusFirstVisibleTab();
          }
        }

        // Alt+Del or Alt+Backspace closes a dropdown tab item
        function closeDropdownMenuItem() {
          if (!e.altKey || !currentMenuItem.parent().is('.dismissible')) {
            return;
          }
          // self.popupmenu.close();
          self.closeDismissibleTab(currentMenuItem.attr('href'));
        }

        var pseudoKeycode = void 0;

        switch (key) {
          case 8:
          case 46:
            closeDropdownMenuItem(e);
            break;
          case 37:
            // left
            pseudoKeycode = isRTL ? 40 : 38;
            if (currentMenuItem.is('a')) {
              if (currentMenuItem.parent().is(':not(:first-child)')) {
                e.preventDefault(); // Prevent popupmenu from closing on left key
              }
              $(document).trigger({ type: 'keydown.popupmenu', which: pseudoKeycode });
            }
            break;
          case 38:
            // up
            prevMenuItem();
            break;
          case 39:
            // right
            pseudoKeycode = isRTL ? 38 : 40;
            if (currentMenuItem.is('a') && !currentMenuItem.parent('.submenu').length) {
              $(document).trigger({ type: 'keydown.popupmenu', which: pseudoKeycode });
            }
            break;
          case 40:
            // down
            nextMenuItem();
            break;
          default:
            break;
        }
      });
    },


    /**
     * Used for checking if a particular tab (in the form of a jquery-wrapped list item)
     * is spilled into the overflow area of the tablist container <UL>.
     * @param {jQuery} li tab list item
     * @returns {boolean} whether or not the tab is overflowed.
     */
    isTabOverflowed: function isTabOverflowed(li) {
      if (this.isVerticalTabs() || this.isScrollableTabs()) {
        return false;
      }

      if (this.tablist.scrollTop() > 0) {
        this.tablist.scrollTop(0);
      }

      var liTop = Math.round(li[0].getBoundingClientRect().top);
      var tablistTop = Math.round(this.tablist[0].getBoundingClientRect().top + 1);

      // +1 to compensate for top border on Module Tabs
      if (this.isModuleTabs()) {
        tablistTop += 1;
      }

      return liTop > tablistTop;
    },


    /**
     * @returns {jQuery} representing the last visible tab.
     */
    findLastVisibleTab: function findLastVisibleTab() {
      var tabs = this.tablist.children('li:not(.separator):not(.hidden):not(.is-disabled)');
      var targetFocus = tabs.first();

      // if Scrollable Tabs, simply get the last tab and focus.
      if (this.isScrollableTabs()) {
        return tabs.last().find('a').focus();
      }

      while (!this.isTabOverflowed(targetFocus)) {
        targetFocus = tabs.eq(tabs.index(targetFocus) + 1);
      }

      return tabs.eq(tabs.index(targetFocus) - 1).find('a').focus();
    },


    /**
     * @returns {void}
     */
    focusFirstVisibleTab: function focusFirstVisibleTab() {
      var tabs = this.tablist.children('li:not(.separator):not(.hidden):not(.is-disabled)');
      tabs.eq(0).find('a').focus();
    },


    /**
     * Moves the animated "selected" state bar to a new tab
     * @param {jQuery} li the new tab list item
     * @param {function} callback fires after the animation is completed.
     * @returns {void}
     */
    focusBar: function focusBar(li, callback) {
      if (!this.hasAnimatedBar()) {
        return;
      }

      if (!(li instanceof $) || !li.length) {
        return;
      }

      var self = this;
      var target = li;
      var scrollingTablist = this.tablistContainer;
      var isRTL = Locale.isRTL();
      var tablistScrollWidth = void 0;
      var tablistScrollLeft = void 0;
      var anchorStyle = void 0;

      this.animatedBar.removeClass('no-transition');

      if (!target || target === undefined || !target.length || !self.anchors.length) {
        this.animatedBar.removeClass('visible');
        return;
      }

      var targetStyle = window.getComputedStyle(target[0], null);
      var paddingRight = parseInt(targetStyle.getPropertyValue('padding-right'), 10) || 0;
      var width = parseInt(targetStyle.getPropertyValue('width'), 10) || 0;

      if (target.is('.tab')) {
        anchorStyle = window.getComputedStyle(target.children('a')[0]);
        paddingRight += parseInt(anchorStyle.getPropertyValue('padding-right'), 10) || 0;
      }

      var left = isRTL ? paddingRight + target.position().left + target.outerWidth(true) : target.position().left;

      clearTimeout(self.animationTimeout);
      this.animatedBar.addClass('visible');

      function animationTimeout(cb) {
        var style = self.animatedBar[0].style;
        tablistScrollLeft = scrollingTablist[0].scrollLeft;
        tablistScrollWidth = scrollingTablist[0].scrollWidth;

        if (isRTL) {
          style.right = tablistScrollWidth + paddingRight - (left + tablistScrollLeft) + 'px';
        } else {
          style.left = left + tablistScrollLeft + 'px';
        }
        style.width = width + 'px';

        if (cb && typeof cb === 'function') {
          cb();
        }
      }

      animationTimeout(callback);
    },


    /**
     * Clears the animated "selected" state bar away.
     * @returns {void}
     */
    defocusBar: function defocusBar() {
      if (!this.hasAnimatedBar()) {
        return;
      }

      var self = this;
      var left = Locale.isRTL() ? 0 : self.animatedBar.position().left + self.animatedBar.outerWidth() / 2;

      clearTimeout(self.animationTimeout);

      this.animatedBar[0].style.left = left + 'px';
      this.animatedBar[0].style.width = 0;

      this.animationTimeout = setTimeout(function () {
        if (self.animatedBar && self.animatedBar.length) {
          self.animatedBar.removeClass('visible').removeAttr('style');
        }
      }, 350);
    },


    /**
     * Wrapper for the Soho behavior _smoothScrollTo()_ that will determine scroll distance.
     * @param {jQuery[]} target - the target <li> or <a> tag
     * @param {number} duration - the time it will take to scroll
     * @returns {undefined}
     */
    scrollTabList: function scrollTabList(target) {
      if (!this.tablistContainer || !target || !(target instanceof $) || !target.length) {
        return;
      }

      var tabCoords = DOM.getDimensions(target[0]);
      var tabContainerDims = DOM.getDimensions(this.tablistContainer[0]);
      var d = void 0;

      var FADED_AREA = 40; // the faded edges on the sides of the tabset
      var adjustedLeft = tabCoords.left;
      var adjustedRight = tabCoords.right;

      if (adjustedLeft < tabContainerDims.left + FADED_AREA) {
        d = Math.round(Math.abs(tabContainerDims.left - adjustedLeft)) * -1 - FADED_AREA;
      }
      if (adjustedRight > tabContainerDims.right - FADED_AREA) {
        d = Math.round(Math.abs(adjustedRight - tabContainerDims.right)) + FADED_AREA;
      }

      if (d === 0) {
        d = undefined;
      }

      // Scroll the tablist container
      this.tablistContainer.smoothScroll(d, 250);
    },


    /**
     * Hides the focus state, if it's visible.
     * @returns {void}
     */
    hideFocusState: function hideFocusState() {
      this.focusState.removeClass('is-visible');
    },


    /**
     * Updates the position of the focus state, to the tab/button that currently has focus.
     * @param {jQuery[]|HTMLElement} target the element that will receive the focus state
     * @param {boolean} [unhide] if true, unhides the focus state if it's previously been hidden.
     * @returns {void}
     */
    positionFocusState: function positionFocusState(target, unhide) {
      var self = this;

      // TODO: Recheck this and improve
      if (target !== undefined) {
        target = $(target);
      } else if (self.moreButton.hasClass('is-selected')) {
        target = self.moreButton;
      } else if (self.tablist.children('.is-selected').length > 0) {
        target = self.tablist.children('.is-selected').children('a');
      }

      /*
      NOTE: this used to replace the code directly above
      target = target !== undefined ? $(target) :
        self.moreButton.hasClass('is-selected') ? self.moreButton :
        self.tablist.children('.is-selected').length > 0 ?
        self.tablist.children('.is-selected').children('a') : undefined;
      */

      if (!target || target === undefined || !target.length || target.is(this.moreButton) && this.isScrollableTabs()) {
        this.focusState.removeClass('is-visible');
        return;
      }

      // Use the parent <li> for anchors to get their dimensions.
      if (target.is('a')) {
        target = target.parent();
      }

      // Move the focus state from inside the tab list container, if applicable.
      // Put it back into the tab list container, if not.
      if (target.is('.add-tab-button, .tab-more')) {
        if (!this.focusState.parent().is(this.element)) {
          this.focusState.prependTo(this.element);
        }
      } else if (!this.focusState.parent().is(this.tablistContainer)) {
        this.focusState.prependTo(this.tablistContainer);
      }

      var focusStateElem = this.focusState[0];
      var targetPos = DOM.getDimensions(target[0]);
      var targetClassList = target[0].classList;
      var isNotHeaderTabs = !this.isHeaderTabs() || this.isHeaderTabs() && this.element[0].classList.contains('alternate');
      var isVerticalTabs = this.isVerticalTabs();
      var isRTL = Locale.isRTL();
      var tabMoreWidth = !isVerticalTabs ? this.moreButton.outerWidth(true) : 0;
      var parentContainer = this.element;
      var scrollingTablist = this.tablistContainer;
      var accountForPadding = scrollingTablist && this.focusState.parent().is(scrollingTablist);

      function adjustForParentContainer(targetRectObj, parentElement, tablistContainer) {
        var parentRect = parentElement[0].getBoundingClientRect();
        var parentPadding = void 0;
        var tabLeftMargin = void 0;
        var tablistScrollWidth = void 0;
        var tablistScrollLeft = void 0;

        // Adjust from the top
        targetRectObj.top -= parentRect.top;
        if (isVerticalTabs) {
          targetRectObj.top += parentElement[0].scrollTop;
        }

        if (isRTL) {
          targetRectObj.right = parentRect.right - targetRectObj.right;
        } else {
          targetRectObj.left -= parentRect.left;
        }

        // If inside a scrollable tablist, account for the scroll position
        if (tablistContainer) {
          tablistScrollLeft = tablistContainer ? tablistContainer[0].scrollLeft : 0;
          tablistScrollWidth = tablistContainer ? tablistContainer[0].scrollWidth : 0;

          if (isRTL && !isVerticalTabs) {
            // TODO: Improve this calculation because there's something off
            var tmpLeft = targetRectObj.left;
            if (isNotHeaderTabs) {
              tabLeftMargin = parseInt(window.getComputedStyle(target[0]).marginLeft, 10);
              targetRectObj.left = tablistScrollWidth - tabLeftMargin - targetRectObj.right + tablistScrollLeft;
              targetRectObj.right = tablistScrollWidth - tabLeftMargin - tmpLeft + tablistScrollLeft;
            } else {
              targetRectObj.left = tablistScrollWidth - (targetRectObj.right + tablistScrollLeft + tabMoreWidth + 32);
              targetRectObj.right = tablistScrollWidth - (tmpLeft + tablistScrollLeft + tabMoreWidth + 32);
            }
          } else {
            targetRectObj.left += tablistScrollLeft;
            targetRectObj.right += tablistScrollLeft;
          }

          if (accountForPadding) {
            parentPadding = parseInt(window.getComputedStyle(parentElement[0])['padding' + (isRTL ? 'Right' : 'Left')], 10);
            targetRectObj.left += isRTL ? parentPadding : parentPadding * -1;
            targetRectObj.right += isRTL ? parentPadding : parentPadding * -1;
          }
        }

        // Alternate Header Tabs have 1px removed from bottom to prevent overlap
        // onto the bottom border
        if (isNotHeaderTabs && !isVerticalTabs) {
          targetRectObj.height -= 1;
        }

        return targetRectObj;
      }

      // Adjust the values one more time if we have tabs contained inside of a
      // page-container, or some other scrollable container.
      targetPos = adjustForParentContainer(targetPos, parentContainer, scrollingTablist);

      // build CSS string containing each prop and set it:
      var targetPosString = '';
      Object.keys(targetPos).forEach(function (key) {
        if (targetPosString.length) {
          targetPosString += ' ';
        }
        targetPosString += key + ': ' + targetPos[key] + 'px;';
      });
      focusStateElem.style.cssText = targetPosString;

      var selected = targetClassList.contains('is-selected') ? 'add' : 'remove';
      focusStateElem.classList[selected]('is-selected');

      var doHide = unhide === true ? 'add' : 'remove';
      focusStateElem.classList[doHide]('is-visible');
    },


    /**
     * Causes the entire tabset to reset with new settings.
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },


    /**
     * Disables all non-active tabs in the list
     * @returns {void}
     */
    disableOtherTabs: function disableOtherTabs() {
      return this.disable(true);
    },


    /**
     * Disables the entire Tab Component
     * @param {boolean} isPartial whether or not this disable call is a partial
     *  disabling of the tabset
     * @returns {void}
     */
    disable: function disable(isPartial) {
      if (!isPartial) {
        this.element.prop('disabled', true).addClass('is-disabled');
      }

      if (!this.disabledElems) {
        this.disabledElems = [];
      }

      var self = this;
      var tabs = this.tablist.children('li:not(.separator)');
      if (isPartial) {
        tabs = tabs.filter(':not(.application-menu-trigger)');
      }

      tabs.each(function () {
        var li = $(this);
        var a = li.children('a');

        if (isPartial && self.isActive(a.attr('href'))) {
          return;
        }

        if (li.is('.is-disabled') || a.prop('disabled') === true) {
          self.disabledElems.push({
            elem: li,
            originalTabindex: li.attr('tabindex'),
            originalDisabled: a.prop('disabled')
          });
        }

        li.addClass('is-disabled');
        a.prop('disabled', true);

        if (li.is('.application-menu-trigger') || li.is('.add-tab-button')) {
          return;
        }

        var panel = $(a.attr('href'));
        panel.addClass('is-disabled');
        panel.find('*').each(function () {
          var t = $(this);

          // These are shadow inputs.  They are already handled by virtue of running
          // .disable() on the original select tag.
          if (t.is('input.dropdown, input.multiselect')) {
            return;
          }

          if (t.attr('tabindex') === '-1' || t.attr('disabled')) {
            self.disabledElems.push({
              elem: t,
              originalTabindex: t.attr('tabindex'),
              originalDisabled: t.prop('disabled')
            });
          }

          t.disable();
        });
      });

      this.moreButton.addClass('is-disabled');

      if (this.isModuleTabs() && !isPartial) {
        this.element.children('.toolbar').disable();
      }

      this.updateAria($());
    },


    /**
     * Enables the entire Tabs component
     * @returns {void}
     */
    enable: function enable() {
      this.element.prop('disabled', false).removeClass('is-disabled');

      var self = this;
      var tabs = this.tablist.children('li:not(.separator)');

      tabs.each(function () {
        var li = $(this);
        var a = li.children('a');

        li.removeClass('is-disabled');
        a.prop('disabled', false);

        if (li.is('.application-menu-trigger') || li.is('.add-tab-button')) {
          return;
        }

        var panel = $(a.attr('href'));
        panel.removeClass('is-disabled');
        panel.find('*').each(function () {
          var t = $(this);
          if (t.enable && typeof t.enable === 'function') {
            t.enable();
          }
        });

        $.each(self.disabledElems, function (i, obj) {
          var attrTarget = obj.elem.is('.tab') ? obj.elem.children('a') : obj.elem;
          if (obj.elem.disable && typeof obj.elem.disable === 'function') {
            obj.elem.disable();
          }

          if (obj.elem.is('li')) {
            obj.elem.addClass('is-disabled');
            return;
          }

          // These are shadow inputs.  They are already handled by virtue of
          // running .disable() on the original select tag.
          if (obj.elem.is('input.dropdown, input.multiselect')) {
            return;
          }

          obj.elem.attr('tabindex', obj.originalTabindex);
          attrTarget.prop('disabled', obj.originalDisabled);
        });
      });

      this.moreButton.removeClass('is-disabled');

      if (this.isModuleTabs()) {
        this.element.children('.toolbar').enable();
      }

      this.disabledElems = [];

      this.updateAria(this.tablist.find('.is-selected > a'));
    },


    /**
     * Pass-through for the `remove()` method, which gets used for removing a dismissible tab.
     * @param {string} tabId the ID of the target tab panel
     * @returns {this} component instance
     */
    closeDismissibleTab: function closeDismissibleTab(tabId) {
      return this.remove(tabId);
    },


    /**
     * Remove top level dismissible tab with dropdown
     * @param {array} tabUrlArray the Array of urls from the target popupmenu
     */
    closeDismissibleTabs: function closeDismissibleTabs(tabUrlArray) {
      var _this4 = this;

      tabUrlArray.forEach(function (tabUrl) {
        var tabId = tabUrl.match(/#.*/);
        return _this4.remove(tabId[0]);
      });
    },


    /**
     * Tears down this instance of the tabs component by removing events,
     * other components, and extraneous markup.
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.panels.removeAttr('style');

      this.tablist.off().removeAttr('role').removeAttr('aria-multiselectable');

      var tabs = this.tablist.children('li');
      tabs.off().removeAttr('role').removeClass('is-selected');

      var dds = tabs.filter('.has-popupmenu');
      dds.each(function () {
        var popup = $(this).data('popupmenu');
        if (popup) {
          popup.menu.children('li:not(.separator)').each(function () {
            var li = $(this);
            var a = li.children('a');
            var panel = a.data('panel-link');

            $.removeData(a[0], 'panel-link');
            if (panel && panel.length) {
              $.removeData(panel[0], 'tab-link');
            }
          });
          popup.destroy();
        }
      });

      this.panels.off();

      this.anchors.off().removeAttr('role').removeAttr('aria-expanded').removeAttr('aria-selected').removeAttr('tabindex');

      if (this.settings.moduleTabsTooltips) {
        this.anchors.each(function () {
          var api = $(this).data('tooltip');
          if (api && typeof api.destroy === 'function') {
            api.destroy();
          }
        });
      }

      this.element.off('focusout.tabs updated.tabs activated.tabs');
      $('body').off('resize.tabs' + this.tabsIndex);
      this.tabsIndex = undefined;

      if (this.moreButton.data('popupmenu')) {
        var popup = this.moreButton.data('popupmenu');
        popup.menu.find('li:not(.separator)').each(function () {
          var li = $(this);
          var a = li.children('a');

          if (a.data('original-tab')) {
            $.removeData(a[0], 'original-tab');
          }
        });
        popup.destroy();
      }

      this.removeHelperMarkupEvents();

      if (this.tablistContainer) {
        this.tablistContainer.off('mousewheel.tabs');
      }

      this.focusState.remove();
      this.focusState = undefined;

      if (this.hasAnimatedBar()) {
        this.animatedBar.remove();
        this.animatedBar = undefined;
      }
      $('.tab-panel input').off('error.tabs valid.tabs');

      return this;
    },


    /**
     * Destroys this component instance, removing its attachment from its parent element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$10);
    }
  };

  /**
   * jQuery component wrapper for Tabs Component
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.tabs = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$10);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$10, new Tabs(this, settings));
      }
    });
  };

  // Deprecated the old Vertical Tabs code in favor of using the Tabs class.
  $.fn.verticaltabs = $.fn.tabs;

  // Component Name
  var COMPONENT_NAME$11 = 'tag';

  // Default Tag Options
  var TAG_DEFAULTS = {};

  /**
  * Implements functionality on tag objects, such as closing tabs.
  * @class Tag
  * @param {string} element The component element.
  * @param {string} settings The component settings.
  */
  function Tag(element, settings) {
    this.settings = utils.mergeSettings(element, settings, TAG_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Tag Methods
  Tag.prototype = {
    init: function init() {
      this.element.hideFocus();
      this.handleEvents();
    },


    /**
     * Remove the tag from the DOM
     * @private
     * @param {object} event Type.
     * @param {string} el The element.
     * @returns {void}
     */
    remove: function remove(event, el) {
      el = el instanceof jQuery ? el : $(el);
      var parent = el.parent();

      /**
      * Fires before tag remove.
      *
      * @event beforetagremove
      * @memberof Tag
      * @type {object}
      * @property {object} event - The jquery event object
      * @property {object} The event used for removing and element
      */
      this.element.triggerHandler('beforetagremove', { event: event, element: el });
      el.remove();

      /**
      * Fires after tag remove.
      *
      * @event aftertagremove
      * @memberof Tag
      * @type {object}
      * @property {object} event - The jquery event object
      */
      parent.triggerHandler('aftertagremove', { event: event });
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.element.off('keydown.tag');
      $('.dismissable-btn, .dismissible-btn', this.element).off('click.tag').remove();
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, TAG_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$11);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;
      var btnDismissable = $('' + ('<span class="dismissible-btn">\n        ' + $.createIcon('close') + '\n        <span class="audible"> ' + Locale.translate('Close') + '</span>\n      </span>'));
      var dismissibleClass = '.is-dismissable, .is-dismissible';

      // EPC: Deprecating "dismissable" in favor of "dismissible" as of 4.3.0
      if (self.element.is(dismissibleClass)) {
        self.element.append(btnDismissable);

        /**
        * Fires when the tag is clicked (if enabled).
        * @event click
        * @memberof Tag
        * @type {object}
        * @property {object} event - The jquery event object
        */
        btnDismissable.on('click.tag', function (event) {
          _this.remove(event, _this.element);
        });

        /**
        * Fires when the tag is focused.
        * @event keydown
        * @memberof Tag
        * @type {object}
        * @property {object} event - The jquery event object
        */
        this.element.on('keydown.tag', function (event) {
          var e = event || window.event;
          if (e.keyCode === 8) {
            // Backspace
            self.remove(event, this);
          }
        });
      }
    }
  };

  // Initialize the plugin (Once)
  $.fn.tag = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$11);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$11, new Tag(this, settings));
      }
    });
  };

  // Name of this component
  var COMPONENT_NAME$12 = 'textarea';

  // Component Options
  var TEXTAREA_DEFAULTS = {
    autoGrow: false,
    autoGrowAnimate: true,
    autoGrowAnimateSpeed: 200,
    characterCounter: true,
    printable: true,
    charRemainingText: null,
    charMaxText: null
  };

  /**
  * The Textarea Component wraps a standard HTML Textarea element and provides additional features.
  * @class Textarea
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {boolean} [settings.autoGrow = false] Will automatically expand the textarea to fit the contents when typing.
  * @param {boolean} [settings.autoGrowAnimate  = true] Will animate the textarea grow.
  * @param {number} [settings.autoGrowAnimateSpeed = 200] The speed of the animation.
  * @param {boolean} [settings.characterCounter = true] Displays a counter that counts down from the maximum
  * length allowed.
  * @param {boolean} [settings.printable = true] Determines whether or not the text area can be displayed on a
  * printed page.
  * @param {null|String} [settings.charRemainingText = 'Characters Left']  Text that will be used in place of the "remaining"
  * text defaulting to a localized 'Characters Left'.
  * @param {null|String} [settings.charMaxText = 'Character count maximum of']  Text that will be used in place of the "Max" text.
  * Defaults to a localized Version of 'Character count maximum of'.
  */
  function Textarea(element, settings) {
    this.settings = utils.mergeSettings(element, settings, TEXTAREA_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  Textarea.prototype = {

    /**
     * @private
     */
    init: function init() {
      this.isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
      this.isSafari = navigator.userAgent.indexOf('Safari') !== -1 && navigator.userAgent.indexOf('Chrome') === -1 && navigator.userAgent.indexOf('Android') === -1;

      this.element.addClass(this.element.is('.textarea-xs') ? 'input-xs' : //eslint-disable-line
      this.element.is('.textarea-sm') ? 'input-sm' : //eslint-disable-line
      this.element.is('.textarea-lg') ? 'input-lg' : ''); //eslint-disable-line

      if (this.settings.characterCounter && this.element.attr('maxlength')) {
        this.counter = $('<span class="textarea-wordcount">Chars Left..</span>').insertAfter(this.element);
      }
      if (this.settings.printable) {
        this.printarea = $('<span class="textarea-print"></span>').insertBefore(this.element);
      }

      if (this.element.hasClass('autogrow')) {
        this.settings.autoGrow = true;
      }

      if (this.settings.autoGrow && this.element.length) {
        this.element.css('overflow', 'hidden');
        this.handleResize(this);
      }

      this.handleEvents();
      this.updateCounter();
    },


    /**
     * Determines if the text is selected.
     * @private
     * @param  {object}  input The input dom element (jQuery)
     * @returns {boolean} True if the text is selected in the input.
     */
    isSelected: function isSelected(input) {
      if (typeof input.selectionStart === 'number') {
        return input.selectionStart === 0 && input.selectionEnd === input.value.length;
      } else if (typeof document.selection !== 'undefined') {
        return document.selection.createRange().text === input.value;
      }
      return false;
    },


    /**
     * Checks a keycode value and determines if it belongs to a printable character.
     * @private
     * @param {number} keycode - a number representing an ASCII keycode value
     * @param {boolean} shiftKey - a boolean set to true if shift key is being pressed
     * @returns {boolean} Returns true if the key is a printable one.
     */
    isPrintable: function isPrintable(keycode, shiftKey) {
      // (keycode > 47 && keycode < 58) || // number keys
      // (keycode > 64 && keycode < 91) || // letter keys
      // (keycode > 95 && keycode < 112) || // numpad keys
      // (keycode > 185 && keycode < 193) || // ;=,-./` (in order)
      // (keycode > 218 && keycode < 223); // [\]' (in order)

      var valid = false;

      if (shiftKey) {
        valid = keycode > 64 && keycode < 91 || // letter keys
        keycode >= 33 && keycode <= 38 || keycode >= 40 && keycode <= 43 || keycode === 126 || keycode === 58 || keycode === 60 || keycode >= 123 && keycode <= 125 || keycode === 94 || keycode === 95 || keycode >= 62 && keycode <= 64;
      } else {
        valid = keycode === 13 || // enter key
        keycode >= 48 && keycode <= 57 || // number keys
        keycode >= 97 && keycode <= 122 || // letter keys
        keycode === 59 || keycode === 61 || keycode >= 44 && keycode <= 47 || keycode === 96 || // ;=,-./` (in order)
        keycode >= 91 && keycode <= 93 || keycode === 39; // [\]' (in order)
      }

      return valid;
    },


    /**
    * Resizes the texarea based on the content.
    * @private
    * @param {obkect} self The textaarea api
    * @param {event} e The resive event object
    */
    handleResize: function handleResize(self, e) {
      var value = self.element.val();
      var oldHeight = self.element.innerHeight();
      var newHeight = self.element.get(0).scrollHeight;
      var minHeight = self.element.data('autogrow-start-height') || 0;
      var clone = void 0;

      if (oldHeight < newHeight) {
        self.scrollTop = 0;

        if (self.settings.autoGrowAnimate) {
          self.element.stop().animate({ height: newHeight }, self.settings.autoGrowAnimateSpeed);
        } else {
          self.element.innerHeight(newHeight);
        }
      } else if (!e || e.which === 8 || e.which === 46 || e.ctrlKey && e.which === 88) {
        if (oldHeight > minHeight) {
          clone = self.element.clone().addClass('clone').css({ position: 'absolute', zIndex: -10, height: '' }).val(xssUtils.sanitizeHTML(value));

          self.element.after(clone);
          do {
            newHeight = clone[0].scrollHeight - 1;
            clone.innerHeight(newHeight);
          } while (newHeight === clone[0].scrollHeight);

          newHeight++;
          clone.remove();

          if (newHeight < minHeight) {
            newHeight = minHeight;
          }

          if (oldHeight > newHeight && self.settings.autoGrowAnimate) {
            self.element.stop().animate({ height: newHeight }, self.settings.autoGrowAnimateSpeed);
          } else {
            self.element.innerHeight(newHeight);
          }
        } else {
          self.element.innerHeight(minHeight);
        }
      }
    },


    /**
     * Counts the number of line breaks in a string
     * @private
     * @param {string} s The string to test.
     * @returns {number} The number of found line countLinebreaks
     */
    countLinebreaks: function countLinebreaks(s) {
      return (s.match(/\n/g) || []).length;
    },


    /**
     * Updates the descriptive markup (counter, etc) to notify the user how many
     * characters can be typed.
     * @private
     * @param {object} self The current object.
     */
    updateCounter: function updateCounter() {
      var self = this;
      var value = self.element.val();
      var isExtraLinebreaks = this.isChrome || this.isSafari;
      var length = value.length + (isExtraLinebreaks ? this.countLinebreaks(value) : 0);
      var max = parseInt(self.element.attr('maxlength'), 10);
      var remaining = parseInt(max, 10) - length;
      var text = (self.settings.charRemainingText ? self.settings.charRemainingText : //eslint-disable-line
      Locale.translate('CharactersLeft') === 'CharactersLeft' ? 'Characters Left' : Locale.translate('CharactersLeft')).replace('{0}', remaining.toString());

      if (self.counter) {
        if (length >= max) {
          text = self.settings.charMaxText ? self.settings.charMaxText.replace('{0}', max) : Locale.translate('CharactersMax') + max;
          self.counter.text(text);
          self.counter.removeClass('almost-empty');
        } else {
          self.counter.text(text);
          if (remaining < 10) {
            self.counter.addClass('almost-empty');
          } else {
            self.counter.removeClass('almost-empty');
          }
        }
      }

      self.printarea.text(self.element.val());
    },


    /**
     * Enables this component instance.
     */
    enable: function enable() {
      this.element.prop('disabled', false).prop('readonly', false);
    },


    /**
     * Disables this component instance.
     */
    disable: function disable() {
      this.element.prop('disabled', true);
    },


    /**
     * Returns true if the texarea is disabled
     * @returns {boolean} True if the elemet is disabled.
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
     * Sets this component instance to "readonly"
     */
    readonly: function readonly() {
      this.element.prop('readonly', true);
    },


    /**
     * Call whenever the plugin's settings are changed
     * @param {object} settings The settings object.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.destroy();
      this.init();
    },


    /**
     * Destroys this component instance and unlinks it from its element.
     */
    destroy: function destroy() {
      if (this.printarea && this.printarea.length) {
        this.printarea.remove();
      }
      if (this.counter && this.counter.length) {
        this.counter.remove();
      }
      this.element.off('keyup.textarea, focus.textarea, updated.dropdown, keypress.textarea, blur.textarea');
    },


    /**
     * Handle key events for functionality like counter and autoGrow.
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.on('keyup.textarea', function (e) {
        var value = self.element.val();
        var isExtraLinebreaks = self.isChrome || self.isSafari;
        var length = value.length + (isExtraLinebreaks ? self.countLinebreaks(value) : 0);
        var max = parseInt(self.element.attr('maxlength'), 10);

        self.updateCounter();

        if (length >= max) {
          e.preventDefault();
          return false;
        }

        if (self.settings.autoGrow) {
          self.handleResize(self, e);
        }

        return true;
      }).on('focus.textarea', function () {
        if (self.counter) {
          self.counter.addClass('focus');
        }
      }).on('updated.dropdown', function () {
        self.updated();
      }).on('keypress.textarea', function (e) {
        var value = self.element.val();
        var isExtraLinebreaks = self.isChrome || self.isSafari;
        var length = value.length + (isExtraLinebreaks ? self.countLinebreaks(value) : 0);
        var max = parseInt(self.element.attr('maxlength'), 10);

        if ([97, 99, 118, 120].indexOf(e.which) > -1 && (e.metaKey || e.ctrlKey)) {
          self.updateCounter();
          return;
        }

        if (!self.isPrintable(e.which, e.shiftKey)) {
          return;
        }

        if (length >= max && !self.isSelected(this)) {
          e.preventDefault();
        }
      }).on('blur.textarea', function () {
        self.updateCounter();
        if (self.counter) {
          self.counter.removeClass('focus');
        }
      });
    }
  };

  /**
   * jQuery Component wrapper for Textarea
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} textarea elements being acted on.
   */
  $.fn.textarea = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$12);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$12, new Textarea(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$13 = 'toolbar';

  /**
   * The Toolbar Component manages various levels of application navigation.
   * It contains a group of buttons that functionally related content. Each panel
   * consists of two levels: the top level identifies the category or section header,
   * and the second level provides the associated options.
   *
   * @class Toolbar
   * @param {HTMLElement|jQuery[]} element the base Toolbar element
   * @param {object} [settings] incoming settings
   *
   * @param {boolean} [settings.rightAligned=false] Will always attempt to right-align the contents of
   *  the toolbar. By default if there is no title it will left align. This forces right alignment.
   * @param {number} [settings.maxVisibleButtons=3] Total amount of buttons that can be present, not
   *  including the More button.
   * @param {boolean} [settings.resizeContainers=true] If true, uses Javascript to size the Title and
   *  Buttonset elements in a way that shows as much of the Title area as possible.
   * @param {boolean} [settings.favorButtonset=true] If "resizeContainers" is true, setting this to
   *  true will try to display as many buttons as possible while resizing the toolbar.
   *  Setting to false attempts to show the entire title instead.
   * @param {object} [settings.moreMenuSettings] If defined, provides a toolbar-level method of
   *  defining settings that will be applied to the More Actions button's popupmenu instance.
   * @param {boolean} [settings.noSearchfieldReinvoke=false] If true, does not manage the lifecycle
   *  of an internal toolbarsearchfield automatically.  Allows an external controller
   *  to do it instead.
   */
  var TOOLBAR_DEFAULTS = {
    rightAligned: false,
    maxVisibleButtons: 3,
    resizeContainers: true,
    favorButtonset: true,
    moreMenuSettings: undefined,
    noSearchfieldReinvoke: false
  };

  function Toolbar(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, TOOLBAR_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Toolbar.prototype = {

    /**
     * Initializes the Toolbar Component
     * @private
     * @chainable
     * @returns {this} component instance
     */
    init: function init() {
      return this.setup().build().handleEvents();
    },


    /**
     * Detects discrepencies in settings.  In general, configures the component
     * based on user settings.
     * @private
     * @chainable
     * @returns {this} component instance
     */
    setup: function setup() {
      // Can't have zero buttons
      if (this.settings.maxVisibleButtons <= 0) {
        this.settings.maxVisibleButtons = TOOLBAR_DEFAULTS.maxVisibleButtons;
      }

      return this;
    },


    /**
     * Adds additional markup, wraps some internal elements, and helps construct a
     * complete Toolbar representation in the HTML Markup. This method also builds the
     * "More Actions" menu and ties its elements to the toolbar items.
     * @private
     * @chainable
     * @returns {this} component instance
     */
    build: function build() {
      var self = this;

      this.element.attr('role', 'toolbar');
      if (this.settings.resizeContainers && this.element.is(':not(:hidden)')) {
        this.element[0].classList.add('do-resize');
      }

      this.buildAriaLabel();

      // keep track of how many popupmenus there are with an ID.
      // Used for managing events that are bound to $(document)
      if (!this.id) {
        this.id = parseInt($('.toolbar, .formatter-toolbar').index(this.element), 10);
      }

      // Check for a "title" element.  This element is optional.
      // If a title element exists, a tooltip will be created for when it's not
      // possible to show the entire title text on screen.
      this.title = this.element.children('.title');
      if (this.title.length) {
        this.element[0].classList.add('has-title');

        this.cutoffTitle = false;
        this.title.on('beforeshow.toolbar', function () {
          return self.cutoffTitle;
        }).tooltip({
          content: '' + this.title.text().trim()
        });
      } else {
        this.element[0].classList.remove('has-title');
      }

      // Container for main group of buttons and input fields.  Only these spill into the More menu.
      this.buttonset = this.element.children('.buttonset');
      if (!this.buttonset.length) {
        this.buttonset = $('<div class="buttonset"></div>');
        if (this.title.length) {
          this.buttonset.insertAfter(this.title);
        } else {
          this.buttonset.prependTo(this.element);
        }
      }

      this.element[this.settings.rightAligned ? 'addClass' : 'removeClass']('right-aligned');

      // Add and invoke More Button, if it doesn't exist
      this.more = this.element.find('.btn-actions');
      if (this.more.length === 0 && !this.element.hasClass('no-actions-button')) {
        var moreContainer = this.element.find('.more');

        if (!moreContainer.length) {
          moreContainer = $('<div class="more"></div>').appendTo(this.element);
        }

        this.more = $('<button class="btn-actions" type="button"></button>').html($.createIcon({ icon: 'more' }) + '<span class="audible">' + Locale.translate('MoreActions') + '</span>').attr('title', Locale.translate('More')).appendTo(moreContainer);
      }

      // Reference all interactive items in the toolbar
      this.buttonsetItems = this.buttonset.children('button').add(this.buttonset.find('input')); // Searchfield Wrappers

      // Items contains all actionable items in the toolbar, including the ones in
      // the title, and the more button
      this.items = this.buttonsetItems.add(this.title.children('button')).add(this.more);

      // Invoke buttons
      var buttons = this.items.filter('button, input[type="button"], [class^="btn"]');
      buttons.each(function () {
        var buttonControl = $(this).data('button');
        if (!buttonControl) {
          $(this).button();
        }

        var tooltipControl = $(this).data('tooltip');
        if (!tooltipControl && $(this).attr('title')) {
          $(this).tooltip();
        }
      });

      // Invoke searchfields
      if (!this.settings.noSearchfieldReinvoke) {
        var searchfields = this.items.filter('.searchfield, .toolbar-searchfield-wrapper, .searchfield-wrapper');
        searchfields.each(function (i, item) {
          var sf = $(item);
          if (sf.is('.toolbar-searchfield-wrapper, .searchfield-wrapper')) {
            sf = sf.children('.searchfield');
          }

          if (!sf.data('searchfield')) {
            var searchfieldOpts = $.extend({}, utils.parseSettings(sf[0]));
            sf.searchfield(searchfieldOpts);
          }
        });
      }

      // Setup the More Actions Menu.  Add Menu Items for existing buttons/elements in
      // the toolbar, but hide them initially. They are revealed when overflow checking
      // happens as the menu is opened.
      var popupMenuInstance = this.more.data('popupmenu');
      var moreAriaAttr = this.more.attr('aria-controls');

      if (!popupMenuInstance) {
        this.moreMenu = $('#' + moreAriaAttr);
        if (!this.moreMenu.length) {
          this.moreMenu = this.more.next('.popupmenu, .popupmenu-wrapper');
        }
        if (!this.moreMenu.length) {
          this.moreMenu = $('<ul id="popupmenu-toolbar-' + this.id + '" class="popupmenu"></ul>').insertAfter(this.more);
        }

        // Allow toolbar to understand pre-wrapped popupmenus
        // Angular Support -- See SOHO-7008
        if (this.moreMenu.is('.popupmenu-wrapper')) {
          this.moreMenu = this.moreMenu.children('.popupmenu');
        }
      } else {
        this.moreMenu = popupMenuInstance.menu;
      }

      function menuItemFilter() {
        return $(this).parent('.buttonset, .inline').length;
      }

      var menuItems = [];
      this.items.not(this.more).filter(menuItemFilter).each(function () {
        menuItems.push(self.buildMoreActionsMenuItem($(this)));
      });

      menuItems.reverse();
      $.each(menuItems, function (i, item) {
        if (item.text() !== '') {
          item.prependTo(self.moreMenu);
        }
      });

      this.defaultMenuItems = this.moreMenu.children('li:not(.separator)');
      this.hasDefaultMenuItems = this.defaultMenuItems.length > 0;

      // Setup an Event Listener that will refresh the contents of the More Actions
      // Menu's items each time the menu is opened.
      var menuButtonSettings = utils.extend({}, this.settings.moreMenuSettings, {
        trigger: 'click',
        menu: this.moreMenu
      }, this.hasDefaultMenuItems ? { predefined: this.defaultMenuItems } : {});
      if (popupMenuInstance) {
        this.more.on('beforeopen.toolbar', function () {
          self.refreshMoreActionsMenu(self.moreMenu);
        }).triggerHandler('updated', [menuButtonSettings]);
      } else {
        this.more.popupmenu(menuButtonSettings).on('beforeopen.toolbar', function () {
          self.refreshMoreActionsMenu(self.moreMenu);
        });
      }

      // Setup the tabindexes of all items in the toolbar and set the starting active button.
      function setActiveToolbarItem() {
        self.items.attr('tabindex', '-1');

        var active = self.items.filter('.is-selected');
        if (active.length) {
          self.activeButton = active.first().attr('tabindex', '0');
          self.items.not(self.activeButton).removeClass('is-selected');
          return;
        }

        // Set active to the first item in the toolbar.
        active = self.items.filter(':visible:not(:disabled)').first().attr('tabindex', '0');
        self.activeButton = active;

        // If the whole toolbar is hidden (contextual toolbars, etc),
        // automatically set the first non-disabled item as visible
        if (self.element.is(':hidden, .is-hidden')) {
          self.activeButton = self.items.filter(':not(:disabled)').first().attr('tabindex', '0');
          return;
        }

        if (self.isItemOverflowed(active)) {
          active.attr('tabindex', '-1');
          self.activeButton = self.more.addClass('is-selected').attr('tabindex', '0');
        }
      }

      setActiveToolbarItem();

      // Toggles the More Menu based on overflow of toolbar items
      this.adjustMenuItemVisibility();
      this.handleResize();

      /**
       * Fires when the Toolbar has completely rendered all its DOM elements.
       *
       * @event rendered
       * @memberof Toolbar
       * @param {jQuery.Event} e the jQuery Event object
       */
      this.element.triggerHandler('rendered');

      var searchfieldWrapper = this.buttonset.find('.searchfield-wrapper, .toolbar-searchfield-wrapper');
      if (searchfieldWrapper.length) {
        searchfieldWrapper.trigger('reanimate');
      }

      return this;
    },


    /**
     * Builds a single "More Actions Menu" item from a source toolbar item.
     * Also sets up linkage between the menu item and the original toolbar item to
     * allow events/properties to propagate when the More Actions item is acted upon.
     * @private
     * @param {jQuery[]} item the source item from the toolbar.
     * @returns {jQuery[]} a jQuery-wrapped <li> representing a More Actions menu
     *  implementation of the toolbar item.
     */
    buildMoreActionsMenuItem: function buildMoreActionsMenuItem(item) {
      var popupLi = void 0;

      // If this item should be skipped, just return out
      if (item.data('skipit') === true) {
        item.data('skipit', undefined);
        return popupLi;
      }

      // Attempt to re-use an existing <li>, if possible.
      // If a new one is created, setup the linkage between the original element and its
      // "More Actions" menu counterpart.
      var a = item.data('action-button-link');

      if (!a || !a.length) {
        popupLi = $('<li></li>');
        a = $('<a href="#"></a>').appendTo(popupLi);

        // Setup data links between the buttons and their corresponding list items
        item.data('action-button-link', a);
        a.data('original-button', item);
      } else {
        popupLi = a.parent();
      }

      // Refresh states
      if (item.hasClass('hidden')) {
        popupLi.addClass('hidden');
      }
      if (item.is(':disabled')) {
        popupLi.addClass('is-disabled');
        a.prop('disabled', true);
      } else {
        popupLi.removeClass('is-disabled');
        a.prop('disabled', false);
      }

      // Refresh Text
      a.text(this.getItemText(item));

      // Pass along any icons except for the dropdown (which is added as part of the submenu design)
      var submenuDesignIcon = $.getBaseURL('#icon-dropdown');
      var icon = item.children('.icon').filter(function () {
        var iconName = $(this).getIconName();
        return iconName && iconName !== submenuDesignIcon && iconName.indexOf('dropdown') === -1;
      });

      if (icon && icon.length) {
        a.html('<span>' + a.text() + '</span>');
        icon.clone().detach().prependTo(a);
      }

      var linkspan = popupLi.find('b');
      if (linkspan.length) {
        this.moreMenu.addClass('has-icons');
        linkspan.detach().prependTo(popupLi);
      }

      function addItemLinksRecursively(menu, diffMenu, parentItem) {
        var children = menu.children('li');
        var id = diffMenu.attr('id');

        diffMenu.children('li').each(function (i, diffMenuItem) {
          var dmi = $(diffMenuItem); // "Diffed" Menu Item
          var omi = children.eq(i); // Corresponding "Original" menu item
          var dmiA = dmi.children('a'); // Anchor inside of "Diffed" menu item
          var omiA = omi.children('a'); // Anchor inside of "Original" menu item
          var dmiID = dmi.attr('id');
          var dmiAID = dmiA.attr('id');

          // replace menu item ids with spillover-menu specific ids.
          if (dmiID) {
            dmi.removeAttr('id').attr('data-original-menu-item', dmiID);
          }
          if (dmiAID) {
            dmiA.removeAttr('id').attr('data-original-menu-anchor', dmiAID);
          }

          omiA.data('action-button-link', dmiA);
          dmiA.data('original-button', omiA);

          var omiSubMenu = omi.children('.wrapper').children('.popupmenu');
          var dmiSubMenu = dmi.children('.wrapper').children('.popupmenu');

          if (omiSubMenu.length && dmiSubMenu.length) {
            addItemLinksRecursively(omiSubMenu, dmiSubMenu, dmi);
          }
        });

        diffMenu.removeAttr('id').attr('data-original-menu', id);
        parentItem.addClass('submenu');

        var appendTarget = void 0;
        if (parentItem.is(popupLi)) {
          appendTarget = parentItem.children('.wrapper');
          if (!appendTarget || !appendTarget.length) {
            appendTarget = $('<div class="wrapper"></div>');
          }
          appendTarget.html(diffMenu);
          parentItem.append(appendTarget);
        }
      }

      if (item.is('.btn-menu')) {
        if (!item.data('popupmenu')) {
          item.popupmenu();
        } else if (!a.children('.icon.arrow').length) {
          a.append($.createIcon({
            classes: 'icon arrow icon-dropdown',
            icon: 'dropdown'
          }));
        }

        var menu = item.data('popupmenu').menu;
        var diffMenu = menu.clone();

        addItemLinksRecursively(menu, diffMenu, popupLi);
      }

      if (item.is('[data-popdown]')) {
        item.popdown();
      }

      return popupLi;
    },


    /**
     * Refreshes the More Actions Menu items' text content, icons, states, and submenu content
     * based on changes made directly to their counterpart elements in the Toolbar.  Can also
     * optionally refresh only part of the menu.
     * @param {jQuery[]} menu the menu/submenu to be refreshed.
     */
    refreshMoreActionsMenu: function refreshMoreActionsMenu(menu) {
      var self = this;

      $('li > a', menu).each(function () {
        var a = $(this);
        var li = a.parent();
        var item = a.data('originalButton');
        var itemParent = void 0;
        var text = self.getItemText(item);
        var submenu = void 0;

        if (item) {
          if (a.find('span').length) {
            a.find('span').text(text.trim());
          } else {
            a.text(text.trim());
          }

          if (item.isHiddenAtBreakpoint() || item.parent().isHiddenAtBreakpoint()) {
            li.addClass('hidden');
          } else {
            li.removeClass('hidden');
          }

          if (item.parent().is('.is-disabled') || item.is(':disabled')) {
            // if it's disabled menu item, OR a disabled menu-button
            li.addClass('is-disabled');
            a.prop('disabled', true);
            a.attr('tabindex', '-1');
          } else {
            li.removeClass('is-disabled');
            a.prop('disabled', false);
          }

          if (item.is('a')) {
            itemParent = item.parent('li');

            if (itemParent.is('.is-checked')) {
              li.addClass('is-checked');
            } else {
              li.removeClass('is-checked');
            }
          }

          if (item.is('.btn-menu')) {
            submenu = a.parent().find('.popupmenu').first();
            self.refreshMoreActionsMenu(submenu);
          }
        }
      });
    },


    /**
     * Gets the complete text contnts of a Toolbar Item, in order to create its
     * corresponding "more actions" menu item.
     *
     * Order of operations for populating the List Item text:
     * 1. span contents (.audible), then
     * 2. button title attribute, then
     * 3. tooltip text (if applicable)
     * @param {jQuery[]} item the item being evaluated.
     * @returns {string} the complete text representation.
     */
    getItemText: function getItemText(item) {
      if (!item) {
        return '';
      }
      var span = item.find('span').first();
      var title = item.attr('title');
      var tooltip = item.data('tooltip');
      var tooltipText = tooltip && typeof tooltip.content === 'string' ? tooltip.content : undefined;
      var popupLiText = void 0;

      if (title !== '' && title !== undefined) {
        popupLiText = title;
      } else if (tooltipText) {
        popupLiText = tooltipText;
      } else if (span.length) {
        popupLiText = span.text();
      } else {
        popupLiText = item.text();
      }

      return xssUtils.stripHTML(popupLiText);
    },


    /**
     * Sets up all necessary event handling on a Toolbar component
     * @private
     * @chainable
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.items.off('keydown.toolbar').on('keydown.toolbar', function (e) {
        self.handleKeys(e);
      }).off('click.toolbar').on('click.toolbar', function (e) {
        self.handleClick(e);
      });

      this.items.filter('.btn-menu, .btn-actions').off('close.toolbar').on('close.toolbar', function onClosePopup() {
        var el = $(this);
        var last = void 0;

        if (el.is('.is-overflowed')) {
          last = self.getLastVisibleButton();
          if (last && last.length) {
            last[0].focus();
          }
          return;
        }

        if (document.activeElement && document.activeElement.tagName === 'INPUT') {
          return;
        }
        el.focus();
        self.buttonset.scrollTop(0);
      });

      this.items.not(this.more).off('selected.toolbar').on('selected.toolbar', function (e, anchor) {
        e.stopPropagation();
        self.handleSelected(e, anchor);
      });

      this.more.on('keydown.toolbar', function (e) {
        self.handleKeys(e);
      }).on('beforeopen.toolbar', function () {
        self.adjustMenuItemVisibility();
      }).on('selected.toolbar', function (e, anchor) {
        e.stopPropagation();
        self.handleSelected(e, anchor);
      });

      // Handle possible AJAX calls on Toolbar Menu buttons
      // TODO: Need to handle mouseenter/touchstart/keydown events that will cause this to trigger,
      // instead of directly handling this itself.
      this.more.off('show-submenu.toolbar').on('show-submenu.toolbar', function (e, li) {
        self.handleTransferToMenuButtonItem(e, li);
      });

      this.element.off('updated.toolbar').on('updated.toolbar', function (e, settings) {
        e.stopPropagation();
        self.updated(settings);
      }).off('recalculate-buttons.toolbar').on('recalculate-buttons.toolbar', function (e, containerDims) {
        self.handleResize(containerDims);
      }).off('scrollup.toolbar').on('scrollup.toolbar', function () {
        var moduleTabsParent = self.element.parents('.tab-container.module-tabs');
        if (moduleTabsParent.length) {
          moduleTabsParent.scrollTop(0);
        }
      });

      $('body').off('resize.toolbar-' + this.id).on('resize.toolbar-' + this.id, function () {
        self.handleResize();
      });

      // Trigger _handleResize()_ once to fix container sizes.
      this.handleResize();

      return this;
    },


    /**
     * Event Handler for the Soho Popupmenu's custom 'show-submenu' event, specifically for
     * the case of a menu button that's been spilled over into this Toolbar's More Actions menu.
     * @param {jQuery.Event} e custom `show-submenu` jQuery event
     * @param {jQuery[]} li the `li.submenu` element.
     */
    handleTransferToMenuButtonItem: function handleTransferToMenuButtonItem(e, li) {
      var originalMenuButton = li.children('a').data('original-button');
      if (!originalMenuButton) {
        return;
      }

      var popupAPI = originalMenuButton.data('popupmenu');
      if (!popupAPI || typeof popupAPI.settings.beforeOpen !== 'function') {
        return;
      }

      // Call out to the MenuButton's AJAX source, get its contents, and populate
      // the corresponding More Actions menu sub-item.
      popupAPI.callSource(e);
      this.buildMoreActionsMenuItem(originalMenuButton);
    },


    /**
     * Event handler for the Soho `selected` event on toolbar items
     * @private
     * @param {jQuery.Event} e custom `selected` event
     * @param {jQuery[]} anchor a reference to the anchor that was selected
     * @returns {void}
     */
    handleSelected: function handleSelected(e, anchor) {
      var itemLink = anchor.data('original-button');
      var li = anchor.parent();
      var itemEvts = void 0;
      var toolbarEvts = void 0;
      var popup = void 0;
      var popupTrigger = void 0;

      // Don't continue if hidden/readonly/disabled
      if (li.is('.hidden, .is-disabled') || anchor.is('[readonly], [disabled]')) {
        e.preventDefault();
        return;
      }

      if (itemLink && itemLink.length > 0) {
        itemEvts = itemLink.listEvents();
        toolbarEvts = this.element.listEvents();

        // Make sure the active button is set properly
        this.setActiveButton(itemLink);

        // Handle popdowns with a custom placement algorithm that correctly pops the menu
        // open against the "More Actions" button instead of in an empty space
        // SOHO-7087
        if (itemLink.is('[data-popdown]')) {
          popupTrigger = itemLink.data('popdown');

          if (this.isItemOverflowed(itemLink)) {
            popupTrigger.settings.trigger = this.more;
            popupTrigger.updated();
          }
        }

        // Fire Angular Events
        if (itemLink.attr('ng-click') || itemLink.attr('data-ng-click')) {
          itemLink.trigger('click');
          return;
        }

        // Check the Toolbar Button for the existence of certain event types.
        // Checks the button, and checks the toolbar container element for delegated events.
        var evtTypes = ['click', 'touchend', 'touchcancel'];
        for (var i = 0; i < evtTypes.length; i++) {
          var type = evtTypes[i];

          // Check toolbar element for delegated-down events first
          if (toolbarEvts && toolbarEvts[type] && toolbarEvts[type].delegateCount > 0) {
            var el = this.element;
            var evt = $.Event(type);

            evt.target = el.find(itemLink)[0];
            el.trigger(evt);
            return;
          }

          // Check for events directly on the element
          if (itemEvts && itemEvts[type] || itemLink[0]['on' + type]) {
            itemLink.trigger(type);
            return;
          }
        }

        // If the linked element is a child of a menu button, trigger its 'selected' event.
        popup = itemLink.parents('.popupmenu');
        popupTrigger = popup.data('trigger');
        if (popup.length && popupTrigger instanceof $ && popupTrigger.length) {
          popupTrigger.triggerHandler('selected', [itemLink]);
          return;
        }

        // Manually Trigger Select on the linked item, since it won't be done by another event
        this.triggerSelect(itemLink);
        return;
      }

      // If no item link exists, it's a pre-defined menu item.
      // Trigger 'selected' manually on the toolbar element.
      // Normally this would happen by virtue of triggering the "click"
      // handlers on a linked button above.
      this.triggerSelect(anchor);
    },


    /**
     * Event handler for clicks on toolbar items
     * @private
     * @listens {jQuery.Event} e
     * @param {jQuery.Event} e jQuery click event
     * @returns {boolean} basic "false" return expected for click events
     */
    handleClick: function handleClick(e) {
      this.setActiveButton($(e.currentTarget));
      this.triggerSelect($(e.currentTarget));
      return false;
    },


    /**
     * Event handler for key presses on toolbar items
     * @private
     * @listens {jQuery.Event} e
     * @param {jQuery.Event} e `keypress` event
     * @returns {void}
     */
    handleKeys: function handleKeys(e) {
      var self = this;
      var key = e.which;
      var target = $(e.target);
      var isActionButton = target.is('.btn-actions');
      var isRTL = Locale.isRTL();

      if (key === 37 && target.is(':not(input)') || key === 38 && target.is(':not(input.is-open)')) {
        // Don't navigate away if Up Arrow in autocomplete field that is open
        e.preventDefault();

        if (isActionButton) {
          self.setActiveButton(isRTL ? self.getFirstVisibleButton() : self.getLastVisibleButton());
        } else {
          self.navigate(isRTL ? 1 : -1);
        }
      }

      if (key === 39 && target.is(':not(input)') || key === 40 && target.is(':not(input.is-open)')) {
        // Don't navigate away if Down Arrow in autocomplete field that is open
        e.preventDefault();

        if (isActionButton) {
          self.setActiveButton(isRTL ? self.getLastVisibleButton() : self.getFirstVisibleButton());
        } else {
          self.navigate(isRTL ? -1 : 1);
        }
      }
    },


    /**
     * Re-renders the toolbar element and adjusts all internal parts to account for the new size.
     * @param {object} [containerDims] an object containing dimensions that can be set
     *  on the Toolbar's title and buttonset elements.
     * @param {number} [containerDims.title] represents the width that will be applied
     *  to the title element
     * @param {number} [containerDims.buttonset] represents the width that will be
     *  applied to the buttonset element
     * @returns {void}
     */
    handleResize: function handleResize(containerDims) {
      if (this.settings.resizeContainers) {
        var title = containerDims ? containerDims.title : undefined;
        var buttonset = containerDims ? containerDims.buttonset : undefined;

        this.sizeContainers(title, buttonset);
      }

      var buttons = this.getButtonsetButtons();
      for (var i = 0; i < buttons.length; i++) {
        buttons[i].removeClass('is-overflowed');
      }

      if (this.element.is(':not(:hidden)')) {
        this.adjustMenuItemVisibility();
        this.toggleMoreMenu(); // Added 9/16/2015 due to issue HFC-2876
      }
    },


    /**
     * Resizes the Toolbar's internal container areas (title, buttonset) to make
     * efficient use of their space.
     * @private
     * @chainable
     * @param {number} titleSize desired size of the title element.
     * @param {number} buttonsetSize desired size of the buttonset element.
     */
    sizeContainers: function sizeContainers(titleSize, buttonsetSize) {
      var containerElem = this.element[0];
      var titleElem = this.title[0];
      var buttonsetElem = this.buttonset[0];
      var moreElem = this.more[0];

      // Don't do this at all unless we have a title element (which is optional)
      if (!this.title || !this.title.length) {
        return;
      }

      // If the element's hidden and has defined sizes, remove them so we can use the defaults.
      if (this.element.is(':hidden')) {
        buttonsetElem.style.width = '';
        titleElem.style.width = '';
        containerElem.classList.remove('do-resize');
        return;
      }

      var WHITE_SPACE = 30;
      var MIN_TITLE_SIZE = 44 + WHITE_SPACE;
      var MIN_BUTTONSET_SIZE = 0;

      buttonsetElem.style.width = '';
      titleElem.style.width = '';

      if (!containerElem.classList.contains('do-resize')) {
        containerElem.classList.add('do-resize');
      }

      var toolbarDims = $(containerElem).getHiddenSize();
      var buttonsetDims = $(buttonsetElem).getHiddenSize();
      var titleDims = $(titleElem).getHiddenSize();
      var moreDims = $(moreElem).getHiddenSize();
      var toolbarPadding = parseInt(toolbarDims.padding.left, 10) + parseInt(toolbarDims.padding.right, 10);

      if (isNaN(moreDims.width)) {
        moreDims.width = 50;
      }

      if (isNaN(buttonsetDims.width) || buttonsetDims.width < MIN_BUTTONSET_SIZE) {
        buttonsetDims.width = MIN_BUTTONSET_SIZE;
      }

      function addPx(val) {
        return val + 'px';
      }

      // Get the target size of the title element
      var self = this;
      var hasTitleSizeGetter = titleSize !== undefined && !isNaN(titleSize);
      var hasButtonsetSizeGetter = buttonsetSize !== undefined && !isNaN(buttonsetSize);
      var d = void 0;
      this.cutoffTitle = false;

      // Determine the target sizes for title, based on external setters,
      //  or building an estimated size.
      function getTargetTitleWidth() {
        if (hasTitleSizeGetter) {
          return parseInt(titleSize, 10);
        }
        if (self.settings.favorButtonset === true) {
          return toolbarDims.width - (toolbarPadding + (hasButtonsetSizeGetter ? parseInt(buttonsetSize, 10) : buttonsetDims.width) + moreDims.width);
        }
        return titleDims.scrollWidth;
      }
      var targetTitleWidth = getTargetTitleWidth();

      // Determine the target sizes for buttonset
      function getTargetButtonsetWidth() {
        if (hasButtonsetSizeGetter) {
          return parseInt(buttonsetSize, 10);
        }
        if (self.settings.favorButtonset === true) {
          return buttonsetDims.width;
        }
        return toolbarDims.width - (toolbarPadding + (hasTitleSizeGetter ? parseInt(titleSize, 10) : titleDims.scrollWidth) + moreDims.width);
      }
      var targetButtonsetWidth = getTargetButtonsetWidth();

      if (this.settings.favorButtonset) {
        // Cut off the buttonset anyway if title is completely hidden.  Something's gotta give!
        if (targetTitleWidth < MIN_TITLE_SIZE) {
          this.cutoffTitle = true;
          d = Math.abs(targetTitleWidth - MIN_TITLE_SIZE);
          targetTitleWidth = MIN_TITLE_SIZE;
          targetButtonsetWidth -= d;
        }

        buttonsetElem.style.width = addPx(targetButtonsetWidth + 2);
        titleElem.style.width = addPx(targetTitleWidth - 2);

        return;
      }
      //= =========================
      // Favor the title element
      // Cut off the title anyway if buttonset is completely hidden.  Something's gotta give!
      if (targetButtonsetWidth < MIN_BUTTONSET_SIZE) {
        this.cutoffTitle = true;
        d = Math.abs(targetButtonsetWidth - MIN_BUTTONSET_SIZE);
        targetButtonsetWidth = MIN_BUTTONSET_SIZE;
        targetTitleWidth -= d;
      }

      // Always favor the title by one extra px for Chrome
      titleElem.style.width = addPx(targetTitleWidth + 2);
      buttonsetElem.style.width = addPx(targetButtonsetWidth - 2);
    },


    /**
     * Changes the "active" button on the toolbar.
     * @param {number} direction can be `-1` (previous), `1` (next), or `0` (remain on current).
     * @returns {void}
     */
    navigate: function navigate(direction) {
      var items = this.items.filter(':visible:not(:disabled)');
      var current = items.index(this.activeButton);
      var next = current + direction;
      var target = void 0;

      if (next >= 0 && next < items.length) {
        target = items.eq(next);
      }

      if (next >= items.length) {
        target = items.first();
      }

      if (next === -1) {
        target = items.last();
      }

      if (this.isItemOverflowed(target)) {
        target = this.more;
      }

      this.setActiveButton(target);
    },


    /**
     * Gets a reference to the last visible (not overflowed) button inside of the buttonset.
     * @returns {jQuery[]} the last visible button in the buttonset.
     */
    getLastVisibleButton: function getLastVisibleButton() {
      var items = $(this.items.get().reverse()).not(this.more);
      var target = void 0;
      var i = 0;
      var elem = void 0;

      while (!target && i < items.length) {
        elem = $(items[i]);
        if (!this.isItemOverflowed(elem)) {
          target = elem;
          break;
        }
        i++;
      }

      if (!target || target.length === 0) {
        target = items.first();
      }

      while (target.length && target.is('.separator, *:disabled, *:hidden')) {
        target = target.prev();
      }

      return target;
    },


    /**
     * Gets a reference to the first visible (not overflowed) button inside of the buttonset.
     * @returns {jQuery[]} the first visible button in the buttonset.
     */
    getFirstVisibleButton: function getFirstVisibleButton() {
      var i = 0;
      var items = this.items;
      var target = items.eq(i);

      while (target.is('.separator, *:disabled, *:hidden')) {
        i++;
        target = items.eq(i);
      }

      return target;
    },


    /**
     * Sets the currently "active" (focused) Toolbar item
     * @param {jQuery[]} activeButton the preferred target element to make active.
     * @param {boolean} [noFocus] if defined, prevents this method from giving focus
     *  to the new active button.
     */
    setActiveButton: function setActiveButton(activeButton, noFocus) {
      // Return out of this if we're clicking the currently-active item
      if (activeButton[0] === this.activeButton[0]) {
        return;
      }

      var self = this;

      function getMoreOrLast() {
        if (self.hasNoMoreButton() || !self.element.hasClass('has-more-button')) {
          return self.getLastVisibleButton();
        }

        return self.more;
      }

      function getActiveButton() {
        // Menu items simply set the "More Actions" button as active
        if (activeButton.is('a')) {
          return getMoreOrLast();
        }

        // If it's the more button, hide the tooltip and set it as active
        var tooltip = self.more.data('tooltip');
        if (activeButton[0] === self.more[0]) {
          if (tooltip && tooltip.tooltip.is(':not(.hidden)')) {
            tooltip.hide();
          }
          return getMoreOrLast();
        }

        // Overflowed items also set
        if (self.isItemOverflowed(activeButton)) {
          if (!activeButton.is('.searchfield')) {
            return getMoreOrLast();
          }
        }

        return activeButton;
      }

      this.items.add(this.more).attr('tabindex', '-1').removeClass('is-selected');

      this.activeButton = getActiveButton();
      this.activeButton.addClass('is-selected').attr('tabindex', '0');

      if (!noFocus) {
        this.activeButton[0].focus();

        /**
         * Fires when the Toolbar's currently `active` element has changed.
         *
         * @event navigate
         * @memberof Toolbar
         * @param {jQuery.Event} e the jQuery Event object
         * @param {jQuery} activeButton a reference to the new active button.
         */
        this.element.triggerHandler('navigate', [this.activeButton]);
      }
    },


    /**
     * Triggers a "selected" event on the base Toolbar element using a common element as an argument.
     * @param {HTMLElement|SVGElement|jQuery[]} element a jQuery Object containing an
     *  anchor tag, button, or input field.
     */
    triggerSelect: function triggerSelect(element) {
      var elem = $(element);
      if (elem.is(this.more) || elem.is('.btn-menu, li.submenu')) {
        return;
      }

      /**
       * Fires when a Toolbar item is selected.
       *
       * @event selected
       * @memberof Toolbar
       * @property {jQuery.Event} e the jQuery event object
       * @property {jQuery[]} itemLink a reference to the corresponding toolbar item, wrapped in a jQuery selector
       */
      this.element.triggerHandler('selected', [elem]);
    },


    /**
     * Assembles and returns a list of all buttons inside the Buttonset element.
     * @returns {array} of elements inside the buttonset
     */
    getButtonsetButtons: function getButtonsetButtons() {
      var buttons = [];
      var items = this.buttonsetItems;
      var item = void 0;

      for (var i = 0; i < items.length; i++) {
        item = items.eq(i);
        if (item.data('action-button-link') !== undefined && item.is(':not(.searchfield)')) {
          buttons.push(item);
        }
      }

      return buttons;
    },


    /**
     * Gets and Iterates through a list of toolbar items and determines which are
     * currently overflowed, and which are visible.
     * @param {array} buttons an Array of jQuery-wrapped elements that represents toolbar items.
     * @returns {object} containing a `visible` items array, and a `hidden` items array.
     */
    getVisibleButtons: function getVisibleButtons(buttons) {
      var self = this;
      var hiddenButtons = [];
      var visibleButtons = [];

      if (!buttons || !Array.isArray(buttons)) {
        buttons = this.getButtonsetButtons();
      }

      for (var i = 0; i < buttons.length; i++) {
        buttons[i][0].classList.remove('is-overflowed');
      }

      function getButtonVisibility(button) {
        if (!self.isItemOverflowed(button)) {
          visibleButtons.push(button);
        } else {
          hiddenButtons.push(button);
        }
      }

      for (var _i = 0; _i < buttons.length; _i++) {
        getButtonVisibility(buttons[_i]);
      }

      return {
        visible: visibleButtons,
        hidden: hiddenButtons
      };
    },


    /**
     * Gets and Iterates through the full list of Toolbar Items and determines which
     *  ones should currently be present in the More Actions menu.
     * @private
     * @param {object} items an object (normally generated by `_.getVisibleButtons()`)
     *  containing arrays of currently visible and hidden buttons, along with some meta-data.
     * @returns {void}
     */
    adjustMenuItemVisibility: function adjustMenuItemVisibility(items) {
      var iconDisplay = 'removeClass';

      if (!items) {
        items = this.getVisibleButtons();
      }

      function toggleClass($elem, doHide) {
        var elem = $elem[0];
        var li = $elem.data('action-button-link').parent()[0];
        var elemIsHidden = $elem.isHiddenAtBreakpoint();

        if (doHide) {
          li.classList.add('hidden');
          elem.classList.remove('is-overflowed');
          return;
        }

        if (!elemIsHidden) {
          li.classList.remove('hidden');
        }
        elem.classList.add('is-overflowed');

        if ($elem.find('.icon').length) {
          iconDisplay = 'addClass';
        }
      }

      var i = 0;
      for (i; i < items.visible.length; i++) {
        toggleClass(items.visible[i], true);
      }
      for (i = 0; i < items.hidden.length; i++) {
        toggleClass(items.hidden[i], false);
      }

      var numIcons = 0;
      this.moreMenu.find('.icon').each(function () {
        if (!$(this).parent().parent().hasClass('hidden')) {
          numIcons++;
        }
      });

      if (numIcons > 0) {
        iconDisplay = 'addClass';
      }

      this.moreMenu[iconDisplay]('has-icons');
    },


    /**
     * Detects whether or not a toolbar item is currently overflowed.  In general,
     *  toolbar items are considered overflow if their right-most edge sits past the
     *  right-most edge of the buttonset border.  There are some edge-cases.
     * @param {jQuery[]} item the Toolbar item being tested.
     * @returns {boolean} whether or not the item belongs in the More Actions menu
     */
    isItemOverflowed: function isItemOverflowed(item) {
      // No items will be overflowed if the `More Actions` menu is purposefully disabled.
      if (this.moreButtonIsDisabled()) {
        return false;
      }

      if (!item || item.length === 0) {
        return true;
      }

      var itemIndexInButtonset = this.buttonsetItems.filter(':not(.hidden)').index(item);
      var maxVisibleButtons = this.settings.maxVisibleButtons;

      // the `maxVisibleButtons` calculation should include a visible More Actions button.
      // Subtract one from the `maxVisibleButtons` setting to account for the More Button,
      // if it's visible. See SOHO-7237
      if (this.moreButtonIsVisible()) {
        maxVisibleButtons -= 1;
      }

      // In cases where a Title is present and buttons are right-aligned,
      // only show up to the maximum allowed.
      if (this.title.length) {
        if (itemIndexInButtonset >= maxVisibleButtons) {
          return true;
        }
      }

      if (this.buttonset.scrollTop() > 0) {
        this.buttonset.scrollTop(0);
      }

      // unwrap from jQuery
      if (item instanceof $ && item.length) {
        item = item[0];
      }

      var classList = item.classList;
      var style = window.getComputedStyle(item);

      if (classList.contains('btn-actions')) {
        return true;
      }
      if (classList.contains('searchfield')) {
        return false;
      }
      if (style.display === 'none') {
        return true;
      }

      var isRTL = Locale.isRTL();
      var itemRect = item.getBoundingClientRect();
      var buttonsetRect = this.buttonset[0].getBoundingClientRect();
      var itemOutsideXEdge = isRTL ? itemRect.left <= buttonsetRect.left : itemRect.right >= buttonsetRect.right;
      var itemBelowYEdge = itemRect.bottom >= buttonsetRect.bottom;

      return itemBelowYEdge === true || itemOutsideXEdge === true;
    },


    /**
     * @returns {boolean} whether or not this toolbar is able to have a More Button
     */
    moreButtonIsDisabled: function moreButtonIsDisabled() {
      return this.element[0].classList.contains('no-actions-button');
    },


    /**
     * Detection for this toolbar to have a More Button
     * @deprecated as of v4.4.0 due to unclear nomenclature.  Use `moreButtonIsDisabled()`
     * @private
     * @returns {boolean} whether or not the More Actions button is disabled.
     */
    hasNoMoreButton: function hasNoMoreButton() {
      return this.moreButtonIsDisabled();
    },


    /**
    * Detection for whether or not More Actions menu is currently visible.  This is
    * different than the More Actions menu being disabled.  This check determines
    * whether or not items have spilled over, causing the menu to be shown or hidden.
    * @returns {boolean} whether or not More Actions menu is currently visible.
    */
    moreButtonIsVisible: function moreButtonIsVisible() {
      return this.element[0].classList.contains('has-more-button');
    },


    /**
     * Determines whether or not the "more actions" button should be displayed.
     * @private
     * @returns {undefined} whether or not the "more actions" button should be displayed.
     */
    toggleMoreMenu: function toggleMoreMenu() {
      if (this.moreButtonIsDisabled()) {
        return;
      }

      var overflowItems = this.moreMenu.children('li:not(.separator)');
      var hiddenOverflowItems = overflowItems.not('.hidden');

      var method = 'removeClass';
      if (hiddenOverflowItems.length > 0) {
        method = 'addClass';
      }

      this.element[method]('has-more-button');

      var popupAPI = this.more.data('popupmenu');
      if (method === 'removeClass') {
        if (!popupAPI) {
          return;
        }

        popupAPI.close();

        var menuItems = popupAPI.menu.find('li:not(.separator)').children('a');
        var shouldFocus = false;

        menuItems.add(this.more).each(function () {
          if (document.activeElement === this) {
            shouldFocus = true;
          }
        });

        if (shouldFocus) {
          this.getLastVisibleButton()[0].focus();
        }
      }
    },


    /**
     * Creates an `aria-label` attribute on the toolbar, for bettery accessibility.
     * Based on AOL Access Guidelines:
     * http://access.aol.com/dhtml-style-guide-working-group/#toolbar
     * @private
     * @returns {void}
     */
    buildAriaLabel: function buildAriaLabel() {
      // Don't re-build if one already exists.
      if (this.element.attr('aria-label')) {
        return;
      }

      var isHeader = this.element.closest('.header').length === 1;
      var id = this.element.attr('id') || '';
      var title = this.element.children('.title');
      var prevLabel = this.element.prev('label');
      var prevSpan = this.element.prev('.label');

      function getLabelText() {
        if (isHeader) {
          return $('header.header').find('h1').text();
        }
        if (title.length) {
          return title.filter('div').text();
        }
        if (prevLabel.length) {
          return prevLabel.text();
        }
        if (prevSpan.length) {
          return prevSpan.text();
        }
        return id + ' ' + Locale.translate('Toolbar');
      }
      var labelText = getLabelText();

      this.element.attr('aria-label', labelText.replace(/\s+/g, ' ').trim());
    },


    /**
     * @param {object} [settings] incoming different settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.unbind().teardown().init();
    },


    /**
     * Enables the entire Toolbar component
     * @returns {void}
     */
    enable: function enable() {
      this.element.prop('disabled', false);
      this.items.prop('disabled', false);
      this.more.prop('disabled', false);
    },


    /**
     * Disables the entire Toolbar component
     * @returns {void}
     */
    disable: function disable() {
      this.element.prop('disabled', true);
      this.items.prop('disabled', true);
      this.more.prop('disabled', true).data('popupmenu').close();
    },


    /**
     * Removes currently associated event listeners from the Toolbar.
     * @private
     * @chainable
     * @returns {this} component instance
     */
    unbind: function unbind() {
      this.items.off('keydown.toolbar click.toolbar focus.toolbar blur.toolbar');

      this.more.off('keydown.toolbar beforeopen.toolbar selected.toolbar');
      $('body').off('resize.toolbar-' + this.id);
      return this;
    },


    /**
     * Returns the Toolbar's internal markup to its original state.
     * @chainable
     * @returns {this} component instance
     */
    teardown: function teardown() {
      var self = this;

      if (this.title && this.title.length) {
        var dataTooltip = this.title.off('beforeshow.toolbar').data('tooltip');
        if (dataTooltip) {
          dataTooltip.destroy();
        }
      }

      var moreMenuChildren = this.moreMenu.children('li');
      moreMenuChildren.each(function () {
        self.teardownMoreActionsMenuItem($(this), true);
      });

      // Remove AJAX-ified menu items.
      moreMenuChildren.not(this.defaultMenuItems).remove();

      return this;
    },


    /**
     * Tears down a More Actions Menu item.
     * @private
     * @param {jQuery[]} item the existing <li> from inside the More Actions menu.
     * @param {boolean} doRemove if defined, causes the list item to be removed from
     *  the more actions menu.
     */
    teardownMoreActionsMenuItem: function teardownMoreActionsMenuItem(item, doRemove) {
      var self = this;
      var li = $(item);
      var a = li.children('a');
      var itemLink = a.data('original-button');

      a.off('updated.toolbar mousedown.toolbar click.toolbar touchend.toolbar touchcancel.toolbar recalculate-buttons.toolbar');

      var icons = li.find('.icon');
      if (icons.length) {
        icons.remove();
      }

      var submenuContainer = void 0;
      if (li.is('.submenu')) {
        submenuContainer = li.children('.wrapper').children('.popupmenu');
        submenuContainer.children('li').each(function () {
          self.teardownMoreActionsMenuItem($(this), true);
        });
      }

      if (itemLink && itemLink.length) {
        $.removeData(a[0], 'original-button');
        $.removeData(itemLink[0], 'action-button-link');
        a.remove();

        if (submenuContainer) {
          submenuContainer.off().parent('.wrapper').off().remove();
        }

        if (doRemove) {
          li.remove();
        }
      }
    },


    /**
     * Destroys this Toolbar Component instance and completely disassociates it from
     *  its corresponding DOM Element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind().teardown();

      if (this.buttonset.children('.searchfield-wrapper').length) {
        var searchFields = this.buttonset.children('.searchfield-wrapper').children('.searchfield');
        if (searchFields.data('searchfield')) {
          searchFields.data('searchfield').destroy();
        }
      }

      if (this.more.length && this.more.data('popupmenu') !== undefined) {
        this.more.data('popupmenu').destroy();
      }

      this.element[0].classList.remove('do-resize');
      this.buttonset[0].style.width = '';
      if (this.title && this.title.length) {
        this.title[0].style.width = '';
      }

      this.element.removeAttr('role').removeAttr('aria-label');
      $.removeData(this.element[0], COMPONENT_NAME$13);
    }
  };

  /**
   * jQuery Component Wrapper for Toolbar
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.toolbar = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$13);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$13, new Toolbar(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$14 = 'toolbarflexitem';

  // Filters out hyperlinks that are part of menu/action button components
  function hyperlinkFilter(elem) {
    if (elem.nodeName !== 'A') {
      throw new Error('Unspecified error occured');
    }

    var wrapped = $(elem);
    return wrapped.parents('.popupmenu').length < 1;
  }

  // Toolbar Focusable Element Selectors.
  // Any of these element/class types are valid toolbar items.
  // TODO: Designate between "button" and "menu button"
  var TOOLBAR_ELEMENTS = [{ type: 'button', selector: 'button:not(.btn-menu):not(.btn-actions), input[type="button"]:not(.btn-menu):not(.btn-actions)' }, { type: 'menubutton', selector: '.btn-menu' }, { type: 'actionbutton', selector: '.btn-actions' }, { type: 'hyperlink', selector: 'a[href]', filter: hyperlinkFilter }, { type: 'checkbox', selector: 'input[type="checkbox"]' }, { type: 'radio', selector: 'input[type="radio"]' }, { type: 'searchfield', selector: '.searchfield' }, { type: 'toolbarsearchfield', selector: '.toolbarsearchfield' // temporary
  }];

  // Mappings from toolbar item type to component API
  var TOOLBAR_COMPONENT_APIS = {
    actionbutton: 'popupmenu',
    menubutton: 'popupmenu',
    hyperlink: 'hyperlink',
    searchfield: 'searchfield',
    toolbarsearchfield: 'searchfield'
  };

  /**
   * Default Settings
   * @namespace
   */
  var TOOLBAR_FLEX_ITEM_DEFAULTS = {
    disabled: false,
    readOnly: false,
    hidden: false,
    componentSettings: undefined
  };

  /**
   * Gets the type of Toolbar Item that an element represents.
   * @param {HTMLElement} element being checked for a toolbar item.
   * @returns {string} representing the type
   */
  function getToolbarItemType(element) {
    var type = false;
    TOOLBAR_ELEMENTS.forEach(function (elemObj) {
      if (!$(element).is(elemObj.selector)) {
        return;
      }
      if (typeof elemObj.filter === 'function' && !elemObj.filter(element)) {
        return;
      }
      type = elemObj.type;
    });

    if (!type) {
      throw new Error('Element ' + element + ' is not a valid Toolbar Item Type.');
    }

    return type;
  }

  /**
   * Toolbar Item Wrapper Component
   * @constructor
   * @param {HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   */
  function ToolbarFlexItem(element, settings) {
    this.element = element;
    this.settings = utils.mergeSettings(this.element, settings, TOOLBAR_FLEX_ITEM_DEFAULTS);

    this.init();
  }

  ToolbarFlexItem.prototype = {

    /**
     * @property {string} type used to determine the type of toolbar item.  Certain toolbar item types
     *  have certain special properties.
     * @property {HTMLElement} section the parent toolbar section that this item is housed in.
     * @property {HTMLElement} toolbar the parent toolbar's base element.
     */
    type: undefined,

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      // internal flags
      this.type = getToolbarItemType(this.element);
      this.section = this.element.parentElement;
      this.toolbar = this.section.parentElement;
      this.trueSelected = false;
    },


    /**
     * @returns {boolean} whether or not the toolbar item is currently able to be focused, based
     *  on its `disabled`, `overflowed`, and `visible` properties.
     */
    get focusable() {
      if (this.disabled === true) {
        return false;
      }
      if (this.overflowed === true) {
        return false;
      }
      if (this.type === 'actionbutton' && this.hasNoOverflowedItems === true) {
        return false;
      }

      return this.visible;
    },

    /**
     * @returns {boolean} whether or not the toolbar item is the one that will currently be focused
     */
    get focused() {
      return this.element.tabIndex === 0;
    },

    /**
     * @param {boolean} boolean, if provided, sets a focused state on the toolbar item.
     * @returns {void}
     */
    set focused(boolean) {
      if (boolean) {
        this.element.tabIndex = 0;
        return;
      }
      this.element.tabIndex = -1;
    },

    /**
     * @returns {boolean} whether or not the Toolbar item is selected.
     */
    get selected() {
      return this.trueSelected;
    },

    /**
     * @param {boolean} boolean, if provided, sets a selected state on the toolbar item.
     * @returns {void}
     */
    set selected(boolean) {
      if (boolean) {
        this.trueSelected = true;
        this.element.classList.add('is-selected');
        this.triggerSelectedEvent();

        if (this.selectedAnchor) {
          delete this.selectedAnchor;
        }
        return;
      }
      this.trueSelected = false;
      this.element.classList.remove('is-selected');
    },

    /**
     * Retrieves an item's main Soho Component instance.
     * @returns {object} Soho Component instance, if applicable
     */
    get componentAPI() {
      var $element = $(this.element);
      var componentType = TOOLBAR_COMPONENT_APIS[this.type];

      if (!componentType) {
        return undefined;
      }

      return $element.data(componentType);
    },

    /**
     * @returns {ToolbarFlex} the parent toolbar API
     */
    get toolbarAPI() {
      if (this.settings.toolbarAPI) {
        return this.settings.toolbarAPI;
      }
      return $(this.toolbar).data('toolbar-flex');
    },

    /**
     * @fires selected
     * @returns {void}
     */
    triggerSelectedEvent: function triggerSelectedEvent() {
      // Searchfields aren't "selectable" in the same way actionable items are,
      // so they shouldn't fire the "selected" event.
      if (this.type === 'searchfield' || this.type === 'toolbarsearchfield') {
        return;
      }

      var eventArgs = [this];

      // MenuButton types pass the currently-selected anchor
      if ((this.type === 'menubutton' || this.type === 'actionbutton') && this.selectedAnchor) {
        eventArgs.push(this.selectedAnchor);
      }

      $(this.element).trigger('selected', eventArgs);
    },


    /**
     * Causes the toolbar item to become visible.
     * @returns {void}
     */
    show: function show() {
      this.visible = true;
    },


    /**
     * Causes the toolbar item to become hidden.
     * @returns {void}
     */
    hide: function hide() {
      this.visible = false;
    },


    /**
     * Toggles the Toolbar item's visiblity.
     * @param {boolean} boolean whether or not the `hidden` class should be set.
     */
    set visible(boolean) {
      // NOTE: Temporary until Searchfield handles this better internally.
      var isSearchfield = this.type === 'searchfield' || this.type === 'toolbarsearchfield';

      if (boolean) {
        if (isSearchfield) {
          this.element.parentNode.classList.remove('hidden');
        }
        this.element.classList.remove('hidden');
        return;
      }

      if (isSearchfield) {
        this.element.parentNode.classList.add('hidden');
      }
      this.element.classList.add('hidden');
    },

    /**
     * @returns {boolean} whether or not the Toolbar Item is visible.
     */
    get visible() {
      return this.element.className.indexOf('hidden') === -1;
    },

    /**
     * @returns {void}
     */
    enable: function enable() {
      this.disabled = false;
      if (this.hasReadOnly) {
        this.readOnly = false;
      }
    },


    /**
     * @returns {boolean} whether or not the element is disabled
     */
    get disabled() {
      return this.element.disabled;
    },

    /**
     * @param {boolean} boolean, if provided, sets a disabled state on the toolbar item.
     * @returns {void}
     */
    set disabled(boolean) {
      if (boolean) {
        this.element.disabled = true;
        this.element.setAttribute('aria-disabled', true);
        this.element.readOnly = false;
        return;
      }

      this.element.disabled = false;
      this.element.removeAttribute('aria-disabled');
    },

    /**
     * @returns {boolean} whether or not `readOnly` as a property exists on this HTMLElement type.
     */
    get hasReadOnly() {
      return 'readOnly' in this.element;
    },

    /**
     * @returns {boolean} element's readOnly prop
     */
    get readOnly() {
      if (!this.hasReadOnly) {
        return false;
      }
      return this.element.readOnly;
    },

    /**
     * @param {boolean} boolean, if provided, sets a readOnly state on the toolbar item, if possible.
     * @returns {void}
     */
    set readOnly(boolean) {
      if (!this.hasReadOnly) {
        return;
      }

      if (boolean) {
        this.disabled = false;
        this.element.disabled = false;
        this.element.readOnly = true;
        return;
      }

      this.element.readOnly = false;
    },

    /**
     * @returns {boolean} whether or not the item is pushed into overflow by the boundaries
     *  of its container element.
     */
    get overflowed() {
      var isRTL = Environment.rtl;
      var elemRect = this.element.getBoundingClientRect();
      var sectionRect = this.section.getBoundingClientRect();

      if (isRTL) {
        return elemRect.left < sectionRect.left;
      }
      return elemRect.right > sectionRect.right;
    },

    /**
     * @param {boolean} isTrue whether or not the more actions menu has overflowed items, causing it to become displayed
     * @returns {void}
     */
    set hasNoOverflowedItems(isTrue) {
      if (this.type !== 'actionbutton') {
        return;
      }

      var popupmenuLength = this.componentAPI.toData({ noMenuWrap: true }).length;
      var menuIsEmpty = popupmenuLength - this.predefinedItems.length < 1;

      if (isTrue && menuIsEmpty) {
        this.element.classList.add('no-overflowed-items');
        this.trueHasNoOverflowedItems = true;

        if (this.focused) {
          this.toolbarAPI.focusedItem = this;
          this.toolbarAPI.navigate(-1, undefined, true);
        }
        return;
      }
      this.trueHasNoOverflowedItems = false;
      this.element.classList.remove('no-overflowed-items');
    },

    /**
     *
     */
    get hasNoOverflowedItems() {
      if (!this.componentAPI) {
        return true;
      }
      return this.trueHasNoOverflowedItems;
    },

    /**
     * Sets up all event listeners for this element.
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;
      var $element = $(this.element);

      if (this.type === 'menubutton' || this.type === 'actionbutton') {
        // Listen to the Popupmenu's selected event
        $element.on('selected.' + COMPONENT_NAME$14, function (e, anchor) {
          if (_this.selectedAnchor) {
            return;
          }

          e.stopPropagation();

          if (_this.type === 'actionbutton') {
            var li = $(anchor).parent();
            var itemLink = li.data('originalButton');
            var itemLinkAPI = $(itemLink).data('toolbarflexitem');
            var elementLink = void 0;

            if (li.parents('ul').length > 1) {
              elementLink = li.data('original-menu-element');
              itemLink = li.parents('li').last().data('originalButton');
              itemLinkAPI = $(itemLink).data('toolbarflexitem');
            }

            // If this item is linked to another toolbar item, trigger its `selected` event instead
            // of the one on the item in this menu.
            if (itemLinkAPI) {
              if (elementLink) {
                e.preventDefault();
                itemLinkAPI.selectedAnchor = $(elementLink).children('a');
              }
              itemLinkAPI.selected = true;
              return;
            }
          }

          self.selectedAnchor = anchor;
          self.selected = true;
        });
      }

      if (this.type === 'actionbutton') {
        $element.on('beforeopen.' + COMPONENT_NAME$14, this.handleActionButtonBeforeOpen.bind(this));
        $('body').off('resize.' + COMPONENT_NAME$14).on('resize.' + COMPONENT_NAME$14, this.handleActionButtonResize.bind(this));
      }

      $element.on('focus.' + COMPONENT_NAME$14, this.handleFocus.bind(this));
    },


    /**
     * If this element is an Action Button, this listener runs before its popupmenu is opened
     * To determine which elements need to be shown/hidden.
     * @private
     * @returns {void}
     */
    handleActionButtonBeforeOpen: function handleActionButtonBeforeOpen() {
      this.refreshMoreActionsMenu();
    },


    /**
     * If this element is an Action Button, this listener runs whenever Soho's custom resize event
     * on the `<body>` tag fires, to determine which elements need to be shown/hidden.
     * @private
     * @returns {void}
     */
    handleActionButtonResize: function handleActionButtonResize() {
      this.refreshMoreActionsMenu();
    },


    /**
     * @private
     * @param {FocusEvent} e `focus`
     * @returns {void}
     */
    handleFocus: function handleFocus(e) {
      if (e.target && e.target === this.element) {
        this.toolbarAPI.focusedItem = this;
      }
    },


    /**
     * Renders extra markup or anything else needed on the toolbar item
     * @returns {void}
     */
    render: function render() {
      this.disabled = this.disabled;
      if (this.hasReadOnly) {
        this.readonly = this.readonly;
      }

      // Setup component APIs, if applicable.
      // NOTE: Soho Initializer doesn't invoke these automatically, by nature of the
      // base elements existing inside the Flex Toolbar.
      var $element = $(this.element);
      var componentType = TOOLBAR_COMPONENT_APIS[this.type];
      if (componentType) {
        var api = $element.data(componentType);
        if (!api) {
          $element[componentType](this.settings.componentSettings);
        } else {
          api.updated(this.settings.componentSettings);
        }
      }

      // Action Buttons need more stuff
      if (this.type !== 'actionbutton') {
        return;
      }
      this.renderMoreActionsMenu();
      this.refreshMoreActionsMenu();

      this.handleEvents();
    },


    /**
     * Uses data from Toolbar Items to build Toolbar-linked, pre-defined items for the More Actions menu.
     * NOTE: This method only runs when this toolbar item is a "More Actions" button
     * @private
     * @returns {void}
     */
    renderMoreActionsMenu: function renderMoreActionsMenu() {
      var menuAPI = this.componentAPI;
      if (!menuAPI || !this.toolbarAPI) {
        return;
      }

      // If the menu doesn't already exist, pre-define it.
      var $menu = menuAPI.menu;
      if (!$menu || !$menu.length) {
        $menu = $('<ul class="popupmenu"></ul>').insertAfter(this.element);
      }

      this.teardownPredefinedItems();

      // Add Toolbar Items
      var data = this.toolbarAPI.toPopupmenuData();
      var menuItems = $(menuAPI.renderItem(data));
      this.predefinedItems = menuItems;
      this.linkToolbarItems(data);

      // Notify the Popupmenu of predefined items
      $menu.prepend(this.predefinedItems);
      menuAPI.updated({
        menu: $menu,
        predefined: menuItems
      });

      this.menuRendered = true;
    },


    /**
     * Refreshes the state of menu items in a "More Actions" menu that were constructed by the Flex Toolbar.
     * @private
     * @returns {void}
     */
    refreshMoreActionsMenu: function refreshMoreActionsMenu() {
      if (this.type !== 'actionbutton') {
        return;
      }

      this.hasNoOverflowedItems = true;

      var menuAPI = this.componentAPI;
      if (!menuAPI || !this.toolbarAPI) {
        return;
      }

      // If there are toolbar items, but no predefined items, render the more-actions menu
      if ((!this.predefinedItems || !this.predefinedItems.length) && this.toolbarAPI.items.length) {
        this.renderMoreActionsMenu();
      }

      var hasNoOverflowedItems = true;

      // Called at the end of the item refresh.
      // Uses the Popupmenu's API to add overflow information.
      function itemRefreshCallback(menuItem, data) {
        if (data.isSubmenuItem) {
          return;
        }

        if (data.overflowed === true) {
          menuItem.classList.add('is-overflowed');

          if (data.visible) {
            menuItem.classList.remove('hidden');
          }

          hasNoOverflowedItems = false;
          return;
        }

        menuItem.classList.remove('is-overflowed');
        menuItem.classList.add('hidden');
      }

      // Each Linked Toolbar Item will be refreshed by the Popupmenu API
      this.toolbarAPI.items.forEach(function (item) {
        if (!item.actionButtonLink) {
          return;
        }

        var itemData = item.toPopupmenuData();
        itemData.overflowed = item.overflowed;

        menuAPI.refreshMenuItem(item.actionButtonLink, itemData, itemRefreshCallback);
      });

      // Set a record for display
      this.hasNoOverflowedItems = hasNoOverflowedItems;
    },


    /**
     * Removes links between the current set of Toolbar Items to `More Actions` menu items.
     * @private
     * @returns {void}
     */
    unlinkToolbarItems: function unlinkToolbarItems() {
      if (this.type !== 'actionbutton' || !this.menuRendered || !this.predefinedItems || !this.predefinedItems.length) {
        return;
      }

      function doUnlinkSubmenuItem(actionMenuElement) {
        var $originalMenuElement = $($(actionMenuElement).data('original-menu-element'));
        $originalMenuElement.removeData('action-button-link');
        $(actionMenuElement).removeData('original-menu-element');

        if ($originalMenuElement.hasClass('submenu')) {
          var submenuItems = actionMenuElement.querySelector('.popupmenu').children;
          for (var j = 0; j < submenuItems.length; j++) {
            doUnlinkSubmenuItem(submenuItems[j]);
          }
        }
      }

      function doUnlinkToolbarItems(i, itemElement) {
        var originalButton = $(itemElement).data('originalButton');
        var originalButtonAPI = $(originalButton).data('toolbarflexitem');

        originalButtonAPI.actionButtonLink = null;
        $(itemElement).removeData('original-button');

        if (originalButtonAPI.type === 'menubutton') {
          var submenuItems = itemElement.querySelector('.popupmenu').children;
          for (var j = 0; j < submenuItems.length; j++) {
            doUnlinkSubmenuItem(submenuItems[j]);
          }
        }
      }

      this.predefinedItems.each(doUnlinkToolbarItems);
    },


    /**
     * Links the current set of Toolbar Items to the `More Actions` menu items.
     * @private
     * @param {object} popupmenuData incoming popupmenu data
     * @returns {void}
     */
    linkToolbarItems: function linkToolbarItems(popupmenuData) {
      if (this.type !== 'actionbutton' || !popupmenuData) {
        return;
      }

      if (!Array.isArray(popupmenuData)) {
        popupmenuData = popupmenuData.menu;
      }

      function doLinkSubmenuItem(menuItemData, actionMenuElement) {
        var originalMenuElement = menuItemData.elementLink;
        $(originalMenuElement).data('action-button-link', actionMenuElement);
        $(actionMenuElement).data('original-menu-element', originalMenuElement);

        var submenu = menuItemData.submenu;
        if (submenu && submenu.length) {
          var submenuItems = actionMenuElement.querySelector('.popupmenu').children;
          for (var j = 0; j < submenuItems.length; j++) {
            doLinkSubmenuItem(submenu[j], submenuItems[j]);
          }
        }
      }

      function doLinkToolbarItems(i, itemElement) {
        var originalButtonAPI = popupmenuData[i].itemLink;
        originalButtonAPI.actionButtonLink = itemElement;
        $(itemElement).data('original-button', originalButtonAPI.element);

        var submenu = popupmenuData[i].submenu;
        if (submenu && submenu.length) {
          var submenuItems = itemElement.querySelector('.popupmenu').children;
          for (var j = 0; j < submenuItems.length; j++) {
            doLinkSubmenuItem(submenu[j], submenuItems[j]);
          }
        }
      }

      this.predefinedItems.each(doLinkToolbarItems);
    },


    /**
     * Converts the contents of the Toolbar Item to a data structure that's compatible with a Popupmenu component.
     * This data structure can be used to populate the contents of a "More Actions" menu.
     * @returns {object} an object representation of the Toolbar Item as a Popupmenu Item.
     */
    toPopupmenuData: function toPopupmenuData() {
      if (this.type === 'searchfield' || this.type === 'toolbarsearchfield' || this.type === 'actionbutton') {
        return undefined;
      }

      var itemData = {
        itemLink: this,
        disabled: this.disabled,
        visible: this.visible
      };

      var icon = this.element.querySelector('.icon:not(.close):not(.icon-dropdown) > use');
      if (icon) {
        itemData.icon = icon.getAttribute('xlink:href').replace('#icon-', '');
      }

      if (this.type === 'button' || this.type === 'menubutton') {
        itemData.text = this.element.textContent.trim();
      }

      function addMenuElementLinks(menu, data) {
        var elems = menu.querySelectorAll('li:not(.heading)');
        data.forEach(function (item, i) {
          item.elementLink = elems[i];
          if (item.submenu) {
            var submenu = elems[i].querySelector('.popupmenu');
            item.submenu = addMenuElementLinks(submenu, item.submenu);
          }
        });
        return data;
      }

      // Add links to the menubutton's menu item elements to the Popupmenu data
      if (this.type === 'menubutton') {
        var menuElem = this.componentAPI.menu;
        var originalSubmenuData = this.componentAPI.toData({ noMenuWrap: true });
        itemData.submenu = addMenuElementLinks(menuElem[0], originalSubmenuData);
      }

      return itemData;
    },


    /**
     * Converts the current state of the toolbar item to an object structure that can be
     * easily passed back/forth and tested.
     * @returns {object} containing the current Toolbar Item state.
     */
    toData: function toData() {
      var itemData = {
        type: this.type,
        disabled: this.disabled,
        focused: this.focused,
        selected: this.selected,
        overflowed: this.overflowed,
        visible: this.visible
      };

      if (this.hasReadOnly) {
        itemData.readOnly = this.readOnly;
      }

      if (this.actionButtonLink) {
        itemData.actionButtonLink = this.actionButtonLink;
      }

      if (this.componentAPI) {
        itemData.componentAPI = this.componentAPI;
      }

      var icon = this.element.querySelector('.icon:not(.close):not(.icon-dropdown) > use');
      if (icon) {
        itemData.icon = icon.getAttribute('xlink:href').replace('#icon-', '');
      }

      if (this.type === 'button' || this.type === 'menubutton') {
        itemData.text = this.element.textContent.trim();
      }

      if (this.type === 'actionbutton') {
        itemData.predefinedItems = this.predefinedItems;
      }

      if (this.type === 'menubutton' || this.type === 'actionbutton') {
        // TODO: Need to convert a Popupmenu's contents to the object format with this method
        itemData.submenu = this.componentAPI.toData({ noMenuWrap: true });
      }

      return itemData;
    },


    /**
     * Completely updates this component with (optional) new settings.
     * @param {object} [settings] incoming settings
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.teardown();
      this.init();
    },


    /**
     * @private
     * @returns {void}
     */
    teardownPredefinedItems: function teardownPredefinedItems() {
      if (this.type !== 'actionbutton') {
        return;
      }

      this.unlinkToolbarItems();
      if (this.predefinedItems && this.predefinedItems.length) {
        this.predefinedItems.remove();
      }
    },


    /**
     * Unbinds events and removes preset internal flags for this component.
     * @returns {void}
     */
    teardown: function teardown() {
      $(this.element).off('selected.' + COMPONENT_NAME$14).off('beforeopen.' + COMPONENT_NAME$14).off('focus.' + COMPONENT_NAME$14);

      $('body').off('resize.' + COMPONENT_NAME$14);

      this.teardownPredefinedItems();

      delete this.type;
      delete this.selected;
      delete this.focusable;
      delete this.visible;
      delete this.disabled;
      delete this.readOnly;

      delete this.section;
      delete this.toolbar;
      delete this.trueSelected;
      delete this.menuRendered;
    }
  };

  /**
   * jQuery component wrapper for Toolbar Flex Item Component
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.toolbarflexitem = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$14);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$14, new ToolbarFlexItem(this, settings));

        // Remove the jQuery Component reference from $.data
        var oldDestroy = instance.destroy;
        instance.destroy = function () {
          if (typeof oldDestroy === 'function') {
            oldDestroy.call(this);
          }
          $.removeData(this, COMPONENT_NAME$14);
        };
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$15 = 'toolbar-flex';

  /**
   * Component Default Settings
   * @namespace
   */
  var TOOLBAR_FLEX_DEFAULTS = {};

  /**
   * @constructor
   * @param {HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   */
  function ToolbarFlex(element, settings) {
    this.element = element;
    this.settings = utils.mergeSettings(this.element, settings, TOOLBAR_FLEX_DEFAULTS);

    this.init();
  }

  ToolbarFlex.prototype = {

    /**
     * @private
     */
    trueFocusedItem: undefined,

    sections: [],

    items: [],

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      var _this = this;

      this.sections = Array.from(this.element.querySelectorAll('.toolbar-section'));
      this.items = this.getElements().map(function (item) {
        $(item).toolbarflexitem({
          toolbarAPI: _this
        });
        return $(item).data('toolbarflexitem');
      });

      if (!this.items) {
        return;
      }

      // Check for a focused item
      this.items.forEach(function (item) {
        if (item.focused) {
          if (_this.focusedItem === undefined) {
            _this.focusedItem = item;
          } else {
            item.focused = false;
          }
        }
      });
      if (!this.focusedItem) {
        this.focusedItem = this.items[0];
      }

      this.render();
      this.handleEvents();
    },


    /**
     * @returns {void}
     */
    render: function render() {
      this.element.setAttribute('role', 'toolbar');
      this.items.forEach(function (item) {
        item.render();
      });
    },


    /**
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      this.keydownListener = this.handleKeydown.bind(this);
      this.element.addEventListener('keydown', this.keydownListener);

      this.keyupListener = this.handleKeyup.bind(this);
      this.element.addEventListener('keyup', this.keyupListener);

      this.clickListener = this.handleClick.bind(this);
      this.element.addEventListener('click', this.clickListener);

      $(this.element).on('selected.' + COMPONENT_NAME$15, function (e) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        log('dir', args);
      });
    },


    /**
     * Event Handler for internal `keydown` events.
     * @private
     * @param {KeyboardEvent} e `keydown`
     * @returns {void}
     */
    handleKeydown: function handleKeydown(e) {
      var target = e.target;

      // Toolbar Items get handled separately.
      if ($(target).data('toolbarflexitem')) {
        this.handleItemKeydown(e);
        // return;
      }
    },


    /**
     * Event Handler for internal `keydown` events, specifically on Toolbar Items.
     * @private
     * @param {KeyboardEvent} e `keydown`
     * @returns {void}
     */
    handleItemKeydown: function handleItemKeydown(e) {
      var key = e.key;
      var item = this.getItemFromElement(e.target);

      // NOTE: 'Enter' and 'SpaceBar' are purposely not handled on keydown, since
      // a `click` event will be fired on Toolbar items while pressing either of these keys.
      if (key === 'Enter') {
        this.clickByEnterKey = true;
        return;
      }

      if (key === ' ') {
        // SpaceBar
        if (item.type === 'hyperlink') {
          this.select(e.target);
        }
        return;
      }

      if (key === 'ArrowLeft' || key === 'ArrowUp') {
        if (item.type === 'searchfield' && key === 'ArrowLeft') {
          return;
        }
        this.navigate(-1, undefined, true);
        return;
      }

      if (key === 'ArrowRight' || key === 'ArrowDown') {
        if (item.type === 'searchfield' && key === 'ArrowRight') {
          return;
        }
        this.navigate(1, undefined, true);
      }
    },


    /**
     * Event Handler for internal `keyup` events
     * @private
     * @param {KeyboardEvent} e `keyup`
     * @returns {void}
     */
    handleKeyup: function handleKeyup(e) {
      this.clearClickByEnter(e);
    },


    /**
     * Event Handler for internal `click` events
     * @private
     * @param {MouseEvent} e `click`
     * @returns {void}
     */
    handleClick: function handleClick(e) {
      var target = e.target;

      // Toolbar Items get handled separately.
      if ($(target).data('toolbarflexitem')) {
        this.handleItemClick(e);
      }

      this.clearClickByEnter();
    },


    /**
     * Event Handler for internal `click` events, specifically on Toolbar Items.
     * @private
     * @param {MouseEvent} e `click`
     * @returns {void}
     */
    handleItemClick: function handleItemClick(e) {
      var item = this.getItemFromElement(e.target);

      this.select(item);
      this.focusedItem = item;
    },


    /**
     * @private
     * @param {Event} e incoming event of multiple types
     * @returns {void}
     */
    clearClickByEnter: function clearClickByEnter(e) {
      // Gets set in `this.handleItemKeydown` by pressing 'Enter'.
      if (this.clickByEnterKey) {
        // Prevents the enter key from triggering a `selected` event on the menu button.
        if (this.type === 'menubutton' || this.type === 'actionbutton') {
          e.preventDefault();
        }
        delete this.clickByEnterKey;
      }
    },


    /**
     * Gets all the elements currently inside the Toolbar Markup.
     * The array of items produced is ordered by Toolbar Section.
     * @returns {array} of Toolbar Items
     */
    getElements: function getElements() {
      var items = [];
      var allSelectors = [];

      // Build a really big selector containing all possible matches
      TOOLBAR_ELEMENTS.forEach(function (elemObj) {
        allSelectors.push(elemObj.selector);
      });
      allSelectors = allSelectors.join(', ');

      // Get all possible Toolbar Element matches
      // NOTE: Important that the toolbar items are picked up by the querySelector
      // in their actual, physical DOM order.
      var thisElems = Array.from(this.element.querySelectorAll(allSelectors));

      // Check each element for each type of toolbar item.
      // If there's a match, push to the item array.
      thisElems.forEach(function (elem) {
        var defined = false;
        TOOLBAR_ELEMENTS.forEach(function (elemObj) {
          if (defined || !$(elem).is(elemObj.selector)) {
            return;
          }
          if (typeof elemObj.filter === 'function') {
            if (!elemObj.filter(elem)) {
              return;
            }
          }
          defined = true;
          items.push(elem);
        });
      });

      return items;
    },


    /**
     * @param {HTMLElement|ToolbarFlexItem} element the element to be checked
     * @returns {ToolbarFlexItem} an instance of a Toolbar item
     */
    getItemFromElement: function getItemFromElement(element) {
      if (element instanceof ToolbarFlexItem) {
        return element;
      }

      var item = void 0;
      for (var i = 0; i < this.items.length; i++) {
        // Simple comparison of innerHTML to figure out if the elements match up
        if (this.items[i].element.innerHTML === element.innerHTML) {
          item = this.items[i];
        }
      }

      if (!item) {
        throw new Error('No Toolbar Item instance available for element ' + element + '.');
      }

      return item;
    },


    /**
     * @returns {ToolbarFlexItem|undefined} either a toolbar item, or undefined if one
     *  wasn't previously focused.
     */
    get focusedItem() {
      if (this.trueFocusedItem) {
        return this.trueFocusedItem;
      }
      for (var i = 0; i < this.items.length; i++) {
        if (this.items[i].focused === true) {
          return this.items[i];
        }
      }
      return undefined;
    },

    /**
     * Sets the currently focused item
     * @param {ToolbarFlexItem} item the item to be focused
     */
    set focusedItem(item) {
      if (this.items.length === 0) {
        return;
      }

      for (var i = 0; i < this.items.length; i++) {
        this.items[i].focused = false;
      }
      item.focused = true;
      this.trueFocusedItem = item;
    },

    // Flag for figuring out if a Toolbar's items are all completely unavailable for keyboard focus.
    get hasFocusableItems() {
      for (var i = 0; i < this.items.length; i++) {
        if (this.items[i].focusable === true) {
          return true;
        }
      }
      return false;
    },

    /**
     * @returns {ToolbarFlexItem[]} all overflowed items in the toolbar
     */
    get overflowedItems() {
      var overflowed = [];

      for (var i = 0; i < this.items.length; i++) {
        if (this.items[i].overflowed === true) {
          overflowed.push(this.items[i]);
        }
      }

      return overflowed;
    },

    /**
     * Navigates among toolbar items and gets a reference to a potential target for focus.
     * @param {number} direction positive/negative value representing how many spaces to move
     * @param {number} [currentIndex] the index to start checking from
     *  the current focus either right/left respectively.
     * @param {boolean} [doSetFocus=false] if set to true, will cause navigation to also set focus.
     */
    navigate: function navigate(direction, currentIndex, doSetFocus) {
      if (this.hasFocusableItems === false) {
        log('No focusable items');
        return;
      }

      // reference the original direction for later, if placement fails.
      var originalDirection = 0 + direction;

      if (currentIndex === undefined) {
        currentIndex = this.items.indexOf(this.focusedItem);
      }

      log('Toolbar Navigation: ' + direction + ' points away from index ' + currentIndex);

      while (direction !== 0) {
        if (direction > 0) {
          if (currentIndex === this.items.length - 1) {
            currentIndex = 0;
          } else {
            currentIndex++;
          }
          --direction;
        }
        if (direction < 0) {
          if (currentIndex === 0) {
            currentIndex = this.items.length - 1;
          } else {
            --currentIndex;
          }
          direction++;
        }
      }

      var targetItem = this.items[currentIndex];
      if (targetItem.focusable === false) {
        this.navigate(originalDirection > 0 ? 1 : -1, currentIndex, doSetFocus);
        return;
      }

      // Retain a reference to the focused item and set focus, if applicable.
      this.focusedItem = targetItem;
      if (doSetFocus) {
        this.focusedItem.element.focus();
      }
    },


    /**
     * @param {HTMLElement|ToolbarFlexItem} element an HTMLElement representing a
     *  Toolbar Item, or an actual ToolbarFlexItem API to use.
     * @returns {void}
     */
    select: function select(element) {
      var item = this.getItemFromElement(element);

      switch (item.type) {
        case 'searchfield':
        case 'actionbutton':
        case 'menubutton':
          {
            if (this.clickByEnterKey) {
              return;
            }
            item.selected = true;
            break;
          }
        default:
          item.selected = true;
          break;
      }

      log('log', 'Item ' + item + ' selected.');
    },


    /**
     * Exports everything in the current `items` array as Popupmenu-friendly data to be
     * converted to menu items.
     * NOTE: Searchfields and other Action Buttons are ignored
     * @returns {object} containing JSON-friendly Popupmenu data
     */
    toPopupmenuData: function toPopupmenuData() {
      var data = {
        noMenuWrap: true
      };

      var hasIcons = false;

      function getItemData(item) {
        var itemData = item.toPopupmenuData();
        if (itemData && itemData.icon) {
          hasIcons = true;
        }
        return itemData;
      }

      data.menu = this.items.filter(function (item) {
        if (item.type === 'actionbutton' || item.type === 'searchfield') {
          return false;
        }
        return true;
      }).map(function (item) {
        return getItemData(item);
      });

      data.hasIcons = hasIcons;

      return data;
    },


    /**
     * Exports everything in the current `items` array as a Flex Toolbar object structure
     * @returns {object} containing JSON-friendly Flex Toolbar data
     */
    toData: function toData() {
      var data = {};
      data.items = this.items.map(function (item) {
        return item.toData();
      });
      return data;
    },


    get disabled() {
      return this.trueDisabled;
    },

    set disabled(bool) {
      this.trueDisabled = bool;
      if (bool === true) {
        this.element.classList.add('is-disabled');
        return;
      }
      this.element.classList.remove('is-disabled');
    },

    /**
     * @param {object} [settings] incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.teardown();
      this.init();
    },


    /**
     * @returns {void}
     */
    teardown: function teardown() {
      this.element.removeEventListener('keydown', this.keydownListener);
      this.element.removeEventListener('keyup', this.keyupListener);
      this.element.removeEventListener('click', this.clickListener);

      $(this.element).off('selected.' + COMPONENT_NAME$15);

      this.items.forEach(function (item) {
        item.teardown();
      });

      delete this.items;
      delete this.sections;
    },


    /**
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
    }
  };

  /**
   * jQuery component wrapper for Toolbar Flex Component
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.toolbarflex = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$15);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$15, new ToolbarFlex(this, settings));

        // Remove the jQuery Component reference from $.data
        var oldDestroy = instance.destroy;
        instance.destroy = function () {
          if (typeof oldDestroy === 'function') {
            oldDestroy.call(this);
          }
          $.removeData(this, COMPONENT_NAME$15);
        };
      }
    });
  };

  /**
   * jQuery Component Wrapper for Toolbar Searchfield
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.toolbarsearchfield = $.fn.searchfield;

  // Component Name
  var COMPONENT_NAME$16 = 'trackdirty';

  // Default Trackdirty Options
  var TRACKDIRTY_DEFAULTS = {};

  /**
  * Track changes on the inputs passed in the jQuery selector and show a dirty indicator
  * @class Trackdirty
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  */
  function Trackdirty(element, settings) {
    this.settings = utils.mergeSettings(element, settings, TRACKDIRTY_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Trackdirty Methods
  Trackdirty.prototype = {
    init: function init() {
      this.handleEvents();
    },


    /**
     * Get the value or checked if checkbox or radio
     * @private
     * @param {object} element .
     * @param {boolean} isOriginal .
     * @returns {string} element value
     */
    valMethod: function valMethod(element, isOriginal) {
      switch (element.attr('type')) {
        case 'checkbox':
        case 'radio':
          return element.prop('checked');
        case 'file':
          {
            if (typeof isOriginal === 'boolean' && isOriginal) {
              var original = element.attr('original');
              return original !== undefined ? original : '';
            }

            var el = element.parent().find('[type="text"]');
            return el.val();
          }
        default:
          return element.val();
      }
    },


    /**
     * Get absolute position for an element
     * @private
     * @param {object} element .
     * @returns {object} position for given element
     */
    getAbsolutePosition: function getAbsolutePosition(element) {
      var pos = element.position();
      // eslint-disable-next-line
      element.parents().each(function () {
        var el = this;
        if (window.getComputedStyle(el, null).position === 'relative') {
          return false;
        }

        pos.left += el.scrollLeft;
        pos.top += el.scrollTop;
      });

      return { left: pos.left, top: pos.top };
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.element.removeClass('dirty').off('resetdirty.dirty change.dirty doresetdirty.dirty');

      if (this.settings && _typeof(this.settings.d) === 'object') {
        var d = this.settings.d;
        $('.icon-dirty, .msg-dirty', d.field).add(d.icon).add(d.msg).remove();
      }

      $.removeData(this.element[0], 'original');
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, TRACKDIRTY_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$16);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var input = this.element;

      if (input.is('.editor')) {
        var textArea = input.parent().find('textarea');
        textArea.data('original', this.valMethod(textArea));
      }

      input.data('original', this.valMethod(input, true)).on('resetdirty.dirty', function () {
        if (input.is('.editor')) {
          var _textArea = input.parent().find('textarea');
          _textArea.data('original', _this.valMethod(_textArea));
        }

        input.data('original', _this.valMethod(input)).triggerHandler('doresetdirty.dirty');
      }).on('change.dirty doresetdirty.dirty', function (e) {
        var el = input;
        var field = input.closest('.field, .radio-group');
        var label = $('label:visible', field);
        var d = { class: '', style: '' };

        if (field.is('.field-fileupload')) {
          el = field.find('input.fileupload-background-transparent');
        }

        if (field.is('.editor-container')) {
          el = field.find('.editor-source');
        }

        // Used element without .field wrapper
        if (!label[0]) {
          label = input.next('label');
        }
        if (input.attr('data-trackdirty') !== 'true') {
          return;
        }

        // Add class to element
        input.addClass('dirty');

        // Set css class
        if (input.is('[type="checkbox"], [type="radio"]')) {
          d.class += ' dirty-' + input.attr('type');
          d.class += input.is(':checked') ? ' is-checked' : '';
        }
        if (input.is('select')) {
          d.class += ' is-select';
          el = input.next('.dropdown-wrapper').find('.dropdown');
        }

        // Add class and icon
        d.icon = el.prev();
        if (!d.icon.is('.icon-dirty')) {
          if (input.is('[type="checkbox"]')) {
            d.rect = _this.getAbsolutePosition(label);
            d.style = 'left:' + d.rect.left + 'px; top:' + d.rect.top + 'px;';
          } else if (input.is('.colorpicker') && !Locale.isRTL()) {
            d.rect = _this.getAbsolutePosition(input);
            d.style = 'left:' + d.rect.left + 'px; top:' + d.rect.top + 'px;';
          }
          d.icon = '<span class="icon-dirty' + d.class + '"></span>';
          d.msg = Locale.translate('MsgDirty') || '';
          d.msg = '<span class="audible msg-dirty">' + d.msg + '</span>';

          // Add icon and msg
          var firstInput = $($(el[0].parentElement).find('input')[0]);
          el = input.is('[type="radio"]') ? firstInput : el;

          if ($(el[0].parentElement).find('.icon-dirty').length === 0) {
            el.before(d.icon);
            label.append(d.msg);

            if (d.style && el.prev('.icon-dirty')[0]) {
              el.prev('.icon-dirty')[0].style.cssText = d.style;
            }
          }

          // Cache icon and msg
          d.icon = el.prev();
          d.msg = label.find('.msg-dirty');
        }

        // Handle resetting value back
        var original = input.data('original');
        var current = _this.valMethod(input);

        d.field = field;
        _this.settings.d = d;

        if (field.is('.editor-container')) {
          // editors values are further down it's tree in a textarea,
          // so get the elements with the value
          var _textArea2 = field.find('textarea');
          original = _textArea2.data('original');
          current = _this.valMethod(_textArea2);
        }

        if (current === original || input.attr('multiple') && utils.equals(current, original)) {
          input.removeClass('dirty');
          $('.icon-dirty, .msg-dirty', field).add(d.icon).add(d.msg).remove();
          input.trigger(e.type === 'doresetdirty' ? 'afterresetdirty' : 'pristine');
          return;
        }

        /**
        * Fires when an inout becomes dirty.
        * @event resetdirty
        * @memberof Trackdirty
        * @property {object} event - The jquery event object
        */
        input.trigger('dirty');
      });
    }
  };

  /**
   * jQuery Component Wrapper for TrackDirty
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.trackdirty = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$16);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$16, new Trackdirty(this, settings));
      }
    });
  };

  // The name of this component.
  var COMPONENT_NAME$17 = 'tree';

  // The Component Defaults.
  var TREE_DEFAULTS = {
    selectable: 'single', // ['single'|'multiple']
    hideCheckboxes: false, // [true|false] -apply only with [selectable: 'multiple']
    menuId: null, // Context Menu to add to nodes
    useStepUI: false, // When using the UI as a stepped tree
    folderIconOpen: 'open-folder',
    folderIconClosed: 'closed-folder',
    sortable: false, // Allow nodes to be sortable
    onBeforeSelect: null,
    onExpand: null,
    onCollapse: null,
    originalEnablementState: null
  };

  /**
  * The tree Component displays a hierarchical list.
  * @class Tree
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [settings.selectable = 'single'] 'single' or 'multiple'.
  * @param {boolean} [settings.hideCheckboxes = false] Only applies when `selectable` is set to 'multiple'.
  * @param {null|string} [settings.menuId] if defined, will be used to identify a Context Menu by ID attribute in which to add nodes.
  * @param {boolean} [settings.useStepUI = false] if `true`, turns this tree instance into a "Stepped" tree.
  * @param {string} [settings.folderIconOpen = 'open-folder']  the icon used when a tree folder node is open.
  * @param {string} [settings.folderIconClosed = 'closed-folder'] the icon used when a tree folder node is closed.
  * @param {boolean} [settings.sortable = false] if `true`, allows nodes to become sortable.
  * @param {null|function} [settings.onBeforeSelect] If defined as a function, fires that function as a callback before the selection on a node occurs.
  * @param {null|function} [settings.onExpand] If defined as a function, fires that function as a node is expanded.
  * @param {null|function} [settings.onCollapse] If defined as a function, fires that function as a node is collapsed.
  */
  function Tree(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, TREE_DEFAULTS);
    this.init();
  }

  // Tree Methods
  Tree.prototype = {

    /**
     * @private
     * @returns {undefined}
     */
    init: function init() {
      this.isIe11 = Environment.browser.name === 'ie' && Environment.browser.version === '11';
      this.initTree();
      this.handleKeys();
      this.setupEvents();

      if (this.loadData(this.settings.dataset) === -1) {
        this.syncDataset();
        this.initSelected();
        this.focusFirst();
        this.attachMenu(this.settings.menuId);
        this.createSortable();
      }
    },


    /**
     * Init Tree from ul, li, a markup structure in DOM
     * @private
    */
    initTree: function initTree() {
      var self = this;
      var s = this.settings;
      var links = this.element.find('a');
      var selectableAttr = this.element.attr('data-selectable');

      // Set attribute "data-selectable"
      s.selectable = typeof selectableAttr !== 'undefined' && (selectableAttr.toLowerCase() === 'single' || selectableAttr.toLowerCase() === 'multiple') ? selectableAttr : s.selectable;

      // Set isMultiselect and checkboxes show/hide
      this.isMultiselect = s.selectable === 'multiple';
      s.hideCheckboxes = s.hideCheckboxes || !this.isMultiselect;

      this.element.addClass(this.isMultiselect ? ' is-multiselect' : '');

      links.each(function () {
        var a = $(this);
        self.decorateNode(a);
      });
    },


    /**
     * Init selected notes
     * @private
    */
    initSelected: function initSelected() {
      var _this = this;

      var listItems = [].slice.call(this.element[0].querySelectorAll('li'));
      listItems.forEach(function (li) {
        return _this.setNodeStatus($(li.querySelector('a')));
      });
    },


    /**
     * Focus the first tree node
     * @private
     */
    focusFirst: function focusFirst() {
      var a = this.element[0].querySelector('a');
      if (a) {
        a.setAttribute('tabindex', '0');
      }
    },


    /**
     * Set focus
     * @private
     * @param {object} node .
     * @returns {void}
     */
    setFocus: function setFocus(node) {
      node = this.isjQuery(node) ? node[0] : node;
      if (!node) {
        return;
      }
      node.focus();
      node.classList.remove('hide-focus');
    },


    /**
     * From the LI, Read props and add stuff
     * @private
     * @param {object} a an anchor tag reference wrapped in a jQuery object.
     * @returns {void}
     */
    decorateNode: function decorateNode(a) {
      a = this.isjQuery(a) ? a : $(a);

      var parentCount = 0;
      var badgeData = a[0].getAttribute('data-badge');
      var alertIcon = a[0].getAttribute('data-alert-icon');
      var isParentsDisabled = a.parentsUntil(this.element, 'ul[role=group].is-disabled').length > 0;
      var isDisabled = a[0].classList.contains('is-disabled') || isParentsDisabled;

      if (typeof badgeData !== 'undefined') {
        badgeData = utils.parseSettings(a, 'data-badge');
      }

      // Set initial 'role', 'tabindex', and 'aria selected' on each link (except the first)
      a[0].setAttribute('role', 'treeitem');
      a[0].setAttribute('tabindex', '-1');
      a[0].setAttribute('aria-selected', 'false');

      // Add Aria disabled
      if (isDisabled) {
        a[0].classList.add('is-disabled');
        a[0].setAttribute('aria-disabled', 'true');
        var childSection = a.next();

        if (childSection[0] && childSection[0].tagName.toLowerCase() === 'ul' && childSection[0].classList.contains('is-open')) {
          var childLinks = [].slice.call(childSection[0].querySelectorAll('a'));
          childLinks.forEach(function (link) {
            link.classList.add('is-disabled');
            link.setAttribute('aria-disabled', 'true');
          });
          var parentUls = [].slice.call(a[0].parentNode.querySelectorAll('ul'));
          parentUls.forEach(function (ul) {
            return ul.classList.add('is-disabled');
          });
        }
      }

      // ParentCount 'aria-level' to the node's level depth
      parentCount = a.parentsUntil(this.element, 'ul').length - 1;
      a[0].setAttribute('aria-level', parentCount + 1);

      // Set the current tree item node position relative to its aria-setsize
      var posinset = a.parent().index();
      a[0].setAttribute('aria-posinset', posinset + 1);

      // Set the current tree item aria-setsize
      var listCount = a.closest('li').siblings().length + 1;
      a[0].setAttribute('aria-setsize', listCount);

      // Set the current tree item node expansion state
      var subNode = a.next('ul');
      if (subNode[0] && subNode.children().length > 0) {
        a[0].setAttribute('aria-expanded', subNode[0].classList.contains('is-open') ? 'true' : 'false');
      }

      // Inject Icons
      var text = a.contents().filter(function () {
        return !$(this).is('.tree-badge'); // Do not include badge text
      }).text();

      a[0].textContent = '';
      if (a.children('svg.icon-tree').length === 0) {
        a[0].insertAdjacentHTML('afterbegin', $.createIcon({ icon: 'tree-node', classes: ['icon-tree'] }));

        if (this.settings.useStepUI) {
          a[0].insertAdjacentHTML('afterbegin', $.createIcon({ icon: alertIcon, classes: ['step-alert', 'icon-' + alertIcon] }));
        }
      }

      // Inject checkbox
      if (this.isMultiselect && !this.settings.hideCheckboxes) {
        a[0].insertAdjacentHTML('beforeend', '<span class="tree-checkbox"></span>');
      }

      // Inject badge
      var badgeHtml = this.getBadgeHtml(badgeData);
      if (badgeHtml !== '') {
        a[0].insertAdjacentHTML('beforeend', badgeHtml);
      }

      var span = document.createElement('span');
      span.classList.add('tree-text');
      span.textContent = text;
      a[0].appendChild(span);

      if (this.hasIconClass(a)) {
        // CreateIconPath
        this.setTreeIcon(a.find('svg.icon-tree'), a[0].getAttribute('class'));
      }

      // Adds role=group' to all subnodes
      if (subNode[0] && subNode[0].tagName.toLowerCase() === 'ul') {
        var aClass = a[0].getAttribute('class');
        subNode[0].setAttribute('role', 'group');
        subNode[0].parentNode.classList.add('folder');
        this.setTreeIcon(a.find('svg.icon-tree'), subNode[0].classList.contains('is-open') ? this.settings.folderIconOpen : this.settings.folderIconClosed);

        if (aClass && aClass.indexOf('open') === -1 && aClass.indexOf('closed') === -1) {
          a[0].setAttribute('class', isDisabled ? 'is-disabled' : '');
          this.setTreeIcon(a.find('svg.icon-tree'), subNode[0].classList.contains('is-open') ? this.settings.folderIconOpen : this.settings.folderIconClosed);
        }

        if (this.hasIconClass(a)) {
          aClass = a[0].getAttribute('class');
          this.setTreeIcon(a.find('svg.icon-tree'), subNode[0].classList.contains('is-open') ? aClass : aClass.replace('open', 'closed'));
        }
      }

      a.hideFocus();
    },


    /**
     * Sets the correct icon to use on a particular SVG element.
     * @private
     * @param {object} svg an SVG element reference wrapped in a jQuery object
     * @param {string} icon the ID of a Soho Icon type.
     * @returns {void}
     */
    setTreeIcon: function setTreeIcon(svg, icon) {
      if (!svg || typeof icon !== 'string') {
        return;
      }
      svg = this.isjQuery(svg) ? svg : $(svg);
      // Replace all "icon-", "hide-focus", "\s? - all spaces if any" with nothing
      var iconStr = icon.replace(/#?icon-|hide-focus|\s?/gi, '');
      svg.changeIcon(iconStr);
    },


    /**
     * Expands a collection of tree nodes.
     * @param {object} nodes - a jQuery-wrapped collection of tree node elements.
     If left undefined, this will automatically use all `ul[role=group]` elements.
     * @returns {void}
     */
    expandAll: function expandAll(nodes) {
      var self = this;
      nodes = nodes || this.element.find('ul[role=group]');

      nodes.each(function () {
        var node = $(this);
        node.addClass('is-open');
        self.setTreeIcon(node.prev('a').find('svg.icon-tree'), self.settings.folderIconOpen);

        if (self.hasIconClass(node.prev('a'))) {
          self.setTreeIcon(node.prev('svg.icon-tree'), node.prev('a').attr('class'));
        }
      });
    },


    /**
     * Collapses a collection of tree nodes.
     * @param {object} nodes - a jQuery-wrapped collection of tree node elements.
     If left undefined, this will automatically use all `ul[role=group]` elements.
     * @returns {void}
     */
    collapseAll: function collapseAll(nodes) {
      var self = this;
      nodes = nodes || this.element.find('ul[role=group]');

      nodes.each(function () {
        var node = $(this);
        node.removeClass('is-open');
        self.setTreeIcon(node.prev('a').find('svg.icon-tree'), self.settings.folderIconClosed);

        if (self.hasIconClass(node.prev('a'))) {
          self.setTreeIcon(node.prev('a').find('svg.icon-tree'), node.prev('a').attr('class').replace('open', 'closed').replace(/\s?is-selected/, ''));
        }

        if (self.hasIconClass(node.prev('a'))) {
          self.setTreeIcon(node.prev('svg.icon-tree'), node.prev('a').attr('class').replace('open', 'closed'));
        }
      });
    },


    /**
     * Check if an object is an instance of a jQuery object
     * @private
     * @param {object} obj the object being tested.
     * @returns {boolean} true if jQuery
     */
    isjQuery: function isjQuery(obj) {
      // TODO: Move this to a Soho utility object?
      return obj && (obj instanceof jQuery || obj.constructor.prototype.jquery);
    },


    /**
     * Selects a tree node specifically using it's ID attribute.
     * @param {string} id - the ID string to use.
     * @returns {void}
     */
    selectNodeById: function selectNodeById(id) {
      this.selectNodeByJquerySelector('#' + id);
    },


    /**
     * Selects a tree node by [jquery selector] -or- [jquery object]
     * @private
     * @param {object} selector uses a string that represents a jQuery-wrapped
     element's ID attribute, or a jQuery-wrapped reference to the element itself.
     * @returns {void}
     */
    selectNodeByJquerySelector: function selectNodeByJquerySelector(selector) {
      var target = this.isjQuery(selector) ? selector : $(selector);
      if (target.length && !target.is('.is-disabled')) {
        var nodes = target.parentsUntil(this.element, 'ul[role=group]');
        this.expandAll(nodes);
        this.selectNode(target, true);
      }
    },


    /**
     * Deselects a tree node
     * @private
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @param {boolean} focus - if defined, causes the node to become focused.
     * @returns {void}
     */
    unSelectedNode: function unSelectedNode(node, focus) {
      if (node.length === 0) {
        return;
      }

      var self = this;
      var aTags = $('a', this.element);

      aTags.attr('tabindex', '-1');
      node.attr('tabindex', '0');

      $('a:not(.is-disabled)', node.parent()).attr('aria-selected', 'false').parent().removeClass('is-selected');

      this.syncNode(node);
      this.setNodeStatus(node);

      if (focus) {
        node.focus();
      }

      // Set active css class
      var listItems = [].slice.call(this.element[0].querySelectorAll('li'));
      listItems.forEach(function (li) {
        return li.classList.remove('is-active');
      });
      node[0].parentNode.classList.add('is-active');

      setTimeout(function () {
        var jsonData = node.data('jsonData') || {};
        /**
        * Fires when the node is deselected.
        * @memberof Tree
        * @event unselected
        * @type {object}
        * @property {object} event - The jquery event object
        * @property {object} args for node element, item
        * @property {HTMLElement} args.node The DOM Element.
        * @property {HTMLElement} args.data The JSON data attached to the node.
        */
        self.element.triggerHandler('unselected', { node: node, data: jsonData });
      }, 0);
    },


    /**
     * Selects a tree node
     * @private
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @param {boolean} focus - if defined, causes the node to become focused.
     * @returns {void}
     */
    selectNode: function selectNode(node, focus) {
      var self = this;
      var s = this.settings;

      if (node.length === 0) {
        return;
      }

      // Possibly Call the onBeforeSelect
      var result = void 0;
      if (typeof s.onBeforeSelect === 'function') {
        result = s.onBeforeSelect(node);
        if (result && result.done && typeof result.done === 'function') {
          // A promise is returned
          result.done(function (continueSelectNode) {
            if (continueSelectNode) {
              self.selectNodeFinish(node, focus);
            }
          });
        } else if (result) {
          // Boolean is returned instead of a promise
          self.selectNodeFinish(node, focus);
        }
      } else {
        // No Callback specified
        self.selectNodeFinish(node, focus);
      }
    },


    /**
     * Select the node when finished
     * @private
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @param {boolean} focus - if defined, causes the node to become focused.
     * @param {object} e - jquery event.
     * @returns {void}
     */
    selectNodeFinish: function selectNodeFinish(node, focus, e) {
      // Don't do selection for toggle type only
      if (this.isMultiselect && e) {
        if (e.type === 'click' || e.type === 'touch') {
          if (e.target.classList.contains('icon') && node[0].parentNode.classList.contains('folder')) {
            return;
          }
        } else if (e.type === 'keydown') {
          var charCode = e.charCode || e.keyCode;
          if (charCode === 37 || charCode === 39) {
            return;
          }
        }
      }

      var self = this;
      var links = [].slice.call(this.element[0].querySelectorAll('a'));
      links.forEach(function (a) {
        return a.setAttribute('tabindex', '-1');
      });
      node[0].setAttribute('tabindex', '0');

      if (this.isMultiselect) {
        var links2 = [].slice.call(node[0].parentNode.querySelectorAll('a:not(.is-disabled)'));
        links2.forEach(function (a) {
          a.setAttribute('aria-selected', 'true');
          a.classList.add('is-selected');
          a.parentNode.classList.add('is-selected');
        });
      } else {
        links.forEach(function (a) {
          a.setAttribute('aria-selected', 'false');
          a.classList.remove('is-selected');
          a.parentNode.classList.remove('is-selected');
        });
        node[0].setAttribute('aria-selected', 'true');
        node[0].classList.add('is-selected');
        node[0].parentNode.classList.add('is-selected');
      }

      this.syncNode(node);
      if (!this.loading) {
        this.setNodeStatus(node);
      }

      if (focus) {
        node.focus();
      }

      // Set active css class
      var listItems = [].slice.call(this.element[0].querySelectorAll('li'));
      listItems.forEach(function (li) {
        return li.classList.remove('is-active');
      });
      node[0].parentNode.classList.add('is-active');

      setTimeout(function () {
        var jsonData = node.data('jsonData') || {};
        /**
         * Fires when the node is selected.
         * @memberof Tree
         * @event unselected
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} args for node element, item
         * @property {HTMLElement} args.node The DOM Element.
         * @property {HTMLElement} args.data The JSON data attached to the node.
         */
        self.element.triggerHandler('selected', { node: node, data: jsonData });
      }, 0);
    },


    /**
     * Set current node status
     * @private
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @returns {void}
     */
    setNodeStatus: function setNodeStatus(node) {
      var self = this;
      var data = node.data('jsonData');
      var nodes = void 0;

      // Not multiselect
      if (!this.isMultiselect) {
        var a = node[0];
        var li = a.parentNode;
        if (data && data.selected) {
          li.classList.add('is-selected');
          a.classList.add('is-selected');
          a.setAttribute('aria-selected', true);
        } else {
          li.classList.remove('is-selected', 'is-partial');
          a.classList.remove('is-selected', 'is-partial');
          a.setAttribute('aria-selected', false);
        }
        return;
      }

      var setStatus = function setStatus(thisNodes, isFirstSkipped) {
        thisNodes.forEach(function (li) {
          var a = $(li.querySelector('a'));
          var status = self.getSelectedStatus(a, isFirstSkipped);

          if (status === 'mixed') {
            li.classList.remove('is-selected', 'is-partial');
            li.classList.add('is-partial');
          } else if (status) {
            li.classList.remove('is-selected', 'is-partial');
            li.classList.add('is-selected');
          } else {
            li.classList.remove('is-selected', 'is-partial');
          }
          self.syncNode(a);
        });
      };

      // Multiselect
      var isFirstSkipped = false;
      nodes = [].slice.call(node[0].parentNode.querySelectorAll('li.folder'));
      setStatus(nodes, isFirstSkipped);

      isFirstSkipped = !(!nodes.length && data && !data.selected);
      nodes = node.parentsUntil(this.element, 'li.folder');
      nodes = [].slice.call(nodes.toArray());
      setStatus(nodes, isFirstSkipped);
    },


    /**
     * Get's a tree node's current 'selected' status
     * @private
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @param {boolean} isFirstSkipped - ?
     * @returns {boolean} status as true|false|'mixed'
     */
    getSelectedStatus: function getSelectedStatus(node, isFirstSkipped) {
      var total = 0;
      var selected = 0;
      var unselected = 0;
      var data = void 0;

      node.parent().find('a').each(function (i) {
        if (isFirstSkipped && i === 0) {
          return;
        }
        total++;
        data = $(this).data('jsonData');
        if (data && data.selected) {
          selected++;
        } else {
          unselected++;
        }
      });

      var status = void 0;
      if (total === selected) {
        status = true;
      } else if (total === unselected) {
        status = false;
      } else {
        status = 'mixed';
      }
      return status;
    },


    /**
     * Changes a node's open/close status to its opposite form.
     * @private
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @param {object} e jquery event
     * @returns {void}
     */
    toggleNode: function toggleNode(node, e) {
      var next = node.next();
      var self = this;
      var s = this.settings;
      var result = void 0;
      if (next[0] && next[0].tagName.toLowerCase() === 'ul' && next[0].getAttribute('role') === 'group') {
        if (next[0].classList.contains('is-open')) {
          if (typeof s.onCollapse === 'function') {
            result = s.onCollapse(node);
            if (result && result.done && typeof result.done === 'function') {
              // A promise is returned
              result.done(function (continueSelectNode) {
                if (continueSelectNode) {
                  self.selectNodeFinish(node, focus, e);
                }
              });
            } else if (result) {
              // Boolean is returned instead of a promise
              self.selectNodeFinish(node, focus, e);
            }
          } else {
            // No Callback specified
            self.selectNodeFinish(node, focus, e);
          }

          self.setTreeIcon(node.closest('.folder').removeClass('is-open').end().find('svg.icon-tree'), s.folderIconClosed);

          if (self.hasIconClass(node.closest('.folder a'))) {
            self.setTreeIcon(node.closest('.folder a').find('svg.icon-tree'), node.closest('.folder a').attr('class').replace('open', 'closed').replace(/\s?is-selected/, ''));
          }

          self.isAnimating = true;

          if (!self.isMultiselect) {
            self.unSelectedNode(node.parent().find('li.is-selected'), false);
            node[0].classList.remove('is-selected');
          }

          next.one('animateclosedcomplete', function () {
            next[0].classList.remove('is-open');
            self.isAnimating = false;
          }).animateClosed();

          node[0].setAttribute('aria-expanded', node[0].getAttribute('aria-expanded') !== 'true');
        } else {
          if (typeof s.onExpand === 'function') {
            result = s.onExpand(node);
            if (result && result.done && typeof result.done === 'function') {
              // A promise is returned
              result.done(function (continueSelectNode) {
                if (continueSelectNode) {
                  self.selectNodeFinish(node, focus, e);
                }
              });
            } else if (result) {
              // Boolean is returned instead of a promise
              self.selectNodeFinish(node, focus, e);
            }
          } else {
            // No Callback specified
            self.selectNodeFinish(node, focus, e);
          }

          var nodeData = node.data('jsonData');

          if (s.source && nodeData.children && nodeData.children.length === 0) {
            var response = function response(nodes) {
              var id = nodeData.id;
              var elem = self.findById(id);

              // Add DB and UI nodes
              elem.children = nodes;
              self.addChildNodes(elem, node.parent());
              node[0].classList.remove('is-loading');
              self.loading = false;

              // Open
              self.accessNode(next, node);

              // Sync data on node
              nodeData.children = nodes;
              node.data('jsonData', nodeData);
              self.selectNode(node, true);
              self.initSelected();
            };

            var args = { node: node, data: node.data('jsonData') };
            node[0].classList.add('is-loading');
            self.loading = true;
            self.settings.source(args, response);

            return;
          }
          self.accessNode(next, node);
        }
      }
    },


    /**
     * Access The Node
     * @private
     * @param  {object} next The next element.
     * @param  {object} node The DOM element.
     */
    accessNode: function accessNode(next, node) {
      var _this2 = this;

      var nodeClass = node.attr('class');

      this.setTreeIcon(node.closest('.folder').addClass('is-open').end().find('svg.icon-tree'), this.settings.folderIconOpen);

      if (this.hasIconClass(nodeClass)) {
        this.setTreeIcon(node.find('svg.icon-tree'), nodeClass.replace('is-selected', ''));
      }

      this.isAnimating = true;

      next.one('animateopencomplete', function () {
        _this2.isAnimating = false;
      }).addClass('is-open').css('height', 0).animateOpen();
      node[0].setAttribute('aria-expanded', node[0].getAttribute('aria-expanded') !== 'true');
    },


    /**
     * Open The Node
     * @private
     * @param  {object} nextTarget The next tree element
     * @param  {object} nodeTarget The DOM element to open.
     */
    openNode: function openNode(nextTarget, nodeTarget) {
      var self = this;
      var nodeData = nodeTarget.data('jsonData');

      if (self.settings.source && nodeData.children && nodeData.children.length === 0) {
        var response = function response(nodes) {
          var id = nodeData.id;
          var elem = self.findById(id);

          // Add DB and UI nodes
          elem.children = nodes;
          self.addChildNodes(elem, nodeTarget.parent());
          nodeTarget.removeClass('is-loading');
          self.loading = false;

          // Open
          self.accessNode(nextTarget, nodeTarget);

          // Sync data on node
          nodeData.children = nodes;
          nodeTarget.data('jsonData', nodeData);
          self.selectNode(nodeTarget, true);
          self.initSelected();
        };

        var args = { node: nodeTarget, data: nodeTarget.data('jsonData') };
        nodeTarget.addClass('is-loading');
        self.loading = true;
        self.settings.source(args, response);

        return;
      }
      self.accessNode(nextTarget, nodeTarget);
    },


    /**
     * Check if given value has icon class
     * @private
     * @param  {string|object} elemClass class or element has icon class
     * @returns  {boolean} true if has icon.
     */
    hasIconClass: function hasIconClass(elemClass) {
      if (typeof elemClass !== 'string') {
        if (this.isjQuery(elemClass)) {
          elemClass = elemClass.length > 1 ? elemClass.first()[0] : elemClass[0];
        }
        elemClass = elemClass.getAttribute('class');
      }
      return elemClass && elemClass.indexOf('icon') > -1;
    },


    /**
     * Close The Node
     * @private
     * @param  {object} nextTarget The next tree element
     * @param  {object} nodeTarget The DOM element to open.
     */
    closeNode: function closeNode(nextTarget, nodeTarget) {
      var self = this;
      self.setTreeIcon(nodeTarget.closest('.folder').removeClass('is-open').end().find('svg.icon-tree'), self.settings.folderIconClosed);

      if (self.hasIconClass(nodeTarget.closest('.folder a'))) {
        self.setTreeIcon(nodeTarget.closest('.folder a').find('svg.icon-tree'), nodeTarget.closest('.folder a').attr('class').replace('open', 'closed').replace(/\s?is-selected/, ''));
      }

      self.isAnimating = true;

      if (!self.isMultiselect) {
        self.unSelectedNode(nodeTarget.parent().find('li.is-selected'), false);
        nodeTarget.removeClass('is-selected');
      }

      nextTarget.one('animateclosedcomplete', function () {
        nextTarget.removeClass('is-open');
        self.isAnimating = false;
      }).animateClosed();

      nodeTarget.attr('aria-expanded', nodeTarget.attr('aria-expanded') !== 'true');
    },


    // Setup event handlers
    setupEvents: function setupEvents() {
      var self = this;
      self.element.on('updated.tree', function (e, newSettings) {
        self.updated(newSettings);
        self.initTree();
      });
    },


    // Handle Keyboard Navigation
    handleKeys: function handleKeys() {
      // Key Behavior as per: http://access.aol.com/dhtml-style-guide-working-group/#treeview
      var self = this;
      // On click give clicked element 0 tabindex and 'aria-selected=true', resets all other links
      this.element.on('click.tree', 'a:not(.is-clone)', function (e) {
        var target = $(this);
        var parent = this.parentNode;
        if (!target[0].classList.contains('is-disabled') && !target[0].classList.contains('is-loading')) {
          if (self.isMultiselect) {
            if (e.target.classList.contains('icon') && parent.classList.contains('folder')) {
              self.toggleNode(target, e);
            } else if (parent.classList.contains('is-selected') || parent.classList.contains('is-partial')) {
              self.unSelectedNode(target, true);
            } else {
              self.selectNode(target, true);
            }
          } else {
            self.selectNode(target, true);
            self.toggleNode(target, e);
          }
          e.stopPropagation();
        }

        if (self.popupEl && self.popupEl.data('popupmenu')) {
          self.popupEl.data('popupmenu').close();
          self.popupEl = null;
        }

        return false; // Prevent Click from Going to Top
      });

      this.element
      // Focus on "a" elements
      .on('focus.tree', 'a', function () {
        if (parseInt(this.getAttribute('aria-level'), 10) === 0 && parseInt(this.getAttribute('aria-posinset'), 10) === 1) {
          // First element if disabled
          if (this.classList.contains('is-disabled')) {
            var e = $.Event('keydown.tree');
            e.keyCode = 40; // move down
            $(this).trigger(e);
            return; // eslint-disable-line
          }
        }
      });

      // Handle Up/Down Arrow Keys and Space
      this.element.on('keydown.tree', 'a', function (e) {
        var charCode = e.charCode || e.keyCode;
        var target = $(this);
        var next = void 0;
        var prev = void 0;

        if (self.isAnimating) {
          return;
        }

        // Down arrow
        if (charCode === 40) {
          var nextNode = self.getNextNode(target);
          self.setFocus(nextNode);
        }

        // Up arrow,
        if (charCode === 38) {
          var prevNode = self.getPreviousNode(target);
          self.setFocus(prevNode);
        }

        // Space
        if (e.keyCode === 32) {
          target.trigger('click.tree');
        }

        // Left arrow
        if (charCode === 37) {
          if (Locale.isRTL()) {
            if (target.next().hasClass('is-open')) {
              prev = target.next().find('a:first');
              self.setFocus(prev);
            } else {
              self.toggleNode(target, e);
            }
          } else if (target.next().hasClass('is-open')) {
            self.toggleNode(target, e);
          } else {
            prev = target.closest('.folder').find('a:first');
            self.setFocus(prev);
          }
          e.stopPropagation();
          return false; // eslint-disable-line
        }

        // Right arrow
        if (charCode === 39) {
          if (Locale.isRTL()) {
            if (target.next().hasClass('is-open')) {
              self.toggleNode(target, e);
            } else {
              next = target.closest('.folder').find('a:first');
              self.setFocus(next);
            }
          } else if (target.next().hasClass('is-open')) {
            next = target.next().find('a:first');
            self.setFocus(next);
          } else {
            self.toggleNode(target, e);
            self.setFocus(target);
          }
          e.stopPropagation();
          return false; // eslint-disable-line
        }

        // Home  (fn-right on mac)
        if (charCode === 36) {
          next = self.element.find('a:first:visible');
          self.setFocus(next);
        }

        // End (fn-right on mac)
        if (charCode === 35) {
          next = self.element.find('a:last:visible');
          self.setFocus(next);
        }
      });

      // Handle Left/Right Arrow Keys
      // eslint-disable-next-line
      this.element.on('keypress.tree', 'a', function (e) {
        var charCode = e.charCode || e.keyCode;
        var target = $(this);

        if (charCode >= 37 && charCode <= 40 || charCode === 32) {
          e.stopPropagation();
          return false;
        }

        // Printable Chars Jump to first high level node with it...
        if (e.which !== 0) {
          // eslint-disable-next-line
          target.closest('li').nextAll().find('a:visible').each(function () {
            var node = $(this);
            var first = node.text().substr(0, 1).toLowerCase();
            var term = String.fromCharCode(e.which).toLowerCase();

            if (first === term) {
              self.setFocus(node);
              return false;
            }
          });
        }
      });
    },


    /**
     * Handle Loading JSON.
     * @param {object} dataset to load.
     * @returns {void}
     */
    loadData: function loadData(dataset) {
      // eslint-disable-line
      if (!dataset) {
        return -1;
      }
      var self = this;
      self.element.empty();

      self.loading = true;
      dataset = this.arrangeDataset(dataset);
      var html = '';
      self.jsonData = [];
      for (var i = 0, l = dataset.length; i < l; i++) {
        html += self.getNodeHtml(dataset[i], i);
      }
      self.element[0].insertAdjacentHTML('beforeend', html);
      var nodes = [].slice.call(self.element[0].querySelectorAll('a[role="treeitem"]'));
      nodes.forEach(function (node, i) {
        var a = $(node);
        var data = self.jsonData[i];
        a.data('jsonData', data);
        if (data.selected) {
          self.selectNode(a, data.focus);
        }
      });
      self.jsonData = undefined;
      self.loading = false;

      self.syncDataset();
      self.initSelected();
      self.focusFirst();
      self.attachMenu(self.settings.menuId);
      self.createSortable();
    },


    /**
     * Rearrange the given or default dataset. if dataset use `parent` key to arrange nodes
     * @private
     * @param {object} dataset a data object.
     * @returns {object} arranged data object
     */
    arrangeDataset: function arrangeDataset(dataset) {
      if (!this.hasKeyInData('parent', dataset)) {
        return dataset;
      }

      dataset = dataset || this.settings.dataset;
      var arrangedData = JSON.parse(JSON.stringify(dataset));

      // Add given node to parent
      var addToParent = function addToParent(node) {
        var arranged = false;
        // Add child to given parent
        var addChild = function addChild(parent) {
          parent.children = parent.children || [];
          parent.children.push(node);
          arranged = true;
        };

        // Traverse in given data and arrange it
        var arrange = function arrange(data) {
          for (var i = 0; i < data.length && !arranged; i++) {
            if (data[i].id === node.parent) {
              addChild(data[i]);
            }
            if (typeof data[i].children !== 'undefined') {
              arrange(data[i].children);
            }
          }
        };
        arrange(arrangedData);
      };

      // Traverse in given data and add to parent
      var traverse = function traverse(data) {
        for (var i = 0; i < data.length; i++) {
          if (typeof data[i].parent !== 'undefined') {
            addToParent(data[i]);
          }
          if (typeof data[i].children !== 'undefined') {
            traverse(data[i].children);
          }
        }
      };
      traverse(dataset);

      // Clean old nodes with parent key
      var clean = function clean(data, id) {
        for (var i = 0; i < data.length; i++) {
          if (typeof data[i].children !== 'undefined') {
            clean(data[i].children, data[i].id);
          }
          if (typeof id === 'undefined' && typeof data[i].parent !== 'undefined' || typeof id !== 'undefined' && typeof data[i].parent !== 'undefined' && id !== data[i].parent) {
            data.splice(i, 1);
            i--;
          } else {
            delete data[i].parent;
          }
        }
      };
      clean(arrangedData);

      // Set and return the arranged data
      this.settings.dataset = arrangedData;
      return arrangedData;
    },


    /**
     * Check if given key is exists in dataset.
     * @private
     * @param {string} key to check.
     * @param {object} data to check in.
     * @returns {boolean} true if key found
     */
    hasKeyInData: function hasKeyInData(key, data) {
      var found = false;
      data = data || this.settings.dataset;

      /* eslint-disable no-restricted-syntax */
      var findkey = function findkey(obj) {
        for (var prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            // eslint-disable-line
            var value = obj[prop];
            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && !found) {
              findkey(value);
            } else if (key === prop) {
              found = true;
            }
            if (found) {
              break;
            }
          }
        }
      };
      /* eslint-enable no-restricted-syntax */

      for (var i = 0, l = data.length; i < l; i++) {
        if (found) {
          break;
        }
        findkey(data[i]);
      }
      return found;
    },


    /**
     * Create html for given json data.
     * @private
     * @param {object} data to do html.
     * @param {number} position for node.
     * @param {number} level for node.
     * @param {boolean} isParentsDisabled for node.
     * @returns {string} created html
     */
    getNodeHtml: function getNodeHtml(data, position, level, isParentsDisabled) {
      level = level || 0;
      position += 1;
      var s = this.settings;
      var isDisabled = isParentsDisabled || data.disabled || false;
      var a = {
        id: typeof data.id !== 'undefined' ? ' id="' + data.id + '"' : '',
        href: ' href="' + (typeof data.href !== 'undefined' ? data.href : '#') + '"',
        expanded: ' aria-expanded="' + (data.open ? 'true' : 'false') + '"',
        icon: 'tree-node',
        alertIcon: '',
        alertIconAttr: typeof data.alertIcon !== 'undefined' ? ' data-alert-icon="' + data.alertIcon + '"' : '',
        text: '<span class="tree-text">' + data.text + '</span>',
        class: ['hide-focus'],
        ariaDisabled: isDisabled ? 'aria-disabled="true"' : '',
        checkbox: this.isMultiselect && !this.settings.hideCheckboxes ? '<span class="tree-checkbox"></span>' : '',
        badge: _typeof(data.badge) === 'object' ? this.getBadgeHtml(data.badge) : ''
      };
      this.jsonData.push(data);

      if (s.useStepUI) {
        a.alertIcon = '<svg class="icon step-alert icon-' + data.alertIcon + '" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-' + data.alertIcon + '"></use>';
      }

      var isChildren = typeof data.children !== 'undefined';
      var liClassList = isChildren ? 'folder' : '';
      liClassList += data.selected ? ' is-selected' : '';
      if (liClassList !== '') {
        liClassList += data.open ? ' is-open' : '';
        liClassList = ' class="' + liClassList + '"';
      }
      if (isDisabled) {
        a.class.push('is-disabled');
      }
      if (data.icon) {
        a.icon = data.icon;
        if (!isChildren || isChildren && /open|closed/i.test(data.icon)) {
          a.class.push(data.icon);
        }
      }
      if (isChildren) {
        if (data.open) {
          a.icon = data.icon && /open|closed/i.test(data.icon) ? data.icon : s.folderIconOpen;
          isParentsDisabled = isDisabled;
        } else {
          a.icon = data.icon && /open|closed/i.test(data.icon) ? data.icon.replace('open', 'closed') : s.folderIconClosed;
        }
      }
      a.icon = '#icon-' + a.icon.replace(/^#?icon-?/, '');
      a.class = ' class="' + a.class.join(' ') + '"';

      var html = '\n      <li' + liClassList + '>\n        <a role="treeitem" aria-selected="false" tabindex="-1"\n          aria-level="' + level + '"\n          aria-position="' + position + '"\n          aria-setsize="' + position + '"\n          ' + (a.id + a.href + a.class + a.expanded + a.ariaDisabled + a.alertIconAttr) + '>\n            <svg class="icon-tree icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="' + a.icon + '"></use>\n            </svg>' + (a.checkbox + a.alertIcon + a.badge + a.text) + '\n        </a>';

      if (isChildren) {
        html += '<ul class="folder' + (data.open ? ' is-open' : '') + '" role="group">';
        for (var i = 0, l = data.children.length; i < l; i++) {
          html += this.getNodeHtml(data.children[i], i, level + 1, isParentsDisabled);
        }
        html += '</ul>';
      }
      html += '</li>';

      return html;
    },


    /**
     * Create badge html.
     * @private
     * @param {object} badgeData to do html.
     * @returns {string} html created
     */
    getBadgeHtml: function getBadgeHtml(badgeData) {
      var badge = { html: '', style: '', class: ['badge', 'tree-badge'] };

      if (badgeData && !badgeData.remove) {
        badge.text = '';

        if (typeof badgeData.text !== 'undefined') {
          badge.text = badgeData.text.toString();
          if (badge.text.length === 1) {
            badge.class.push('round');
          }
        }

        if (/info|good|error|alert|pending/i.test(badgeData.type)) {
          badge.class.push(badgeData.type);
        } else if (badgeData.type && badgeData.type.charAt(0) === '#' && badgeData.type.length === 7) {
          badge.style = 'background-color: ' + badgeData.type + ' !important;';
        }
        if (badgeData.backColor) {
          badge.style = 'background-color: ' + badgeData.backColor + ' !important;';
        }
        if (badgeData.foreColor) {
          badge.style += 'color: ' + badgeData.foreColor + ' !important;';
        }
        if (badge.style !== '') {
          badge.style = ' style="' + badge.style + '"';
        }
        if (badge.text !== '') {
          if (badgeData.type && badgeData.type.indexOf('pending') !== -1) {
            badge.text = '';
          }
          badge.html = '<span class="' + badge.class.join(' ') + '"' + badge.style + '>' + badge.text + '</span>';
        }
      }
      return badge.html;
    },


    // Functions to Handle Internal Data Store
    addToDataset: function addToDataset(node, location) {
      var elem = void 0;

      if (node.parent) {
        elem = this.findById(node.parent);
      }

      if (location === 'bottom' && !node.parent && !elem) {
        this.settings.dataset.push(node);
      }

      if (location === 'top' && !node.parent && !elem) {
        this.settings.dataset.unshift(node);
      }

      if (node.parent && elem) {
        if (!elem.children) {
          elem.children = [];
        }

        if (location === 'bottom') {
          elem.children.push(node);
        } else {
          elem.children.unshift(node);
        }
      }

      return !(node.parent && !elem);
    },


    // Find the Node (Dataset) By Id
    findById: function findById(id, source) {
      var self = this;

      if (!source) {
        source = this.settings.dataset;
      }

      /* eslint-disable guard-for-in */
      /* eslint-disable no-restricted-syntax */
      for (var key in source) {
        var item = source[key];
        if (item.id === id) {
          return item;
        }

        if (item.children) {
          var subresult = self.findById(id, item.children);

          if (subresult) {
            return subresult;
          }
        }
      }
      /* eslint-enable no-restricted-syntax */
      /* eslint-enable guard-for-in */
      return null;
    },


    // Get node by ID if selected
    getNodeByIdIfSelected: function getNodeByIdIfSelected(id, source) {
      var node = this.findById(id, source);
      return node && node.selected ? node : null;
    },


    /**
     * Get selected nodes.
     * @returns {object} selected nodes
     */
    getSelectedNodes: function getSelectedNodes() {
      var node = void 0;
      var data = void 0;
      var selected = [];

      $('li.is-selected', this.element).each(function () {
        node = $('a:first', this);
        data = node.data('jsonData');
        selected.push({ node: node, data: data });
      });
      return selected;
    },
    getNextNode: function getNextNode(target) {
      var next = target.parent().next().find('a:first');
      var subTarget = target.next();

      // Move Into Children
      if (subTarget.is('ul.is-open')) {
        next = subTarget.find('a:first');
      }

      // Skip disabled
      if (next.hasClass('is-disabled')) {
        next = next.parent().next().find('a:first');
      }

      // Bottom of a group..{l=1000: max folders to be deep }
      if (next.length === 0) {
        for (var i = 0, l = 1000, closest = target; i < l; i++) {
          closest = closest.parent().closest('.folder');
          next = closest.next().find('a:first');
          if (next.length) {
            break;
          }
        }
      }

      // Another check for disabled
      if (next.hasClass('is-disabled')) {
        next = this.getNextNode(next);
      }

      return next;
    },
    getPreviousNode: function getPreviousNode(target) {
      var prev = target.parent().prev().find('a:first');
      var subTarget = prev.parent();

      // Move into children at bottom
      if (subTarget.is('.folder.is-open') && subTarget.find('ul.is-open a').length && !subTarget.find('ul.is-disabled').length) {
        prev = subTarget.find('ul.is-open a:last');
      }

      // Skip disabled
      if (prev.hasClass('is-disabled')) {
        prev = prev.parent().prev().find('a:first');

        // Another check if get to prev open folder
        subTarget = prev.parent();
        if (subTarget.is('.folder.is-open') && subTarget.find('ul.is-open a').length && !subTarget.find('ul.is-disabled').length) {
          prev = subTarget.find('ul.is-open a:last');
        }
      }

      // Top of a group
      if (prev.length === 0) {
        prev = target.closest('ul').prev('a');
      }

      // Another check for disabled
      if (prev.hasClass('is-disabled')) {
        prev = this.getPreviousNode(prev);
      }

      return prev;
    },


    /**
     * Sync the tree with the underlying dataset
     * @private
     * @param {object} node the jQuery element to sync (Optional)
     * @returns {void}
     */
    syncDataset: function syncDataset(node) {
      var json = [];
      var self = this;
      node = node || this.element;

      var items = [].slice.call(node.children('li').toArray());
      items.forEach(function (li) {
        json.push(self.syncNode(li.querySelector('a')));
      });

      this.settings.dataset = json;
      this.element.triggerHandler('rendered', { data: this.settings.dataset });
    },


    /**
     * Sync a node with its dataset record
     * @private
     * @param {object} node The node to sync (jQuery or DOM element)
     * @returns {object} synced node data
     */
    syncNode: function syncNode(node) {
      var self = this;
      var nodeJQ = this.isjQuery(node) ? node : $(node);
      node = nodeJQ[0];
      var parent = node.parentNode;
      var hasClass = function hasClass(el, className) {
        return el.classList.contains(className);
      };

      var entry = {
        node: nodeJQ,
        id: node.getAttribute('id'),
        text: node.querySelector('.tree-text').textContent
      };

      // Is folder open
      if (hasClass(node, 'is-open') || parent && parent.tagName.toLowerCase() === 'li' && hasClass(parent, 'is-open')) {
        entry.open = true;
      }

      // Href
      var href = node.getAttribute('href');
      if (href) {
        entry.href = href;
      }

      // Selected
      if (hasClass(parent, 'is-selected')) {
        entry.selected = true;
      }

      // Disabled
      if (hasClass(node, 'is-disabled')) {
        entry.disabled = true;
      }

      // Icon
      var classAttribute = node.getAttribute('class');
      if (classAttribute && classAttribute.indexOf('icon') > -1) {
        entry.icon = classAttribute;
      }

      // Children
      var ul = nodeJQ.next();
      if (ul[0] && ul[0].tagName.toLowerCase() === 'ul') {
        entry.children = [];

        var items = [].slice.call(ul.children('li').toArray());
        items.forEach(function (li) {
          entry.children.push(self.syncNode(li.querySelector('a')));
        });
      }

      // Merge json data
      var jsonData = nodeJQ.data('jsonData');
      if (jsonData) {
        delete jsonData.selected;
        delete jsonData.children;
        entry = $.extend({}, jsonData, entry);
      }

      nodeJQ.data('jsonData', entry);
      return entry;
    },


    /**
     * Add a node and all its related markup.
     * @param {object} nodeData to add.
     * @param {object} location in tree.
     * @returns {object} li added
     */
    addNode: function addNode(nodeData, location) {
      var badgeAttr = _typeof(nodeData.badge) === 'object' ? JSON.stringify(nodeData.badge) : nodeData.badge;

      nodeData.href = typeof nodeData.href !== 'undefined' ? nodeData.href : '#';

      location = !location ? 'bottom' : location; // supports button or top or jquery node

      var a = document.createElement('a');
      a.setAttribute('id', nodeData.id);
      a.setAttribute('href', nodeData.href);
      if (typeof badgeAttr !== 'undefined') {
        a.setAttribute('data-badge', badgeAttr);
      }
      if (typeof nodeData.alertIcon !== 'undefined') {
        a.setAttribute('data-alert-icon', nodeData.alertIcon);
      }

      if (nodeData.text) {
        a.textContent = nodeData.text;
      }

      if (nodeData.disabled) {
        a.classList.add('is-disabled');
      }
      if (nodeData.icon) {
        a.classList.add(nodeData.icon);
      }

      var li = document.createElement('li');

      if (nodeData.open) {
        li.classList.add('is-open');
      }

      li.appendChild(a);

      // Handle Location
      var found = this.loading ? true : this.addToDataset(nodeData, location);

      if (nodeData.parent instanceof jQuery) {
        found = true;
      }

      if (location instanceof jQuery && (!nodeData.parent || !found) && !(nodeData.parent instanceof jQuery)) {
        location[0].appendChild(li);
        found = true;
      }

      if (location === 'bottom' && (!nodeData.parent || !found)) {
        this.element[0].appendChild(li);
      }

      if (location === 'top' && (!nodeData.parent || !found)) {
        this.element.prepend(li);
      }

      // Support ParentId in JSON Like jsTree
      if (nodeData.parent) {
        if (found && typeof nodeData.parent === 'string') {
          li = this.element.find('#' + nodeData.parent).parent();

          if (!nodeData.disabled && li.is('.is-selected') && typeof nodeData.selected === 'undefined') {
            nodeData.selected = true;
          }
          this.addAsChild(nodeData, li);
        }

        if (nodeData.parent && nodeData.parent instanceof jQuery) {
          li = nodeData.parent;
          if (nodeData.parent.is('a')) {
            li = nodeData.parent.parent();
          }
          this.addAsChild(nodeData, li);
        }
        if (this.isjQuery(li)) {
          nodeData.node = li.find('ul li a#' + nodeData.id);
        }
      } else {
        li = $(li);
        this.addChildNodes(nodeData, li);
        nodeData.node = li.children('a').first();
      }

      a = $(a);
      this.decorateNode(a);

      if (nodeData.selected) {
        this.selectNode(a, nodeData.focus);
      }

      a.data('jsonData', nodeData);
      return li;
    },


    /**
     * Add a node to an existing node, making it a folder if need be
     * @private
     * @param {object} nodeData data for node to be added.
     * @param {object} li parent node to add node.
     * @returns {void}
     */
    addAsChild: function addAsChild(nodeData, li) {
      li = this.isjQuery(li) ? li[0] : li;
      var ul = li.querySelector('ul');
      if (!ul) {
        li.insertAdjacentHTML('beforeend', '<ul class="folder"></ul>');
        ul = li.querySelector('ul');
      }

      if (nodeData.open) {
        ul.classList.add('is-open');
      }

      this.decorateNode(li.querySelector('a'));

      nodeData.parent = '';
      this.addNode(nodeData, $(ul));
    },


    /**
     * Add the children for the specified node element,
     * and if `nodeData.children` not passed will remove current children from node
     * @private
     * @param {object} nodeData data for children to be added.
     * @param {object} li parent node to add children.
     * @returns {void}
     */
    addChildNodes: function addChildNodes(nodeData, li) {
      var _this3 = this;

      li = this.isjQuery(li) ? li[0] : li;
      var ul = li.querySelector('ul');

      if (!nodeData.children) {
        if (ul) {
          ul.parentNode.removeChild(ul);
        }
        return;
      }

      if (!ul) {
        li.insertAdjacentHTML('beforeend', '<ul class="folder' + (nodeData.open ? ' is-open' : '') + '"></ul>');
        ul = li.querySelector('ul');
      }

      ul.innerHTML = '';

      if (nodeData.children) {
        nodeData.children.forEach(function (elem) {
          return _this3.addNode(elem, $(ul));
        });
      }
    },


    // Check for true value
    isTrue: function isTrue(v) {
      return typeof v !== 'undefined' && v !== null && (typeof v === 'boolean' && v === true || typeof v === 'string' && v.toLowerCase() === 'true');
    },


    // Check for false value
    isFalse: function isFalse(v) {
      return typeof v !== 'undefined' && v !== null && (typeof v === 'boolean' && v === false || typeof v === 'string' && v.toLowerCase() === 'false');
    },


    /**
     * Update fx rename a node.
     * @param {object} nodeData to update.
     * @returns {void}
     */
    updateNode: function updateNode(nodeData) {
      // Passed in the node element or find the node in the dataset and ui and sync it
      var elem = nodeData.node ? { node: nodeData.node } : this.findById(nodeData.id);
      if (!elem || !elem.node[0]) {
        return;
      }

      var parent = elem.node[0].parentNode;
      var nodetext = elem.node[0].querySelector('.tree-text');
      var isDisabled = this.isTrue(nodeData.disabled) || this.isFalse(nodeData.enabled);
      var isEnabled = this.isTrue(nodeData.enabled) || this.isFalse(nodeData.disabled);

      // Update badge
      if (nodeData.badge) {
        var badge = elem.node[0].querySelector('.tree-badge');
        if (!badge && !nodeData.badge.remove) {
          if (typeof nodeData.badge.text !== 'undefined' && $.trim(nodeData.badge.text) !== '') {
            var newBadge = document.createElement('span');
            newBadge.classList.add('tree-badge', 'badge');
            nodetext.parentNode.insertBefore(newBadge, nodetext);
            badge = elem.node[0].querySelector('.tree-badge');
          }
        }
        // Make update changes
        if (badge) {
          if (typeof nodeData.badge.text !== 'undefined') {
            nodeData.badge.text = nodeData.badge.text.toString();
            badge.textContent = nodeData.badge.text;
            badge.classList.remove('round');
            if (nodeData.badge.text.length === 1) {
              badge.classList.add('round');
            }
          }
          if (typeof nodeData.badge.type !== 'undefined') {
            badge.classList.remove('info', 'good', 'error', 'alert', 'pending');
            if (/info|good|error|alert|pending/i.test(nodeData.badge.type)) {
              badge.classList.add(nodeData.badge.type);
            } else if (nodeData.badge.type.charAt(0) === '#' && nodeData.badge.type.length === 7) {
              badge.style.backgroundColor = nodeData.badge.type;
            }

            if (nodeData.badge.type.indexOf('pending') !== -1) {
              badge.textContent = '';
            }
          }
          elem.badge = nodeData.badge;

          // Remove badge
          if (this.parseBool(nodeData.badge.remove)) {
            badge.parentNode.removeChild(badge);
            if (typeof elem.badge !== 'undefined') {
              delete elem.badge;
            }
          }
        }
      }

      if (nodeData.text) {
        nodetext.textContent = nodeData.text;
        elem.text = nodeData.text;
      }

      if (nodeData.icon) {
        this.setTreeIcon(elem.node[0].querySelector('svg.icon-tree'), nodeData.icon);
        elem.icon = nodeData.icon;
      } else if (nodeData.children && nodeData.children.length && !parent.classList.contains('folder')) {
        this.convertFileToFolder(elem.node);
      }

      if (isDisabled) {
        elem.node[0].classList.add('is-disabled');
        elem.node[0].setAttribute('aria-disabled', 'true');

        if (parent.classList.contains('folder') && parent.classList.contains('is-open')) {
          var nodes = [].slice.call(parent.querySelectorAll('a, ul[role=group]'));
          nodes.forEach(function (node) {
            node.classList.add('is-disabled');
            node.setAttribute('aria-disabled', 'true');
          });
        }
      }

      if (isEnabled) {
        var isParentsDisabled = elem.node.parentsUntil(this.element, 'ul[role=group].is-disabled').length > 0;

        if (!isParentsDisabled) {
          elem.node[0].classList.remove('is-disabled');
          elem.node[0].removeAttribute('aria-disabled');

          if (parent.classList.contains('folder') && parent.classList.contains('is-open')) {
            var _nodes = [].slice.call(parent.querySelectorAll('a, ul[role=group]'));
            _nodes.forEach(function (node) {
              node.classList.remove('is-disabled');
              node.removeAttribute('aria-disabled');
            });
          }
        }
      }

      if (nodeData.node) {
        this.syncDataset();
      }

      if (nodeData.children) {
        if (nodeData.children.length) {
          this.addChildNodes(nodeData, parent);
        } else {
          this.removeChildren(nodeData, parent);
        }
      }
      this.createSortable();
    },


    // Performs the usual Boolean coercion with the exception of
    // the strings "false" (case insensitive) and "0"
    parseBool: function parseBool(b) {
      return !/^(false|0)$/i.test(b) && !!b;
    },


    /**
     * Delete children nodes
     * @private
     * @param {object} nodeData data for icon to be replaced.
     * @param {object} li parent node to delete children.
     * @returns {void}
     */
    removeChildren: function removeChildren(nodeData, li) {
      li = this.isjQuery(li) ? li[0] : li;
      var ul = li.querySelector('ul');

      this.setTreeIcon(li.querySelector('svg.icon-tree'), nodeData.icon || 'icon-tree-node');
      li.classList.remove('folder', 'is-open');
      if (ul) {
        ul.parentNode.removeChild(ul);
      }
    },


    /**
     * Delete a node from the dataset or tree.
     * @param {object} nodeData to delete.
     * @returns {void}
     */
    removeNode: function removeNode(nodeData) {
      var elem = this.findById(nodeData.id);

      if (nodeData instanceof jQuery) {
        elem = nodeData;
        elem.parent().remove();
      } else if (elem) {
        elem.node.parent().remove();
      }

      if (!elem) {
        return;
      }
      this.syncDataset();
    },


    // Attach Context Menus
    attachMenu: function attachMenu(menuId) {
      var self = this;

      if (!menuId) {
        return;
      }

      this.element.off('contextmenu.tree').on('contextmenu.tree', 'a', function (e) {
        var node = $(this);
        e.preventDefault();
        self.popupEl = $(e.currentTarget).popupmenu({ menuId: menuId, eventObj: e, trigger: 'immediate', attachToBody: true }).off('selected').on('selected', function (event, args) {
          /**
          * Fires when the an attached context menu item is selected.
          *
          * @event menuselect
          * @memberof Tree
          * @type {object}
          * @property {object} event - The jquery event object
          * @property {object} args for node element, item
          * @property {HTMLElement} args.node The DOM Element.
          * @property {object} data.item The attached node data.
          */
          self.element.triggerHandler('menuselect', { node: node, item: args });
        });

        /**
        * Fires when the attached context menu is opened. Use it to update the menu as needed
        * @memberof Tree
        * @event menuopen
        * @type {object}
        * @property {object} event - The jquery event object
        * @property {object} args for node element, item
        * @property {HTMLElement} args.menu The menu item
        * @property {HTMLElement} args.node The DOM Element.
        */
        self.element.triggerHandler('menuopen', { menu: $('#' + menuId), node: node });
        return false;
      });
    },


    /**
     * Create sortable.
     * @private
     * @returns {void}
     */
    createSortable: function createSortable() {
      if (!this.settings.sortable) {
        return;
      }

      var self = this;
      var clone = void 0;
      var interval = void 0;
      var doDrag = void 0;

      self.targetArrow = self.element[0].previousElementSibling;
      self.linkSelector = 'a:not(.is-dragging-clone):not(.is-disabled)';

      if (!self.targetArrow || self.targetArrow && !self.targetArrow.classList.contains('tree-drag-target-arrow')) {
        var div = document.createElement('div');
        div.classList.add('tree-drag-target-arrow');
        self.element[0].parentNode.insertBefore(div, self.element[0]);
        self.targetArrow = self.element[0].previousElementSibling;
      }

      function isReady() {
        // Make sure all dynamic nodes sync
        if (!self.loading) {
          clearInterval(interval);

          var links = [].slice.call(self.element[0].querySelectorAll(self.linkSelector));
          links.forEach(function (link) {
            var a = $(link);

            // Quit if already binded with `drag`
            if (a.data('drag')) {
              return;
            }

            // Don't drag with folder icon, save for toggle nodes
            a.on('mousedown.tree', function (e) {
              e.preventDefault();

              if (e.which === 3) {
                doDrag = false;
              } else {
                doDrag = e.target.classList.contains('icon') ? !link.parentNode.classList.contains('folder') : true;
              }
            })

            // Invoke drag
            .drag({
              clone: true,
              cloneAppendTo: a.closest('li'),
              clonePosIsFixed: true
            })

            // Drag start =======================================
            .on('dragstart.tree', function (e, pos, thisClone) {
              if (!thisClone || !doDrag) {
                link.classList.remove('is-dragging');
                if (thisClone) {
                  thisClone[0].parentNode.removeChild(thisClone[0]);
                }
                return;
              }
              clone = thisClone;
              clone[0].removeAttribute('id');
              clone[0].classList.add('is-dragging-clone');

              var items = [].slice.call(clone[0].querySelectorAll('.tree-checkbox, .tree-badge'));
              items.forEach(function (node) {
                return node.parentNode.removeChild(node);
              });

              var startUl = a.closest('ul');
              self.sortable = {
                // Do not use index from each loop, get updated index on drag start
                startIndex: $(self.linkSelector, self.element).index(a),
                startNode: a,
                startIcon: $('svg.icon-tree', a).getIconName(),
                startUl: startUl,
                startLi: a.closest('li'),
                startFolderNode: startUl.prev('a'),
                startWidth: a.outerWidth()
              };

              self.element.triggerHandler('dragstart', self.sortable);
              e.preventDefault();
              e.stopImmediatePropagation();
            })

            // While dragging ===================================
            .on('drag.tree', function (e, pos) {
              if (!clone) {
                return;
              }
              clone[0].style.left = pos.left + 'px';
              clone[0].style.top = pos.top + 'px';
              clone[0].style.opacity = '1';
              self.setDragOver(clone, pos);
            })

            // Drag end =========================================
            .on('dragend.tree', function (e, pos) {
              self.targetArrow.style.display = 'none';
              var items = [].slice.call(self.element[0].querySelectorAll(self.linkSelector));
              items.forEach(function (node) {
                return node.classList.remove('is-over');
              });

              if (!clone || !self.sortable.overDirection) {
                return;
              }
              clone[0].style.left = pos.left + 'px';
              clone[0].style.top = pos.top + 'px';

              var start = self.sortable.startNode.parent();
              var end = self.sortable.overNode.parent();

              // Over
              if (self.sortable.overDirection === 'over') {
                if (!end[0].classList.contains('folder')) {
                  self.convertFileToFolder(self.sortable.overNode);
                }
                end[0].querySelector('ul').appendChild(start[0]);
                if (!end[0].classList.contains('is-open')) {
                  self.toggleNode(self.sortable.overNode, e);
                }
              } else if (self.sortable.overDirection === 'up') {
                // Up
                start.insertBefore(end);
              } else if (self.sortable.overDirection === 'down') {
                // Down
                if (end[0].classList.contains('is-open') && end[0].classList.contains('folder')) {
                  $('ul:first', end).prepend(start);
                } else {
                  start.insertAfter(end);
                }
              }

              // Restore file type
              if (!self.sortable.startUl[0].querySelector('li') && !!self.sortable.startFolderNode.data('oldData') && self.sortable.startFolderNode.data('oldData').type === 'file') {
                self.convertFolderToFile(self.sortable.startFolderNode);
              }

              // Fix: On windows 10 with IE-11 icons disappears
              utils.fixSVGIcons(start);

              self.element.triggerHandler('dragend', self.sortable);
              // Sync dataset and ui
              self.syncDataset();
              if (self.isMultiselect) {
                self.initSelected();
              }
            });
          });
        }
      }
      // Wait for make sure all dynamic nodes sync
      interval = setInterval(isReady, 10);
    },


    /**
     * Set actions while drag over.
     * @private
     * @param {object} clone node.
     * @param {object} pos node positions to compare.
     * @returns {void}
     */
    setDragOver: function setDragOver(clone, pos) {
      var self = this;
      var cloneSvg = clone[0].querySelector('svg.icon-tree');
      var treeRec = self.element[0].getBoundingClientRect();
      var extra = 20;
      var exMargin = void 0;
      var isParentsStartNode = void 0;
      var isBeforeStart = void 0;
      var isAfterSttart = void 0;
      var li = void 0;
      var a = void 0;
      var ul = void 0;
      var links = void 0;
      var rec = void 0;
      var left = void 0;
      var top = void 0;
      var direction = void 0;
      var doAction = void 0;

      // Set as out of range
      var outOfRange = function outOfRange() {
        self.sortable.overNode = null;
        self.sortable.overIndex = null;
        self.sortable.overDirection = null;

        self.targetArrow.style.display = 'none';
        self.setTreeIcon(cloneSvg, 'icon-cancel');
      };

      // Moving inside tree
      if (pos.top > treeRec.top - extra && pos.top < treeRec.bottom + extra && pos.left > treeRec.left - extra - self.sortable.startWidth && pos.left < treeRec.left + treeRec.height + extra) {
        extra = 2;
        links = [].slice.call(self.element[0].querySelectorAll(self.linkSelector));

        links.forEach(function (link, i) {
          direction = null;
          rec = link.getBoundingClientRect();

          // Moving on/around node range
          if (pos.top > rec.top - extra && pos.top < rec.bottom + extra) {
            a = $(link);

            // Moving on/around node has parents as same node need to rearrange
            // Cannot rearrange parents to child
            isParentsStartNode = !!a.parentsUntil(self.element, '.folder').filter(function () {
              return $('a:first', this).is(self.sortable.startNode) && self.sortable.startLi.is('.folder');
            }).length;
            if (isParentsStartNode) {
              outOfRange();
              return;
            }

            li = link.parentNode;
            left = rec.left;
            ul = a.closest('ul');
            exMargin = parseInt(li.style.marginTop, 10) > 0 ? 2 : 0;
            isBeforeStart = i - 1 === self.sortable.startIndex && ul.is(self.sortable.startUl);
            isAfterSttart = i + 1 === self.sortable.startIndex && ul.is(self.sortable.startUl);
            links.forEach(function (node) {
              return node.classList.remove('is-over');
            });

            // Apply actions
            /* eslint-disable no-loop-func */
            doAction = function doAction() {
              if (!direction) {
                outOfRange();
                return;
              }

              // Reset icon
              self.setTreeIcon(cloneSvg, self.sortable.startIcon);

              // Over
              if (direction === 'over') {
                self.targetArrow.style.display = 'none';
                if (!link.classList.contains('is-disabled')) {
                  link.classList.add('is-over');
                }
              } else {
                // Up -or- Down
                links.forEach(function (node) {
                  return node.classList.remove('is-over');
                });
                top = direction === 'up' ? rec.top - 1.5 - (li.classList.contains('is-active') ? 3 : 0) : rec.bottom + (li.nextElementSibling && li.nextElementSibling.classList.contains('is-active') ? -1 : 1.5) + exMargin;
                self.targetArrow.style.left = left + 'px';
                self.targetArrow.style.top = top + 'px';
                self.targetArrow.style.display = 'block';
              }

              // Set changes
              self.sortable.overNode = a;
              self.sortable.overIndex = i;
              self.sortable.overDirection = direction;
            };
            /* eslint-disable no-loop-func */

            // Set moveing directions
            if (i !== self.sortable.startIndex) {
              // If hover on link
              if (pos.left > rec.left - extra - self.sortable.startWidth && pos.left < rec.right + extra) {
                if (!isBeforeStart && pos.top < rec.top) {
                  direction = 'up';
                } else if (!isAfterSttart && pos.top > rec.top + extra * 2) {
                  direction = 'down';
                } else {
                  direction = 'over';
                }
              } else if (!isBeforeStart && pos.top < rec.top) {
                // Not hover on link
                direction = 'up';
              } else if (!isAfterSttart) {
                direction = 'down';
              }
            }
            doAction(direction);
          }
        });
      } else {
        // Out side from tree area
        outOfRange();
      }
    },


    // Convert file node to folder type
    convertFileToFolder: function convertFileToFolder(node) {
      var newFolder = document.createElement('ul');
      newFolder.setAttribute('role', 'group');
      var oldData = {
        icon: $('svg.icon-tree', node).getIconName(),
        type: 'file'
      };
      if (this.hasIconClass(node)) {
        var iconClass = node.attr('class').replace(/\s?is-selected/, '');
        oldData.iconClass = iconClass;
        node.removeClass(iconClass);
      }
      node.data('oldData', oldData);
      var parent = node[0].parentNode;
      if (parent && parent.tagName.toLowerCase() === 'li') {
        parent.classList.add('folder');
        parent.appendChild(newFolder);
      }
      this.setTreeIcon($('svg.icon-tree', node), this.settings.folderIconClosed);
    },


    // Convert folder node to file type
    convertFolderToFile: function convertFolderToFile(node) {
      var parent = node.parent('.folder');
      parent.removeClass('folder is-open');
      $('ul:first', parent).remove();
      if (parent.length) {
        this.setTreeIcon($('svg.icon-tree', node), node.data('oldData') ? node.data('oldData').icon : 'tree-node');
        if (node.data('oldData') && node.data('oldData').iconClass) {
          node.addClass(node.data('oldData').iconClass);
        }
        node.data('oldData', null);
      }
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      if (this.settings.sortable) {
        this.element.find('a').each(function () {
          var a = $(this);
          var dragApi = a.data('drag');
          a.off('mousedown.tree');
          if (!!dragApi && !!dragApi.destroy) {
            dragApi.destroy();
          }
        });
        this.element.prev('.tree-drag-target-arrow').remove();
      }
      this.element.off('contextmenu.tree updated.tree click.tree focus.tree keydown.tree keypress.tree');

      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, TREE_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      this.element.empty();
      $.removeData(this.element[0], COMPONENT_NAME$17);
    },


    /**
     * Disables all nodes in the Tree component
     * @returns {void}
     */
    disable: function disable() {
      var nodes = this.element[0].querySelectorAll('a');
      nodes.forEach(function (node) {
        node.classList.add('is-disabled');
        node.setAttribute('aria-disabled', 'true');
      });
    },


    /**
     * Enables all nodes in the Tree component
     * @returns {void}
     */
    enable: function enable() {
      var nodes = this.element[0].querySelectorAll('a');
      nodes.forEach(function (node) {
        node.classList.remove('is-disabled');
        node.removeAttribute('aria-disabled');
      });
    },


    /**
     * Preserves all nodes' enablement states in the Tree component
     * @returns {array} of node objects containing attributes nodeId and state (enablement state)
     */
    preserveEnablementState: function preserveEnablementState() {
      var nodes = this.element[0].querySelectorAll('a');
      var enablementStates = [];

      nodes.forEach(function (node) {
        if (node.classList.contains('is-disabled') || node.getAttribute('aria-disabled') === true) {
          enablementStates.push({ nodeId: node.id, state: 'disabled' });
        } else {
          enablementStates.push({ nodeId: node.id, state: 'enabled' });
        }
      });

      this.settings.originalEnablementState = enablementStates;
      return enablementStates;
    },


    /**
     * Restores all nodes' original enablement states in the Tree component
     * @returns {void}
     */
    restoreEnablementState: function restoreEnablementState() {
      var _this4 = this;

      var nodes = this.element[0].querySelectorAll('a');

      // check to prevent error if preserveEnablementState() has not been invoked
      if (!(this.settings.originalEnablementState === null)) {
        nodes.forEach(function (node) {
          _this4.settings.originalEnablementState.forEach(function (origNode) {
            if (origNode.nodeId === node.id) {
              if (origNode.state === 'disabled') {
                node.classList.add('is-disabled');
                node.setAttribute('aria-disabled', 'true');
              } else {
                node.classList.remove('is-disabled');
                node.removeAttribute('aria-disabled');
              }
            }
          });
        });
      }
    }
  };

  /**
   * jQuery Component Wrapper for Tree
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.tree = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$17);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$17, new Tree(this, settings));
      }
    });
  };

  // Shared Imports

  // Settings and Options
  var COMPONENT_NAME$18 = 'treemap';

  // Default Radar Options
  var TREEMAP_DEFAULTS = {
    dataset: [],
    redrawOnResize: true,
    margin: { top: 20, right: 20, bottom: 20, left: 20 },
    colors: ['#133C59', '#134D71', '#1D5F8A', '#2578A9', '#368AC0', '#54A1D3', '#69B5DD', '#8DC9E6', '#ADD8EB', '#4B2A5E', '#5D3E70', '#6E5282', '#806594', '#9279A6', '#A38DB7', '#B59ECA', '#C7B4DB', '#DACCEC', '#0E5B52', '#206B62', '#317C73', '#448D83', '#579E95', '#69ADA3', '#7CC0B5', '#8ED1C6', '#A9E1D6'],
    showLabel: true,
    labelFormatter: '.0%',
    showTitle: true,
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' }
  };

  /**
   * A radar chart is a diagram representing hierarchical data in the form of nested rectangles,
   * the area of each corresponding to its numerical value.
   * @class Treemap
   * @param {string} element The plugin element for the constuctor
   * @param {string} settings The settings element.
   * @param {array} settings.dataset The data to use in the radar
   * @param {boolean} [settings.redrawOnResize = true] If false, the component will not resize when resizing the page.
   * @param {object} [settings.margin] The margins of the SVG, which you may want to adjust depending on text location.
   * @param {array} [settings.colors] An array of colors used in sequence from front to end of the array.
   * @param {boolean} [settings.showLabel] If false then the percentage wont be shown in the blocks.
   * @param {string} [settings.labelFormatter] The d3 formatter function for the value label.
   * @param {boolean} [settings.showTitle] If true then the first name will be used for the title area.
   * @param {object} [settings.emptyMessage] An empty message will be displayed when there is no chart data.
   * This accepts an object of the form emptyMessage:
   * `{title: 'No Data Available',
   *  info: 'Make a selection on the list above to see results', icon: 'icon-empty-no-data',
   *  button: {text: 'xxx', click: <function>}
   *  }`
  *   Set this to null for no message or will default to 'No Data Found with an icon.'
  */
  function Treemap(element, settings) {
    this.settings = utils.mergeSettings(element, settings, TREEMAP_DEFAULTS);
    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Treemap.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.build().handleEvents();

      /**
      * Fires when the chart is complete done rendering, for customization.
      * @event rendered
      * @memberof Treemap
      * @property {object} event - The jquery event object
      * @property {array} svg - The svg object.
      */
      this.element.trigger('rendered', [this.svg]);

      return this;
    },


    /**
     * Build the Component.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    build: function build() {
      this.updateData(this.settings.dataset);
      return this;
    },


    /**
     * Update the chart with a new dataset
     * @param  {object} data The data to use.
     */
    updateData: function updateData(data) {
      var _this = this;

      var margin = Object.create(this.settings.margin);
      var width = this.element.parent().width() - margin.left - margin.right;
      var height = this.element.parent().height() - margin.top - margin.bottom;
      // Define the colors
      var color = d3.scaleOrdinal().range(this.settings.colors);

      // Handle Empty Data Set
      if (data.length === 0) {
        this.element.emptymessage(this.settings.emptyMessage);
        return;
      }

      // Show the title area
      if (this.settings.showTitle && data.name) {
        d3.select(this.element[0]).append('div').attr('class', 'chart-treemap-title').text(data.name);

        height -= 35;
        margin.top -= 19;
      }

      // Run the d3 tree map algorithm
      var treemap = d3.treemap().size([width, height]);

      // Set the height / width and class
      this.root = d3.select(this.element[0]).classed('chart-treemap', true).append('div').style('position', 'relative').style('width', width + margin.left + margin.right + 'px').style('height', height + margin.top + margin.bottom + 'px').style('left', margin.left + 'px').style('top', margin.top + 'px');

      // Format the data into a hierarchy tree
      var root = d3.hierarchy(data, function (d) {
        return d.children;
      }).sum(function (d) {
        return d.value;
      });
      var tree = treemap(root);

      this.total = d3.sum(tree.leaves(), function (d) {
        return d.value;
      });

      // Add the tree map nodes
      this.root.datum(root).selectAll('.chart-treemap-node').data(tree.leaves()).enter().append('div').attr('class', 'chart-treemap-node').style('left', function (d) {
        return d.x0 + 'px';
      }).style('top', function (d) {
        return d.y0 + 'px';
      }).style('width', function (d) {
        return Math.max(0, d.x1 - d.x0 - 1) + 'px';
      }).style('height', function (d) {
        return Math.max(0, d.y1 - d.y0 - 1) + 'px';
      }).style('background', function (d) {
        if (!d || !d.parent || !d.parent.data) {
          return '';
        }
        return color(d.parent.data.name);
      }).text(function (d) {
        return d.data.name;
      });

      if (this.settings.showLabel) {
        this.root.selectAll('.chart-treemap-node').append('span').attr('class', 'chart-treemap-percent').text(function (d) {
          return d3.format(_this.settings.labelFormatter)(d.value / _this.total);
        });
      }
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      this.element.on('updated.' + COMPONENT_NAME$18, function () {
        _this2.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on('resize.' + COMPONENT_NAME$18, function () {
          _this2.handleResize();
        });

        this.element.on('resize.' + COMPONENT_NAME$18, function () {
          _this2.handleResize();
        });
      }

      return this;
    },


    /**
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      this.element.empty();
      return this.build();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$18);
      $('body').off('resize.' + COMPONENT_NAME$18);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('chart-treemap');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$18);
    }
  };

  /**
   * jQuery Component Wrapper for Tremmap
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.treemap = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$18);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$18, new Treemap(this, settings));
      }
    });
  };

  // jQuery Components

  // Component Name
  var COMPONENT_NAME$19 = 'wizard';

  // Component Default Settings
  var WIZARD_DEFAULTS = {
    ticks: null
  };

  /**
   * A horizontal form based wizard component.
   * @class Wizard
   * @constructor
   * @param {jQuery[]|HTMLElement} element the Wizard container
   * @param {object} [settings] incoming settings
   * @param {jQuery[]} [settings.ticks]  Defines the data to use, must be specified.
   */
  function Wizard(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, WIZARD_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Wizard.prototype = {

    /**
     * @private
     */
    init: function init() {
      this.build().handleEvents();
    },


    /**
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      this.header = this.element.find('.wizard-header');
      if (!this.header.length) {
        this.header = $('<div class="wizard-header"></div>').appendTo(this.element);
      }

      this.bar = this.element.find('.bar');
      if (!this.bar.length) {
        this.bar = $('<div class="bar"></div>').appendTo(this.header);
      }

      this.completedRange = this.element.find('.completed-range');
      if (!this.completedRange.length) {
        this.completedRange = $('<div class="completed-range"></div>').appendTo(this.bar);
      }

      this.buildTicks().updateRange();

      return this;
    },


    /**
     * Builds the HTML Markup that draws out defined Wizard tick marks.
     * @private
     * @returns {this} component instance
     */
    buildTicks: function buildTicks() {
      var settingTicks = this.settings.ticks;
      var self = this;

      this.ticks = this.bar.children('.tick');

      if (!this.ticks.length && settingTicks) {
        for (var i = 0; i < settingTicks.length; i++) {
          var link = $('<a ng-click="handleClick()" class="tick ' + (settingTicks[i].state ? settingTicks[i].state : '') + '" href="' + (settingTicks[i].href ? settingTicks[i].href : '#') + '"><span class="label">' + settingTicks[i].label + '</span></a>');

          if (settingTicks[i].ngClick) {
            link.attr('ng-click', settingTicks[i].ngClick);
          }

          self.bar.append(link);
        }
        this.ticks = this.bar.children('.tick');
      }
      this.positionTicks();

      $('.tick', self.element).each(function () {
        var tick = $(this);
        if (tick.hasClass('is-disabled')) {
          tick.removeAttr('onclick ng-click');
        }
      });

      this.element.find('.wizard-header')[0].style.opacity = '1';
      return this;
    },
    positionTicks: function positionTicks() {
      var l = this.ticks.length;
      var delta = 100 / (l - 1);
      var tickPos = [];

      function getPoint(i) {
        if (i === 0) {
          return 0;
        }
        if (i === l - 1) {
          return 100;
        }
        return delta * i;
      }

      for (var i = 0; i < l; i++) {
        tickPos.push(getPoint(i));
      }

      this.ticks.each(function (i) {
        var tick = $(this);
        var label = tick.children('.label');
        var left = (Locale ? Locale.isRTL() : false) ? 100 - tickPos[i] : tickPos[i];

        this.style.left = left + '%';

        for (var i2 = 0, l2 = label.length; i2 < l2; i2++) {
          label[i2].style.left = '-' + (label.outerWidth() / 2 - tick.outerWidth() / 2) + 'px';
        }

        if (tick.is('.is-disabled')) {
          tick.attr('tabindex', '-1');
        }
      });
    },


    /**
     * Re-renders the Wizard Range with updated ticks
     * @private
     * @returns {this} component instance
     */
    updateRange: function updateRange() {
      var currentTick = this.ticks.filter('.current').last();
      var widthPercentage = 0;

      if (currentTick.length) {
        widthPercentage = 100 * parseFloat(window.getComputedStyle(currentTick[0]).left) / parseFloat(window.getComputedStyle(currentTick.parent()[0]).width);
        widthPercentage = (Locale ? Locale.isRTL() : false) ? 100 - widthPercentage : widthPercentage;
      }

      this.completedRange[0].style.width = widthPercentage + '%';
      return this;
    },


    /**
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.buildTicks().updateRange();

      return this;
    },


    /**
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.ticks.off('click.wizard');
      this.element.off('updated.wizard');

      this.ticks.remove();
      return this;
    },


    /**
     * Deprecating the "select()" method in favor of "activate()" to match the API
     * of our other controls. Temporarily adding functionality that reroutes this
     * method to the new "activate" method.
     * @private
     * @deprecated as of v4.4.0
     * @param {jQuery.Event} e the activate event object
     * @param {jQuery[]|HTMLElement} tick the target tick to be activated
     * @returns {this} component instance
     */
    select: function select(e, tick) {
      return this.activate(e, tick);
    },


    /**
     * Activates one of the Wizard's ticks.
     * Tick can either be a number (representing the tick's index) or a jQuery
     * element reference to a tick.
     * @param {jQuery.Event} e the activate event object
     * @param {jQuery[]|HTMLElement} tick the target tick to be activated
     * @returns {this} component instance
     */
    activate: function activate(e, tick) {
      if (e === undefined && !tick) {
        return this;
      }

      var self = this;

      function getTick() {
        var target = void 0;

        // Use the first variable as the tick definition or index if "e" is null,
        // undefined, or not an event object. This is for backwards compatibility with
        // this control's old select() method, which took an index as an argument.
        if (e !== undefined && (e === undefined || e === null || !e.type || !e.target) && !tick) {
          tick = e;
        }

        if (tick === undefined) {
          target = $(e.target);
          return target.is('.label') ? target.parent() : target;
        }

        if (typeof tick === 'number') {
          return self.ticks.eq(tick);
        }

        return tick;
      }

      tick = getTick();

      if (e && (tick.is('[disabled], .is-disabled') || !tick.is('a'))) {
        e.preventDefault();
        e.stopPropagation();
        return this;
      }

      /**
       * Fires before a step is activated/pressed. You can cancel selection by returning a 'beforeactivate'
       * handler as 'false'
       * @event beforeactivate
       * @memberof Wizard
       * @property {object} event - The jquery event object
       * @property {HTMLElement} tick - The tick (link) that was activated.
       */
      var canNav = this.element.triggerHandler('beforeactivate', [tick]);
      if (canNav === false) {
        return this;
      }

      var trueIndex = this.ticks.index(tick);
      this.ticks.removeClass('complete current').eq(trueIndex).addClass('current').prevAll('.tick').addClass('complete');

      this.updateRange();

      /**
       * Fires while a step is activated/pressed.
       * handler as 'false'
       * @event activated
       * @memberof Wizard
       * @property {object} event - The jquery event object
       * @property {HTMLElement} tick - The tick (link) that was activated.
       */
      this.element.trigger('activated', [tick]);

      /**
       * Fires after a step is activated/pressed. And the new Dom is loaded.
       * handler as 'false'
       * @event afteractivated
       * @memberof Wizard
       * @property {object} event - The jquery event object
       * @property {HTMLElement} tick - The tick (link) that was activated.
       */
      setTimeout(function () {
        self.element.trigger('afteractivated', [tick]);
      }, 300);

      return this;
    },


    /**
     * Teardown - Remove added markup and events
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$19);
    },


    /**
     * This component listens to the following events:
     * @private
     * @listens updated custom updated event
     * @listens click jQuery click event
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.on('updated', function () {
        self.updated();
      });

      this.ticks.on('click.wizard', function (e) {
        self.activate(e, $(this));
      });

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Wizard
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.wizard = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$19);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$19, new Wizard(this, settings));
      }
    });
  };

  // Name of this component
  var COMPONENT_NAME$1a = 'zoom';

  /**
  * The Zoom Component is used to manage zoom on mobile devices.
  * @class Zoom
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  */
  function Zoom(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(element, settings);
    this.init();
  }

  Zoom.prototype = {
    init: function init() {
      return this.build().handleEvents();
    },


    /**
    * Add markup to the control
    * @private
    * @returns {object} The api prototype for chaining.
    */
    build: function build() {
      // get references to elements
      this.viewport = this.element.find('meta[name=viewport]');
      this.body = $('body');

      return this;
    },


    /**
    * Sets up event handlers for this control and its sub-elements
    * @private
    * @returns {object} The api prototype for chaining.
    */
    handleEvents: function handleEvents() {
      var self = this;

      // Allow the head to listen to events to globally deal with the zoom problem on
      // a per-control basis (for example, Dropdown/Multiselect need to handle this issue manually).
      this.element.on('updated.' + COMPONENT_NAME$1a, function () {
        self.updated();
      }).on('enable-zoom', function () {
        self.enableZoom();
      }).on('disable-zoom', function () {
        self.disableZoom();
      });

      // Don't continue setting this up on each element if
      if (Environment.os.name !== 'ios') {
        return this;
      }

      // Setup conditional events for all elements that need it.
      this.body.on('touchstart.zoomdisabler', 'input, label', function () {
        if (self.noZoomTimeout) {
          return;
        }

        self.disableZoom();
      }).on('touchend.zoomdisabler', 'input, label', function () {
        if (self.noZoomTimeout) {
          clearTimeout(self.noZoomTimeout);
          self.noZoomTimeout = null;
        }
        self.noZoomTimeout = setTimeout(function () {
          self.noZoomTimeout = null;
          self.enableZoom();
        }, 600);
      });

      return this;
    },


    /**
    * Enable zoom by un-setting the meta tag.
    * @returns {void}
    */
    enableZoom: function enableZoom() {
      // TODO: Test to see if prepending this meta tag conflicts with Base Tag implementation
      this.viewport[0].setAttribute('content', 'width=device-width, initial-scale=1.0, user-scalable=1');
    },


    /**
    * Disable zoom by setting the meta tag.
    * @returns {void}
    */
    disableZoom: function disableZoom() {
      // TODO: Test to see if prepending this meta tag conflicts with Base Tag implementation
      this.viewport[0].setAttribute('content', 'width=device-width, initial-scale=1.0, user-scalable=0');
    },


    /**
    * Handle Updating Settings
    * @param {object} settings The settings to update to.
    * @returns {this} component instance
    */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },


    /**
    * Simple Teardown - remove events & rebuildable markup.
    * @private
    * @returns {object} component instance
    */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$1a + ' enable-zoom disable-zoom');
      this.body.off('touchstart.zoomdisabler touchend.zoomdisabler');
      return this;
    },


    /**
    * Teardown - Remove added markup and events
    */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$1a);
    }
  };

  /**
   * jQuery Component Wrapper for Zoom
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.zoom = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1a);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1a, new Zoom(this, settings));
      }
    });
  };

  /**
  * A object containing all the supported UI formatters.
  * @private
  */
  var formatters = {
    Text: function Text(row, cell, value) {
      var str = value === null || value === undefined || value === '' ? '' : value.toString();
      return str;
    },
    Input: function Input(row, cell, value, col) {
      if (col.inlineEditor) {
        var html = '<label for="datagrid-inline-input-' + row + '-' + cell + '" class="audible">' + col.name + '</label><input id="datagrid-inline-input-' + row + '-' + cell + '" class="' + (col.align === 'right' ? 'is-number-mask' : '') + '" value="' + value + '">';

        return html;
      }

      var str = value === null || value === undefined || value === '' ? '' : value.toString();
      return str;
    },
    Placeholder: function Placeholder(row, cell, value, col, item) {
      if (col.placeholder && value === '') {
        var placeholder = col.placeholder;
        var getType = {};
        if (getType.toString.call(placeholder) === '[object Function]') {
          placeholder = placeholder(row, cell, value, col, item);
        } else if (item && placeholder in item) {
          placeholder = item[placeholder];
        }
        var html = '<span class="is-placeholder">' + placeholder + '</span>';

        return html;
      }

      var str = value === null || value === undefined || value === '' ? '' : value.toString();
      return str;
    },
    Ellipsis: function Ellipsis(row, cell, value, col) {
      var str = value === null || value === undefined || value === '' ? '' : value.toString();
      col.textOverflow = 'ellipsis';
      return str;
    },
    Password: function Password(row, cell, value) {
      var str = value === null || value === undefined || value === '' ? '' : value.toString();
      return str.replace(/./g, '*');
    },
    Readonly: function Readonly(row, cell, value) {
      return '<span class="is-readonly">' + (value === null || value === undefined ? '' : value) + '</span>';
    },
    Date: function Date(row, cell, value, col, isReturnValue) {
      var formatted = value === null || value === undefined ? '' : value;
      var value2 = void 0;

      if (typeof value === 'string' && value) {
        // Means no date in some applications
        if (value === '0000' || value === '000000' || value === '00000000') {
          return '';
        }

        if (col.sourceFormat) {
          value2 = Locale.parseDate(value, typeof col.sourceFormat === 'string' ? { pattern: col.sourceFormat } : col.sourceFormat);
        } else {
          value2 = Locale.parseDate(value, typeof col.dateFormat === 'string' ? { pattern: col.dateFormat } : col.dateFormat);
        }

        if (value2) {
          formatted = Locale.formatDate(value2, typeof col.dateFormat === 'string' ? { pattern: col.dateFormat } : col.dateFormat);
        } else {
          formatted = Locale.formatDate(value, typeof col.dateFormat === 'string' ? { pattern: col.dateFormat } : col.dateFormat);

          if (formatted === 'NaN/NaN/NaN' || !formatted) {
            // show invalid dates not NA/NA/NA
            formatted = value;
          }
        }
      } else if (value) {
        formatted = Locale.formatDate(value, typeof col.dateFormat === 'string' ? { pattern: col.dateFormat } : col.dateFormat);
      }

      if (!col.editor || isReturnValue === true) {
        return formatted;
      }
      return '<span class="trigger">' + formatted + '</span>' + $.createIcon({ icon: 'calendar', classes: ['icon-calendar'] });
    },
    Time: function Time(row, cell, value, col) {
      var formatted = value === null || value === undefined ? '' : value;
      var localeDateFormat = (typeof Locale === 'undefined' ? 'undefined' : _typeof(Locale)) === 'object' && Locale.calendar().dateFormat ? Locale.calendar().dateFormat.short : null;
      var localeTimeFormat = (typeof Locale === 'undefined' ? 'undefined' : _typeof(Locale)) === 'object' && Locale.calendar().timeFormat ? Locale.calendar().timeFormat : null;
      var value2 = void 0;

      var parseTime = function parseTime(timeString) {
        if (timeString === '') {
          return null;
        }
        var time = timeString.match(/(\d+)(?::(\d\d))(?::(\d\d))?\s*([pP]?)/i);
        if (time === null) {
          return null;
        }
        var d = new Date();
        d.setHours(parseInt(time[1], 10) + (time[4] ? 12 : 0));
        d.setMinutes(parseInt(time[2], 10) || 0);
        d.setSeconds(parseInt(time[3], 10) || 0);
        return d;
      };

      if (typeof value === 'string' && value) {
        value2 = Locale.formatDate(parseTime(value), { pattern: localeDateFormat + ' ' + (col.sourceFormat || col.timeFormat || localeTimeFormat) });

        if (value2) {
          formatted = value2.slice(value2.indexOf(' '));
        }
      } else if (value) {
        value2 = Locale.formatDate(value, { pattern: localeDateFormat + ' ' + (col.sourceFormat || col.timeFormat || localeTimeFormat) });
        if (value2) {
          formatted = value2.slice(value2.indexOf(' '));
        }
      }

      // Remove extra space in begining
      formatted = formatted.replace(/^\s/, '');

      if (!col.editor) {
        return formatted;
      }
      return '<span class="trigger">' + formatted + '</span>' + $.createIcon({ icon: 'clock', classes: ['icon-clock'] });
    },
    Autocomplete: function Autocomplete(row, cell, value) {
      var formatted = value === null || value === undefined ? '' : value;
      return formatted;
    },
    Lookup: function Lookup(row, cell, value, col, item) {
      var formatted = value === null || value === undefined ? '' : value;

      if (!col.editor) {
        return formatted;
      }

      if (col.editorOptions && typeof col.editorOptions.field === 'function') {
        formatted = col.editorOptions.field(item, null, null);
      }

      return '<span class="trigger ' + (col.align === 'right' ? 'align-text-right' : '') + '">' + formatted + '</span>' + $.createIcon({ icon: 'search-list', classes: ['icon-search-list'] });
    },
    Decimal: function Decimal(row, cell, value, col) {
      var formatted = value;
      if (typeof Locale !== 'undefined' && formatted !== null && formatted !== undefined && formatted !== '') {
        formatted = Locale.formatNumber(value, col.numberFormat);
      }
      return formatted === null || formatted === undefined || formatted === 'NaN' ? '' : formatted;
    },
    Integer: function Integer(row, cell, value, col) {
      var formatted = value;
      if (typeof Locale !== 'undefined' && formatted !== null && formatted !== undefined && formatted !== '') {
        formatted = Locale.formatNumber(value, col.numberFormat || { style: 'integer' });
      }
      return formatted === null || formatted === undefined || formatted === 'NaN' ? '' : formatted;
    },
    Hyperlink: function Hyperlink(row, cell, value, col, item, api) {
      var colHref = col.href || '#';

      // Support for dynamic links based on content
      if (col.href && typeof col.href === 'function') {
        colHref = col.href(row, cell, item, col);
        // Passing a null href will produce "just text" with no link
        if (colHref == null) {
          return col.text || value;
        }
      } else {
        colHref = colHref.replace('{{value}}', value);
      }

      var textValue = col.text || value;
      if (!textValue && !col.icon) {
        return '';
      }

      return col.icon ? '<a href="' + colHref + '" class="btn-icon row-btn ' + (col.cssClass || '') + '" ' + (!api.settings.rowNavigation ? '' : 'tabindex="-1"') + (col.hyperlinkTooltip ? ' title="' + col.hyperlinkTooltip + '"' : '') + '>\n          ' + $.createIcon({ icon: col.icon, file: col.iconFile }) + '\n          <span class="audible">' + textValue + '</span>\n        </a>' : '<a href="' + colHref + '" ' + (!api.settings.rowNavigation ? '' : 'tabindex="-1"') + ' role="presentation" class="hyperlink ' + (col.cssClass || '') + '"' + (col.target ? ' target="' + col.target + '"' : '') + (col.hyperlinkTooltip ? ' title="' + col.hyperlinkTooltip + '"' : '') + '>' + textValue + '</a>';
    },
    Template: function Template(row, cell, value, col, item) {
      var tmpl = col.template;
      var renderedTmpl = '';

      if (Tmpl && item && tmpl) {
        renderedTmpl = Tmpl.compile('{{#dataset}}' + tmpl + '{{/dataset}}', { dataset: item });
      }

      return renderedTmpl;
    },
    Drilldown: function Drilldown() {
      var text = Locale.translate('Drilldown');

      if (text === undefined) {
        text = '';
      }

      return '<button type="button" tabindex="-1" class="btn-icon small datagrid-drilldown">\n         ' + $.createIcon({ icon: 'drilldown' }) + '\n        <span>' + text + '</span>\n      </button>';
    },
    RowReorder: function RowReorder() {
      var text = Locale.translate('ReorderRows');

      if (text === undefined) {
        text = 'Reorder Rows';
      }

      return '<div class="datagrid-reorder-icon">\n         ' + $.createIcon({ icon: 'drag' }) + '\n        <span class="audible">' + text + '</span>\n      </div>';
    },
    Checkbox: function Checkbox(row, cell, value, col, item, api) {
      var isChecked = void 0;

      // Use isChecked function if exists
      if (col.isChecked) {
        isChecked = col.isChecked(value);
      } else {
        // treat 1, true or '1' as checked
        isChecked = value === undefined ? false : value === true;
      }

      // We add hidden Yes/No text so that the exported excel spreadsheet shows
      // this text in checkbox columns
      var hiddenText = '<span class="hidden" aria-hidden="true" role="presentation"> ' + Locale.translate(isChecked ? 'Yes' : 'No') + '</span>';

      var animate = api.wasJustUpdated;
      api.wasJustUpdated = false;
      return '<div class="datagrid-checkbox-wrapper"><span role="checkbox" aria-label="' + col.name + '" class="datagrid-checkbox\n     ' + (isChecked ? 'is-checked ' + (!animate ? ' no-animation' : ' ') : '') + '" aria-checked="' + isChecked + '"></span>' + hiddenText + '</div>';
    },
    SelectionCheckbox: function SelectionCheckbox(row, cell, value, col, item, api) {
      var isChecked = value === undefined ? false : value === true;
      if (!value) {
        isChecked = api.isNodeSelected(item);
      }
      return '<div class="datagrid-checkbox-wrapper"><span role="checkbox" aria-label="' + (col.name ? col.name : Locale.translate('Select')) + '" class="datagrid-checkbox datagrid-selection-checkbox' + (isChecked ? ' is-checked no-animate' : '') + '" aria-checked="' + isChecked + '"></span></div>';
    },
    Actions: function Actions(row, cell, value, col) {
      // Render an Action Formatter
      return '<button type="button" class="btn-actions" aria-haspopup="true" aria-expanded="false" aria-owns="' + col.menuId + ' +\'">\n        <span class="audible">' + col.title + '</span>\n        ' + $.createIcon({ icon: 'more' }) + '\n      </button>';
    },


    // Multi Line TextArea
    Textarea: function Textarea(row, cell, value) {
      var formatted = value === null || value === undefined ? '' : value;
      return '<span class="datagrid-multiline-text">' + formatted + '</span>';
    },


    // Rich Text Editor
    Editor: function Editor(row, cell, value, col) {
      var formatted = value === null || value === undefined ? '' : value;
      var classes = 'is-editor';
      classes += col.singleline ? ' is-singleline' : ' datagrid-multiline-text';
      classes += col.contentTooltip ? ' content-tooltip' : '';
      return '<div class="' + classes + '">' + xssUtils.unescapeHTML(formatted) + '</div>';
    },


    // Expand / Collapse Button
    Expander: function Expander(row, cell, value) {
      var button = '<button type="button" aria-label="' + Locale.translate('ExpandCollapse') + '" class="btn-icon datagrid-expand-btn" tabindex="-1">\n      <span class="icon plus-minus"></span>\n      </button>' + (value ? '<span> ' + value + '</span>' : '');

      return button;
    },


    // Datagrid Group Row
    GroupRow: function GroupRow(row, cell, value, col, item, api) {
      var groupSettings = api.settings.groupable;
      var groups = '';
      var isOpen = groupSettings.expanded === undefined ? true : groupSettings.expanded;

      if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
        isOpen = groupSettings.expanded(row, cell, value, col, item, api);
      }

      for (var i = 0; i < groupSettings.fields.length; i++) {
        groups += item[groupSettings.fields[i]] + (i === 0 ? '' : ',');
      }

      if (groupSettings.groupRowFormatter) {
        groups = groupSettings.groupRowFormatter(row, cell, value, col, item, api);
      }

      var button = '<button type="button" class="btn-icon datagrid-expand-btn' + (isOpen ? ' is-expanded' : '') + '" tabindex="-1">\n    <span class="icon plus-minus' + (isOpen ? ' active' : '') + '"></span>\n    <span class="audible">' + Locale.translate('ExpandCollapse') + '</span>\n    </button><span> ' + groups + '</span>';

      return button;
    },
    GroupFooterRow: function GroupFooterRow(row, cell, value, col, item, api) {
      var groupSettings = api.settings.groupable;
      // eslint-disable-next-line
      var isOpen = groupSettings.expanded === undefined ? true : groupSettings.expanded;

      if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
        isOpen = groupSettings.expanded(row, cell, value, col, item, api);
      }

      var idx = api.columnIdxById(groupSettings.aggregate);
      var html = '<td role="gridcell" colspan=' + idx + '><div class="datagrid-cell-wrapper"></div></td><td role="gridcell"><div class="datagrid-cell-wrapper"> ' + item.sum + '</div></td>';

      if (groupSettings.groupFooterRowFormatter) {
        html = groupSettings.groupFooterRowFormatter(idx, row, cell, value, col, item, api);
      }

      return html;
    },
    SummaryRow: function SummaryRow(row, cell, value, col) {
      var afterText = '';
      var beforeText = col.summaryText || '<b class="datagrid-summary-totals">' + Locale.translate('Total') + ' </b>';

      if (col.summaryTextPlacement === 'after') {
        afterText = beforeText;
        beforeText = '';
      }

      if (typeof Locale !== 'undefined' && col.numberFormat && value !== null && value !== undefined && value !== '') {
        value = Locale.formatNumber(+value, col.numberFormat);
      }

      return beforeText + (value === null || value === undefined || value === '' ? '' : value.toString()) + afterText;
    },


    // Tree Expand / Collapse Button and Paddings
    Tree: function Tree(row, cell, value, col, item) {
      var isOpen = item ? item.expanded : true;
      var depth = item && item.depth ? item.depth : 0;
      var button = '<button type="button" class="btn-icon datagrid-expand-btn' + (isOpen ? ' is-expanded' : '') + '" tabindex="-1"' + (depth ? ' style="margin-left: ' + (depth ? 30 * (depth - 1) + 'px' : '') + '"' : '') + '>\n      <span class="icon plus-minus ' + (isOpen ? ' active' : '') + '"></span>\n      <span class="audible">' + Locale.translate('ExpandCollapse') + '</span>\n      </button>' + (value ? '<span> ' + value + '</span>' : '');
      var node = '<span class="datagrid-tree-node"' + (depth ? ' style="margin-left: ' + (depth ? 30 * (depth - 1) + 'px' : '') + '"' : '') + '> ' + value + '</span>';

      return item && item[col.children ? col.children : 'children'] ? button : node;
    },


    // Badge / Tags and Visual Indictors
    ClassRange: function ClassRange(row, cell, value, col) {
      var ranges = col.ranges;
      var classes = '';
      var text = '';

      if (!ranges) {
        return {};
      }

      for (var i = 0; i < ranges.length; i++) {
        if (value >= ranges[i].min && value <= ranges[i].max) {
          classes = ranges[i].classes;
          text = ranges[i].text ? ranges[i].text : classes.split(' ')[0];
        }

        if (value === ranges[i].value) {
          classes = ranges[i].classes;
          text = ranges[i].text ? ranges[i].text : value;
        }
      }

      return { classes: classes, text: text };
    },


    // Badge (Visual Indictors)
    Badge: function Badge(row, cell, value, col) {
      var colorClasses = col.color;
      var text = col.name;

      if (col.ranges) {
        var ranges = formatters.ClassRange(row, cell, value, col);
        colorClasses = ranges.classes;
        text = ranges.text;
      }
      return '<span class="badge ' + colorClasses + '">' + value + ' <span class="audible">' + text + '</span></span>';
    },
    Tag: function Tag(row, cell, value, col) {
      var ranges = formatters.ClassRange(row, cell, value, col);
      return '<span class="tag ' + ranges.classes + '">' + value + '</span>';
    },
    Alert: function Alert(row, cell, value, col) {
      var ranges = formatters.ClassRange(row, cell, value, col);
      var icon = $.createIcon({
        icon: ranges.classes,
        classes: ['icon', 'datagrid-alert-icon', 'icon-' + ranges.classes]
      });
      return icon + '<span class="datagrid-alert-text">' + (ranges.text === 'value' ? value : ranges.text) + '</span>';
    },
    Image: function Image(row, cell, value, col) {
      return '<img class="datagrid-img" src="' + value + '" alt="' + (col.alt ? col.alt : Locale.translate('Image')) + '"' + (col.dimensions ? ' style="height:' + col.dimensions.height + ';width:' + col.dimensions.height + '"' : '') + '/>';
    },
    Color: function Color(row, cell, value, col) {
      var ranges = formatters.ClassRange(row, cell, value, col);
      var text = value === null || value === undefined || value === '' ? '' : value.toString();

      return '<span class="' + ranges.classes + '">' + text + '</span>';
    },
    Colorpicker: function Colorpicker(row, cell, value, col) {
      var html = value === null || value === undefined || value === '' ? '' : value.toString();
      if (col.inlineEditor) {
        return html;
      }
      var classList = 'swatch' + (value === '' ? ' is-empty' : '');
      html = '<span class="colorpicker-container trigger dropdown-trigger"><span class="' + classList + '" style="background-color: ' + value + '"></span><input class="colorpicker" id="colorpicker-' + cell + '" name="colorpicker-' + cell + '" type="text" role="combobox" aria-autocomplete="list" value="' + value + '" aria-describedby="">';
      html += '<span class="trigger">' + $.createIcon({ icon: 'dropdown' }) + '</span></span>';

      return html;
    },
    Button: function Button(row, cell, value, col, item, api) {
      var text = void 0;
      if (col.text) {
        text = col.text;
      } else {
        text = value === null || value === undefined || value === '' ? '' : value.toString();
      }
      var markup = '<button type="button" class="' + (col.icon ? 'btn-icon' : 'btn-secondary') + ' row-btn ' + (col.cssClass ? col.cssClass : '') + '"' + (!api.settings.rowNavigation ? '' : ' tabindex="-1"') + ' >';

      if (col.icon) {
        markup += $.createIcon({ icon: col.icon, file: col.iconFile });
      }
      markup += '<span>' + text + '</span></button>';

      return markup;
    },
    Dropdown: function Dropdown(row, cell, value, col) {
      var formattedValue = value;
      var compareValue = void 0;
      var option = void 0;
      var optionValue = void 0;

      if (col.options && value !== undefined) {
        compareValue = col.caseInsensitive && typeof value === 'string' ? value.toLowerCase() : value;

        for (var i = 0, l = col.options.length; i < l; i++) {
          option = col.options[i];
          optionValue = col.caseInsensitive && typeof option.value === 'string' ? option.value.toLowerCase() : option.value;

          if (optionValue === compareValue) {
            formattedValue = option.label;
            break;
          }
        }
      }

      var html = '<span class="trigger dropdown-trigger">' + formattedValue + '</span>' + $.createIcon({ icon: 'dropdown' });

      if (col.inlineEditor) {
        html = '<label for="full-dropdown" class="audible">' + col.name + '</label><select id="datagrid-dropdown' + row + '" class="dropdown">';

        for (var _i = 0, _l = col.options.length; _i < _l; _i++) {
          var opt = col.options[_i];
          var labelOrValue = void 0;
          if (opt.label !== undefined) {
            labelOrValue = opt.label;
          } else {
            labelOrValue = opt.value !== undefined ? opt.value : '';
          }
          html += '<option' + (opt.id === undefined ? '' : ' id="' + opt.id + '"') + '  value="' + opt.value + '"' + (opt.selected || opt.value === compareValue ? ' selected ' : '') + '>' + labelOrValue + '</option>';
        }

        html += '</select>\n      <div class="dropdown-wrapper is-inline">\n        <div class="dropdown"><span>' + formattedValue + '</span></div>\n        <svg class="icon" focusable="false" aria-hidden="true" role="presentation">\n          <use xlink:href="#icon-dropdown"></use>\n        </svg>\n      </div>';
      }

      return html;
    },
    Fileupload: function Fileupload(row, cell, value, col) {
      var html = value === null || value === undefined || value === '' ? '' : value.toString();

      if (!col.inlineEditor) {
        if ($.trim(html) === '') {
          html = '<span class="trigger">' + html + '</span>' + $.createIcon({ icon: 'folder', classes: ['icon-fileupload'] });
        } else {
          html = '<span class="trigger is-clearable">' + html + '</span>' + $.createIcon({ icon: 'close', classes: ['icon-close'] }) + $.createIcon({ icon: 'folder', classes: ['icon-fileupload'] });
        }
      }

      return html;
    },
    Spinbox: function Spinbox(row, cell, value, col) {
      var html = value === null || value === undefined || value === '' ? '' : value.toString();

      if (col.inlineEditor) {
        html = '<label for="spinbox-' + cell + '" class="audible">Quantity</label>\n        <span class="spinbox-wrapper"><span class="spinbox-control down">-</span>\n        <input id="spinbox-' + cell + '" name="spinbox-' + cell + '" type="text" class="spinbox" value="' + value + '">\n        <span class="spinbox-control up">+</span></span>';
      }

      return html;
    },
    Favorite: function Favorite(row, cell, value, col, item, api) {
      var isChecked = void 0;

      // Use isChecked function if exists
      if (col.isChecked) {
        isChecked = col.isChecked(value);
      } else {
        isChecked = value === undefined ? false : value === true;
      }

      var isEditable = col.editor && api.settings.editable;

      if (isChecked) {
        return '<span aria-label="' + Locale.translate('Favorite') + '" class="icon-favorite' + (isEditable ? ' is-editable' : '') + '">' + $.createIcon({ icon: 'star-filled' }) + '</span>';
      }
      return col.showEmpty ? '<span aria-label="' + Locale.translate('Favorite') + '" class="icon-favorite' + (isEditable ? ' is-editable' : '') + '">' + $.createIcon({ icon: 'star-outlined' }) + '</span>' : '';
    },
    Status: function Status(row, cell, value, col, item) {
      if (!item || !item.rowStatus) {
        return '<span></span>';
      }

      return $.createIcon({ icon: item.rowStatus.icon, classes: ['icon', 'icon-' + item.rowStatus.icon] }) + '<span class="audible">' + item.rowStatus.text + '</span>';
    },
    TargetedAchievement: function TargetedAchievement(row, cell, value, col) {
      var perc = 100 * value;
      var text = perc + '%';
      var ranges = formatters.ClassRange(row, cell, perc, col);
      var target = col.target;
      var isWhite = perc > 60;

      if (col.text) {
        text = col.text;
        text = text.replace('{{value}}', value);
        text = text.replace('<% value %>', value);
        text = text.replace('<%value%>', value);

        text = text.replace('{{percent}}', perc);
        text = text.replace('<% percent %>', perc);
        text = text.replace('<%percent%>', perc);

        col.showPercentText = true;
        isWhite = perc > 75;
      }

      var barClass = col.ranges && ranges.classes ? ranges.classes : 'primary';
      return '<div class="total bar chart-completion-target chart-targeted-achievement">\n              <div class="target remaining bar" style="width: ' + (target || 0) + '%;"></div>\n              <div class="completed bar ' + barClass + '" style="width: ' + perc + '%;"></div>\n              ' + (col.showPercentText ? '<div class="chart-targeted-text l-center" ' + (isWhite ? 'style="color: white"' : '') + '>' + text + '</div>\n            </div>' : '');
    }

    // TODO Possible future Formatters
    // Multi Select
    // Sparkline
    // Progress Indicator (n of 100%)
    // Process Indicator
    // File Upload (Simple)
    // Menu Button
    // Color Picker (Low)
    // Radio

  };

  /**
  *  A object containing all the supported Editors
  * @private
  */
  var editors = {

    // Supports, Text, Numeric, Integer via mask
    Input: function Input(row, cell, value, container, column, e, api, item) {
      this.name = 'input';
      this.originalValue = value;
      this.useValue = !!column.inlineEditor;

      this.init = function () {
        if (column.inlineEditor) {
          this.input = container.find('input');
        } else {
          this.input = $('<input type="' + (column.inputType || 'text') + '"/>').appendTo(container);
        }

        if (column.align) {
          this.input.addClass('l-' + column.align + '-text');
        }

        if (column.maxLength) {
          this.input.attr('maxlength', column.maxLength);
        }

        if (column.uppercase) {
          this.input.addClass('uppercase-text');
        }

        if (column.mask && typeof column.mask === 'function') {
          var mask = column.mask(row, cell, value, column, item);
          this.input.mask({ pattern: mask, mode: column.maskMode });
        } else if (column.maskOptions && typeof column.maskOptions === 'function') {
          var maskOptions = column.maskOptions(row, cell, value, column, item);
          this.input.mask(maskOptions);
        } else if (column.mask) {
          this.input.mask({ pattern: column.mask, mode: column.maskMode });
        }

        var defaults$$1 = {
          patternOptions: {
            allowNegative: true,
            allowDecimal: true,
            integerLimit: 4,
            decimalLimit: 2,
            symbols: {
              thousands: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.group : ',',
              decimal: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.decimal : '.',
              negative: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.minusSign : '-'
            }
          },
          process: 'number'
        };

        var useMask = false;

        if (column.maskOptions) {
          useMask = true;
        }

        if (column.numberFormat) {
          useMask = true;
          defaults$$1 = { patternOptions: { decimalLimit: column.numberFormat.maximumFractionDigits } };
        }

        if (column.maskOptions && typeof column.maskOptions === 'function') {
          useMask = false;
        }

        if (useMask) {
          column.maskOptions = utils.extend(true, {}, defaults$$1, column.maskOptions);
          this.input.mask(column.maskOptions);
        }

        if (!column.align || column.align !== 'right') {
          this.input.removeClass('is-number-mask');
        }
      };

      this.val = function (v) {
        var thisValue = void 0;
        if (v) {
          this.input.val(v);
        }
        if (column && column.numberFormat && column.numberFormat.style === 'percent') {
          thisValue = this.input.val().trim().replace(/(\s%?|%)$/g, '');
          return Locale.parseNumber(thisValue) / 100;
        }
        return this.input.val();
      };

      this.focus = function () {
        this.input.focus().select();
      };

      this.destroy = function () {
        var _this = this;

        if (column.inlineEditor) {
          return;
        }

        setTimeout(function () {
          _this.input.remove();
        }, 0);
      };

      this.init();
    },
    Textarea: function Textarea(row, cell, value, container, column) {
      this.name = 'textarea';
      this.originalValue = value;

      this.init = function () {
        this.input = $('<textarea class="textarea"></textarea>').appendTo(container);

        if (column.maxLength) {
          this.input.attr('maxlength', column.maxLength);
        }

        if (column.uppercase) {
          this.input.addClass('uppercase-text');
        }
      };

      this.val = function (v) {
        if (v) {
          // note that focus will help move text to end of input.
          this.input.focus().val(v);
        }
        return this.input.val();
      };

      this.focus = function () {
        this.input.focus();
      };

      this.destroy = function () {
        var _this2 = this;

        setTimeout(function () {
          _this2.input.remove();
        }, 0);
      };

      this.init();
    },


    // Rich Text Editor
    Editor: function Editor(row, cell, value, container, column, e, api) {
      this.name = 'editor';
      this.originalValue = value;

      this.init = function () {
        var self = this;
        // Editor options
        var editorOptions = $.extend({}, {
          buttons: { editor: ['bold', 'italic', 'underline', 'strikethrough', 'separator', 'foreColor'], source: [] },
          excludeButtons: { editor: [] }
        }, column.editorOptions);

        // Editor width
        this.editorWidth = api.setUnit(editorOptions.width || container.outerWidth());
        delete editorOptions.width;

        container[0].innerHTML = '<div class="editor-wrapper" style="width: ' + this.editorWidth + ';">\n          <div class="editor" data-init="false">' + xssUtils.unescapeHTML(value) + '</div>\n        </div>';
        this.td = container.closest('td');
        this.input = $('.editor', container);

        this.input.popover({
          content: $('.editor-wrapper', container),
          placementOpts: {
            x: 0,
            y: '-' + (parseInt(container[0].style.height, 10) + 35),
            parent: this.td,
            parentXAlignment: Locale.isRTL() ? 'right' : 'left',
            strategies: ['flip', 'nudge', 'shrink']
          },
          placement: 'bottom',
          popover: true,
          trigger: 'immediate',
          tooltipElement: '#editor-popup',
          extraClass: 'editor-popup'
        }).editor(editorOptions).on('hide.editor', function () {
          api.commitCellEdit(self.input);
        }).on('keydown.editor', function (event) {
          var key = event.which || event.keyCode || event.charCode || 0;
          // Ctrl + Enter (Some browser return keyCode: 10, not 13)
          if ((event.ctrlKey || event.metaKey) && (key === 13 || key === 10)) {
            var apiPopover = self.input.data('tooltip');
            if (apiPopover) {
              apiPopover.hide();
              api.setNextActiveCell(event);
            }
          }
        });
        utils.fixSVGIcons($('#editor-popup'));
      };

      this.val = function () {
        return this.input.html();
      };

      this.focus = function () {
        var _this3 = this;

        setTimeout(function () {
          _this3.input.focus();
        }, 0);
      };

      this.destroy = function () {
        var self = this;
        container.removeAttr('style');
        api.quickEditMode = false;
        self.input.off('hide.editor keydown.editor');
        setTimeout(function () {
          self.input.remove();
          // Reset tooltip
          var elem = self.td.find('.is-editor.content-tooltip');
          api.setupContentTooltip(elem, self.editorWidth);
        }, 0);
      };

      this.init();
    },
    Checkbox: function Checkbox(row, cell, value, container, column, event, grid) {
      this.name = 'checkbox';
      this.originalValue = value;
      this.useValue = true; // use the data set value not cell value
      this.container = container;

      this.init = function () {
        this.input = $('<input type="checkbox" class="checkbox"/>').appendTo(container);
        this.input.after('<label class="checkbox-label"></label>');

        if (column.align) {
          this.input.addClass('l-' + column.align + '-text');
        }
      };

      this.val = function (v) {
        // eslint-disable-line
        var isChecked = void 0;

        if (v === undefined) {
          return this.input.prop('checked');
        }

        // Use isChecked function if exists
        if (column.isChecked) {
          isChecked = column.isChecked(v);
        } else {
          isChecked = v;
        }

        // just toggle it if we click right on it
        if ((event.type === 'click' || event.type === 'keydown' && event.keyCode === 32) && !$(event.target).is('.datagrid-checkbox-wrapper, .datagrid-cell-wrapper')) {
          isChecked = !isChecked;
          grid.setNextActiveCell(event);
        }

        this.input.prop('checked', isChecked);
      };

      this.focus = function () {
        this.input.trigger('focusout');
        this.container.parent().focus();
      };

      this.destroy = function () {
        var _this4 = this;

        setTimeout(function () {
          _this4.input.next('.checkbox-label').remove();
          _this4.input.remove();
        }, 0);
      };

      this.init();
    },
    Colorpicker: function Colorpicker(row, cell, value, container, column, event, grid) {
      this.name = 'colorpicker';
      this.originalValue = value;
      this.useValue = true; // use the data set value not cell value
      value = xssUtils.stripTags(value);

      this.init = function () {
        this.input = $('<input id="colorpicker-' + cell + '" name="colorpicker-' + cell + '" class="colorpicker" value="' + value + '" type="text" />').appendTo(container);
        this.input.colorpicker(column.editorOptions);
      };

      this.val = function (v) {
        return v ? this.input.val(v) : this.input.val();
      };

      this.focus = function () {
        var self = this;

        this.input.trigger('openlist');
        this.input.focus().select();

        this.input.off('listclosed').on('listclosed', function () {
          grid.commitCellEdit(self.input);

          container.parent('td').focus();
          return; // eslint-disable-line
        });
      };

      this.destroy = function () {
        // We dont need to destroy since it will when the list is closed
      };

      this.init();
    },
    Dropdown: function Dropdown(row, cell, value, container, column, event, grid, rowData) {
      this.name = 'dropdown';
      this.originalValue = value;
      this.useValue = true; // use the data set value not cell value
      this.cell = grid.activeCell;

      this.init = function () {
        if (column.inlineEditor) {
          this.input = container.find('select');
          return;
        }

        this.input = $('<select class="dropdown"></select>').appendTo(container);

        if (column.options) {
          var html = void 0;
          var opt = void 0;
          var optionValue = void 0;
          value = grid.fieldValue(rowData, column.field);

          var compareValue = column.caseInsensitive && typeof value === 'string' ? value.toLowerCase() : value;

          for (var i = 0; i < column.options.length; i++) {
            html = $('<option></option>');
            opt = column.options[i];
            optionValue = column.caseInsensitive && typeof opt.value === 'string' ? opt.value.toLowerCase() : opt.value;

            if (opt.selected || compareValue === optionValue) {
              html.attr('selected', 'true');
              this.originalValue = optionValue;
            }

            html.attr('value', opt.value).attr('id', opt.id).attr('data-type', _typeof(opt.value));
            html.text(opt.label);
            this.input.append(html);
          }
        }

        var editorOptions = column.editorOptions || {};

        function hasEditingClass() {
          return editorOptions.cssClass && /is-editing/g.test(editorOptions.cssClass);
        }
        // Add the class to both the options being passed, as well as the column's original options
        if (!hasEditingClass()) {
          editorOptions.cssClass = editorOptions.cssClass || '';
          editorOptions.cssClass += ' is-editing';
        }

        this.input.dropdown(editorOptions);

        // Append the Dropdown's sourceArguments with some row/col meta-data
        var api = this.input.data('dropdown');
        api.settings.sourceArguments = {
          column: column,
          container: container,
          grid: grid,
          cell: cell,
          event: event,
          row: row,
          rowData: rowData,
          value: value
        };
      };

      this.val = function (v) {
        if (v !== undefined) {
          var compareValue = column.caseInsensitive && typeof v === 'string' ? v.toLowerCase() : v;
          this.input.val(v);

          this.input.find('option').each(function () {
            var opt = $(this);
            var valueAttr = opt.attr('value');
            var type = opt.attr('data-type');
            var optionValue = valueAttr;

            // Get option value in proper type before checking equality
            if (type === 'number') {
              optionValue = parseFloat(valueAttr);
            } else if (type === 'boolean') {
              optionValue = valueAttr === 'true';
            } else if (type === 'string' && column.caseInsensitive) {
              optionValue = valueAttr.toLowerCase();
            }

            if (optionValue === compareValue) {
              opt.attr('selected', 'true');
            }
          });
        }

        var selected = this.input.find(':selected');
        var val = selected.attr('value');
        var dataType = selected.attr('data-type');

        // For non-string option values (number, boolean, etc.),
        // convert string attr value to proper type
        if (dataType === 'number') {
          val = parseFloat(val);
        } else if (dataType === 'boolean') {
          val = val === 'true';
        }

        if (val === undefined) {
          val = selected.text();
        }

        return val;
      };

      this.focus = function () {
        var self = this;

        // Check if isClick or cell touch and just open the list
        if (event.type === 'click') {
          this.input.trigger('openlist');
        }
        this.input[0].parentNode.querySelector('div.dropdown').focus();

        this.input.off('listclosed').on('listclosed', function (e, type) {
          grid.commitCellEdit(self.input);

          if (type === 'select') {
            container.parent('td').focus();
            return;
          }

          if (type === 'tab') {
            setTimeout(function () {
              container.parent('td').focus();
            }, 100);
          }
        });
      };

      this.destroy = function () {
        // We dont need to destroy since it will when the list is closed
      };

      this.init();
    },
    Date: function Date(row, cell, value, container, column, event, grid) {
      this.name = 'date';
      this.originalValue = value;

      this.init = function () {
        this.input = $('<input class="datepicker"/>').appendTo(container);
        this.input.datepicker(column.editorOptions || { dateFormat: column.dateFormat });
      };

      this.val = function (v) {
        if (v) {
          // Note that the value should be formatted from the formatter.
          this.input.val(v);
        }
        return formatters.Date(row, cell, this.input.val(), column, true);
      };

      this.focus = function () {
        var self = this;

        this.input.select().focus();

        // Check if isClick or cell touch and just open the list
        if (event.type === 'click' && $(event.target).is('.icon')) {
          this.input.parent().find('.icon').trigger('click');
          this.input.closest('td').addClass('is-focused');
        }

        this.input.on('listclosed', function () {
          self.input.closest('td').removeClass('is-focused');

          setTimeout(function () {
            self.input.trigger('focusout');
            container.parent().focus();
            grid.setNextActiveCell(event);
          }, 1);
        });
      };

      this.destroy = function () {
        var _this5 = this;

        setTimeout(function () {
          grid.quickEditMode = false;
          _this5.input.remove();
        }, 0);
      };

      this.init();
    },
    Fileupload: function Fileupload(row, cell, value, container, column, event, grid) {
      var _this6 = this;

      var s = utils.mergeSettings(undefined, column.editorOptions, {
        allowedTypes: '*' // restrict file types(ie. 'jpg|png|gif') ['*' all types]
      });
      var fileExtensions = s.allowedTypes.split(/[\s|]+/g);
      var id = utils.uniqueId(this, 'fileupload-' + row + '-' + cell + '-');

      var multiple = s.useMultiple ? ' multiple' : '';
      var disabled = s.isDisabled ? ' disabled' : '';
      var types = '';

      if (fileExtensions.length === 1) {
        if (fileExtensions[0] !== '*') {
          types = '.' + xssUtils.ensureAlphaNumeric(fileExtensions[0]);
        }
      } else {
        for (var i = 0, l = fileExtensions.length; i < l; i++) {
          types += '.' + (xssUtils.ensureAlphaNumeric(fileExtensions[i]) + (i !== l - 1 ? ',' : ''));
        }
      }
      if (types !== '') {
        types = ' accept="' + types + '"';
      }

      this.name = 'fileupload';
      this.originalValue = value;
      this.status = 'init';
      this.useValue = true; // use the data set value not cell value

      this.init = function () {
        id = xssUtils.ensureAlphaNumeric(id);
        multiple = xssUtils.ensureAlphaNumeric(multiple);
        disabled = xssUtils.ensureAlphaNumeric(disabled);

        this.input = $('<input id="' + id + '" name="' + id + '" class="fileupload" type="file" ' + types + multiple + disabled + ' />');
        container.append('<label>' + this.input[0].outerHTML + '</label>');
        this.api = this.input.fileupload(column.editorOptions).data('fileupload');
        this.input.closest('td').addClass('is-fileupload').find('label:eq(1)').addClass('audible');
      };

      this.val = function (v) {
        if (v) {
          v = xssUtils.stripTags(v);
          this.input.attr('value', v);
          return v;
        }
        return this.input.val();
      };

      this.focus = function () {
        /**
         * Handle cancel on file-input
         * Bind body to listen one time only, right after file chooser window popup open
         * Listen on body `focusin`(on close popup window),
         * if no `change` event triggered means it canceled
         * @private
         * @returns {void}
         */
        var handleCancel = function handleCancel() {
          $('body').one('focusin.fileuploadeditor', function () {
            setTimeout(function () {
              if (_this6.status !== 'change') {
                _this6.status = 'cancel';
                grid.commitCellEdit(_this6.input);
              }
            }, 100);
          });
        };

        /**
         * Handle clear the value on file-input
         * @private
         * @returns {void}
         */
        var handleClear = function handleClear() {
          if (_this6.originalValue !== '') {
            _this6.status = 'clear';
          }
          grid.commitCellEdit(_this6.input);
        };

        /**
         * Open file chooser popup window for file-input
         * @private
         * @returns {void}
         */
        var openFileChooserWindow = function openFileChooserWindow() {
          if (_this6.api) {
            handleCancel();
            _this6.api.fileInput.trigger('click');
          }
        };

        // Handle change for file-input
        _this6.input.on('change.fileuploadeditor', function () {
          _this6.status = 'change';
          grid.commitCellEdit(_this6.input);
        });

        // Using keyboard
        if (event.type === 'keydown') {
          var key = event.which || event.keyCode || event.charCode || 0;

          if (key === 8 || key === 46) {
            // Backspace: 8, Delete: 46
            handleClear();
          } else if (key === 13 || key === 10) {
            // Enter (Some browser return keyCode: 10, not 13)
            openFileChooserWindow();
          } else {
            grid.commitCellEdit(_this6.input);
          }
        }

        // Check if isClick or cell touch
        if (event.type === 'click') {
          var target = $(event.target);
          if (target.is('.icon-close')) {
            handleClear();
          } else if (target.is('.icon-fileupload')) {
            openFileChooserWindow();
          } else {
            grid.commitCellEdit(_this6.input);
          }
        }
      };

      this.destroy = function () {
        _this6.input.off('change.fileuploadeditor');
        grid.quickEditMode = false;
        if (_this6.api) {
          _this6.api.destroy();
        }
      };

      this.init();
    },
    Time: function Time(row, cell, value, container, column, event, grid) {
      this.name = 'time';
      this.originalValue = value;

      this.init = function () {
        this.input = $('<input class="timepicker"/>').appendTo(container);
        this.api = this.input.timepicker(column.editorOptions || '').data('timepicker');
      };

      this.val = function (v) {
        if (v) {
          // Note that the value should be formatted from the formatter.
          this.input.val(v);
        }

        return this.input.val();
      };

      this.focus = function () {
        var self = this;

        this.input.select().focus();

        // Check if isClick or cell touch and just open the list
        if (event.type === 'click' && $(event.target).is('.icon')) {
          this.input.parent().find('.icon').trigger('click');
          this.input.closest('td').addClass('is-focused');
        }

        this.api.trigger.on('hide.editortime', function () {
          self.input.closest('td').removeClass('is-focused');

          setTimeout(function () {
            self.input.trigger('focusout');
            container.parent().focus();
            grid.setNextActiveCell(event);
          }, 1);
        });
      };

      this.destroy = function () {
        var self = this;
        if (self.api && self.api.trigger) {
          self.api.trigger.off('hide.editortime');
        }

        setTimeout(function () {
          grid.quickEditMode = false;
          self.input.remove();
        }, 0);
      };

      this.init();
    },
    Lookup: function Lookup(row, cell, value, container, column, event, grid, rowData) {
      this.name = 'lookup';
      this.originalValue = value;

      this.init = function () {
        this.input = $('<input class="lookup ' + (column.align === 'right' ? 'align-text-right' : '') + '" data-init="false" />').appendTo(container);

        if (column.maxLength) {
          this.input.attr('maxlength', column.maxLength);
        }

        if (column.uppercase) {
          this.input.addClass('uppercase-text');
        }

        this.input.lookup(column.editorOptions);

        // Append the Lookup's clickArguments with some row/col meta-data
        var api = this.input.data('lookup');
        api.settings.clickArguments = {
          column: column,
          container: container,
          grid: grid,
          cell: cell,
          event: event,
          row: row,
          rowData: rowData,
          value: value
        };
      };

      this.val = function (v) {
        var fieldValue = this.input.val();
        if (fieldValue && fieldValue.indexOf('|') > -1) {
          fieldValue = fieldValue.substr(0, fieldValue.indexOf('|'));
        }
        return v ? this.input.val(v) : fieldValue;
      };

      this.focus = function () {
        var self = this;
        var api = self.input.data('lookup');
        var td = self.input.closest('td');

        // Using keyboard
        if (event.type === 'keydown') {
          self.input.select().focus();
          td.on('keydown.editorlookup', function (e) {
            if (e.keyCode === 40 && grid.quickEditMode) {
              e.preventDefault();
              e.stopPropagation();
            }
          });
        }

        // Check if isClick or cell touch and just open the list
        if (event.type === 'click') {
          if ($(event.target).is('svg')) {
            api.openDialog(event);
          } else {
            self.input.select().focus();
            td.on('touchcancel.editorlookup touchend.editorlookup', '.trigger', function () {
              api.openDialog();
            });
          }
        }

        // Update on change from lookup
        self.input.on('change', function () {
          setTimeout(function () {
            container.parent().focus();
            grid.setNextActiveCell(event);
            grid.quickEditMode = false;
          }, 1);
        });
      };

      this.destroy = function () {
        var self = this;
        var td = this.input.closest('td');
        setTimeout(function () {
          grid.quickEditMode = false;
          td.off('keydown.editorlookup').find('.trigger').off('touchcancel.editorlookup touchend.editorlookup');
          self.input.remove();
        }, 0);
      };

      this.init();
    },
    Autocomplete: function Autocomplete(ow, cell, value, container, column, event, grid) {
      this.name = 'autocomplete';
      this.originalValue = value;

      this.init = function () {
        this.input = $('<input class="autocomplete datagrid-autocomplete" />').appendTo(container);

        if (!column.editorOptions) {
          column.editorOptions = {};
        }
        column.editorOptions.width = container.parent().width();
        column.editorOptions.offset = { left: -1, top: grid.settings.rowHeight === 'medium' ? 1 : 5 };

        if (column.maxLength) {
          this.input.attr('maxlength', column.maxLength);
        }

        if (column.uppercase) {
          this.input.addClass('uppercase-text');
        }

        this.input.autocomplete(column.editorOptions);
      };

      this.val = function (v) {
        return v ? this.input.val(v) : this.input.val();
      };

      this.focus = function () {
        grid.quickEditMode = true;
        this.input.select().focus();
      };

      this.destroy = function () {
        var _this7 = this;

        setTimeout(function () {
          grid.quickEditMode = false;
          _this7.input.remove();
        }, 0);
      };

      this.init();
    },
    Spinbox: function Spinbox(ow, cell, value, container, column, event, grid) {
      this.name = 'spinbox';
      this.originalValue = value;
      this.useValue = true; // use the data set value not cell value

      this.init = function () {
        if (column.inlineEditor) {
          this.input = container.find('input');
          return;
        }

        var markup = '<label for="spinbox-' + cell + '" class="audible">Quantity</label>\n        <span class="spinbox-wrapper"><span class="spinbox-control down">-</span>\n        <input id="spinbox-' + cell + '" name="spinbox-' + cell + '" type="text" class="spinbox" value="\'+ ' + value + ' +\'">\n        <span class="spinbox-control up">+</span></span>';

        DOM.append(container, markup, '<label><span><input>');
        this.input = container.find('input');

        if (!column.editorOptions) {
          column.editorOptions = {};
        }

        this.input.spinbox(column.editorOptions);
      };

      this.val = function (v) {
        return v ? parseInt(this.input.val(v), 10) : parseInt(this.input.val(), 10);
      };

      this.focus = function () {
        grid.quickEditMode = true;
        this.input.select().focus();
      };

      this.destroy = function () {
        var _this8 = this;

        if (column.inlineEditor) {
          return;
        }

        setTimeout(function () {
          grid.quickEditMode = false;
          _this8.input.remove();
        }, 0);
      };

      this.init();
    },
    Favorite: function Favorite(row, cell, value, container, column, event, grid) {
      this.name = 'favorite';
      this.useValue = true;
      this.originalValue = value;

      this.init = function () {
        this.input = $('<span class="icon-favorite">' + $.createIcon({ icon: value ? 'star-filled' : 'star-outlined' }) + '<input type="checkbox"></span>').appendTo(container);

        this.input = this.input.find('input');
      };

      this.val = function (v) {
        // eslint-disable-line
        var isChecked = void 0;

        if (v === undefined) {
          return this.input.prop('checked');
        }

        // Use isChecked function if exists
        if (column.isChecked) {
          isChecked = column.isChecked(v);
        } else {
          isChecked = v;
        }

        // just toggle it when clicked
        if ((event.type === 'click' || event.type === 'keydown' && event.keyCode === 32) && !$(event.target).is('.datagrid-cell-wrapper')) {
          isChecked = !isChecked;
          grid.setNextActiveCell(event);
        }

        this.input.prop('checked', isChecked);
        this.input.find('use').attr('xlink:href', isChecked ? '#icon-star-filled' : '#icon-star-outlined');
      };

      this.focus = function () {
        this.input.trigger('focusout').focus();
      };

      this.destroy = function () {
        var _this9 = this;

        setTimeout(function () {
          _this9.input.parent().remove();
        }, 0);
      };

      this.init();
    }
  };

  /* eslint-disable import/prefer-default-export */
  var excel = {};

  /**
   * Clean all extra stuff
   * @private
   * @param {string} customDs An optional customized version of the data to use.
   * @param {string} self The grid api to use (if customDs is not used)
   * @returns {object} an table element cleaned extra stuff
   */
  excel.cleanExtra = function (customDs, self) {
    var clean = function clean(table) {
      var removeNode = function removeNode(node) {
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
      };
      var nonExportables = [];
      var elements = [].slice.call(table[0].querySelectorAll('tr, th, td, div, span'));
      elements.forEach(function (el) {
        if (el.classList.contains('is-hidden') || el.classList.contains('datagrid-expandable-row')) {
          removeNode(el);
          return;
        }

        // THEAD
        var attrId = el.getAttribute('id');
        var attrExportable = el.getAttribute('data-exportable');
        if (attrExportable && attrExportable === 'no' && typeof attrId !== 'undefined') {
          nonExportables.push(parseInt(attrId.charAt(attrId.length - 1), 10) + 1);
          removeNode(el);
          return;
        }

        // TBODY
        var attrAriaColindex = el.getAttribute('aria-colindex');
        if (el.tagName.toLowerCase() !== 'th' && typeof attrAriaColindex !== 'undefined') {
          if (nonExportables.indexOf(parseInt(attrAriaColindex, 10)) !== -1) {
            removeNode(el);
            return;
          }
        }

        var innerElements = [].slice.call(table[0].querySelectorAll('.is-hidden, .is-draggable-target, .handle, .sort-indicator, .datagrid-filter-wrapper'));
        innerElements.forEach(function (innerEl) {
          return removeNode(innerEl);
        });

        while (el.attributes.length > 0) {
          el.removeAttribute(el.attributes[0].name);
        }

        // White Hat Security Violation. Remove Excel formulas
        // Excel Formulas Start with =SOMETHING
        var text = el.textContent;
        if (text.substr(0, 1) === '=' && text.substr(1, 1) !== '') {
          el.textContent = '\'' + text + '\'';
        }
      });
      return table;
    };

    var table = [];
    if (!self && customDs) {
      table = excel.datasetToHtml(customDs);
    } else {
      table = excel.appendRows(self.settings.dataset, self.table[0].cloneNode(true), self);
    }

    if (!customDs && !table[0].querySelector('thead')) {
      var tbody = table[0].querySelector('tbody');
      tbody.parentNode.insertBefore(self.headerRow[0].cloneNode(true), tbody);
    }

    table = clean(table);

    // Exporting data with trailing negative signs moved in front
    if (self && self.settings.exportConvertNegative) {
      var cells = [].slice.call(table[0].querySelectorAll('td'));
      cells.forEach(function (td) {
        td.textContent = td.textContent.replace(/^(.+)(-$)/, '$2$1');
      });
    }
    return table;
  };

  /**
   * Save file to download `.xls or .csv`.
   * @private
   * @param {string} content The content for the file in the download.
   * @param {string} fileName The desired export filename in the download.
   * @returns {void}
   */
  excel.save = function (content, fileName) {
    var ext = (fileName.match(/\.([^.]*?)(?=\?|#|$)/) || [])[1];
    var isTypeExcel = typeof ext === 'string' && /\b(xlsx|xls)\b/g.test(ext);

    if (Environment.browser.name === 'ie' || Environment.browser.name === 'edge') {
      if (window.navigator.msSaveBlob) {
        var blob = new Blob([content], {
          type: 'application/csv;charset=utf-8;'
        });
        navigator.msSaveBlob(blob, fileName);
      }
    } else if (window.URL.createObjectURL) {
      // createObjectURL api allows downloading larger files
      var _blob = new Blob([content], {
        type: 'application/' + (isTypeExcel ? 'vnd.ms-excel' : 'csv') + ';charset=utf-8;'
      });
      var objectUrl = URL.createObjectURL(_blob);
      var link = document.createElement('a');
      link.href = objectUrl;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(objectUrl);
    } else {
      var _link = document.createElement('a');
      _link.href = this.base64(content);
      _link.download = fileName;
      document.body.appendChild(_link);
      _link.click();
      document.body.removeChild(_link);
    }
  };

  /**
  * Convert a dataset to a html table for conversion to excel.
  * @private
  * @param {string} dataset The array of objects to convert
  * @returns {string} an html table as a string
  */
  excel.datasetToHtml = function (dataset) {
    var tableHtml = '<tbody>';

    var _loop = function _loop(i) {
      tableHtml += '<tr>';
      Object.keys(dataset[i]).forEach(function (key, index) {
        //eslint-disable-line
        if (dataset[i] && Object.prototype.hasOwnProperty.call(dataset[i], key)) {
          tableHtml += '<td>' + dataset[i][key] + '</td>';
        }
      });
      tableHtml += '</tr>';
    };

    for (var i = 0; i < dataset.length; i++) {
      _loop(i);
    }

    tableHtml += '</tbody>';
    return $('<table></table>').append(tableHtml);
  };

  /**
  * Convert a dataset to a html table for conversion to excel.
  * @private
  * @param {array} dataset The array of objects to convert.
  * @param {object} table The table object.
  * @param {object} self The grid API.
  * @returns {object} The table with rows appended.
  */
  excel.appendRows = function (dataset, table, self) {
    var isjQuery = function isjQuery(obj) {
      return obj && (obj instanceof jQuery || obj.constructor.prototype.jquery);
    };
    var tableJq = isjQuery(table) ? table : $(table);
    table = tableJq[0];

    var tableHtml = '';
    var body = table.querySelector('tbody');
    body.innerHTML = '';

    dataset.forEach(function (d, i) {
      if (!d.isFiltered) {
        tableHtml += self.rowHtml(d, i, i);
      }
    });

    body.insertAdjacentHTML('beforeend', tableHtml);
    return tableJq;
  };

  /**
   * Convert a excel string to base64 format for download.
   * @private
   * @param {string} s The string containing the document.
   * @returns {string} The excel doc as a base64 string.
   */
  excel.base64 = function (s) {
    if (window.btoa) {
      return 'data:application/vnd.ms-excel;base64,' + window.btoa(unescape(encodeURIComponent(s)));
    }
    return 'data:application/vnd.ms-excel;,' + unescape(encodeURIComponent(s));
  };

  /**
   * Copy pasted data into the dataset to facilitate copy from excel.
   * @param {object} pastedData The paste data from the paste event.
   * @param {[type]} rowCount The number of rows.
   * @param {[type]} colIndex The column index we started on.
   * @param {[type]} dataSet The dataset.
   * @param {[type]} self The datagrid API.
   * @returns {void}
   */
  excel.copyToDataSet = function (pastedData, rowCount, colIndex, dataSet, self) {
    var validateFields = function validateFields(values, settings, rowData, idx) {
      for (var j = 0; j < values.length; j++) {
        var col = settings.columns[idx];

        if (col.formatter !== formatters.Readonly) {
          switch (col.editor.name) {
            case editors.Input.name:
              if (col.filterType === 'integer' || col.filterType === 'decimal' || col.filterType === 'number') {
                // Number Values

                // Validates if input is number. If true, will overwrite the data in cell otherwise nothing will happen.
                if (!isNaN(values[j].trim())) {
                  rowData[col.field] = values[j];
                }
              } else {
                // String Values
                // Just overwrite the data in the cell
                rowData[col.field] = values[j];
              }
              break;
            case editors.Date.name:
              // Validates if input is date. If true, will overwrite the data in cell otherwise nothing will happen.
              if (!isNaN(Date.parse(values[j]))) {
                rowData[col.field] = new Date(values[j]);
              }
              break;
            default:
              break;
          }
        }

        idx++;
      }
    };

    for (var i = 0; i < pastedData.length; i++) {
      var rawVal = pastedData[i].split('\t');
      var startColIndex = colIndex;

      if (rowCount < dataSet.length) {
        var currentRowData = dataSet[rowCount];
        validateFields(rawVal, self.settings, currentRowData, startColIndex);
      } else {
        var newRowData = {};
        for (var k = 0; k < self.settings.columns.length; k++) {
          newRowData[self.settings.columns[k].field] = '';
        }
        validateFields(rawVal, self.settings, newRowData, startColIndex);
        dataSet.push(newRowData);
      }
      rowCount++;
    }

    self.renderRows();
    self.syncSelectedUI();
    self.pagerRefresh('bottom');
  };

  /**
   * Export the grid contents to xls format. This may give a warning when opening the file.
   * exportToCsv may be prefered.
   * @param {string} fileName The desired export filename in the download.
   * @param {string} worksheetName A name to give the excel worksheet tab.
   * @param {string} customDs An optional customized version of the data to use.
   * @param {object} self The grid api if customDS is not used
   * @returns {void}
   */
  excel.exportToExcel = function (fileName, worksheetName, customDs, self) {
    var template = '' + '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">' + '<head>' + '<!--[if gte mso 9]>' + '<xml>' + '<x:ExcelWorkbook>' + '<x:ExcelWorksheets>' + '<x:ExcelWorksheet>' + '<x:Name>{worksheet}</x:Name>' + '<x:WorksheetOptions>' + '<x:Panes></x:Panes>' + '<x:DisplayGridlines></x:DisplayGridlines>' + '</x:WorksheetOptions>' + '</x:ExcelWorksheet>' + '</x:ExcelWorksheets>' + '</x:ExcelWorkbook>' + '</xml>' + '<![endif]-->' + '<meta http-equiv="content-type" content="text/plain; charset=UTF-8"/>' + '</head>' + '<body>' + '<table border="1px solid #999999">{table}</table>' + '</body>' + '</html>';

    var formatExcel = function formatExcel(s, c) {
      return s.replace(/{(\w+)}/g, function (m, p) {
        return c[p];
      });
    };

    var table = excel.cleanExtra(customDs, self);
    var ctx = { worksheet: worksheetName || 'Worksheet', table: table[0].innerHTML };

    fileName = (fileName || self.element[0].id || 'Export') + '.xls';
    excel.save(formatExcel(template, ctx), fileName);
  };

  /**
   * Export the grid contents to csv
   * @param {string} fileName The desired export filename in the download.
   * @param {string} customDs An optional customized version of the data to use.
   * @param {string} self The grid api to use (if customDs is not used)
   * @param {string} separator (optional) If user's machine is configured for a locale with alternate default seperator.
   * @returns {void}
   */
  excel.exportToCsv = function (fileName, customDs, self) {
    var separator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'sep=,';

    var formatCsv = function formatCsv(table) {
      var csv = [];
      var rows = [].slice.call(table[0].querySelectorAll('tr'));
      rows.forEach(function (row) {
        var rowContent = [];
        var cols = [].slice.call(row.querySelectorAll('td, th'));
        cols.forEach(function (col) {
          return rowContent.push(col.textContent.replace(/\r?\n|\r/g, '').replace(/"/g, '""').trim());
        });
        csv.push(rowContent.join('","'));
      });
      csv.unshift(['' + separator]);
      return '"' + csv.join('"\n"') + '"';
    };

    var table = excel.cleanExtra(customDs, self);

    fileName = (fileName || self.element[0].id || 'Export') + '.csv';
    excel.save(formatCsv(table), fileName);
  };

  /* eslint-enable import/prefer-default-export */

  /**
  * An api for grouping data by a given field (s)
  * @private
  */
  var groupBy = function () {
    // Can also use in isEquivalent: function(obj1, obj2)  in datagrid.js
    var equals = utils.equals;

    // See if the object has these proprties or not
    var has = function has(obj, target) {
      return obj.some(function (value) {
        return equals(value, target);
      });
    };

    // Return just the object properties matching the names
    var pick = function pick(obj, names) {
      var chosen = {};
      for (var i = 0, l = names.length; i < l; i++) {
        chosen[names[i]] = obj[names[i]];
      }
      return chosen;
    };

    // Return the specific keys from the object
    var keys = function keys(data, names) {
      return data.reduce(function (memo, item) {
        var key = pick(item, names);

        if (!has(memo, key)) {
          memo.push(key);
        }
        return memo;
      }, []);
    };

    // Look through each value in the list and return an array of all the values
    // that contain all of the key-value pairs listed in properties.
    var where = function where(data, names) {
      var chosen = [];

      /* eslint-disable */
      data.map(function (item) {
        for (var prop in names) {
          if (names[prop] !== item[prop]) {
            return;
          }
        }
        chosen.push(item);
        return;
      });
      /* eslint-enable */

      return chosen;
    };

    // Grouping Function with Plugins/Aggregator
    var group = function group(data, names) {
      var stems = keys(data, names);

      return stems.map(function (stem) {
        return {
          key: stem,
          values: where(data, stem).map(function (item) {
            return item;
          })
        };
      });
    };

    // Register an aggregator
    group.register = function (name, converter) {
      group[name] = function (data, names, extra) {
        var that = this;
        that.extra = extra;
        return group(data, names).map(converter, that);
      };
      return group[name];
    };

    return group;
  }();

  /**
  * Register built in aggregators
  * @private
  */
  groupBy.register('none', function (item) {
    return $.extend({}, item.key, { values: item.values });
  });

  groupBy.register('sum', function (item) {
    var extra = this.extra;
    return $.extend({}, item.key, { values: item.values }, { sum: item.values.reduce(function (memo, node) {
        return memo + Number(node[extra]);
      }, 0) });
  });

  groupBy.register('max', function (item) {
    var extra = this.extra;
    return $.extend({}, item.key, { values: item.values }, // eslint-disable-next-line
    { max: item.values.reduce(function (memo, node) {
        return Math.max(memo, Number(node[extra]));
      }, Number.NEGATIVE_INFINITY) });
  });

  groupBy.register('list', function (item) {
    var extra = this.extra;

    return $.extend({}, item.key, { values: item.values }, {
      list: item.values.map(function (thisItem) {
        var list = [];

        for (var i = 0, l = extra.list.length; i < l; i++) {
          var exclude = extra.exclude ? thisItem[extra.exclude] : false;
          if (thisItem[extra.list[i]] && !exclude) {
            list.push({ value: thisItem[extra.list[i]], key: extra.list[i] });
          }
        }
        return list;
      })
    });
  });

  /**
  * Simple Summary Row Accumlator
  * @private
  */
  var aggregators = {};
  aggregators.aggregate = function (items, columns) {
    var totals = {};
    var self = this;

    for (var i = 0, l = columns.length; i < l; i++) {
      if (columns[i].aggregator) {
        (function () {
          var field = columns[i].field;

          self.sum = function (sum, node) {
            if (node.isFiltered) {
              // If excluded / filtered out.
              return sum;
            }

            var value = void 0;

            if (field.indexOf('.') > -1) {
              value = field.split('.').reduce(function (o, x) {
                return o ? o[x] : '';
              }, node);
            } else {
              value = node[field];
            }
            return sum + Number(value);
          };

          var total = items.reduce(self[columns[i].aggregator], 0);

          if (field.indexOf('.') > -1) {
            var currentObj = totals;
            for (var j = 0, k = field.split('.').length; j < k; j++) {
              if (j === field.split('.').length - 1) {
                currentObj[field.split('.')[j]] = total;
              } else {
                if (!(field.split('.')[j] in currentObj)) {
                  currentObj[field.split('.')[j]] = {};
                }

                currentObj = currentObj[field.split('.')[j]];
              }
            }
          } else {
            totals[field] = total;
          }
        })();
      }
    }

    return totals;
  };

  /* eslint-disable no-underscore-dangle, no-continue, no-nested-ternary */

  // The name of this component.
  var COMPONENT_NAME$1b = 'datagrid';

  /**
   * The Datagrid Component displays and process data in tabular format.
   * @class Datagrid
   * @constructor
   *
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object}   [settings] The component settings.
   * @param {boolean}  [settings.actionableMode=false] If actionableMode is "true, tab and shift tab behave like left and right arrow key, if the cell is editable it goes in and out of edit mode. F2 - toggles actionableMode "true" and "false"
   * @param {boolean}  [settings.cellNavigation=true] If cellNavigation is "false, will show border around whole row on focus
   * @param {boolean}  [settings.rowNavigation=true] If rowNavigation is "false, will NOT show border around the row
   * @param {boolean}  [settings.alternateRowShading=false] Sets shading for readonly grids
   * @param {array}    [settings.columns=[]] An array of columns (see column options)
   * @param {array}    [settings.dataset=[]] An array of data objects
   * @param {boolean}  [settings.columnReorder=false] Allow Column reorder
   * @param {boolean}  [settings.saveColumns=false] Save Column Reorder and resize, this is deprecated, use saveUserSettings
   * @param {object}   [settings.saveUserSettings]
   * @param {object}   [settings.saveUserSettings.columns=true]
   * @param {object}   [settings.saveUserSettings.rowHeight=true]
   * @param {object}   [settings.saveUserSettings.sortOrdertrue]
   * @param {object}   [settings.saveUserSettings.pageSize=true]
   * @param {object}   [settings.saveUserSettings.activePage=true]
   * @param {object}   [settings.saveUserSettings.filter=true]
   * @param {boolean}  [settings.focusAfterSort=false] If true will focus the active cell after sorting.
   * @param {boolean}  [settings.editable=false] Enable editing in the grid, requires column editors.
   * @param {boolean}  [settings.isList=false] Makes the grid have readonly "list" styling
   * @param {string}   [settings.menuId=null]  ID of the menu to use for a row level right click context menu
   * @param {string}   [settings.menuSelected=null] Callback for the grid level context menu
   * @param {string}   [settings.menuBeforeOpen=null] Callback for the grid level beforeopen menu event
   * @param {string}   [settings.headerMenuId=null] Id of the menu to use for a header right click context menu
   * @param {string}   [settings.headerMenuSelected=false] Callback for the header level context menu
   * @param {string}   [settings.headerMenuBeforeOpen=false] Callback for the header level beforeopen menu event
   * @param {string}   [settings.uniqueId=null] Unique DOM ID to use as local storage reference and internal variable names
   * @param {string}   [settings.rowHeight=normal] Controls the height of the rows / number visible rows. May be (short, medium or normal)
   * @param {string}   [settings.selectable=false] Controls the selection Mode this may be: false, 'single' or 'multiple' or 'mixed' or 'siblings'
   * @param {object}   [settings.groupable=null]  Controls fields to use for data grouping Use Data grouping, e.g. `{fields: ['incidentId'], supressRow: true, aggregator: 'list', aggregatorOptions: ['unitName1']}`
   * @param {boolean}  [settings.spacerColumn=false] if true and the grid is not wide enough to fit the last column will get filled with an empty spacer column.
   * @param {boolean}  [settings.stretchColumn='last'] If 'last' the last column will stretch we will add more options.
   * @param {boolean}  [settings.clickToSelect=true] Controls if using a selection mode if you can click the rows to select
   * @param {object}   [settings.toolbar=false]  Toggles and appends toolbar features fx..
   * @param {boolean}  [settings.selectChildren=true] Can prevent selecting of all child nodes on multiselect `{title: 'Data Grid Header Title', results: true, keywordFilter: true, filter: true, rowHeight: true, views: true}`
   * @param {boolean}  [settings.allowSelectAcrossPages=null] Makes it possible to save selections when changing pages on server side paging. You may want to also use showSelectAllCheckBox: false
   * @param {boolean}  [settings.initializeToolbar=true] Set to false if you will initialize the toolbar yourself
   * @param {boolean}  [settings.paging=false] Enable paging mode
   * @param {number}   [settings.pagesize=25] Number of rows per page
   * @param {array}    [settings.pagesizes=[10, 25, 50, 75]] Array of page sizes to show in the page size dropdown.
   * @param {boolean}  [settings.indeterminate=false] Disable the ability to go to a specific page when paging.
   * @param {Function} [settings.source=false]  Callback function for paging
   * @param {boolean}  [settings.hidePagerOnOnePage=false]  If true, hides the pager if there's only one page worth of results.
   * @param {boolean}  [settings.filterable=false] Enable Column Filtering, This will require column filterTypes as well.
   * @param {boolean}  [settings.filterWhenTyping=true] Enable Column Filtering as you stop typing in inputs
   * @param {boolean}  [settings.disableClientFilter=false] Disable Filter Logic client side and let your server do it
   * @param {boolean}  [settings.disableClientSort=false] Disable Sort Logic client side and let your server do it
   * @param {string}   [settings.resultsText=null] Can provide a custom function to adjust results text on the toolbar
   * @param {boolean}  [settings.showFilterTotal=true] Paging results display filter count, change to false to not show filtered count
   * @param {boolean}  [settings.rowReorder=false] If set you can reorder rows. Requires rowReorder formatter
   * @param {boolean}  [settings.showDirty=false]  If true the dirty indicator will be shown on the rows
   * @param {boolean}  [settings.showSelectAllCheckBox=true] Allow to hide the checkbox header (true to show, false to hide)
   * @param {boolean}  [settings.allowOneExpandedRow=true] Controls if you cna expand more than one expandable row.
   * @param {boolean}  [settings.enableTooltips=false] Process tooltip logic at a cost of performance
   * @param {boolean}  [settings.disableRowDeactivation=false] if a row is activated the user should not be able to deactivate it by clicking on the activated row
   * @param {boolean}  [settings.sizeColumnsEqually=false] If true make all the columns equal width
   * @param {boolean}  [settings.expandableRow=false] If true we append an expandable row area without the rowTemplate feature being needed.
   * @param {boolean}  [settings.redrawOnResize=false] If set to false we skip redraw logic on the resize of the page.
   * @param {boolean}  [settings.exportConvertNegative=false] If set to true export data with trailing negative signs moved in front.
   * @param {array}    [settings.columnGroups=null] An array of columns to use for grouped column headers.
   * @param {boolean}  [settings.treeGrid=false] If true a tree grid is expected so addition calculations will be used to calculate of the row children
   * @param {Function} [settings.onPostRenderCell=null] A call back function that will fire and send you the cell container and related information for any cells cells with a component attribute in the column definition.
   * @param {Function} [settings.onDestroyCell=null] A call back that goes along with onPostRenderCel and will fire when this cell is destroyed and you need noification of that.
   * @param {Function} [settings.onEditCell=null] A callback that fires when a cell is edited, the editor object is passed in to the function
   * @param {Function} [settings.onExpandRow=null] A callback function that fires when expanding rows. To be used. when expandableRow is true. The function gets eventData about the row and grid and a response function callback. Call the response function with markup to append and delay opening the row.
   * @param {object}   [settings.emptyMessage]
   * @param {object}   [settings.emptyMessage.title='No Data Available']
   * @param {object}   [settings.emptyMessage.info='']
   * @param {object}   [settings.emptyMessage.icon='icon-empty-no-data']
   * @param {boolean}  [settings.searchExpandableRow=true] If true enable expanding of row on search
   * An empty message will be displayed when there is no rows in the grid. This accepts an object of the form
   * emptyMessage: {title: 'No Data Available', info: 'Make a selection on the list above to see results',
   * icon: 'icon-empty-no-data', button: {text: 'xxx', click: <function>}} set this to null for no message
   * or will default to 'No Data Found with an icon.'
   */
  var DATAGRID_DEFAULTS = {
    // F2 - toggles actionableMode "true" and "false"
    // If actionableMode is "true, tab and shift tab behave like left and right arrow key,
    // if the cell is editable it goes in and out of edit mode
    actionableMode: false,
    cellNavigation: true, // If cellNavigation is "false, will show border around whole row on focus
    rowNavigation: true, // If rowNavigation is "false, will NOT show border around the row
    alternateRowShading: false,
    columns: [],
    dataset: [],
    columnReorder: false, // Allow Column reorder
    saveColumns: false, // Save Column Reorder and resize
    saveUserSettings: {},
    focusAfterSort: false, // If true will focus the active cell after sorting.
    editable: false,
    isList: false, // Makes a readonly "list"
    menuId: null, // Id to the right click context menu
    headerMenuId: null, // Id to the right click context menu to use for the header
    menuSelected: null, // Callback for the grid level right click menu
    menuBeforeOpen: null, // Call back for the grid level before open menu event
    headerMenuSelected: null, // Callback for the header level right click menu
    headerMenuBeforeOpen: null, // Call back for the header level before open menu event
    uniqueId: null, // Unique ID for local storage reference and variable names
    rowHeight: 'normal', // (short, medium or normal)
    selectable: false, // false, 'single' or 'multiple' or 'siblings'
    selectChildren: true, // can prevent selecting of all child nodes on multiselect
    allowSelectAcrossPages: null,
    groupable: null,
    spacerColumn: false,
    stretchColumn: 'last',
    twoLineHeader: false,
    clickToSelect: true,
    toolbar: false,
    initializeToolbar: true, // can set to false if you will initialize the toolbar yourself
    // Paging settings
    paging: false,
    pagesize: 25,
    pagesizes: [10, 25, 50, 75],
    showPageSizeSelector: true, // Will show page size selector
    indeterminate: false, // removed ability to go to a specific page.
    source: null, // callback for paging
    hidePagerOnOnePage: false, // If true, hides the pager if there's only one page worth of results.
    // Filtering settings
    filterable: false,
    filterWhenTyping: true,
    disableClientFilter: false, // Disable Filter Logic client side and let your server do it
    disableClientSort: false, // Disable Sort Logic client side and let your server do it
    resultsText: null, // Can provide a custom function to adjust results text
    showFilterTotal: true, // Paging results show filtered count, false to not show.
    virtualized: false, // Prevent Unused rows from being added to the DOM
    virtualRowBuffer: 10, // how many extra rows top and bottom to allow as a buffer
    rowReorder: false, // Allows you to reorder rows. Requires rowReorder formatter
    showDirty: false,
    showSelectAllCheckBox: true, // Allow to hide the checkbox header (true to show, false to hide)
    allowOneExpandedRow: true, // Only allows one expandable row at a time
    enableTooltips: false, // Process tooltip logic at a cost of performance
    disableRowDeactivation: false,
    sizeColumnsEqually: false, // If true make all the columns equal width
    expandableRow: false, // Supply an empty expandable row template
    redrawOnResize: false, // Run column redraw logic on resize
    exportConvertNegative: false, // Export data with trailing negative signs moved in front
    columnGroups: null, // The columns to use for grouped column headings
    treeGrid: false,
    onPostRenderCell: null,
    onDestroyCell: null,
    onEditCell: null,
    onExpandRow: null,
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' },
    searchExpandableRow: true
  };

  function Datagrid(element, settings) {
    this.settings = utils.mergeSettings(element, settings, DATAGRID_DEFAULTS);
    this.element = $(element);
    if (settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.init();
  }

  /**
  * Actual Datagrid prototype
  * @private
  */
  Datagrid.prototype = {

    /**
    * Init the datagrid from its uninitialized state.
    * @private
    * @returns {void}
    */
    init: function init() {
      var html = $('html');

      this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      this.isFirefoxMac = navigator.platform.indexOf('Mac') !== -1 && navigator.userAgent.indexOf(') Gecko') !== -1;
      this.isIe = html.is('.ie');
      this.isIe9 = html.is('.ie9');
      this.isSafari = html.is('.is-safari');
      this.isWindows = navigator.userAgent.indexOf('Windows') !== -1;
      this.appendTooltip('grid-tooltip');
      this.initSettings();
      this.originalColumns = this.columnsFromString(JSON.stringify(this.settings.columns));
      this.removeToolbarOnDestroy = false;
      this.nonVisibleCellErrors = [];
      this.recordCount = 0;
      this.canvas = null;
      this.totalWidth = 0;
      this.editor = null; // Current Cell Editor thats in Use
      this.activeCell = { node: null, cell: null, row: null }; // Current Active Cell
      this.dontSyncUi = false;
      this.widthPercent = false;
      this.rowSpans = [];
      this.headerWidths = []; // Cache
      this.filterRowRendered = false; // Flag used to determine if the header is rendered or not.
      this.scrollLeft = 0;
      this.scrollTop = 0;
      this._selectedRows = [];
      this.restoreColumns();
      this.restoreUserSettings();
      this.appendToolbar();
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();
      this.firstRender();
      this.handlePaging();
      this.handleEvents();
      this.handleKeys();

      /**
       * Fires after the grid is rendered.
      * @event rendered
      * @memberof Datagrid
      * @property {object} event - The jquery event object
      * @property {array} ui - An array with references to the domElement, header and pagerBar
      */
      this.element.trigger('rendered', [this.element, this.headerRow, this.pagerBar]);
    },


    /**
    * Initialize internal variables and states.
    * @private
    */
    initSettings: function initSettings() {
      this.ignoredColumnById('rowStatus');
      this.sortColumn = { sortField: null, sortAsc: true };
      this.gridCount = $('.datagrid').length + 1;
      this.lastSelectedRow = 0; // Remember index to use shift key

      this.contextualToolbar = this.element.prev('.contextual-toolbar');
      this.contextualToolbar.addClass('datagrid-contextual-toolbar');
    },


    /**
    * Ignore given Column from settings.
    * @private
    * @param {string} columnId for column to be ignored
    * @returns {void}
    */
    ignoredColumnById: function ignoredColumnById(columnId) {
      var s = this.settings;
      if (!columnId || !s.columns || s.columns && !s.columns.length) {
        return;
      }
      var column = { index: -1 };
      for (var i = 0, l = s.columns.length; i < l; i++) {
        if (s.columns[i].id === columnId) {
          column.index = i;
        }
      }
      if (column.index > -1) {
        s.columns.splice(column.index, 1);
      }
    },


    /**
    * Render or render both the header and row area.
    * @param {string} isToggleFilter Check if filterrow type should be passed to the data source request
    */
    render: function render(isToggleFilter) {
      if (isToggleFilter) {
        this.loadData(this.settings.dataset, { type: 'filterrow' });
      } else {
        this.loadData(this.settings.dataset);
      }
    },


    /**
    * Run the initial render on the Header and Rows.
    * @private
    */
    firstRender: function firstRender() {
      var self = this;

      self.contentContainer = $('<div class="datagrid-body"></div>');

      if (this.settings.dataset === 'table') {
        self.table = $(this.element).addClass('datagrid');

        var wrapper = $(this.element).closest('.datagrid-container');
        if (wrapper.length === 0) {
          self.table.wrap('<div class="datagrid-container"></div>');
          this.element = self.table.closest('.datagrid-container');
        }

        self.settings.dataset = self.htmlToDataset();
        self.table.remove();
        self.table = $('<table></table>').addClass('datagrid').attr('role', 'grid').appendTo(self.contentContainer);
      } else {
        self.table = $('<table></table>').addClass('datagrid').attr('role', this.settings.treeGrid ? 'treegrid' : 'grid').appendTo(self.contentContainer);
        this.element.addClass('datagrid-container').attr('x-ms-format-detection', 'none');
      }

      if (this.isWindows) {
        this.element.addClass('is-windows'); // need since scrollbars are visible
      }

      // initialize row height by a setting
      if (this.settings.rowHeight !== 'normal') {
        self.table.addClass(this.settings.rowHeight + '-rowheight');
        this.element.addClass(this.settings.rowHeight + '-rowheight');
      }

      // A treegrid is considered not editable unless otherwise specified.
      if (this.settings.treeGrid && !this.settings.editable) {
        self.table.attr('aria-readonly', 'true');
      }

      if (this.settings.isList) {
        $(this.element).addClass('is-gridlist');
      } else {
        $(this.element).removeClass('is-gridlist');
      }

      this.isInitialRender = true;
      self.table.empty();
      self.clearHeaderCache();
      self.renderRows();
      self.element.append(self.contentContainer);
      self.renderHeader();
      self.container = self.element.closest('.datagrid-container');

      if (this.settings.emptyMessage) {
        self.setEmptyMessage(this.settings.emptyMessage);
      }

      self.buttonSelector = '.btn, .btn-secondary, .btn-primary, .btn-modal-primary, .btn-tertiary, .btn-icon, .btn-actions, .btn-menu, .btn-split';
      $(self.buttonSelector, self.table).button();
    },


    /**
    * If the datagrid is a html table, convert that table to an internal dataset to use.
    * @private
    * @returns {void}
    */
    htmlToDataset: function htmlToDataset() {
      var rows = $(this.element).find('tbody tr');
      var self = this;
      var specifiedCols = self.settings.columns.length > 0;
      var dataset = [];

      // Geneate the columns if not supplier
      if (!specifiedCols) {
        var headers = $(this.element).find('thead th');
        var firstRow = self.element.find('tbody tr:first()');

        headers.each(function (i, col) {
          var colSpecs = {};
          var column = $(col);
          var colName = 'column' + i;

          colSpecs.id = column.text().toLowerCase();
          colSpecs.name = column.text();
          colSpecs.field = colName;

          var link = firstRow.find('td').eq(i).find('a');
          if (link.length > 0) {
            colSpecs.formatter = formatters.Hyperlink;
            colSpecs.href = link.attr('href');
          }

          self.settings.columns.push(colSpecs);
        });
      }

      rows.each(function () {
        var cols = $(this).find('td');
        var newRow = {};

        cols.each(function (i, col) {
          var column = $(col);
          var colName = 'column' + i;

          if (self.settings.columns[i].formatter) {
            newRow[colName] = column.text();
          } else {
            newRow[colName] = column.html();
          }

          if (specifiedCols) {
            self.settings.columns[i].field = colName;
          }
        });

        dataset.push(newRow);
      });

      return dataset;
    },


    /**
    * Add a row of data to the grid and dataset.
    * @param {object} data An data row object
    * @param {string} location Where to add the row. This can be 'bottom' or 'top', default is top.
    */
    addRow: function addRow(data, location) {
      var self = this;
      var isTop = false;
      var row = 0;
      var cell = 0;
      var args = void 0;
      var rowNode = void 0;

      if (!location || location === 'top') {
        location = 'top';
        isTop = true;
      }
      // Add row status
      data.rowStatus = { icon: 'new', text: Locale.translate('New'), tooltip: Locale.translate('New') };

      // Add to array
      if (typeof location === 'string') {
        self.settings.dataset[isTop ? 'unshift' : 'push'](data);
      } else {
        self.settings.dataset.splice(location, 0, data);
      }

      // Add to ui
      self.renderRows();

      // Sync with others
      self.syncSelectedUI();

      // Set active and fire handler
      setTimeout(function () {
        row = isTop ? row : self.settings.dataset.length - 1;
        self.setActiveCell(row, cell);

        rowNode = self.tableBody.find('tr[aria-rowindex="' + (row + 1) + '"]');
        args = { row: row, cell: cell, target: rowNode, value: data, oldValue: {} };

        self.pagerRefresh(location);

        /**
         * Fires after a row is added via the api.
        * @event addrow
        * @memberof Datagrid
        * @property {object} event The jquery event object
        * @property {number} args.row The row index
        * @property {number} args.cell The cell index
        * @property {HTMLElement} args.target The html element.
        * @property {object} args.value - An object all the row data.
        * @property {object} args.oldValue - Always an empty object added for consistent api.
        */
        self.element.triggerHandler('addrow', args);
      }, 100);
    },


    /**
    * Refresh the pager based on the current page and dataset.
    * @private
    * @param {object} location Deprecated - Can be set to 'top' or left off for bottom pager.
    */
    pagerRefresh: function pagerRefresh(location) {
      if (this.pager) {
        if (typeof location === 'string') {
          this.pager.activePage = location === 'top' ? 1 : this.pager._pageCount;
        } else if (typeof location === 'number') {
          this.pager.activePage = Math.floor(location / (this.pager.settings.pagesize + 1));
        }

        if (!this.settings.source) {
          this.pager.pagingInfo = $.extend({}, this.pager.pagingInfo, {
            activePage: this.pager.activePage,
            total: this.settings.dataset.length,
            pagesize: this.settings.pagesize
          });
        }
        this.renderPager(this.pager.pagingInfo, true);
      }
    },


    /**
    * Remove a row of data to the grid and dataset.
    * @param {number} row The row index
    * @param {boolean} nosync Dont sync the selected rows.
    */
    removeRow: function removeRow(row, nosync) {
      var rowNode = this.tableBody.find('tr[aria-rowindex="' + (row + 1) + '"]');
      var rowData = this.settings.dataset[row];

      this.unselectRow(row, nosync);
      this.settings.dataset.splice(row, 1);
      this.renderRows();

      /**
      *  Fires after a row is removed via the api
      * @event rowremove
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Object with the arguments
      * @property {number} args.row The row index
      * @property {number} args.cell The cell index
      * @property {HTMLElement} args.target The row node that is being dragged.
      * @property {HTMLElement} args.item The dragged rows data.
      */
      this.element.trigger('rowremove', { row: row, cell: null, target: rowNode, item: rowData, oldValue: rowData });
    },


    /**
    * Remove all selected rows from the grid and dataset.
    */
    removeSelected: function removeSelected() {
      this._selectedRows.sort(function (a, b) {
        return a.idx > b.idx;
      });

      for (var i = this._selectedRows.length - 1; i >= 0; i--) {
        this.removeRow(this._selectedRows[i].idx, true);
      }
      this.pagerRefresh();
      this.syncSelectedUI();
    },


    /**
    * Send in a new data set to display in the datagrid.
    * @param {object} dataset The array of objects to show in the grid. Should match
    * the column definitions.
    * @param {object} pagerInfo The pager info object with information like activePage ect.
    */
    updateDataset: function updateDataset(dataset, pagerInfo) {
      if (this.settings.toolbar && this.settings.toolbar.keywordFilter) {
        var searchField = this.element.parent().find('.toolbar').find('.searchfield');
        searchField.val('');
        searchField.parent().removeClass('has-text');

        this.clearFilter();
      }

      this.loadData(dataset, pagerInfo);
    },


    /**
    * Trigger the source method to call to the backend on demand.
    *
    * @param {object} pagerType The pager info object with information like activePage ect.
    * @param {function} callback The call back functions
    */
    triggerSource: function triggerSource(pagerType, callback) {
      this.pager.pagerInfo = this.pager.pagerInfo || {};
      this.pager.pagerInfo.type = pagerType;

      if (pagerType !== 'refresh') {
        this.pager.pagerInfo.activePage = 1;
      }

      this.renderPager(this.pager.pagerInfo, false, function () {
        if (callback && typeof callback === 'function') {
          callback();
        }
      });
    },


    /**
    * Send in a new data set to display in the datagrid. Use better named updateDataset
    * @deprecated
    * @private
    * @param {object} dataset The array of objects to show in the grid.
    * Should match the column definitions.
    * @param {object} pagerInfo The pager info object with information like activePage ect.
    * @param {object} isResponse Called internally if the load data is response
    */
    loadData: function loadData(dataset, pagerInfo, isResponse) {
      this.settings.dataset = dataset;

      if (!pagerInfo) {
        pagerInfo = {};
      }

      if (pagerInfo.type === 'filterrow') {
        pagerInfo.activePage = this.pager && this.pager.activePage || 1;
        pagerInfo.pagesize = this.settings.pagesize;
        pagerInfo.total = pagerInfo.total || -1;
        pagerInfo.type = 'filterrow';
      }

      if (!pagerInfo.activePage) {
        pagerInfo.activePage = 1;
        pagerInfo.pagesize = this.settings.pagesize;
        pagerInfo.total = -1;
        pagerInfo.type = 'initial';
        if (this.settings.treeGrid) {
          pagerInfo.preserveSelected = true;
        }
      }

      if (this.settings.source && pagerInfo.grandTotal) {
        this.grandTotal = pagerInfo.grandTotal;
      } else {
        this.grandTotal = null;
      }

      if (this.pager) {
        if (pagerInfo.activePage > -1) {
          this.pager.activePage = pagerInfo.activePage;
        }
        this.pager.settings.dataset = dataset;
      }

      // Update Paging and Clear Rows
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();

      if (pagerInfo && !pagerInfo.preserveSelected) {
        this.unSelectAllRows();
      }

      // Resize and re-render if have a new dataset
      // (since automatic column sizing depends on the dataset)
      if (pagerInfo.type === 'initial') {
        this.clearHeaderCache();
        this.restoreUserSettings();
        this.renderRows();
        this.renderHeader();
      } else {
        this.renderRows();
      }

      this.renderPager(pagerInfo, isResponse);
      this.syncSelectedUI();
      this.displayCounts(pagerInfo.total);
    },


    /**
    * Generate a unique id based on the page and grid count. Add a suffix.
    * @deprecated
    * @private
    * @param {object} suffix Add this string to make the id more unique
    * @returns {string} The unique id.
    */
    uniqueId: function uniqueId(suffix) {
      var uniqueid = this.settings.uniqueId ? this.settings.uniqueId + '-' + suffix : window.location.pathname.split('/').pop().replace(/\.xhtml|\.shtml|\.html|\.htm|\.aspx|\.asp|\.jspx|\.jsp|\.php/g, '').replace(/[^-\w]+/g, '').replace(/\./g, '-').replace(/ /g, '-').replace(/%20/g, '-') + '-' + (this.element.attr('id') || 'datagrid') + '-' + this.gridCount + suffix;

      return uniqueid.replace(/--/g, '-');
    },


    /**
    * Returns an array with all visible columns.
    * @param {boolean} skipBuiltIn If true then built in columns like selectionCheckbox are skipped.
    * @returns {array} An array with the visible columns.
    */
    visibleColumns: function visibleColumns(skipBuiltIn) {
      var visible = [];
      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = this.settings.columns[j];

        if (column.hidden) {
          continue;
        }

        if (skipBuiltIn && column.id === 'selectionCheckbox') {
          continue;
        }
        visible.push(column);
      }
      return visible;
    },


    /**
    * Returns the index of the last column.
    * @private
    * @returns {number} The last columns index.
    */
    lastColumnIdx: function lastColumnIdx() {
      var last = 0;

      if (this.lastColumn) {
        return this.lastColumn;
      }

      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = this.settings.columns[j];

        if (column.hidden) {
          continue;
        }

        last = j;
      }

      this.lastColumn = last;
      return last;
    },


    /**
    * Gets an if for the column group used for grouped headers.
    * @private
    * @param {object} idx The index of the column group
    * @returns {string} The name of the column group
    */
    getColumnGroup: function getColumnGroup(idx) {
      var total = 0;
      var colGroups = this.settings.columnGroups;

      for (var l = 0; l < colGroups.length; l++) {
        if (colGroups[l].hidden) {
          continue;
        }
        total += colGroups[l].colspan;

        if (total >= idx) {
          return this.uniqueId('-header-group-' + l);
        }
      }

      return '';
    },


    /**
    * Gets an if for the column group used for grouped headers.
    * @private
    * @param {number} idx The index of the column group
    * @param {boolean} show Did we show or hide the col.
    */
    updateColumnGroup: function updateColumnGroup() {
      var colGroups = this.settings.columnGroups;
      if (!this.originalColGroups) {
        this.originalColGroups = JSON.parse(JSON.stringify(colGroups));
      }

      if (this.settings.groupable) {
        // need to rerender here to get the colspans correct.
        var groupHeaders = this.tableBody.find('.datagrid-rowgroup-header');
        var newColspan = this.visibleColumns().length;

        for (var _i = 0; _i < groupHeaders.length; _i++) {
          groupHeaders[_i].children[0].setAttribute('colspan', newColspan);
        }
        return;
      }

      if (!colGroups) {
        return;
      }

      // Update the dom
      if (!this.colGroups) {
        return;
      }

      var headGroups = [].slice.call(this.colGroups[0].querySelectorAll('th'));
      var columns = this.settings.columns;
      var columnsLen = columns.length;
      var visibleColumnsLen = this.visibleColumns().length;
      var groups = colGroups.map(function (group) {
        return parseInt(group.colspan, 10);
      });
      var getGroupsTotal = function getGroupsTotal() {
        return groups.reduce(function (a, b) {
          return a + b;
        }, 0);
      };
      var getDiff = function getDiff() {
        var groupsTotal = getGroupsTotal();
        return groupsTotal > columnsLen ? groupsTotal - columnsLen : columnsLen - groupsTotal;
      };

      var groupsTotal = getGroupsTotal();
      var diff = void 0;
      if (groupsTotal > columnsLen) {
        var move = true;
        for (var _i2 = groups.length - 1; _i2 >= 0 && move; _i2--) {
          diff = getDiff();
          if (groups[_i2] >= diff) {
            groups[_i2] -= diff;
            move = false;
          } else {
            groups[_i2] = 0;
          }
        }
      }

      var i = 0;
      var total = 0;
      groups.forEach(function (groupColspan, k) {
        var colspan = groupColspan;
        for (var l = i + groupColspan; i < l; i++) {
          if (i < columnsLen && columns[i].hidden) {
            colspan--;
          }
        }

        if (colspan > 0) {
          total += colspan;
        }

        var groupHeaderEl = headGroups[k];
        groupHeaderEl.setAttribute('colspan', colspan > 0 ? colspan : 1);

        if (colGroups[k].hidden || colspan < 1) {
          groupHeaderEl.classList.add('hidden');
        } else {
          groupHeaderEl.classList.remove('hidden');
        }
      });

      if (total < visibleColumnsLen) {
        var groupHeaderEl = headGroups[headGroups.length - 1];
        diff = visibleColumnsLen - total;
        groupHeaderEl.setAttribute('colspan', diff > 0 ? diff : 1);
      }
    },


    /**
    * Update group headers after column reorder/dragged.
    * @private
    * @param {number} indexFrom The column index dragged from.
    * @param {number} indexTo The column index dragged to.
    * @returns {void}
    */
    updateGroupHeadersAfterColumnReorder: function updateGroupHeadersAfterColumnReorder(indexFrom, indexTo) {
      var colGroups = this.settings.columnGroups;
      if (!colGroups) {
        return;
      }

      if (!this.originalColGroups) {
        this.originalColGroups = JSON.parse(JSON.stringify(colGroups));
      }

      var groups = colGroups.map(function (group) {
        return parseInt(group.colspan, 10);
      });
      var changed = { from: null, to: null, total: 0 };

      groups.forEach(function (colspan, i) {
        changed.total += colspan;

        if (changed.total > indexFrom && changed.from === null) {
          changed.from = i;
        }
        if (changed.total > indexTo && changed.to === null) {
          changed.to = i;
        }
      });

      if (changed.from !== changed.to) {
        colGroups[changed.from].colspan -= 1;
        colGroups[changed.to].colspan += 1;
      }
    },


    /**
    * Returns the text for a header adding built in defaults
    * @private
    * @param {object} col The column id.
    * @returns {string} The current header text
    */
    headerText: function headerText(col) {
      var text = col.name ? col.name : '';

      if (!text && col.id === 'drilldown') {
        text = Locale.translate('Drilldown');
        return '<span class="audible">' + text + '</span>';
      }

      return text;
    },


    /**
    * Render the header area.
    * @private
    */
    renderHeader: function renderHeader() {
      var self = this;
      var headerRow = '';
      var headerColGroup = '<colgroup>';
      var cols = '';
      var uniqueId = void 0;

      // Handle Nested Headers
      var colGroups = this.settings.columnGroups;
      if (colGroups) {
        this.element.addClass('has-group-headers');

        var columns = this.settings.columns;
        var columnsLen = columns.length;
        var visibleColumnsLen = this.visibleColumns().length;
        var groups = colGroups.map(function (group) {
          return parseInt(group.colspan, 10);
        });
        var getGroupsTotal = function getGroupsTotal() {
          return groups.reduce(function (a, b) {
            return a + b;
          }, 0);
        };
        var getDiff = function getDiff() {
          var groupsTotal = getGroupsTotal();
          return groupsTotal > columnsLen ? groupsTotal - columnsLen : columnsLen - groupsTotal;
        };

        headerRow += '<tr role="row" class="datagrid-header-groups">';

        var groupsTotal = getGroupsTotal();
        var diff = void 0;
        if (groupsTotal > columnsLen) {
          var move = true;
          for (var _i3 = groups.length - 1; _i3 >= 0 && move; _i3--) {
            diff = getDiff();
            if (groups[_i3] >= diff) {
              groups[_i3] -= diff;
              move = false;
            } else {
              groups[_i3] = 0;
            }
          }
        }

        var i = 0;
        var total = 0;
        groups.forEach(function (groupColspan, k) {
          var colspan = groupColspan;
          for (var l = i + groupColspan; i < l; i++) {
            if (i < columnsLen && columns[i].hidden) {
              colspan--;
            }
          }
          var hiddenStr = colGroups[k].hidden || colspan < 1 ? ' class="hidden"' : '';
          var colspanStr = ' colspan="' + (colspan > 0 ? colspan : 1) + '"';
          uniqueId = self.uniqueId('-header-group-' + k);
          if (colspan > 0) {
            total += colspan;
          }

          headerRow += '<th' + hiddenStr + colspanStr + ' id="' + uniqueId + '"><div class="datagrid-column-wrapper"><span class="datagrid-header-text">' + colGroups[k].name + '</span></div></th>';
        });

        if (total < visibleColumnsLen) {
          diff = visibleColumnsLen - total;
          var colspanStr = ' colspan="' + (diff > 0 ? diff : 1) + '"';
          headerRow += '<th' + colspanStr + '></th>';
        }
        headerRow += '</tr><tr>';
      } else {
        headerRow += '<tr role="row">';
      }

      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = self.settings.columns[j];

        var id = self.uniqueId('-header-' + j);
        var isSortable = column.sortable === undefined ? true : column.sortable;
        var isResizable = column.resizable === undefined ? true : column.resizable;
        var isExportable = column.exportable === undefined ? true : column.exportable;
        var isSelection = column.id === 'selectionCheckbox';
        var alignmentClass = column.align === 'center' ? ' l-' + column.align + '-text' : ''; // Disable right align for now as this was acting wierd

        headerRow += '<th scope="col" role="columnheader" class="' + (isSortable ? 'is-sortable' : '') + (isResizable ? ' is-resizable' : '') + (column.hidden ? ' is-hidden' : '') + (column.filterType ? ' is-filterable' : '') + (alignmentClass || '') + '" id="' + id + '" data-column-id="' + column.id + '"' + (column.field ? ' data-field="' + column.field + '"' : '') + (column.headerTooltip ? 'title="' + column.headerTooltip + '"' : '') + (column.reorderable === false ? ' data-reorder="false"' : '') + (colGroups ? ' headers="' + self.getColumnGroup(j) + '"' : '') + (isExportable ? 'data-exportable="yes"' : 'data-exportable="no"') + '>';

        var sortIndicator = '';
        if (isSortable) {
          sortIndicator = '' + ('<div class="sort-indicator">' + '<span class="sort-asc">') + $.createIcon({ icon: 'dropdown' }) + '</span>' + ('<span class="sort-desc">' + $.createIcon({ icon: 'dropdown' }) + '</div>');
        }

        headerRow += '<div class="' + (isSelection ? 'datagrid-checkbox-wrapper ' : 'datagrid-column-wrapper') + (column.align === undefined ? '' : ' l-' + column.align + '-text') + '"><span class="datagrid-header-text' + (column.required ? ' required' : '') + '">' + self.headerText(this.settings.columns[j]) + (column.align === 'center' ? sortIndicator : '') + '</span>';
        cols += '<col' + this.columnWidth(column, j) + (column.hidden ? ' class="is-hidden"' : '') + '>';

        if (isSelection) {
          if (self.settings.showSelectAllCheckBox) {
            headerRow += '<span aria-checked="false" class="datagrid-checkbox" aria-label="Selection" role="checkbox"></span>';
          } else {
            headerRow += '<span aria-checked="false" class="datagrid-checkbox" aria-label="Selection" role="checkbox" style="display:none"></span>';
          }
        }

        if (isSortable && column.align !== 'center') {
          headerRow += sortIndicator;
        }

        headerRow += '</div>' + self.filterRowHtml(column, j) + '</th>';
      }
      headerRow += '</tr>';

      headerColGroup += cols + '</colgroup>';

      if (self.headerRow === undefined) {
        self.headerContainer = $('<div class="datagrid-header"><table role="grid"></table></div>');
        self.headerTable = self.headerContainer.find('table');
        self.headerTable.width(this.headerTableWidth());
        self.headerColGroup = $(headerColGroup).appendTo(self.headerTable);
        DOM.append(self.headerContainer.find('table'), '<thead>' + headerRow + '</thead>', '*');
        self.headerRow = self.headerContainer.find('thead');
        self.element.prepend(self.headerContainer);
      } else {
        self.headerTable.width(this.headerTableWidth());
        DOM.html(self.headerRow, headerRow, '*');
        self.headerColGroup.html(cols);
      }

      if (colGroups && self.headerRow) {
        self.colGroups = self.headerRow.find('.datagrid-header-groups');
      }

      self.syncHeaderCheckbox(this.settings.dataset);

      if (self.settings.columnReorder) {
        self.createDraggableColumns();
      }

      this.attachFilterRowEvents();

      if (this.restoreSortOrder) {
        this.setSortIndicator(this.sortColumn.sortId, this.sortColumn.sortAsc);
        this.restoreSortOrder = false;
      }

      if (this.restoreFilter) {
        this.applyFilter(this.savedFilter, 'render');
        this.restoreFilter = false;
        this.savedFilter = null;
      }
    },


    /**
    * Set filter datepicker with range/single date.
    * @private
    * @param {object} input element to target datepicker.
    * @param {string} operator filter type.
    * @param {object} options pass in to datepicker.
    * @returns {void}
    */
    filterSetDatepicker: function filterSetDatepicker(input, operator, options) {
      var datepickerApi = input.data('datepicker');
      var isRange = input.data('is-range');
      options = options || {};

      // Init datepicker
      var initDatepicker = function initDatepicker() {
        if (datepickerApi && typeof datepickerApi.destroy === 'function') {
          datepickerApi.destroy();
        }
        input.datepicker(options);
      };

      // invoke datepicker
      if ((!datepickerApi || !isRange) && operator === 'in-range') {
        input.data('is-range', true);
        options.range = { useRange: true };
        initDatepicker();
      } else if ((!datepickerApi || isRange) && operator !== 'in-range') {
        input.removeData('is-range');
        initDatepicker();
      }
    },


    /**
    * Returns the markup for a specific filter row area.
    * @private
    * @param {object} columnDef The column object for the header
    * @param {object} idx The column idx for the header
    * @returns {string} The filter html to use
    */
    filterRowHtml: function filterRowHtml(columnDef, idx) {
      var self = this;
      var filterMarkup = '';

      // Generate the markup for the various Types
      // Supported Filter Types: text, integer, date, select, decimal,
      // lookup, percent, checkbox, contents
      if (columnDef.filterType) {
        var col = columnDef;
        var filterId = self.uniqueId('-header-filter-' + idx);
        var integerDefaults = void 0;

        filterMarkup = '<div class="datagrid-filter-wrapper" ' + (!self.settings.filterable ? ' style="display:none"' : '') + '>' + self.filterButtonHtml(col) + '<label class="audible" for="' + filterId + '">' + col.name + '</label>';

        switch (col.filterType) {
          case 'checkbox':
            // just the button
            break;
          case 'date':
            filterMarkup += '<input ' + (col.filterDisabled ? ' disabled' : '') + ' type="text" class="datepicker" id="' + filterId + '"/>';
            break;
          case 'integer':
            {
              integerDefaults = {
                patternOptions: {
                  allowNegative: true,
                  allowThousandsSeparator: false,
                  allowDecimal: false,
                  symbols: {
                    thousands: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.group : ',',
                    decimal: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.decimal : '.',
                    negative: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.minusSign : '-'
                  }
                },
                process: 'number'
              };

              col.maskOptions = utils.extend(true, {}, integerDefaults, col.maskOptions);
              filterMarkup += '<input' + (col.filterDisabled ? ' disabled' : '') + ' type="text" id="' + filterId + '" />';
              break;
            }
          case 'percent':
          case 'decimal':
            {
              var decimalDefaults = {
                patternOptions: {
                  allowNegative: true,
                  allowDecimal: true,
                  symbols: {
                    thousands: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.group : ',',
                    decimal: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.decimal : '.',
                    negative: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.minusSign : '-'
                  }
                },
                process: 'number'
              };

              if (col.numberFormat) {
                integerDefaults = {
                  patternOptions: { decimalLimit: col.numberFormat.maximumFractionDigits }
                };

                col.maskOptions = utils.extend(true, {}, integerDefaults, decimalDefaults, col.maskOptions);
              } else {
                col.maskOptions = utils.extend(true, {}, decimalDefaults, col.maskOptions);
              }

              filterMarkup += '<input' + (col.filterDisabled ? ' disabled' : '') + ' type="text" id="' + filterId + '" />';
              break;
            }
          case 'contents':
          case 'select':

            filterMarkup += '<select ' + (col.filterDisabled ? ' disabled' : '') + (col.filterType === 'select' ? ' class="dropdown"' : ' multiple class="multiselect"') + 'id="' + filterId + '">';
            if (col.options) {
              if (col.filterType === 'select') {
                filterMarkup += '<option></option>';
              }

              for (var i = 0; i < col.options.length; i++) {
                var option = col.options[i];
                var optionValue = col.caseInsensitive && typeof option.value === 'string' ? option.value.toLowerCase() : option.value;
                if (option && optionValue) {
                  filterMarkup += '<option value = "' + optionValue + '">' + option.label + '</option>';
                }
              }
            }
            filterMarkup += '</select><div class="dropdown-wrapper"><div class="dropdown"><span></span></div><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-dropdown"></use></svg></div>';

            break;
          case 'multiselect':
            filterMarkup += '<select ' + (col.filterDisabled ? ' disabled' : '') + (col.filterType === 'select' ? ' class="dropdown"' : ' multiple class="multiselect"') + 'id="' + filterId + '">';
            if (col.options) {
              if (col.filterType === 'select') {
                filterMarkup += '<option></option>';
              }

              for (var _i4 = 0; _i4 < col.options.length; _i4++) {
                var _option = col.options[_i4];
                var _optionValue = col.caseInsensitive && typeof _option.value === 'string' ? _option.value.toLowerCase() : _option.value;
                if (_option && _optionValue) {
                  filterMarkup += '<option value = "' + _optionValue + '">' + _option.label + '</option>';
                }
              }
            }
            filterMarkup += '</select><div class="dropdown-wrapper"><div class="dropdown"><span></span></div><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-dropdown"></use></svg></div>';

            break;
          case 'time':
            filterMarkup += '<input ' + (col.filterDisabled ? ' disabled' : '') + ' type="text" class="timepicker" id="' + filterId + '"/>';
            break;
          default:
            filterMarkup += '<input' + (col.filterDisabled ? ' disabled' : '') + ' type="text" id="' + filterId + '"/>';
            break;
        }

        filterMarkup += '</div>';
      }

      if (!columnDef.filterType) {
        filterMarkup = '<div class="datagrid-filter-wrapper"></div>';
      }
      return filterMarkup;
    },


    /**
    * Attach Events and initialize plugins for the filter row.
    * @private
    */
    attachFilterRowEvents: function attachFilterRowEvents() {
      var _this = this;

      var self = this;

      if (!this.settings.filterable) {
        return;
      }

      this.element.addClass('has-filterable-columns');

      if (this.settings.twoLineHeader) {
        this.element.addClass('has-two-line-header');
      }

      // Attach Keyboard support
      this.headerRow.off('click.datagrid-filter').on('click.datagrid-filter', '.btn-filter', function () {
        var popupOpts = { trigger: 'immediate', offset: { y: 15 }, placementOpts: { strategies: ['flip', 'nudge'] } };
        var popupmenu = $(this).data('popupmenu');

        if (popupmenu) {
          popupmenu.close(true, true);
        } else {
          $(this).off('beforeopen.datagrid-filter').on('beforeopen.datagrid-filter', function () {
            var menu = $(this).next('.popupmenu-wrapper');
            utils.fixSVGIcons(menu);
          }).popupmenu(popupOpts).off('selected.datagrid-filter').on('selected.datagrid-filter', function (e, anchor) {
            var rowElem = anchor.closest('th[role="columnheader"]');
            var col = self.columnById(rowElem.attr('data-column-id'))[0];

            // Set datepicker with range/single date
            if (col && col.filterType === 'date') {
              var input = rowElem.find('input');
              var svg = rowElem.find('.btn-filter .icon-dropdown:first');
              var operator = svg.getIconName().replace('filter-', '');
              self.filterSetDatepicker(input, operator);
            }
            self.applyFilter(null, 'selected');
          }).off('close.datagrid-filter').on('close.datagrid-filter', function () {
            var data = $(this).data('popupmenu');
            if (data) {
              data.destroy();
            }
          });
        }
        return false;
      });

      var typingTimer = void 0;
      this.headerRow.off('keydown.datagrid').on('keydown.datagrid', '.datagrid-filter-wrapper input', function (e) {
        clearTimeout(typingTimer);
        e.stopPropagation();

        if (e.which === 13) {
          self.applyFilter(null, 'enter');
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        return true;
      });

      if (this.settings.filterWhenTyping) {
        this.headerRow.off('keyup.datagrid').on('keyup.datagrid', '.datagrid-filter-wrapper input', function (e) {
          if (e.which === 13) {
            return;
          }

          if (_this.activeCell && _this.activeCell.isFocused) {
            _this.activeCell.isFocused = false;
          }

          clearTimeout(typingTimer);
          typingTimer = setTimeout(function () {
            self.applyFilter(null, 'keyup');
          }, 400);
        });
      }

      this.headerRow.find('tr:last th').each(function () {
        var col = self.columnById($(this).attr('data-column-id'))[0];
        var elem = $(this);

        if (!col) {
          // No ID found
          return true;
        }

        elem.find('select.dropdown').each(function () {
          var dropdown = $(this);
          dropdown.dropdown(col.editorOptions).on('selected.datagrid', function () {
            self.applyFilter(null, 'selected');
          });

          // Append the Dropdown's sourceArguments with some row/col meta-data
          var api = dropdown.data('dropdown');
          api.settings.sourceArguments = {
            column: col,
            container: elem,
            grid: self,
            cell: col,
            event: undefined,
            row: -1,
            rowData: {},
            value: undefined
          };
        });

        elem.find('select.multiselect').each(function () {
          var multiselect = $(this);
          multiselect.multiselect(col.editorOptions).on('selected.datagrid', function () {
            self.applyFilter(null, 'selected');
          });

          // Append the Dropdown's sourceArguments with some row/col meta-data
          var api = multiselect.data('dropdown');
          api.settings.sourceArguments = {
            column: col,
            container: elem,
            grid: self,
            cell: col,
            event: undefined,
            row: -1,
            rowData: {},
            value: undefined
          };
        });

        if (col.maskOptions) {
          elem.find('input').mask(col.maskOptions);
        }

        if (col.mask) {
          elem.find('input').mask(col.mask);
        }

        if (typeof elem.find('.datepicker').datepicker === 'function') {
          elem.find('.datepicker').datepicker(col.editorOptions ? col.editorOptions : { dateFormat: col.dateFormat }).on('listclosed.datepicker', function () {
            self.applyFilter(null, 'selected');
          });
        }

        if (typeof elem.find('.timepicker').datepicker === 'function') {
          elem.find('.timepicker').timepicker(col.editorOptions ? col.editorOptions : { timeFormat: col.timeFormat });
        }

        // Attach Mask
        if (col.mask) {
          elem.find('input').mask({ pattern: col.mask, mode: col.maskMode });
        }

        return null;
      });

      self.filterRowRendered = true;
    },


    /**
    * Render one filter item as used in renderFilterButton
    * @private
    * @param {object} icon The icon for the menu item
    * @param {object} text The text for the menu item
    * @param {object} checked If the menu item is selected
    * @returns {string} The html for the filter item.
    */
    filterItemHtml: function filterItemHtml(icon, text, checked) {
      var iconMarkup = $.createIcon({ classes: 'icon icon-filter', icon: 'filter-' + icon });
      return '<li ' + (checked ? 'class="is-checked"' : '') + '><a href="#">' + iconMarkup + '<span>' + Locale.translate(text) + '</span></a></li>';
    },


    /**
    * Render the Filter Button and Menu based on filterType - which determines the options
    * @private
    * @param {object} col The column object
    * @returns {string} The html for the filter button.
    */
    filterButtonHtml: function filterButtonHtml(col) {
      if (!col.filterType) {
        return '';
      }

      var self = this;
      var isDisabled = col.filterDisabled;
      var filterConditions = $.isArray(col.filterConditions) ? col.filterConditions : [];
      var inArray = function inArray(s, array) {
        array = array || filterConditions;
        return $.inArray(s, array) > -1;
      };
      var render = function render(icon, text, checked) {
        return filterConditions.length && !inArray(icon) ? '' : self.filterItemHtml(icon, text, checked);
      };
      var renderButton = function renderButton(defaultValue) {
        return '<button type="button" class="btn-menu btn-filter" data-init="false" ' + (isDisabled ? ' disabled' : '') + (defaultValue ? ' data-default="' + defaultValue + '"' : '') + ' type="button"><span class="audible">Filter</span>' + ('<svg class="icon-dropdown icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-filter-{{icon}}"></use></svg>' + $.createIcon({ icon: 'dropdown', classes: 'icon-dropdown' }) + '</button><ul class="popupmenu has-icons is-translatable is-selectable">');
      };
      var btnMarkup = '';

      // Just the dropdown
      if (col.filterType === 'contents' || col.filterType === 'select' || col.filterType === 'multiselect') {
        return '';
      }

      if (col.filterType === 'text') {
        btnMarkup = renderButton('contains') + render('contains', 'Contains', true) + render('does-not-contain', 'DoesNotContain') + render('equals', 'Equals') + render('does-not-equal', 'DoesNotEqual') + render('is-empty', 'IsEmpty') + render('is-not-empty', 'IsNotEmpty');
        btnMarkup = btnMarkup.replace('{{icon}}', 'contains');
      }

      if (col.filterType === 'checkbox') {
        btnMarkup += renderButton('selected-notselected') + render('selected-notselected', 'All', true) + render('selected', 'Selected') + render('not-selected', 'NotSelected');
        btnMarkup = btnMarkup.replace('{{icon}}', 'selected-notselected');
      }

      if (col.filterType !== 'checkbox' && col.filterType !== 'text') {
        btnMarkup += renderButton('equals') + render('equals', 'Equals', col.filterType === 'integer' || col.filterType === 'decimal' || col.filterType === 'date' || col.filterType === 'time') + render('does-not-equal', 'DoesNotEqual') + render('is-empty', 'IsEmpty') + render('is-not-empty', 'IsNotEmpty');
        btnMarkup = btnMarkup.replace('{{icon}}', 'equals');
      }

      if (col.filterType === 'date') {
        btnMarkup += render('in-range', 'InRange');
      }

      if (/\b(integer|decimal|date|time|percent)\b/g.test(col.filterType)) {
        btnMarkup += '' + render('less-than', 'LessThan') + render('less-equals', 'LessOrEquals') + render('greater-than', 'GreaterThan') + render('greater-equals', 'GreaterOrEquals');
        btnMarkup = btnMarkup.replace('{{icon}}', 'less-than');
      }

      if (col.filterType === 'text') {
        btnMarkup += '' + render('end-with', 'EndsWith') + render('does-not-end-with', 'DoesNotEndWith') + render('start-with', 'StartsWith') + render('does-not-start-with', 'DoesNotStartWith');
        btnMarkup = btnMarkup.replace('{{icon}}', 'end-with');
      }

      btnMarkup += '</ul>';
      return btnMarkup;
    },


    /**
    * Toggle the visibility of the filter row.
    */
    toggleFilterRow: function toggleFilterRow() {
      if (this.settings.filterable) {
        this.headerRow.removeClass('is-filterable');
        this.headerRow.find('.is-filterable').removeClass('is-filterable');
        this.headerRow.find('.datagrid-filter-wrapper').hide();
        this.settings.filterable = false;
        this.filterRowRendered = false;
        this.element.removeClass('has-filterable-columns');
        this.element.removeClass('has-two-line-header');
        /**
        *  Fires after the filter row is closed by the user.
        * @event closefilterrow
        * @memberof Datagrid
        * @property {object} event The jquery event object
        */
        this.element.triggerHandler('closefilterrow');
      } else {
        this.settings.filterable = true;
        this.filterRowRendered = true;

        this.element.addClass('has-filterable-columns');

        if (this.settings.twoLineHeader) {
          this.element.addClass('has-two-line-header');
        }

        this.headerRow.addClass('is-filterable');
        this.headerRow.find('.is-filterable').addClass('is-filterable');
        this.headerRow.find('.datagrid-filter-wrapper').show();

        /**
        * Fires after the filter row is opened by the user.
        * @event openfilterrow
        * @memberof Datagrid
        * @property {object} event The jquery event object
        */
        this.element.triggerHandler('openfilterrow');
        this.attachFilterRowEvents();
      }
    },


    /**
    * Apply the Filter with the currently selected conditions, or the ones passed in.
    * @param {object} conditions An array of objects with the filter conditions.
    * @param {string} [trigger] A string to identify the triggering action.
    */
    applyFilter: function applyFilter(conditions, trigger) {
      var self = this;
      this.filteredDataset = null;

      if (conditions) {
        this.setFilterConditions(conditions);
      } else {
        conditions = this.filterConditions();
      }

      var checkRow = function checkRow(rowData) {
        var isMatch = true;

        var _loop = function _loop(i) {
          var columnDef = self.columnById(conditions[i].columnId)[0];

          var rowValue = rowData ? rowData[columnDef.field] : self.fieldValue(rowData, columnDef.field);
          var rowValueStr = rowValue === null || rowValue === undefined ? '' : rowValue.toString().toLowerCase();
          var conditionValue = conditions[i].value.toString().toLowerCase();
          var rangeData = null;

          // Percent filter type
          if (columnDef.filterType === 'percent') {
            conditionValue = (conditionValue / 100).toString();
            if (('' + columnDef.name).toLowerCase() === 'decimal') {
              rowValue = formatters.Decimal(false, false, rowValue, columnDef);
              conditionValue = formatters.Decimal(false, false, conditionValue, columnDef);
            } else if (('' + columnDef.name).toLowerCase() === 'integer') {
              rowValue = formatters.Integer(false, false, rowValue, columnDef);
              conditionValue = formatters.Integer(false, false, conditionValue, columnDef);
            }
          }

          // Run Data over the formatter
          if (columnDef.filterType === 'text') {
            var fmt = columnDef.formatter;
            var id = conditions[i].columnId;
            rowValue = self.formatValue(fmt, i, id, rowValue, columnDef, rowData, self);

            // Strip any html markup that might be in the formatters
            var rex = /(<([^>]+)>)|(amp;)|(&lt;([^>]+)&gt;)/ig;
            rowValue = rowValue.replace(rex, '').trim().toLowerCase();

            rowValueStr = rowValue === null || rowValue === undefined ? '' : rowValue.toString().toLowerCase();
          }

          if (columnDef.filterType === 'contents' || columnDef.filterType === 'select' || columnDef.filterType === 'multiselect') {
            rowValue = rowValue.toLowerCase();
          }

          if ((typeof rowValue === 'number' || !isNaN(rowValue) && rowValue !== '') && columnDef.filterType !== 'date' && columnDef.filterType !== 'time') {
            rowValue = parseFloat(rowValue);
            conditionValue = Locale.parseNumber(conditionValue);
          }

          if (columnDef.filterType === 'date' || columnDef.filterType === 'time') {
            if (columnDef.filterType === 'date' && typeof rowValue === 'string') {
              rowValue = columnDef.formatter(false, false, rowValue, columnDef, true);
            }
            var getValues = function getValues(rValue, cValue) {
              cValue = Locale.parseDate(cValue, conditions[i].format);
              if (cValue) {
                if (columnDef.filterType === 'time') {
                  // drop the day, month and year
                  cValue.setDate(1);
                  cValue.setMonth(0);
                  cValue.setYear(0);
                }

                cValue = cValue.getTime();
              }

              if (rValue instanceof Date) {
                // Copy date
                rValue = new Date(rValue.getTime());
                if (columnDef.filterType === 'time') {
                  // drop the day, month and year
                  rValue.setDate(1);
                  rValue.setMonth(0);
                  rValue.setYear(0);
                } else if (!(columnDef.editorOptions && columnDef.editorOptions.showTime)) {
                  // Drop any time component of the row data for the filter as it is a date only field
                  rValue.setHours(0);
                  rValue.setMinutes(0);
                  rValue.setSeconds(0);
                  rValue.setMilliseconds(0);
                }
                rValue = rValue.getTime();
              } else if (typeof rValue === 'string' && rValue) {
                if (!columnDef.sourceFormat) {
                  rValue = Locale.parseDate(rValue, { pattern: conditions[i].format });
                } else {
                  rValue = Locale.parseDate(rValue, typeof columnDef.sourceFormat === 'string' ? { pattern: columnDef.sourceFormat } : columnDef.sourceFormat);
                }

                if (rValue) {
                  if (columnDef.filterType === 'time') {
                    // drop the day, month and year
                    rValue.setDate(1);
                    rValue.setMonth(0);
                    rValue.setYear(0);
                  } else if (!(columnDef.editorOptions && columnDef.editorOptions.showTime)) {
                    // Drop any time component of the row data for the filter
                    // as it is a date only field
                    rValue.setHours(0);
                    rValue.setMinutes(0);
                    rValue.setSeconds(0);
                    rValue.setMilliseconds(0);
                  }
                  rValue = rValue.getTime();
                }
              }
              return { rValue: rValue, cValue: cValue };
            };

            var values = null;
            if (conditions[i].operator === 'in-range') {
              var cell = self.settings.columns.indexOf(columnDef);
              var input = self.headerRow.find('th:eq(' + cell + ') .datagrid-filter-wrapper input');
              var datepickerApi = input.data('datepicker');
              if (datepickerApi) {
                rangeData = datepickerApi.settings.range.data;
                if (rangeData && rangeData.start) {
                  values = getValues(rowValue, rangeData.start);
                }
              }
            } else {
              values = getValues(rowValue, conditions[i].value);
            }
            rowValue = values ? values.rValue : rowValue;
            conditionValue = values ? values.cValue : conditionValue;
          }

          switch (conditions[i].operator) {
            case 'equals':

              // This case is multiselect
              if (conditions[i].value instanceof Array) {
                isMatch = false;

                for (var k = 0; k < conditions[i].value.length; k++) {
                  var match = conditions[i].value[k].toLowerCase().indexOf(rowValue) >= 0 && (rowValue.toString() !== '' || conditions[i].value[k] === '');
                  if (match) {
                    isMatch = true;
                  }
                }
              } else {
                isMatch = rowValue === conditionValue && rowValue !== '';
              }

              break;
            case 'does-not-equal':
              isMatch = rowValue !== conditionValue;
              break;
            case 'contains':
              isMatch = rowValueStr.indexOf(conditionValue) > -1 && rowValue.toString() !== '';
              break;
            case 'does-not-contain':
              isMatch = rowValueStr.indexOf(conditionValue) === -1;
              break;
            case 'end-with':
              isMatch = rowValueStr.lastIndexOf(conditionValue) === rowValueStr.length - conditionValue.toString().length && rowValueStr !== '' && rowValueStr.length >= conditionValue.toString().length;
              break;
            case 'start-with':
              isMatch = rowValueStr.indexOf(conditionValue) === 0 && rowValueStr !== '';
              break;
            case 'does-not-end-with':
              isMatch = rowValueStr.lastIndexOf(conditionValue) === rowValueStr.length - conditionValue.toString().length && rowValueStr !== '' && rowValueStr.length >= conditionValue.toString().length;
              isMatch = !isMatch;
              break;
            case 'does-not-start-with':
              isMatch = !(rowValueStr.indexOf(conditionValue) === 0 && rowValueStr !== '');
              break;
            case 'is-empty':
              isMatch = rowValueStr === '';
              break;
            case 'is-not-empty':
              isMatch = rowValue !== '';
              break;
            case 'in-range':
              isMatch = false;
              if (rangeData && rangeData.startDate && rangeData.endDate) {
                var d1 = rangeData.startDate.getTime();
                var d2 = rangeData.endDate.getTime();
                isMatch = rowValue >= d1 && rowValue <= d2;
              }
              break;
            case 'less-than':
              isMatch = rowValue < conditionValue && rowValue !== '';
              break;
            case 'less-equals':
              isMatch = rowValue <= conditionValue && rowValue !== '';
              break;
            case 'greater-than':
              isMatch = rowValue > conditionValue && rowValue !== '';
              break;
            case 'greater-equals':
              isMatch = rowValue >= conditionValue && rowValue !== '';
              break;
            case 'selected':
              if (columnDef && columnDef.isChecked) {
                isMatch = columnDef.isChecked(rowValue);
                break;
              }
              isMatch = (rowValueStr === '1' || rowValueStr === 'true' || rowValue === true || rowValue === 1) && rowValueStr !== '';
              break;
            case 'not-selected':
              if (columnDef && columnDef.isChecked) {
                isMatch = !columnDef.isChecked(rowValue);
                break;
              }
              isMatch = (rowValueStr === '0' || rowValueStr === 'false' || rowValue === false || rowValue === 0) && rowValueStr !== '';
              break;
            case 'selected-notselected':
              isMatch = true;
              break;
            default:
          }

          if (!isMatch) {
            return {
              v: false
            };
          }
        };

        for (var i = 0; i < conditions.length; i++) {
          var _ret = _loop(i);

          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
        }
        return isMatch;
      };

      if (!this.settings.disableClientFilter) {
        var dataset = void 0;
        var isFiltered = void 0;
        var i = void 0;
        var ii = void 0;
        var len = void 0;
        var dataSetLen = void 0;

        if (this.settings.treeGrid) {
          dataset = this.settings.dataset;

          var checkChildNodes = function checkChildNodes(nodeData, parentNode) {
            for (var j = 0; j < nodeData.length; j++) {
              var childNode = nodeData[j];

              if (isFiltered) {
                isFiltered = !checkRow(childNode);
              }

              childNode.isFiltered = !checkRow(childNode);

              if (parentNode && !childNode.isFiltered) {
                parentNode.isFiltered = false;
              }

              if (childNode.children && childNode.children.length) {
                checkChildNodes(childNode.children, childNode);
              }
            }
          };

          for (i = 0, len = dataset.length; i < len; i++) {
            isFiltered = !checkRow(dataset[i]);

            if (dataset[i].children && dataset[i].children.length) {
              checkChildNodes(dataset[i].children);
            }

            dataset[i].isFiltered = isFiltered;
          }
        } else if (this.settings.groupable) {
          for (i = 0, len = this.settings.dataset.length; i < len; i++) {
            var isGroupFiltered = true;
            for (ii = 0, dataSetLen = this.settings.dataset[i].values.length; ii < dataSetLen; ii++) {
              isFiltered = !checkRow(this.settings.dataset[i].values[ii]);
              this.settings.dataset[i].values[ii].isFiltered = isFiltered;

              if (!isFiltered) {
                isGroupFiltered = false;
              }
            }

            this.settings.dataset[i].isFiltered = isGroupFiltered;
          }
        } else {
          for (i = 0, len = this.settings.dataset.length; i < len; i++) {
            isFiltered = !checkRow(this.settings.dataset[i]);
            this.settings.dataset[i].isFiltered = isFiltered;
          }
        }
      }

      if (!this.settings.source) {
        this.renderRows();
      }
      this.setSearchActivePage();

      /**
      * Fires after a filter action ocurs
      * @event filtered
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Object with the arguments
      * @property {number} args.op The filter operation, this can be 'apply', 'clear'
      * @property {object} args.conditions An object with all the condition data.
      * @property {string} args.trigger Info on what was the triggering action. May be render, select or key
      */
      this.element.trigger('filtered', { op: 'apply', conditions: conditions, trigger: trigger });
      this.resetPager('filtered', trigger);
      this.saveUserSettings();
    },


    /**
    * Clear the Filter row Conditions and Reset the Data.
    */
    clearFilter: function clearFilter() {
      if (!this.settings.filterable) {
        return;
      }

      this.headerRow.find('input, select').val('').trigger('updated');
      // reset all the filters to first item
      this.headerRow.find('.btn-filter').each(function () {
        var btn = $(this);
        var ul = btn.next();
        var first = ul.find('li:first');

        btn.find('svg:first > use').attr('xlink:href', '#icon-filter-' + btn.attr('data-default'));
        ul.find('.is-checked').removeClass('is-checked');
        first.addClass('is-checked');
      });

      this.applyFilter();
      this.element.trigger('filtered', { op: 'clear', conditions: [] });
    },


    /**
    * Set the Filter Conditions on the UI Only.
    * @param {object} conditions An array of objects with the filter conditions.
    */
    setFilterConditions: function setFilterConditions(conditions) {
      for (var i = 0; i < conditions.length; i++) {
        // Find the filter row
        var rowElem = this.headerRow.find('th[data-column-id="' + conditions[i].columnId + '"]');
        var input = rowElem.find('input, select');
        var btn = rowElem.find('.btn-filter');

        if (conditions[i].value === undefined) {
          conditions[i].value = '';
        }

        input.val(conditions[i].value);

        if (input.is('select')) {
          if (conditions[i].value instanceof Array) {
            for (var j = 0; j < conditions[i].value.length; j++) {
              input.find('option[value="' + conditions[i].value[j] + '"]').prop('selected', true);
            }
          } else {
            input.find('option[value="' + conditions[i].value + '"]').prop('selected', true);
          }
          input.trigger('updated');
        }

        btn.find('svg:first > use').attr('xlink:href', '#icon-filter-' + conditions[i].operator);
      }
    },


    /**
    * Get filter conditions in array from whats set in the UI.
    * @returns {array} An array with the currently showing filter conditions.
    */
    filterConditions: function filterConditions() {
      // Do not modify keyword search filter expr
      if (this.filterExpr && this.filterExpr.length === 1 && this.filterExpr[0].keywordSearch) {
        delete this.filterExpr[0].keywordSearch;
        return this.filterExpr;
      }

      var self = this;
      this.filterExpr = [];

      // Create an array of objects with: field, id, filterType, operator, value
      this.headerRow.find('th').each(function () {
        var rowElem = $(this);
        var btn = rowElem.find('.btn-filter');
        var input = rowElem.find('input, select');
        var isDropdown = input.is('select');
        var svg = btn.find('.icon-dropdown:first');
        var op = null;
        var format = null;

        if (!btn.length && !isDropdown) {
          return;
        }

        op = isDropdown ? 'equals' : svg.getIconName().replace('filter-', '');

        if (op === 'selected-notselected') {
          return;
        }

        if (input.val() === '' && ['is-not-empty', 'is-empty', 'selected', 'not-selected'].indexOf(op) === -1) {
          return;
        }

        if (input.val() instanceof Array && input.val().length === 0) {
          return;
        }

        var value = input.val() ? input.val() : '';
        if (input.attr('data-mask-mode') && input.attr('data-mask-mode') === 'number') {
          value = Locale.parseNumber(value);
        }

        var condition = {
          columnId: rowElem.attr('data-column-id'),
          operator: op,
          value: value
        };

        if (input.data('datepicker')) {
          format = input.data('datepicker').settings.dateFormat;
          if (format === 'locale') {
            format = Locale.calendar().dateFormat.short;
          }
          condition.format = format;
        }

        if (input.data('timepicker')) {
          format = input.data('timepicker').settings.timeFormat;
          condition.format = format;
        }

        self.filterExpr.push(condition);
      });

      return self.filterExpr;
    },


    /**
    * Get extra top position for current target in header
    * @private
    * @returns {number} the extra top position of the rows depending on rowHeight setting.
    */
    getExtraTop: function getExtraTop() {
      var s = this.settings;
      var topPositions = {
        default: { short: 0, medium: 0, normal: 0 },
        filterable: { short: 0, medium: 0, normal: 0 },
        group: { short: -25, medium: -30, normal: -39 },
        groupFilterable: { short: -29, medium: -30, normal: -41 }
      };
      var extraTop = 0;
      if (s.columnGroups) {
        extraTop = s.filterable ? topPositions.groupFilterable[s.rowHeight] : topPositions.group[s.rowHeight];
      } else {
        extraTop = s.filterable ? topPositions.filterable[s.rowHeight] : topPositions.default[s.rowHeight];
      }
      return extraTop;
    },


    /**
    * Get height for current target in header
    * @private
    * @returns {number} the height of the rows depending on rowHeight setting.
    */
    getTargetHeight: function getTargetHeight() {
      var s = this.settings;
      var heights = {
        default: { short: 20, medium: 28, normal: 35 },
        filterable: { short: 48, medium: 51, normal: 56 },
        group: { short: 46, medium: 56, normal: 74 },
        groupFilterable: { short: 78, medium: 84, normal: 99 }
      };
      var height = 0;
      if (s.columnGroups) {
        height = s.filterable ? heights.groupFilterable[s.rowHeight] : heights.group[s.rowHeight];
      } else {
        height = s.filterable ? heights.filterable[s.rowHeight] : heights.default[s.rowHeight];
      }
      return height;
    },


    /**
    * Create draggable columns
    * @private
    */
    createDraggableColumns: function createDraggableColumns() {
      var self = this;
      var headers = self.headerNodes().not('[data-column-id="selectionCheckbox"]');
      var showTarget = $('.drag-target-arrows', self.element);

      if (!showTarget.length) {
        self.element.prepend('<span class="drag-target-arrows" style="height: ' + self.getTargetHeight() + 'px;"></span>');
        showTarget = $('.drag-target-arrows', self.element);
      }

      headers.not('[data-reorder="false"]').prepend('</span><span class="handle">&#8286;</span>');
      headers.prepend('<span class="is-draggable-target"></span>');
      headers.last().append('<span class="is-draggable-target last"></span>');
      self.element.addClass('has-draggable-columns');

      // Initialize Drag api
      $('.handle', headers).each(function () {
        var clone = null;
        var headerPos = null;
        var offPos = null;
        var extraTopPos = 0;
        var handle = $(this);
        var header = handle.parent();

        handle.on('mousedown.datagrid', function (e) {
          e.preventDefault();

          header.drag({
            clone: true, cloneAppendTo: headers.first().parent().parent(), clonePosIsFixed: true
          }).on('dragstart.datagrid', function (dragStartEvent, pos, thisClone) {
            clone = thisClone;

            clone.removeAttr('id').addClass('is-dragging-clone').css({ left: pos.left, top: pos.top, height: header.height(), border: 0 });

            $('.is-draggable-target', clone).remove();

            self.setDraggableColumnTargets();

            extraTopPos = self.getExtraTop();
            headerPos = header.position();
            offPos = { top: pos.top - headerPos.top, left: pos.left - headerPos.left };

            var index = self.targetColumn(headerPos);
            self.draggableStatus.startIndex = index;
            e.stopImmediatePropagation();
          }).on('drag.datagrid', function (dragEvent, pos) {
            clone[0].style.left = parseInt(pos.left, 10) + 'px';
            clone[0].style.top = parseInt(pos.top, 10) + 'px';
            headerPos = { top: pos.top - offPos.top, left: pos.left - offPos.left };

            var n = 0;
            var target = null;
            var rect = null;
            var index = self.targetColumn(headerPos);

            $('.is-draggable-target', headers).add(showTarget).removeClass('is-over');

            if (index !== -1) {
              for (var i = 0, l = self.draggableColumnTargets.length; i < l; i++) {
                target = self.draggableColumnTargets[i];
                n = i + 1;

                if (target.index === index && target.index !== self.draggableStatus.startIndex) {
                  if (target.index > self.draggableStatus.startIndex && n < l) {
                    target = self.draggableColumnTargets[n];
                  }

                  target.el.addClass('is-over');
                  showTarget.addClass('is-over');
                  rect = target.el[0].getBoundingClientRect();
                  showTarget[0].style.left = parseInt(rect.left, 10) + 'px';
                  showTarget[0].style.top = parseInt(rect.top, 10) + 1 + extraTopPos + 'px';
                }
              }
            }

            e.stopImmediatePropagation();
          }).on('dragend.datagrid', function (dragendEvent, pos) {
            clone[0].style.left = parseInt(pos.left, 10) + 'px';
            clone[0].style.top = parseInt(pos.top, 10) + 'px';

            headerPos = { top: pos.top - offPos.top, left: pos.left - offPos.left };

            var index = self.targetColumn(headerPos);
            var dragApi = header.data('drag');
            var tempArray = [];
            var i = void 0;
            var l = void 0;
            var indexFrom = void 0;
            var indexTo = void 0;

            // Unbind drag from header
            if (dragApi && dragApi.destroy) {
              dragApi.destroy();
            }

            self.draggableStatus.endIndex = index;
            $('.is-draggable-target', headers).add(showTarget).removeClass('is-over');

            if (self.draggableStatus.endIndex !== -1) {
              if (self.draggableStatus.startIndex !== self.draggableStatus.endIndex) {
                // Swap columns
                for (i = 0, l = self.settings.columns.length; i < l; i++) {
                  if (!self.settings.columns[i].hidden && self.settings.columns[i].id !== 'selectionCheckbox') {
                    tempArray.push(i);
                  }
                }

                indexFrom = tempArray[self.draggableStatus.startIndex] || 0;
                indexTo = tempArray[self.draggableStatus.endIndex] || 0;

                self.updateGroupHeadersAfterColumnReorder(indexFrom, indexTo);
                self.arrayIndexMove(self.settings.columns, indexFrom, indexTo);
                self.updateColumns(self.settings.columns);
              }
            }
          });
        });
      });
    },


    /**
    * Set draggable columns target elements
    * @private
    */
    setDraggableColumnTargets: function setDraggableColumnTargets() {
      var self = this;
      var headers = self.headerNodes().not('.is-hidden').not('[data-column-id="selectionCheckbox"]');
      var target = void 0;
      var pos = void 0;
      var extra = void 0;

      self.draggableColumnTargets = [];
      self.draggableStatus = {};

      // Move last target if not found in last header
      if (!$('.is-draggable-target.last', headers.last()).length) {
        headers.last().append($('.is-draggable-target.last', self.headerNodes()));
      }

      $('.is-draggable-target', headers).each(function (index) {
        var idx = $(this).is('.last') ? index - 1 : index; // Extra target for last header th
        target = headers.eq(idx);
        pos = target.position();
        // Extra space around, if dropped item bit off from drop area
        extra = 20;

        self.draggableColumnTargets.push({
          el: $(this),
          index: idx,
          pos: pos,
          width: target.outerWidth(),
          height: target.outerHeight(),
          dropArea: {
            x1: pos.left - extra,
            x2: pos.left + target.outerWidth() + extra,
            y1: pos.top - extra + self.getExtraTop(),
            y2: pos.top + target.outerHeight() + extra
          }
        });
      });
    },


    /**
    * Get column index for dragging columns
    * @private
    * @param {object} pos The position index
    * @returns {number} The column array index
    */
    targetColumn: function targetColumn(pos) {
      var self = this;
      var idx = -1;
      var target = void 0;
      var i = void 0;
      var l = void 0;

      for (i = 0, l = self.draggableColumnTargets.length - 1; i < l; i++) {
        target = self.draggableColumnTargets[i];
        if (pos.left > target.dropArea.x1 && pos.left < target.dropArea.x2 && pos.top > target.dropArea.y1 && pos.top < target.dropArea.y2) {
          idx = target.index;
        }
      }
      return idx;
    },


    /**
    * Move an array element to a different position. May be dups of this function.
    * @private
    * @param {array} arr The array
    * @param {array} from The from position
    * @param {array} to The to position
    */
    arrayIndexMove: function arrayIndexMove(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
    },


    /**
    * Attach Drag Events to Rows
    * @private
    */
    createDraggableRows: function createDraggableRows() {
      var self = this;

      if (!this.settings.rowReorder) {
        return;
      }

      this.tableBody.children().filter(function () {
        return $(this).find('.datagrid-reorder-icon').length < 1;
      }).attr('data-arrange-exclude', true);

      // Attach the Drag API
      this.tableBody.arrange({
        placeholder: '<tr class="datagrid-reorder-placeholder"><td colspan="' + this.visibleColumns().length + '"></td></tr>',
        handle: '.datagrid-reorder-icon',
        isVisualItems: true
      }).off('beforearrange.datagrid').on('beforearrange.datagrid', function (e, status) {
        if (self.isSafari) {
          status.start.css({ display: 'inline-block' });
        }
      }).off('arrangeupdate.datagrid').on('arrangeupdate.datagrid', function (e, status) {
        if (self.isSafari) {
          status.end.css({ display: '' });
        }
        // Move the elem in the data set
        var first = self.settings.dataset.splice(status.startIndex, 1)[0];
        self.settings.dataset.splice(status.endIndex, 0, first);

        var moveDown = status.endIndex > status.startIndex;

        // If using expandable rows move the expandable row with it
        if ((self.settings.rowTemplate || self.settings.expandableRow) && moveDown) {
          self.tableBody.find('tr').eq(status.startIndex * 2).insertAfter(status.end);
          status.end.next().next().insertAfter(status.over);
        }

        if ((self.settings.rowTemplate || self.settings.expandableRow) && !moveDown) {
          self.tableBody.find('tr').eq(status.startIndex * 2).next().insertAfter(status.end);
        }

        // Resequence the rows
        var allRows = self.tableBody.find('tr:not(.datagrid-expandable-row)');
        for (var i = 0; i < allRows.length; i++) {
          allRows[i].setAttribute('data-index', i);
          allRows[i].setAttribute('aria-rowindex', i + 1);
        }

        /**
        * Fires after a row is moved via the rowReorder option.
        * @event rowremove
        * @memberof Datagrid
        * @property {object} event The jquery event object
        * @property {object} status Object with row reorder info
        * @property {number} status.endIndex The ending row index
        * @property {number} status.startIndex The starting row index
        * @property {HTMLElement} status.over The row object that was dragged over.
        * @property {HTMLElement} status.start The starting row object.
        */
        self.element.trigger('rowreorder', [status]);
      });
    },


    /**
    * Return the value in a field, taking into account nested objects. Fx obj.field.id
    * @private
    * @param {object} obj The object to use
    * @param {string} field The field as a string fx 'field' or 'obj.field.id'
    * @returns {any} The current value in the field.
    */
    fieldValue: function fieldValue(obj, field) {
      if (!field || !obj) {
        return '';
      }

      if (field.indexOf('.') > -1) {
        return field.split('.').reduce(function (o, x) {
          return o ? o[x] : '';
        }, obj);
      }

      var rawValue = obj[field];
      var value = rawValue || rawValue === 0 || rawValue === false ? rawValue : '';

      value = xssUtils.escapeHTML(value);
      return value;
    },


    /**
    * Setup internal tree root nodes array.
    * @private
    */
    setTreeRootNodes: function setTreeRootNodes() {
      if (!this.settings.treeGrid) {
        return;
      }
      this.settings.treeRootNodes = this.settings.treeDepth.filter(function (node) {
        return node.depth === 1;
      });
    },


    /**
     * Setup internal tree depth array.
     * @private
     * @param {array} dataset The json array to use for calculating tree depth.
     */
    setTreeDepth: function setTreeDepth(dataset) {
      if (!this.settings.treeGrid) {
        return;
      }
      var self = this;
      var idx = 0;
      var iterate = function iterate(node, depth) {
        idx++;
        self.settings.treeDepth.push({ idx: idx, depth: depth, node: node });
        var children = node.children || [];
        for (var i = 0, len = children.length; i < len; i++) {
          iterate(children[i], depth + 1);
        }
      };

      dataset = dataset || this.settings.dataset;
      self.settings.treeDepth = [];

      for (var i = 0, len = dataset.length; i < len; i++) {
        iterate(dataset[i], 1);
      }
    },


    /**
    * Setup internal row grouping
    * @private
    */
    setRowGrouping: function setRowGrouping() {
      var groupSettings = this.settings.groupable;
      if (!groupSettings) {
        return;
      }

      this.originalDataset = this.settings.dataset.slice();

      if (!groupSettings.aggregator || groupSettings.aggregator === 'none') {
        this.settings.dataset = groupBy.none(this.settings.dataset, groupSettings.fields);
        return;
      }

      if (groupSettings.aggregator === 'sum') {
        this.settings.dataset = groupBy.sum(this.settings.dataset, groupSettings.fields, groupSettings.aggregate);
        return;
      }

      if (groupSettings.aggregator === 'max') {
        this.settings.dataset = groupBy.max(this.settings.dataset, groupSettings.fields, groupSettings.aggregate);
        return;
      }

      if (groupSettings.aggregator === 'list') {
        this.settings.dataset = groupBy.list(this.settings.dataset, groupSettings.fields, groupSettings.aggregatorOptions);
        return;
      }

      this.settings.dataset = groupBy(this.settings.dataset, groupSettings.fields);
    },


    /**
    * Clear the table body and rows.
    * @private
    */
    renderRows: function renderRows() {
      var tableHtml = '';
      var self = this;
      var s = self.settings;
      var activePage = self.pager ? self.pager.activePage : 1;
      var body = self.table.find('tbody');

      self.bodyColGroupHtml = '<colgroup>';
      self.triggerDestroyCell(); // Trigger Destroy on previous cells

      // Prevent flashing message area on filter / reload
      if (self.emptyMessageContainer) {
        self.emptyMessageContainer.hide();
      }

      if (body.length === 0) {
        self.tableBody = $('<tbody></tbody>');
        self.table.append(self.tableBody);
      }

      self.groupArray = [];

      self.recordCount = 0;
      self.filteredCount = 0;

      // Reset recordCount for paging
      if (s.treeGrid && s.paging && !s.source && activePage > 1) {
        self.recordCount = s.treeRootNodes[s.pagesize * activePage - s.pagesize].idx - 1;
      }

      if (this.restoreSortOrder) {
        this.sortDataset();
      }

      var rowStatusTooltip = false;
      for (var i = 0; i < s.dataset.length; i++) {
        // For better performance dont render out of page
        if (s.paging && !s.source) {
          if (activePage === 1 && i - this.filteredCount >= s.pagesize) {
            if (!s.dataset[i].isFiltered) {
              this.recordCount++;
            } else {
              this.filteredCount++;
            }
            continue; //eslint-disable-line
          }

          if (activePage > 1 && !(i - this.filteredCount >= s.pagesize * (activePage - 1) && i - this.filteredCount < s.pagesize * activePage)) {
            if (!s.dataset[i].isFiltered) {
              if (this.filteredCount) {
                this.recordCount++;
              }
            } else {
              this.filteredCount++;
            }
            continue; //eslint-disable-line
          }
        }

        if (s.virtualized) {
          if (!this.isRowVisible(this.recordCount)) {
            this.recordCount++;
            continue; //eslint-disable-line
          }
        }

        // Exclude Filtered Rows
        if ((s.treeGrid ? s.treeRootNodes[i].node : s.dataset[i]).isFiltered) {
          this.filteredCount++;
          continue; //eslint-disable-line
        }

        // Handle Grouping
        if (this.settings.groupable) {
          // First push group row
          if (!this.settings.groupable.suppressGroupRow) {
            // Show the grouping row
            tableHtml += self.rowHtml(s.dataset[i], this.recordCount, i, true);
          }

          if (this.settings.groupable.showOnlyGroupRow && s.dataset[i].values[0]) {
            var rowData = s.dataset[i].values[0];

            if (s.dataset[i].list) {
              rowData.list = s.dataset[i].list;
            }

            rowData.values = s.dataset[i].values;
            tableHtml += self.rowHtml(rowData, this.recordCount, i);
            this.recordCount++;
            self.groupArray.push({ group: i, node: 0 });
            continue; //eslint-disable-line
          }

          // Now Push Groups
          for (var k = 0; k < s.dataset[i].values.length; k++) {
            if (!s.dataset[i].values[k].isFiltered) {
              tableHtml += self.rowHtml(s.dataset[i].values[k], this.recordCount, i);
              this.recordCount++;
              self.groupArray.push({ group: i, node: k });
            }
          }

          // Now Push summary rowHtml
          if (this.settings.groupable.groupFooterRow) {
            tableHtml += self.rowHtml(s.dataset[i], this.recordCount, i, true, true);
          }

          continue; //eslint-disable-line
        }

        var currentCount = i;
        if (s.treeGrid) {
          currentCount = this.recordCount;
        }
        tableHtml += self.rowHtml(s.dataset[i], currentCount, i);
        this.recordCount++;

        if (s.dataset[i].rowStatus) {
          rowStatusTooltip = true;
        }
      }

      // Append a Summary Row
      if (this.settings.summaryRow) {
        tableHtml += self.rowHtml(self.calculateTotals(), this.recordCount, null, false, true);
      }

      if (self.bodyColGroupHtml !== '<colgroup>') {
        self.bodyColGroupHtml += '</colgroup>';

        if (self.bodyColGroup) {
          self.bodyColGroup.remove();
        }

        self.bodyColGroup = $(self.bodyColGroupHtml);
        self.tableBody.before(self.bodyColGroup);
      }

      DOM.html(self.tableBody, tableHtml, '*');
      self.setVirtualHeight();
      self.setScrollClass();
      self.setupTooltips(rowStatusTooltip);
      self.afterRender();
    },


    /**
    * Fire events and do steps needed after a full render.
    * @private
    */
    afterRender: function afterRender() {
      var self = this;

      // Column column postRender functions
      if (this.settings.onPostRenderCell) {
        var _loop2 = function _loop2(i) {
          var col = self.settings.columns[i];

          if (col.component) {
            self.tableBody.find('tr').each(function () {
              var row = $(this);
              var rowIdx = row.attr('data-index');
              var colIdx = self.columnIdxById(col.id);
              var args = {
                row: rowIdx,
                cell: colIdx,
                value: self.settings.dataset[rowIdx],
                col: col,
                api: self
              };

              self.settings.onPostRenderCell(row.find('td').eq(colIdx).find('.datagrid-cell-wrapper .content')[0], args);
            });
          }
        };

        for (var i = 0; i < this.settings.columns.length; i++) {
          _loop2(i);
        }
      }

      // Init Inline Elements
      var dropdowns = self.tableBody.find('select.dropdown');
      if (dropdowns.dropdown) {
        dropdowns.dropdown();
      }

      // Commit Edits for inline editing
      self.tableBody.find('.dropdown-wrapper.is-inline').prev('select').on('listclosed', function () {
        var elem = $(this);
        var newValue = elem.val();
        var row = elem.closest('tr');

        self.updateCellNode(row.attr('aria-rowindex'), elem.closest('td').index(), newValue, false, true);
      });

      var spinboxes = self.tableBody.find('.spinbox');
      if (spinboxes.spinbox) {
        spinboxes.spinbox();
      }

      // Set UI elements after dataload
      if (!self.settings.source) {
        self.displayCounts();
        self.checkEmptyMessage();
      }

      self.setAlternateRowShading();
      self.createDraggableRows();

      if (!self.activeCell || !self.activeCell.node) {
        self.activeCell = { node: self.cellNode(0, 0, true).attr('tabindex', '0'), isFocused: false, cell: 0, row: 0 };
      }

      if (self.activeCell.isFocused) {
        self.setActiveCell(self.activeCell.row, self.activeCell.cell);
      }

      // Deselect rows when changing pages
      if (self.settings.paging && self.settings.source && !self.settings.allowSelectAcrossPages) {
        self._selectedRows = [];
        self.syncSelectedUI();
      }

      // Restore selected rows when pages change
      if (self.settings.paging && self.settings.source && self.settings.allowSelectAcrossPages) {
        self.syncSelectedRows();
        self.syncSelectedUI();
      }

      // Restore selected rows when pages change for single select
      if (self.settings.paging && !self.settings.source && self.settings.allowSelectAcrossPages === null) {
        self.syncSelectedRows();
        self.syncSelectedUI();
      }

      /**
      * Fires after the entire grid is rendered.
      * @event rowremove
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {HTMLElement} body Object table body area
      * @property {HTMLElement} header Object table header area
      * @property {HTMLElement} pager Object pager body area
      */
      self.element.trigger('afterrender', { body: self.tableBody, header: self.headerRow, pager: self.pagerBar });
    },


    /**
    * Trigger the onDestroyCell for each cell
    * @private
    */
    triggerDestroyCell: function triggerDestroyCell() {
      var _this2 = this;

      var self = this;

      if (!self.tableBody) {
        return;
      }

      // Call onDestroyCell
      if (this.settings.onPostRenderCell && this.settings.onDestroyCell) {
        var rows = self.tableBody.find('tr');

        if (rows.length === 0) {
          return;
        }

        var _loop3 = function _loop3(i) {
          var col = _this2.settings.columns[i];

          if (col.component) {
            rows.each(function () {
              var row = $(this);
              var rowIdx = row.index();
              var colIdx = self.columnIdxById(col.id);
              var args = {
                row: row.index(),
                cell: colIdx,
                value: self.settings.dataset[rowIdx],
                col: col,
                api: self
              };

              self.settings.onDestroyCell(row.find('td').eq(colIdx).find('.datagrid-cell-wrapper .content')[0], args);
            });
          }
        };

        for (var i = 0; i < this.settings.columns.length; i++) {
          _loop3(i);
        }
      }
    },


    /**
    * Cache info on virtual scrolling for better performance.
    * @private
    */
    cacheVirtualStats: function cacheVirtualStats() {
      var containerHeight = this.element[0].offsetHeight;
      var scrollTop = this.contentContainer[0].scrollTop;
      var headerHeight = this.settings.rowHeight === 'normal' ? 40 : this.settings.rowHeight === 'medium' ? 30 : 25;
      var bodyH = containerHeight - headerHeight;
      var rowH = this.settings.rowHeight === 'normal' ? 50 : this.settings.rowHeight === 'medium' ? 40 : 30;

      this.virtualRange = {
        rowHeight: rowH,
        top: Math.max(scrollTop - (this.settings.virtualRowBuffer - 1) * rowH, 0),
        bottom: scrollTop + bodyH + (this.settings.virtualRowBuffer - 1) * rowH,
        totalHeight: rowH * this.settings.dataset.length,
        bodyHeight: bodyH
      };
    },


    /**
    * Check if the row is in the visble scroll area + buffer
    * Just call renderRows() on events that change
    * @private
    * @param  {number} rowIndex Row index to check.
    * @returns {boolean} Current row visibility.
    */
    isRowVisible: function isRowVisible(rowIndex) {
      if (!this.settings.virtualized) {
        if (this.settings.paging && !this.settings.source && rowIndex && this.pager) {
          return (this.pager.activePage - 1) * this.settings.pagesize >= rowIndex && this.pager.activePage * this.settings.pagesize <= rowIndex;
        }

        return true;
      }

      if (rowIndex === 0) {
        this.cacheVirtualStats();
      }

      // determine if the row is in view
      var pos = rowIndex * this.virtualRange.rowHeight;

      if (pos >= this.virtualRange.top && pos < this.virtualRange.bottom) {
        return true;
      }

      return false;
    },


    /**
     * Set the heights on top or bottom based on scroll position
     * @private
     */
    setVirtualHeight: function setVirtualHeight() {
      if (!this.settings.virtualized || !this.virtualRange) {
        return;
      }

      var bottom = this.virtualRange.totalHeight - this.virtualRange.bottom;
      var vTop = this.virtualRange.top;

      this.topSpacer = this.tableBody.find('.datagrid-virtual-row-top');
      this.bottomSpacer = this.tableBody.find('.datagrid-virtual-row-bottom');

      if (vTop > 0 && !this.topSpacer.length) {
        this.topSpacer = $('<tr class="datagrid-virtual-row-top" style="height: ' + vTop + 'px"><td colspan="' + this.visibleColumns().length + '"></td></tr>');
        this.tableBody.prepend(this.topSpacer);
      }

      if (vTop > 0 && this.topSpacer.length) {
        this.topSpacer.css('height', vTop + 'px');
      }

      if (vTop === 0 && (this.topSpacer.length || this.virtualRange.topRow <= 1)) {
        this.topSpacer.remove();
      }

      if (bottom > 0 && !this.bottomSpacer.length) {
        this.bottomSpacer = $('<tr class="datagrid-virtual-row-bottom" style="height: ' + bottom + 'px"><td colspan="' + this.visibleColumns().length + '"></td></tr>');
        this.tableBody.append(this.bottomSpacer);
      }

      if (bottom > 0 && this.bottomSpacer.length) {
        this.bottomSpacer.css('height', bottom + 'px');
      }

      if (bottom <= 0 && (this.bottomSpacer.length || this.virtualRange.bottomRow >= this.settings.dataset.length)) {
        this.bottomSpacer.remove();
      }
    },


    /**
     * Set the alternate shading class.
     * @private
     */
    setAlternateRowShading: function setAlternateRowShading() {
      if (this.settings.alternateRowShading && this.settings.treeGrid) {
        $('tr[role="row"]:visible', this.tableBody).removeClass('alt-shading').filter(':odd').addClass('alt-shading');
      }
    },


    /**
     * The default cell formatters thats used when no formatter is provided.
     * @private
     * @param  {function} formatter The formatter function.
     * @param  {number} row The row index.
     * @param  {number} cell The cell index.
     * @param  {string} fieldValue The current field value.
     * @param  {object} columnDef The column settings.
     * @param  {object} rowData The current row data.
     * @param  {object} api The grid API reference.
     * @returns {void}
     */
    formatValue: function formatValue(formatter, row, cell, fieldValue, columnDef, rowData, api) {
      var formattedValue = void 0;
      api = api || this;

      // Use default formatter if undefined
      if (formatter === undefined) {
        formatter = this.defaultFormatter;
      }

      if (typeof formatter === 'string') {
        formattedValue = formatters[formatter](row, cell, fieldValue, columnDef, rowData, api);
        formattedValue = formattedValue.toString();
      } else {
        formattedValue = formatter(row, cell, fieldValue, columnDef, rowData, api).toString();
      }
      return formattedValue;
    },


    /**
     * Return the html markup for the row.
     * @private
     * @param  {object} rowData The data to use to render the row
     * @param  {number} dataRowIdx The row index.
     * @param  {number} actualIndex The actual data index
     * @param  {boolean} isGroup If true we are building a group row.
     * @param  {object} isFooter If true we are building a footer row.
     * @returns {string} The html used to construct the row.
     */
    rowHtml: function rowHtml(rowData, dataRowIdx, actualIndex, isGroup, isFooter) {
      var isEven = false;
      var self = this;
      var isSummaryRow = this.settings.summaryRow && !isGroup && isFooter;
      var activePage = self.pager ? self.pager.activePage : 1;
      var rowHtml = '';
      var d = self.settings.treeDepth ? self.settings.treeDepth[dataRowIdx] : 0;
      var depth = null;
      var j = 0;
      var isHidden = false;
      var skipColumns = void 0;

      if (!rowData) {
        return '';
      }

      // Default
      d = d ? d.depth : 0;
      depth = d;

      // Setup if this row will be hidden or not
      if (self.settings.treeDepth && self.settings.treeDepth.length) {
        for (var i = 0; i < self.settings.treeDepth.length; i++) {
          var treeDepthItem = self.settings.treeDepth[i];

          if (rowData.id === treeDepthItem.node.id) {
            var parentNode = null;
            var currentDepth = 0;
            for (var ii = i; ii >= 0; ii--) {
              currentDepth = self.settings.treeDepth[ii].node.depth < currentDepth || currentDepth === 0 ? self.settings.treeDepth[ii].node.depth : currentDepth;
              if (currentDepth < treeDepthItem.node.depth) {
                parentNode = self.settings.treeDepth[ii];

                if (parentNode.node.isExpanded !== undefined && !parentNode.node.isExpanded || currentDepth === 1) {
                  break;
                }
              }
            }

            if (parentNode && parentNode.node.expanded !== undefined && !parentNode.node.expanded) {
              isHidden = true;
            } else {
              isHidden = rowData.isFiltered;
            }

            depth = treeDepthItem.depth;

            break;
          }
        }
      }

      if (this.settings.groupable) {
        var groupSettings = this.settings.groupable;
        isHidden = groupSettings.expanded === undefined ? false : !groupSettings.expanded;

        if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
          isHidden = !groupSettings.expanded(dataRowIdx, 0, null, null, rowData, this);
        }
      }

      // Group Rows
      if (this.settings.groupable && isGroup && !isFooter) {
        rowHtml = '<tr class="datagrid-rowgroup-header' + (isHidden ? '' : ' is-expanded') + '" role="rowgroup"><td role="gridcell" colspan="' + this.visibleColumns().length + '">' + formatters.GroupRow(dataRowIdx, 0, null, null, rowData, this) + '</td></tr>';
        return rowHtml;
      }

      if (this.settings.groupable && isGroup && isFooter) {
        rowHtml = '<tr class="datagrid-row datagrid-rowgroup-footer' + (isHidden ? '' : ' is-expanded') + '" role="rowgroup">' + formatters.GroupFooterRow(dataRowIdx, 0, null, null, rowData, this) + '</tr>';
        return rowHtml;
      }

      var ariaRowindex = dataRowIdx + 1 + (self.settings.source && !self.settings.indeterminate ? (activePage - 1) * self.settings.pagesize : 0);

      isEven = this.recordCount % 2 === 0;
      var isSelected = this.isNodeSelected(rowData);
      var isActivated = rowData._rowactivated;
      var rowStatus = { class: '', svg: '' };
      if (rowData && rowData.rowStatus) {
        rowStatus.show = true;
        rowStatus.class = ' rowstatus-row-' + rowData.rowStatus.icon;
        rowStatus.icon = rowData.rowStatus.icon === 'confirm' ? '#icon-check' : '#icon-exclamation';
        rowStatus.title = rowData.rowStatus.tooltip !== '' ? ' title="' + rowData.rowStatus.tooltip + '"' : '';
        rowStatus.svg = '<svg class="icon icon-rowstatus" focusable="false" aria-hidden="true" role="presentation"' + rowStatus.title + '><use xlink:href="' + rowStatus.icon + '"></use></svg>';
      }

      rowHtml = '<tr role="row" aria-rowindex="' + ariaRowindex + '"' + (' data-index="' + actualIndex + '"' + (self.settings.treeGrid && rowData.children ? ' aria-expanded="' + (rowData.expanded ? 'true"' : 'false"') : '') + (self.settings.treeGrid ? ' aria-level= "' + depth + '"' : '') + (isSelected ? ' aria-selected= "true"' : '') + ' class="datagrid-row' + rowStatus.class + (isHidden ? ' is-hidden' : '') + (rowData.isFiltered ? ' is-filtered' : '') + (isActivated ? ' is-rowactivated' : '') + (isSelected ? this.settings.selectable === 'mixed' ? ' is-selected hide-selected-color' : ' is-selected' : '') + (self.settings.alternateRowShading && !isEven ? ' alt-shading' : '') + (isSummaryRow ? ' datagrid-summary-row' : '') + (!self.settings.cellNavigation && self.settings.selectable !== false ? ' is-clickable' : '') + (self.settings.treeGrid ? rowData.children ? ' datagrid-tree-parent' : depth > 1 ? ' datagrid-tree-child' : '' : '') + '">');

      for (j = 0; j < self.settings.columns.length; j++) {
        var _col = self.settings.columns[j];

        var cssClass = '';
        var defaultFormatter = _col.summaryRowFormatter || _col.formatter || self.defaultFormatter;
        var formatter = isSummaryRow ? defaultFormatter : _col.formatter || self.defaultFormatter;
        var formatted = self.formatValue(formatter, dataRowIdx, j, self.fieldValue(rowData, self.settings.columns[j].field), self.settings.columns[j], rowData, self);

        if (formatted.indexOf('<span class="is-readonly">') === 0) {
          _col.readonly = true;
        }

        if (formatted.indexOf('datagrid-checkbox') > -1 || formatted.indexOf('btn-actions') > -1) {
          cssClass += ' l-center-text';
        }

        if (formatted.indexOf('trigger') > -1) {
          cssClass += ' datagrid-trigger-cell';
        }

        if (_col.editor) {
          cssClass += ' has-editor';
        }

        if (_col.expanded) {
          self.treeExpansionField = _col.expanded;
        }

        if (_col.align) {
          cssClass += ' l-' + _col.align + '-text';
        }

        if (_col.textOverflow === 'ellipsis') {
          cssClass += ' text-ellipsis';
        }

        if (_col.uppercase) {
          cssClass += ' uppercase-text';
        }

        // Add Column Css Classes

        // Add a readonly class if set on the column
        cssClass += _col.readonly ? ' is-readonly' : '';
        cssClass += _col.hidden ? ' is-hidden' : '';

        // Run a function that helps check if editable
        if (_col.isEditable && !_col.readonly) {
          var fieldVal = self.fieldValue(rowData, self.settings.columns[j].field);
          var canEdit = _col.isEditable(ariaRowindex - 1, j, fieldVal, _col, rowData);

          if (!canEdit) {
            cssClass += ' is-readonly';
          }
        }

        // Run a function that helps check if readonly
        var ariaReadonly = _col.id !== 'selectionCheckbox' && (_col.readonly || _col.editor === undefined) ? 'aria-readonly="true"' : '';

        if (_col.isReadonly && !_col.readonly && _col.id !== 'selectionCheckbox') {
          var _fieldVal = self.fieldValue(rowData, self.settings.columns[j].field);
          var isReadonly = _col.isReadonly(this.recordCount, j, _fieldVal, _col, rowData);

          if (isReadonly) {
            cssClass += ' is-cell-readonly';
            ariaReadonly = 'aria-readonly="true"';
          }
        }

        var cellValue = self.fieldValue(rowData, self.settings.columns[j].field);

        // Run a function that dynamically adds a class
        if (_col.cssClass && typeof _col.cssClass === 'function') {
          cssClass += ' ' + _col.cssClass(this.recordCount, j, cellValue, _col, rowData);
        }

        if (_col.cssClass && typeof _col.cssClass === 'string') {
          cssClass += ' ' + _col.cssClass;
        }

        cssClass += _col.focusable ? ' is-focusable' : '';

        var rowspan = this.calculateRowspan(cellValue, dataRowIdx, _col);

        if (rowspan === '') {
          continue;
        }

        // Set Width of table col / col group elements
        var colWidth = '';

        if (this.recordCount === 0) {
          colWidth = this.columnWidth(_col, j);

          self.bodyColGroupHtml += '<col' + colWidth + (_col.hidden ? ' class="is-hidden"' : '') + '></col>';

          if (_col.colspan) {
            this.hasColSpans = true;
          }
        }

        if (skipColumns > 0) {
          skipColumns -= 1;
          cssClass += ' is-hidden';
        }

        // Run an optional function to calculate a colspan
        var colspan = null;
        if (_col.colspan && typeof _col.colspan === 'function') {
          var _fieldVal2 = self.fieldValue(rowData, self.settings.columns[j].field);
          colspan = _col.colspan(ariaRowindex - 1, j, _fieldVal2, _col, rowData, self);

          var max = self.settings.columns.length - j;
          colspan = colspan && colspan > max ? max : colspan;
          if (colspan && colspan > 1) {
            skipColumns = colspan - 1;
            if (_col.align) {
              cssClass = cssClass.replace(' l-' + _col.align + '-text', '');
            }
            cssClass += ' l-left-text';
          } else {
            colspan = null;
          }
        }

        // Set rowStatus info
        if (j !== 0) {
          rowStatus.class = '';
          rowStatus.svg = '';
        }

        if (rowStatus.class !== '') {
          cssClass += ' rowstatus-cell';
        }

        // Trim extra spaces
        if (cssClass !== '') {
          cssClass = cssClass.replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ');
        }

        rowHtml += '<td role="gridcell" ' + ariaReadonly + ' aria-colindex="' + (j + 1) + '"' + (' aria-describedby="' + self.uniqueId('-header-' + j) + '"' + (isSelected ? ' aria-selected= "true"' : '') + (cssClass ? ' class="' + cssClass + '"' : '') + (colspan ? ' colspan="' + colspan + '"' : '') + (_col.tooltip && typeof _col.tooltip === 'string' ? ' title="' + _col.tooltip.replace('{{value}}', cellValue) + '"' : '') + (self.settings.columnGroups ? 'headers = "' + self.uniqueId('-header-' + j) + ' ' + self.getColumnGroup(j) + '"' : '') + (rowspan || '') + '>' + rowStatus.svg + '<div class="datagrid-cell-wrapper">');

        if (_col.contentVisible) {
          var canShow = _col.contentVisible(dataRowIdx + 1, j, cellValue, _col, rowData);
          if (!canShow) {
            formatted = '';
          }
        }

        if (self.settings.onPostRenderCell && _col.component) {
          rowHtml += '<div class="content"></div>';
          formatted = '';
        }

        rowHtml += formatted + '</div></td>';
      }

      rowHtml += '</tr>';

      if (self.settings.rowTemplate) {
        var tmpl = self.settings.rowTemplate;
        var item = rowData;
        var renderedTmpl = '';

        if (Tmpl && item) {
          renderedTmpl = Tmpl.compile('{{#dataset}}' + tmpl + '{{/dataset}}', { dataset: item });
        }

        rowHtml += '<tr class="datagrid-expandable-row"><td colspan="' + this.visibleColumns().length + '">' + ('<div class="datagrid-row-detail"><div class="datagrid-row-detail-padding">' + renderedTmpl + '</div></div>') + '</td></tr>';
      }

      if (self.settings.expandableRow) {
        rowHtml += '<tr class="datagrid-expandable-row"><td colspan="' + this.visibleColumns().length + '">' + '<div class="datagrid-row-detail"><div class="datagrid-row-detail-padding"></div></div>' + '</td></tr>';
      }

      // Render Tree Children
      if (rowData.children) {
        for (var _i5 = 0, l = rowData.children.length; _i5 < l; _i5++) {
          this.recordCount++;
          rowHtml += self.rowHtml(rowData.children[_i5], this.recordCount, _i5);
        }
      }

      return rowHtml;
    },


    /**
     * This Function approximates the table auto widthing
     * Except use all column values and compare the text width of the header as max
     * @private
     * @param  {object} columnDef The column to check.
     * @returns {number} The text width.
     */
    calculateTextWidth: function calculateTextWidth(columnDef) {
      var max = 0;
      var self = this;
      var maxText = '';
      var title = columnDef.name || '';
      var chooseHeader = false;

      // Get max cell value length for this column
      for (var i = 0; i < this.settings.dataset.length; i++) {
        var val = this.fieldValue(this.settings.dataset[i], columnDef.field);
        var len = 0;
        var row = this.settings.dataset[i];

        // Get formatted value (without html) so we have accurate string that
        // will display for this cell
        val = self.formatValue(columnDef.formatter, i, null, val, columnDef, row, self);
        val = xssUtils.stripHTML(val);

        len = val.toString().length;

        if (this.settings.groupable && row.values) {
          for (var k = 0; k < row.values.length; k++) {
            var groupVal = this.fieldValue(row.values[k], columnDef.field);
            groupVal = self.formatValue(columnDef.formatter, i, null, groupVal, columnDef, row, self);
            groupVal = xssUtils.stripHTML(groupVal);

            len = groupVal.toString().length;
            if (len > max) {
              max = len;
              maxText = groupVal;
            }
          }
        }

        if (len > max) {
          max = len;
          maxText = val;
        }
      }

      var hasTag = columnDef.formatter ? columnDef.formatter.toString().indexOf('<span class="tag') > -1 : false;

      var hasAlert = columnDef.formatter ? columnDef.formatter.toString().indexOf('datagrid-alert-icon') > -1 : false;

      if (hasAlert) {
        max += 10;
      }

      // Use header text length as max if bigger than all data cells
      if (title.length > max) {
        max = title.length;
        maxText = title;
        chooseHeader = true;
      }

      if (maxText === '' || this.settings.dataset.length === 0) {
        maxText = columnDef.name || ' Default ';
        chooseHeader = true;
      }

      // if given, use cached canvas for better performance, else, create new canvas
      this.canvas = this.canvas || (this.canvas = document.createElement('canvas'));
      var context = this.canvas.getContext('2d');
      context.font = '14px arial';

      var metrics = context.measureText(maxText);
      var padding = chooseHeader ? 40 : 45;

      if (hasAlert && !chooseHeader) {
        padding += 20;
      }

      if (hasTag && !chooseHeader) {
        padding += 10;
      }

      if (columnDef.filterType) {
        var minWidth = columnDef.filterType === 'date' ? 170 : 100;

        if (columnDef.filterType === 'checkbox') {
          minWidth = 40;
          padding = 40;
        }

        return Math.round(Math.max(metrics.width + padding, minWidth));
      }

      return Math.round(metrics.width + padding); // Add padding and borders
    },


    /**
     * Return the currently caached table width.
     * Except use all column values and compare the text width of the header as max
     * @private
     * @returns {string} The css width.
     */
    headerTableWidth: function headerTableWidth() {
      var cacheWidths = this.headerWidths[this.settings.columns.length - 1];

      if (!cacheWidths) {
        return '';
      }
      this.setScrollClass();

      if (cacheWidths.widthPercent) {
        return '100%';
      } else if (!isNaN(this.totalWidth)) {
        return parseFloat(this.totalWidth) + 'px';
      }

      return '';
    },


    /**
     * Set the scroll class if the scrollbar is visible to effect the scrollheight.
     * @private
     */
    setScrollClass: function setScrollClass() {
      var height = parseInt(this.contentContainer[0].offsetHeight, 10);
      var hasScrollBar = parseInt(this.contentContainer[0].scrollHeight, 10) > height + 2;

      this.element.removeClass('has-vertical-scroll has-less-rows');

      if (hasScrollBar) {
        this.element.addClass('has-vertical-scroll');
      }

      if (!hasScrollBar && this.tableBody[0].offsetHeight < height) {
        this.element.addClass('has-less-rows');
      }
    },


    /**
     * Clear internal header cache info.
     * @private
     * @returns {void}
     */
    clearHeaderCache: function clearHeaderCache() {
      this.headerWidths = [];
      this.totalWidth = 0;
      this.elemWidth = 0;
      this.lastColumn = null;
      this.isInitialRender = true;
      this.calculateColumnWidths();
    },


    /**
     * Return the width for a column (upfront with no rendering)
     * Simulates https://www.w3.org/TR/CSS21/tables.html#width-layout
     * @private
     * @param  {[type]} col The column object to use
     * @param  {[type]} index The column index
     * @returns {void}
     */
    columnWidth: function columnWidth(col, index) {
      if (!this.elemWidth) {
        this.elemWidth = this.element.outerWidth();

        if (this.elemWidth === 0) {
          // handle on invisible tab container
          this.elemWidth = this.element.closest('.tab-container').outerWidth();
        }
        if (!this.elemWidth || this.elemWidth === 0) {
          // handle on invisible modal
          this.elemWidth = this.element.closest('.modal-contents').outerWidth();
        }

        this.widthSpecified = false;
      }

      // use cache
      if (this.headerWidths[index]) {
        var cacheWidths = this.headerWidths[index];

        if (cacheWidths.width === 'default') {
          return '';
        }

        if (this.widthSpecified && !cacheWidths.width) {
          return '';
        }

        return ' style="width: ' + cacheWidths.width + (cacheWidths.widthPercent ? '%' : 'px') + '"';
      }
      return this.calculateColumnWidth(col, index);
    },


    /**
     * Calculate the width for all the columns
     * Simulates https://www.w3.org/TR/CSS21/tables.html#width-layout
     * @private
     */
    calculateColumnWidths: function calculateColumnWidths() {
      for (var i = 0; i < this.settings.columns.length; i++) {
        var _col2 = this.settings.columns[i];
        this.calculateColumnWidth(_col2, i);
      }
    },


    /**
     * Calculate the width for a column (upfront with no rendering)
     * Simulates https://www.w3.org/TR/CSS21/tables.html#width-layout
     * @private
     * @param {object} col The column object to use
     * @param {number} index The column index
     * @returns {void}
     */
    calculateColumnWidth: function calculateColumnWidth(col, index) {
      var _this3 = this;

      var colPercWidth = void 0;
      var visibleColumns = this.visibleColumns(true);
      var lastColumn = index === this.lastColumnIdx();

      if (!this.elemWidth) {
        this.elemWidth = this.element.outerWidth();

        if (this.elemWidth === 0) {
          // handle on invisible tab container
          this.elemWidth = this.element.closest('.tab-container').outerWidth();
        }
        if (!this.elemWidth || this.elemWidth === 0) {
          // handle on invisible modal
          this.elemWidth = this.element.closest('.modal-contents').outerWidth();
        }

        this.widthSpecified = false;
        this.widthPixel = false;
      }

      // use cache
      if (this.headerWidths[index]) {
        var cacheWidths = this.headerWidths[index];

        if (cacheWidths.width === 'default') {
          return '';
        }

        if (this.widthSpecified && !cacheWidths.width) {
          return '';
        }

        return ' style="width: ' + cacheWidths.width + (cacheWidths.widthPercent ? '%' : 'px') + '"';
      }

      // A column element with a value other than 'auto' for the 'width' property
      // sets the width for that column.
      if (col.width) {
        this.widthSpecified = true;
        this.widthPercent = false;
      }

      if (!this.widthPixel && col.width) {
        this.widthPixel = typeof col.width !== 'string';
      }

      var colWidth = col.width;

      if (typeof col.width === 'string' && col.width.indexOf('px') === -1) {
        this.widthPercent = true;
        colPercWidth = col.width.replace('%', '');
      }

      var textWidth = this.calculateTextWidth(col); // reasonable default on error

      if (!this.widthSpecified || !colWidth) {
        colWidth = Math.max(textWidth, colWidth || 0);
      }

      lastColumn = index === this.lastColumnIdx();

      // Simulate Auto Width Algorithm
      if ((!this.widthSpecified || col.width === undefined) && this.settings.sizeColumnsEqually && ['selectionCheckbox', 'expander', 'drilldown', 'rowStatus', 'favorite'].indexOf(col.id) === -1) {
        var percentWidth = Math.round(this.elemWidth / visibleColumns.length);
        colWidth = percentWidth - (lastColumn ? 2 : 0); // borders causing scroll

        // Handle Columns where auto width is bigger than the percent width
        if (percentWidth < textWidth) {
          colWidth = textWidth;
        }
      }

      // Some Built in columns
      if (col.id === 'selectionCheckbox' || col.id === 'favorite') {
        colWidth = 43;
        col.width = colWidth;
      }

      if (col.id === 'expander') {
        colWidth = 55;
        col.width = colWidth;
      }

      if (col.id === 'rowStatus') {
        colWidth = 62;
        col.width = colWidth;
      }

      if (col.id === 'rowReorder') {
        colWidth = 62;
        col.width = colWidth;
      }

      if (col.id === 'drilldown') {
        colWidth = 78;
        col.width = colWidth;
      }

      // cache the header widths
      this.headerWidths[index] = {
        id: col.id,
        width: this.widthPercent ? colPercWidth : colWidth,
        widthPercent: this.widthPercent
      };

      if (col.id !== 'spacerColumn') {
        this.totalWidth += col.hidden || lastColumn ? 0 : colWidth;
      }

      // For the last column stretch it if it doesnt fit the area
      if (lastColumn && this.isInitialRender && !this.settings.spacerColumn) {
        var diff = this.elemWidth - this.totalWidth;

        if (this.settings.stretchColumn === 'last') {
          if (diff > 0 && diff > colWidth && !this.widthPercent && !col.width) {
            colWidth = diff - 2 - 10; // borders and last edge padding
            this.headerWidths[index] = {
              id: col.id,
              width: colWidth,
              widthPercent: this.widthPercent
            };
            this.totalWidth = this.elemWidth - 2;
          }
        } else {
          this.headerWidths[index] = { id: col.id, width: colWidth, widthPercent: this.widthPercent };
          this.totalWidth += col.hidden ? 0 : colWidth;
          var diff2 = this.elemWidth - this.totalWidth;
          var stretchColumn = $.grep(this.headerWidths, function (e) {
            return e.id === _this3.settings.stretchColumn;
          });
          if (diff2 > 0 && !stretchColumn[0].widthPercent) {
            stretchColumn[0].width += diff2 - 2;
            this.totalWidth += diff2 - 2;
          }
        }

        if (this.widthPercent) {
          this.table.css('width', '100%');
        } else if (!isNaN(this.totalWidth)) {
          this.table.css('width', this.totalWidth);
        }

        this.isInitialRender = false;
      }

      if (lastColumn && this.isInitialRender && this.settings.spacerColumn) {
        var _diff = this.elemWidth - this.totalWidth;

        if (_diff > 0 && _diff > colWidth && !this.widthPercent && !col.width) {
          this.settings.columns.push({ id: 'spacerColumn', name: '', field: '', width: _diff - 2 - colWidth });
        }
      }

      if (lastColumn && this.settings.spacerColumn && this.isInitialRender) {
        if (this.widthPercent) {
          this.table.css('width', '100%');
        } else if (!isNaN(this.totalWidth)) {
          this.table.css('width', this.totalWidth);
        }
        this.isInitialRender = false;
      }

      if (!this.widthPercent && colWidth === undefined) {
        return '';
      }

      return ' style="width: ' + (this.widthPercent ? colPercWidth + '%' : colWidth + 'px') + '"';
    },


    /**
    * Figure out if the row spans and should skip rendiner.
    * @private
    * @param  {any} value Value to check
    * @param  {number} row Row index
    * @param  {number} col Column index
    * @returns {void}
    */
    calculateRowspan: function calculateRowspan(value, row, col) {
      var total = 0;
      var min = null;

      if (!col.rowspan) {
        return null;
      }

      for (var i = 0; i < this.settings.dataset.length; i++) {
        if (value === this.settings.dataset[i][col.field]) {
          total++;
          if (min === null) {
            min = i;
          }
        }
      }

      return row === min ? ' rowspan ="' + total + '"' : '';
    },


    /**
    * Summary Row Totals use the aggregators
    * @private
    * @returns {number} the total widths
    */
    calculateTotals: function calculateTotals() {
      this.settings.totals = aggregators.aggregate(this.settings.dataset, this.settings.columns);
      return this.settings.totals;
    },


    /**
    * Set unit type (pixel or percent)
    * @private
    * @param  {any} v value to check
    * @returns {number} the total widths
    */
    setUnit: function setUnit(v) {
      return v + (/(px|%)/i.test('' + v) ? '' : 'px');
    },


    /**
     * Setup tooltips on the cells.
     * @private
     * @param  {boolean} rowstatus true set tootip with row status
     * @param  {boolean} isForced true set tootip
     * @returns {void}
     */
    setupTooltips: function setupTooltips(rowstatus, isForced) {
      var _this4 = this;

      if (!rowstatus && !isForced && !this.settings.enableTooltips) {
        return;
      }

      var self = this;
      var defaultDelay = 400;
      var tooltipTimer = void 0;

      // Set selector
      var selector = {
        th: '.datagrid-header th',
        td: '.datagrid-body tr.datagrid-row td[role="gridcell"]:not(.rowstatus-cell)',
        rowstatus: '.datagrid-body tr.datagrid-row td[role="gridcell"] .icon-rowstatus'
      };
      selector.iconAlert = selector.td + ' .icon-alert';
      selector.iconConfirm = selector.td + ' .icon-confirm';
      selector.iconError = selector.td + ' .icon-error';
      selector.iconInfo = selector.td + ' .icon-info';

      selector.icons = selector.iconAlert + ', ' + selector.iconConfirm + ', ' + selector.iconError + ', ' + selector.iconInfo;

      // Selector string
      if (rowstatus && this.settings.enableTooltips) {
        selector.str = selector.th + ', ' + selector.td + ', ' + selector.icons + ', ' + selector.rowstatus;
      } else if (rowstatus) {
        selector.str = selector.th + ', ' + selector.rowstatus;
      } else {
        selector.str = selector.th + ', ' + selector.td + ', ' + selector.icons;
      }

      // Handle tooltip to show
      var handleShow = function handleShow(elem, delay) {
        delay = typeof delay === 'undefined' ? defaultDelay : delay;
        tooltipTimer = setTimeout(function () {
          var tooltip = $(elem).data('gridtooltip') || self.cacheTooltip(elem);
          var width = self.getOuterWidth(elem);

          if (tooltip && (tooltip.forced || tooltip.textwidth > width - 35)) {
            self.showTooltip(tooltip);
          }
        }, delay);
      };

      // Handle tooltip to hide
      var handleHide = function handleHide(delay) {
        delay = typeof delay === 'undefined' ? defaultDelay : delay;
        clearTimeout(tooltipTimer);
        setTimeout(function () {
          self.hideTooltip();
        }, delay);
      };

      // Bind events
      this.element.off('mouseenter.gridtooltip', selector.str).on('mouseenter.gridtooltip', selector.str, function () {
        handleShow(this);
      }).off('mouseleave.gridtooltip click.gridtooltip', selector.str).on('mouseleave.gridtooltip click.gridtooltip', selector.str, function () {
        handleHide();
      }).off('longpress.gridtooltip', selector.str).on('longpress.gridtooltip', selector.str, function () {
        handleShow(_this4, 0);
      }).off('keydown.gridtooltip', selector.str).on('keydown.gridtooltip', selector.str, function (e) {
        var key = e.which || e.keyCode || e.charCode || 0;
        var handle = false;

        if (e.shiftKey && key === 112) {
          // Shift + F1
          handleShow(this, 0);
        } else if (key === 27) {
          // Escape
          handle = self.isGridtooltip();
          handleHide(0);
        }

        if (handle) {
          e.preventDefault();
        }
        return !handle;
      });
    },


    /**
     * Get outerWidth for a given element.
     * @private
     * @param  {boolean} element to calculate the outerWidth
     * @returns {number} computed outerWidth
     */
    getOuterWidth: function getOuterWidth(element) {
      var style = getComputedStyle(element);
      var width = element.offsetWidth;
      width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
      return width;
    },


    /**
     * Get closest element of a given element by passing callback to
     * target by class, id, or tag name
     * Callback usage as:
     * const elem = this.element[0].querySelector(selectorString);
     * class: const closestEl = this.closest(elem, el => el.classList.contains('some-class'));
     * id: const closestEl = this.closest(elem, el => el.id === 'some-id');
     * tag: const closestEl = this.closest(elem, el => el.tagName.toLowerCase() === 'some-tag');
     * http://clubmate.fi/jquerys-closest-function-and-pure-javascript-alternatives/
     * @private
     * @param  {object} el The element to start from.
     * @param  {object} fn The callback function.
     * @returns {object} The closest element.
     */
    closest: function closest(el, fn) {
      return el && (fn(el) ? el : this.closest(el.parentNode, fn));
    },


    /**
     * Returns all header nodes (not the groups)
     * @private
     * @returns {array} Array with all header dom nodes
     */
    headerNodes: function headerNodes() {
      return this.headerRow.find('tr:not(.datagrid-header-groups) th');
    },


    /**
     * Refresh one row in the grid
     * @param  {number} idx The row index to update.
     * @param  {object} data The data object.
     * @returns {void}
     */
    updateRow: function updateRow(idx, data) {
      var rowData = data || this.settings.dataset[idx];

      for (var j = 0; j < this.settings.columns.length; j++) {
        var _col3 = this.settings.columns[j];

        if (_col3.hidden) {
          continue;
        }

        this.updateCellNode(idx, j, this.fieldValue(rowData, _col3.field), true);
      }
    },


    /**
     * Given a new column set update the rows and reload
     * @param  {array} columns The array with columns to use.
     * @param  {array} columnGroups The array with new columns groups to use.
     * @returns {void}
     */
    updateColumns: function updateColumns(columns, columnGroups) {
      this.settings.columns = columns;

      if (columnGroups) {
        this.settings.columnGroups = columnGroups;
      }

      this.clearHeaderCache();
      this.renderRows();
      this.renderHeader();
      this.resetPager('updatecolumns');

      /**
      * Fires after the entire grid is rendered.
      * @event columnchange
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {HTMLElement} args Additional arguments
      * @property {string} args.type Info on the type of column change action, can be 'updatecolumns', 'hidecolumn', 'showcolumn', 'resizecolumn'
      * @property {object} args.columns The columns object
      */
      this.element.trigger('columnchange', [{ type: 'updatecolumns', columns: this.settings.columns }]);
      this.saveColumns();
      this.saveUserSettings();
    },


    /**
     * Save the columns to local storage
     * @deprecated Use saveUserSettings, will remove this in a few versions (4.10.0)
     * @returns {void}
     */
    saveColumns: function saveColumns() {
      if (!this.settings.saveColumns) {
        return;
      }

      // Save to local storage
      if (this.canUseLocalStorage()) {
        localStorage[this.uniqueId('columns')] = JSON.stringify(this.settings.columns);
      }
    },


    /**
     * Omit events and save to local storage for supported settings.
     * @returns {void}
     */
    saveUserSettings: function saveUserSettings() {
      /**
      * Fires after settings are changed in some way
      * @event settingschanged
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.rowHeight The current row height
      * @property {object} args.columns The columns object
      * @property {string} args.sortOrder The current sort column.
      * @property {number} args.pagesize The current page size
      * @property {boolean} args.showPageSizeSelector If the page size selector is shown.
      * @property {number} args.activePage The currently active page.
      * @property {string} args.filter Info on the type of column change action, can be 'updatecolumns'
      */
      this.element.trigger('settingschanged', [{
        rowHeight: this.settings.rowHeight,
        columns: this.settings.columns,
        sortOrder: this.sortColumn,
        pagesize: this.settings.pagesize,
        showPageSizeSelector: this.settings.showPageSizeSelector,
        activePage: this.pager ? this.pager.activePage : 1,
        filter: this.filterConditions()
      }]);

      // Save to Local Storage if the settings are set
      var savedSettings = this.settings.saveUserSettings;
      if ($.isEmptyObject(savedSettings) || !this.canUseLocalStorage()) {
        return;
      }

      // Save Columns
      if (savedSettings.columns) {
        localStorage[this.uniqueId('usersettings-columns')] = JSON.stringify(this.settings.columns);
      }

      // Save Row Height
      if (savedSettings.rowHeight) {
        localStorage[this.uniqueId('usersettings-row-height')] = this.settings.rowHeight;
      }

      // Save Sort Order
      if (savedSettings.sortOrder) {
        localStorage[this.uniqueId('usersettings-sort-order')] = JSON.stringify(this.sortColumn);
      }

      // Save Page Size
      if (savedSettings.pagesize) {
        localStorage[this.uniqueId('usersettings-pagesize')] = this.settings.pagesize;
      }

      // Save Show Page Size Selector
      if (savedSettings.showPageSizeSelector) {
        localStorage[this.uniqueId('usersettings-show-pagesize-selector')] = this.settings.showPageSizeSelector;
      }

      // Save Page Num
      if (savedSettings.activePage && this.pager) {
        localStorage[this.uniqueId('usersettings-active-page')] = this.pager.activePage;
      }

      // Filter Conditions
      if (savedSettings.filter) {
        localStorage[this.uniqueId('usersettings-filter')] = JSON.stringify(this.filterConditions());
      }
    },


    /**
     * Returns true if local storage may be used / is available
     * @private
     * @returns {boolean} If it can be used.
     */
    canUseLocalStorage: function canUseLocalStorage() {
      try {
        if (localStorage.getItem) {
          return true;
        }
      } catch (exception) {
        return false;
      }

      return false;
    },


    /**
     * Parse a JSON array with columns and return the column object.
     * @private
     * @param  {string} columnStr The json represntation of the column object.
     * @returns {array} The array of columns.
     */
    columnsFromString: function columnsFromString(columnStr) {
      if (!columnStr) {
        return [];
      }

      var self = this;
      var columns = JSON.parse(columnStr);

      if (!columns) {
        return [];
      }

      // Map back the missing functions/objects
      for (var i = 0; i < columns.length; i++) {
        var isHidden = void 0;
        var orgColumn = self.columnById(columns[i].id);

        if (orgColumn) {
          isHidden = columns[i].hidden;

          $.extend(columns[i], orgColumn[0]);

          if (isHidden !== undefined) {
            columns[i].hidden = isHidden;
          }
        }
      }

      return columns;
    },


    /**
    * Restore the columns from a provided list or local storage
    * @param {array} cols - The columns list to restore, if you saved the settings manually.
    */
    restoreColumns: function restoreColumns(cols) {
      if (!this.settings.saveColumns || !this.canUseLocalStorage()) {
        return;
      }

      if (cols) {
        this.updateColumns(cols);
        return;
      }

      // Done on load as apposed to passed in
      var lsCols = localStorage[this.uniqueId('columns')];

      if (!cols && lsCols) {
        this.originalColumns = this.settings.columns;
        this.settings.columns = this.columnsFromString(lsCols);
      }
    },


    /**
     * Restore the user settings from local Storage or as passed in.
     * @param  {object} settings The object containing the settings to use.
     * @returns {void}
     */
    restoreUserSettings: function restoreUserSettings(settings) {
      var options = this.settings.saveUserSettings;

      if (!settings && ($.isEmptyObject(options) || !this.canUseLocalStorage())) {
        return;
      }

      // Restore The data thats passed in
      if (settings) {
        if (settings.columns) {
          this.updateColumns(settings.columns);
        }

        if (settings.rowHeight) {
          this.rowHeight(settings.rowHeight);
        }

        if (settings.sortOrder) {
          this.setSortColumn(settings.sortOrder.sortId, settings.sortOrder.sortAsc);
        }

        if (settings.pagesize) {
          this.settings.pagesize = parseInt(settings.pagesize, 10);
          this.pager.settings.pagesize = parseInt(settings.pagesize, 10);
          this.pager.setActivePage(1, true);
        }

        if (settings.showPageSizeSelector) {
          this.settings.showPageSizeSelector = settings.showPageSizeSelector;
          this.pager.showPageSizeSelector(settings.showPageSizeSelector);
        }

        if (settings.activePage) {
          this.pager.setActivePage(parseInt(settings.activePage, 10), true);
        }

        if (settings.filter) {
          this.applyFilter(settings.filter, 'restore');
        }
        return;
      }

      // Restore Column Width and Order
      if (options.columns) {
        var savedColumns = localStorage[this.uniqueId('usersettings-columns')];
        if (savedColumns) {
          this.originalColumns = this.settings.columns;
          this.settings.columns = this.columnsFromString(savedColumns);
        }
      }

      // Restore Row Height
      if (options.rowHeight) {
        var savedRowHeight = localStorage[this.uniqueId('usersettings-row-height')];

        if (savedRowHeight) {
          this.settings.rowHeight = savedRowHeight;
        }
      }

      // Restore Sort Order
      if (options.sortOrder) {
        var savedSortOrder = localStorage[this.uniqueId('usersettings-sort-order')];
        if (savedSortOrder) {
          this.sortColumn = JSON.parse(savedSortOrder);
          this.restoreSortOrder = true;
        }
      }

      // Restore Page Size
      if (options.pagesize) {
        var savedPagesize = localStorage[this.uniqueId('usersettings-pagesize')];
        if (savedPagesize) {
          this.settings.pagesize = parseInt(savedPagesize, 10);
        }
      }

      // Restore Show Page Size Selector
      if (options.showPageSizeSelector) {
        var savedShowPageSizeSelector = localStorage[this.uniqueId('usersettings-show-pagesize-selector')];
        savedShowPageSizeSelector = savedShowPageSizeSelector.toString().toLowerCase() === 'true';
        if (savedShowPageSizeSelector) {
          this.settings.showPageSizeSelector = savedShowPageSizeSelector;
        }
      }

      // Restore Active Page
      if (options.activePage) {
        var savedActivePage = localStorage[this.uniqueId('usersettings-active-page')];
        if (savedActivePage) {
          this.savedActivePage = parseInt(savedActivePage, 10);
          this.restoreActivePage = true;
        }
      }

      if (options.filter) {
        var savedFilter = localStorage[this.uniqueId('usersettings-filter')];
        if (savedFilter) {
          this.savedFilter = JSON.parse(savedFilter);
          this.restoreFilter = true;
        }
      }
    },


    /**
    * Reset Columns to defaults (used on restore menu item)
    */
    resetColumns: function resetColumns() {
      if (this.canUseLocalStorage()) {
        localStorage.removeItem(this.uniqueId('columns'));
      }

      if (this.originalColumns) {
        var originalColumns = this.columnsFromString(JSON.stringify(this.originalColumns));
        var columnGroups = this.settings.columnGroups && this.originalColGroups ? this.originalColGroups : null;
        this.updateColumns(originalColumns, columnGroups);
      }

      this.clearFilter();
    },


    /**
    * Hide a column.
    * @param {string} id The id of the column to hide.
    */
    hideColumn: function hideColumn(id) {
      var idx = this.columnIdxById(id);

      if (idx === -1) {
        return;
      }

      this.settings.columns[idx].hidden = true;
      this.headerNodes().eq(idx).addClass('is-hidden');
      this.tableBody.find('> tr > td:nth-child(' + (idx + 1) + ')').addClass('is-hidden');
      this.headerColGroup.find('col').eq(idx).addClass('is-hidden');

      // Shrink or remove colgroups
      this.updateColumnGroup();

      if (this.bodyColGroup) {
        this.bodyColGroup.find('col').eq(idx).addClass('is-hidden');
      }

      // Handle colSpans if present on the column
      if (this.hasColSpans) {
        var colSpan = this.headerRow.find('th').eq(idx).attr('colspan');

        if (colSpan && colSpan > 0) {
          colSpan -= 1;
          for (var i = 0; i < colSpan; i++) {
            idx += colSpan;
            this.tableBody.find('> tr > td:nth-child(' + (idx + 1) + ')').addClass('is-hidden');
          }
        }
      }

      // Handle expandable rows
      if (this.settings.rowTemplate || this.settings.expandableRow) {
        this.syncExpandableRowColspan();
      }

      this.element.trigger('columnchange', [{ type: 'hidecolumn', index: idx, columns: this.settings.columns }]);
      this.saveColumns();
      this.saveUserSettings();
    },


    /**
    * Sync the colspan on the expandable row. (When column count changes)
    * @private
    */
    syncExpandableRowColspan: function syncExpandableRowColspan() {
      var visibleColumnCount = this.visibleColumns().length;
      this.tableBody.find('.datagrid-expandable-row > td').attr('colspan', visibleColumnCount);
    },


    /**
    * Show a hidden column.
    * @param {string} id The id of the column to show.
    */
    showColumn: function showColumn(id) {
      var idx = this.columnIdxById(id);

      if (idx === -1) {
        return;
      }

      this.settings.columns[idx].hidden = false;
      this.headerNodes().eq(idx).removeClass('is-hidden');
      this.tableBody.find('> tr > td:nth-child(' + (idx + 1) + ')').removeClass('is-hidden');
      this.headerColGroup.find('col').eq(idx).removeClass('is-hidden');

      if (this.bodyColGroup) {
        this.bodyColGroup.find('col').eq(idx).removeClass('is-hidden');
      }

      // Shrink or add colgroups
      this.updateColumnGroup();

      // Handle colSpans if present on the column
      if (this.hasColSpans) {
        var colSpan = this.headerRow.find('th').eq(idx).attr('colspan');

        if (colSpan && colSpan > 0) {
          colSpan -= 1;
          for (var i = 0; i < colSpan; i++) {
            idx += colSpan;
            this.tableBody.find('> tr > td:nth-child(' + (idx + 1) + ')').removeClass('is-hidden');
          }
        }
      }

      // Handle expandable rows
      if (this.settings.rowTemplate || this.settings.expandableRow) {
        this.syncExpandableRowColspan();
      }

      this.element.trigger('columnchange', [{ type: 'showcolumn', index: idx, columns: this.settings.columns }]);
      this.saveColumns();
      this.saveUserSettings();
    },


    /**
    * Export the grid contents to csv
    * Consider Deprecated use excel.exportToCsv
    *
    * @param {string} fileName The desired export filename in the download.
    * @param {string} customDs An optional customized version of the data to use.
    */
    exportToCsv: function exportToCsv(fileName, customDs) {
      excel.exportToCsv(fileName, customDs, this);
    },


    /**
    * Export the grid contents to xls format. This may give a warning when opening the file.
    * exportToCsv may be prefered.
    * Consider Deprecated use excel.exportToExcel
    * @param {string} fileName The desired export filename in the download.
    * @param {string} worksheetName A name to give the excel worksheet tab.
    * @param {string} customDs An optional customized version of the data to use.
    */
    exportToExcel: function exportToExcel(fileName, worksheetName, customDs) {
      excel.exportToExcel(fileName, worksheetName, customDs, this);
    },
    copyToDataSet: function copyToDataSet(pastedValue, rowCount, colIndex, dataSet) {
      excel.copyToDataSet(pastedValue, rowCount, colIndex, dataSet, this);
    },


    /**
    * Open the personalization dialog.
    * @private
    */
    personalizeColumns: function personalizeColumns() {
      var self = this;
      var spanNext = 0;
      var markup = '<div class="listview-search alternate-bg"><label class="audible" for="gridfilter">Search</label><input class="searchfield" placeholder="' + Locale.translate('SearchColumnName') + '" name="searchfield" id="gridfilter"></div>';
      markup += '<div class="listview alternate-bg" id="search-listview"><ul>';

      for (var i = 0; i < this.settings.columns.length; i++) {
        var _col4 = this.settings.columns[i];
        var colName = _col4.name;

        if (colName && spanNext <= 0) {
          colName = colName.replace('<br>', ' ').replace('<br/>', ' ').replace('<br />', ' ');
          markup += '<li><a href="#" target="_self" tabindex="-1"> <label class="inline"><input tabindex="-1" ' + (_col4.hideable === false ? 'disabled' : '') + ' type="checkbox" class="checkbox" ' + (_col4.hidden ? '' : ' checked') + ' data-column-id="' + (_col4.id || i) + '"><span class="label-text">' + colName + '</span></label></a></li>';
        }

        if (spanNext > 0) {
          spanNext--;
        }

        if (_col4.colspan) {
          spanNext = _col4.colspan - 1;
        }
      }
      markup += '</ul></div>';

      $('body').modal({
        title: Locale.translate('PersonalizeColumns'),
        content: markup,
        cssClass: 'full-width datagrid-columns-dialog',
        buttons: [{
          text: Locale.translate('Close'),
          click: function click(e, modal) {
            modal.close();
            $('body').off('open.datagrid');
          }
        }]
      }).on('beforeopen.datagrid', function () {
        self.isColumnsChanged = false;
      }).on('open.datagrid', function (e, modal) {
        modal.element.find('.searchfield').searchfield({ clearable: true });
        modal.element.find('.listview').listview({ searchable: true, selectOnFocus: false }).on('selected', function (selectedEvent, args) {
          var chk = args.elem.find('.checkbox');
          var id = chk.attr('data-column-id');
          var isChecked = chk.prop('checked');

          args.elem.removeClass('is-selected hide-selected-color');

          if (chk.is(':disabled')) {
            return;
          }
          self.isColumnsChanged = true;

          if (!isChecked) {
            self.showColumn(id);
            chk.prop('checked', true);
          } else {
            self.hideColumn(id);
            chk.prop('checked', false);
          }
        });

        modal.element.on('close.datagrid', function () {
          self.isColumnsChanged = false;
        });
        modal.element.on('keydown.datagrid', function (event) {
          // Escape Button Code. Make sure to close the modal correctly.
          if (event.keyCode === 27) {
            modal.close();
            $('body').off('open.datagrid');
          }
        });
      });
    },


    /**
    * Explicitly Set the width of a column
    * @private
    * @param {boolean} idOrNode Specifies if the column info is provide by id or as a node reference.
    * @param {number} width The width of the column
    * @param {number} diff The difference between the old and new width
    */
    setColumnWidth: function setColumnWidth(idOrNode, width) {
      var self = this;
      var percent = parseFloat(width);
      var columnNode = idOrNode;
      var columnSettings = this.columnById(typeof idOrNode === 'string' ? idOrNode : idOrNode.attr('data-column-id'))[0];
      var idx = columnNode.index();

      if (!percent) {
        return;
      }

      if (typeof idOrNode === 'string') {
        self.headerNodes().each(function () {
          var col = $(this);

          if (col.attr('data-column-id') === idOrNode) {
            columnNode = col;
          }
        });
      }

      // Handles min width on some browsers
      if (columnSettings.minWidth && width > parseInt(columnSettings.minWidth, 10)) {
        return;
      }

      // calculate percentage
      if (typeof width !== 'number') {
        width = percent / 100 * self.element.width();
      }

      // Prevent Sub Pixel Thrashing
      if (Math.abs(width - columnSettings.width) < 2) {
        return;
      }

      // Handle Col Span - as the width is calculated on the total
      if (typeof columnSettings.colspan === 'number') {
        width /= columnSettings.colspan;
      }

      // Save the column back in settings for later
      if (columnSettings) {
        columnSettings.width = width;
      }

      this.element.trigger('columnchange', [{ type: 'resizecolumn', index: idx, columns: this.settings.columns }]);
      this.saveColumns();
      this.saveUserSettings();
      this.headerWidths[idx].width = width;
    },


    /**
     * Change the width of the column as the user drags the resizeHandle
     * @param {boolean} idOrNode Specifies if the column info is provide by id or as a node reference.
     * @param {number} width The width of the column
     * @param {number} diff The difference between the old and new width
     */
    resizeColumnWidth: function resizeColumnWidth(idOrNode, width, diff) {
      var idx = idOrNode.index();
      this.headerColGroup.find('col').eq(idx)[0].style.width = width + 'px';

      if (this.settings.dataset.length > 0) {
        this.bodyColGroup.find('col').eq(idx)[0].style.width = width + 'px';
      }

      if (this.tableWidth && diff) {
        this.headerTable.css('width', parseInt(this.tableWidth, 10) + diff);
        this.table.css('width', parseInt(this.tableWidth, 10) + diff);
      }
    },


    /**
    * Generate the ui handles used to resize columns.
    * @private
    */
    createResizeHandle: function createResizeHandle() {
      var self = this;
      if (this.resizeHandle) {
        return;
      }

      this.resizeHandle = $('<div class="resize-handle" aria-hidden="true"></div>');
      if (this.settings.columnGroups) {
        this.resizeHandle[0].style.height = '80px';
      }

      if (this.settings.filterable) {
        this.resizeHandle[0].style.height = '62px';
      }

      this.headerContainer.find('table').before(this.resizeHandle);

      var columnId = void 0;
      var startingLeft = void 0;
      var columnStartWidth = void 0;
      var column = void 0;

      this.resizeHandle.drag({ axis: 'x', containment: 'parent' }).on('dragstart.datagrid', function () {
        if (!self.currentHeader) {
          return;
        }

        self.dragging = true;

        columnId = self.currentHeader.attr('data-column-id');
        column = self.columnById(columnId)[0]; // eslint-disable-line

        startingLeft = self.currentHeader.position().left + (self.table.scrollLeft() - 10);
        self.tableWidth = self.table[0].offsetWidth;
        columnStartWidth = self.currentHeader[0].offsetWidth;
      }).on('drag.datagrid', function (e, ui) {
        if (!self.currentHeader || !column) {
          return;
        }

        var width = ui.left - startingLeft - 1;
        var minWidth = column.minWidth || 12;
        var maxWidth = column.maxWidth || 1000;

        if (width < minWidth || width > maxWidth) {
          self.resizeHandle.css('cursor', 'inherit');
          return;
        }

        width = Math.round(width);
        self.resizeColumnWidth(self.currentHeader, width, width - columnStartWidth);
      }).on('dragend.datagrid', function (e, ui) {
        var width = ui.left - startingLeft - 1;
        self.dragging = false;
        self.setColumnWidth(self.currentHeader, width);
      });
    },


    /**
    * Show Summary and any other count info
    * @private
    * @param {boolean} totals The total to display on the UI.
    */
    displayCounts: function displayCounts(totals) {
      var self = this;
      var count = self.tableBody.find('tr:visible').length;
      var isClientSide = self.settings.paging && !self.settings.source;

      if (isClientSide || !totals) {
        this.recordCount = self.settings.dataset.length;
        count = self.settings.dataset.length;
      }

      // Update Selected
      if (self.contextualToolbar && self.contextualToolbar.length) {
        self.contextualToolbar.find('.selection-count').text(self._selectedRows.length + ' ' + Locale.translate('Selected'));
      }

      if (totals && totals !== -1) {
        count = totals;
      }

      if (!totals && this.settings.source) {
        count = this.lastCount;
      }

      var countText = void 0;
      if (self.settings.showFilterTotal && self.filteredCount > 0) {
        countText = '(' + Locale.formatNumber(count - self.filteredCount, { style: 'integer' }) + ' of ' + Locale.formatNumber(count, { style: 'integer' }) + ' ' + Locale.translate(count === 1 ? 'Result' : 'Results') + ')';
      } else {
        countText = '(' + Locale.formatNumber(count, { style: 'integer' }) + ' ' + Locale.translate(count === 1 ? 'Result' : 'Results') + ')';
      }

      if (self.settings.resultsText) {
        if (typeof self.settings.resultsText === 'function') {
          if (self.grandTotal) {
            countText = self.settings.resultsText(self, self.grandTotal, count);
          } else {
            var filteredCount = self.filteredCount === 0 ? 0 : count - self.filteredCount;
            countText = self.settings.resultsText(self, count, filteredCount);
          }
        } else {
          countText = self.settings.resultsText;
        }
      }

      if (self.toolbar) {
        DOM.html(self.toolbar.find('.datagrid-result-count'), countText, '<span>');
        self.toolbar[0].setAttribute('aria-label', self.toolbar.find('.title').text());
        self.toolbar.find('.datagrid-row-count').text(count);
      }
      DOM.html(self.element.closest('.modal').find('.datagrid-result-count'), countText, '<span>');
      this.lastCount = count;

      this.checkEmptyMessage();
    },


    /**
    * Set the content dynamically on the empty message area.
    * @param {object} emptyMessage The update empty message config object.
    */
    setEmptyMessage: function setEmptyMessage(emptyMessage) {
      if (!this.emptyMessage) {
        this.emptyMessageContainer = $('<div>');
        this.contentContainer.prepend(this.emptyMessageContainer);
        this.emptyMessage = this.emptyMessageContainer.emptymessage(emptyMessage).data('emptymessage');
      } else {
        this.emptyMessage.settings = emptyMessage;
        this.emptyMessage.updated();
      }
    },


    /**
    * See if the empty message object should be shown.
    * @private
    */
    checkEmptyMessage: function checkEmptyMessage() {
      if (this.emptyMessage && this.emptyMessageContainer) {
        if (this.filteredCount === this.recordCount || this.recordCount === 0) {
          this.emptyMessageContainer.show();
          this.element.addClass('is-empty');
        } else {
          this.emptyMessageContainer.hide();
          this.element.removeClass('is-empty');
        }
      }
    },


    /**
    * Trigger event on parent and compose the args
    * @private
    * @param  {strung} eventName Event to trigger
    * @param  {object} e  Actual event
    * @param  {boolean} stopPropagation If stopPropagation should be done
    * @returns {boolean} False when the event should not propagte.
    */
    triggerRowEvent: function triggerRowEvent(eventName, e, stopPropagation) {
      var self = this;
      var cell = $(e.target).closest('td').index();
      var rowElem = $(e.target).closest('tr');
      var row = this.settings.treeGrid ? this.actualRowIndex(rowElem) : this.dataRowIndex(rowElem);
      var isTrigger = true;

      if ($(e.target).is('a')) {
        stopPropagation = false;
      }

      if (stopPropagation) {
        e.stopPropagation();
        e.preventDefault();
      }

      var item = self.settings.dataset[row];

      //  Groupable
      if (this.settings.groupable) {
        if (rowElem.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer')) {
          isTrigger = false; // No need to trigger if no data item
        } else {
          row = self.pagingRowIndex(self.actualRowIndex(rowElem));
          item = self.settings.dataset[self.groupArray[row].group];
          if (item && item.values) {
            item = item.values[self.groupArray[row].node];
          }
        }
      }

      if (isTrigger) {
        self.element.trigger(eventName, [{ row: row, cell: cell, item: item, originalEvent: e }]);
      }

      return false;
    },


    /**
     * Returns the cell dom node.
     * @param  {number} row The row index.
     * @param  {number} cell The cell index.
     * @param  {boolean} includeGroups If true groups are taken into account.
     * @returns {object} The dom node
     */
    cellNode: function cellNode(row, cell, includeGroups) {
      var cells = null;
      var rowNode = null;

      if (row instanceof jQuery) {
        rowNode = row;
      } else {
        rowNode = this.tableBody.find('tr:not(.datagrid-expandable-row)[aria-rowindex="' + (row + 1) + '"]');
      }

      if (includeGroups && this.settings.groupable) {
        rowNode = this.tableBody.prevAll('.datagrid-rowgroup-header').eq(row);
        if (rowNode) {
          rowNode = this.tableBody.find('.datagrid-rowgroup-header').eq(row);
        }
      }

      if (cell === -1 || rowNode.length === 0) {
        return $();
      }

      cells = rowNode.find('td');
      return cells.eq(cell >= cells.length ? cells.length - 1 : cell);
    },


    /**
    * Scroll event handler.
    * @private
    */
    handleScroll: function handleScroll() {
      var left = this.contentContainer[0].scrollLeft;

      if (left !== this.scrollLeft && this.headerContainer) {
        this.scrollLeft = left;
        this.headerContainer[0].scrollLeft = this.scrollLeft;
      }
    },


    /**
    * Resize event handler.
    * @private
    */
    handleResize: function handleResize() {
      var self = this;
      self.clearHeaderCache();
      self.renderRows();
      self.renderHeader();
    },


    /**
     * Attach All relevant event handlers.
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var self = this;
      var isMultiple = this.settings.selectable === 'multiple';
      var isMixed = this.settings.selectable === 'mixed';

      // Set Focus on rows
      if (!self.settings.cellNavigation && self.settings.rowNavigation) {
        self.table.on('focus.datagrid', 'tbody > tr', function () {
          $(this).addClass('is-active-row');
        }).on('blur.datagrid', 'tbody > tr', function () {
          $('tbody > tr', self.table).removeClass('is-active-row');
        });
      }

      // Sync Header and Body During scrolling
      self.contentContainer.on('scroll.table', function () {
        self.handleScroll();
      });

      if (this.settings.virtualized) {
        var oldScroll = 0;
        var oldHeight = 0;

        self.contentContainer.on('scroll.vtable', debounce(function () {
          var scrollTop = this.scrollTop;
          var buffer = 25;
          var hitBottom = scrollTop > self.virtualRange.bottom - self.virtualRange.bodyHeight - buffer;
          var hitTop = scrollTop < self.virtualRange.top + buffer;

          if (scrollTop !== oldScroll && (hitTop || hitBottom)) {
            oldScroll = this.scrollTop;
            self.renderRows();
          }
        }, 0));

        $('body').on('resize.vtable', function () {
          var height = this.offsetHeight;

          if (height !== oldHeight) {
            oldHeight = this.scrollTop;
            self.renderRows();
          }
        });
      }

      // Handle Resize - Re do the columns
      if (self.settings.redrawOnResize) {
        var oldWidth = self.element.outerWidth();

        $('body').on('resize.datagrid', function () {
          var width = self.element.outerWidth();
          if (width !== oldWidth) {
            oldWidth = width;
            self.handleResize();
          }
        });
      }

      // Handle Sorting
      this.element.off('click.datagrid').on('click.datagrid', '> .datagrid-header th.is-sortable, > .datagrid-header th.btn-filter', function (e) {
        if ($(e.target).parent().is('.datagrid-filter-wrapper')) {
          return;
        }

        self.setSortColumn($(this).attr('data-column-id'));
      });

      // Prevent redirects
      this.table.off('click.datagrid').on('click.datagrid', '.datagrid-row a', function (e) {
        e.preventDefault();
      });

      // Handle Row Clicking
      var tbody = this.table.find('tbody');

      // Add a paste event for handling pasting from excel
      if (self.settings.editable) {
        this.element.off('paste.datagrid').on('paste.datagrid', function (e) {
          var pastedData = void 0;
          if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
            pastedData = e.originalEvent.clipboardData.getData('text/plain');
          } else {
            pastedData = window.clipboardData && window.clipboardData.getData ? window.clipboardData.getData('Text') : false;
          }

          var hasLineFeed = /\n/.exec(pastedData);
          var hasCarriageReturn = /\r/.exec(pastedData);
          var hasBoth = /\r\n/.exec(pastedData);

          if (self.activeCell && self.activeCell.node.hasClass('is-readonly')) {
            return; // disallow pasting on non editable cells.
          }

          if (pastedData && hasCarriageReturn || hasLineFeed || hasBoth) {
            var splitData = hasLineFeed ? pastedData.split('\n') : pastedData.split('\r');
            if (hasBoth) {
              splitData = pastedData.split('\r\n');
            }

            splitData.pop();

            var startRowCount = parseInt($(e.target)[0].parentElement.parentElement.parentElement.getAttribute('data-index'), 10);
            var startColIndex = parseInt($(e.target)[0].parentElement.parentElement.getAttribute('aria-colindex'), 10) - 1;

            if (self.editor && self.editor.input) {
              self.commitCellEdit(self.editor.input);
            }
            self.copyToDataSet(splitData, startRowCount, startColIndex, self.settings.dataset);
          }
        });
      }

      tbody.off('click.datagrid').on('click.datagrid', 'td', function (e) {
        var rowNode = null;
        var dataRowIdx = null;
        var target = $(e.target);

        if ($(e.currentTarget).parent().hasClass('.datagrid-row-detail')) {
          return;
        }

        if (target.parents('td').length > 1) {
          e.preventDefault(); // stop nested clicks from propagating
          e.stopPropagation();
        }

        /**
        * Fires after a row is clicked.
        * @event click
        * @memberof Datagrid
        * @property {object} event The jquery event object
        * @property {object} args Additional arguments
        * @property {number} args.row The current row height
        * @property {number} args.cell The columns object
        * @property {object} args.item The current sort column.
        * @property {object} args.originalEvent The original event object.
        */
        self.triggerRowEvent('click', e, true);
        self.setActiveCell(target.closest('td'));

        // Dont Expand rows or make cell editable when clicking expand button
        if (target.is('.datagrid-expand-btn')) {
          rowNode = $(this).closest('tr');
          dataRowIdx = self.actualRowIndex(rowNode);

          self.toggleRowDetail(dataRowIdx);
          self.toggleGroupChildren(rowNode);
          self.toggleChildren(e, dataRowIdx);
          return false; //eslint-disable-line
        }

        var isSelectionCheckbox = target.is('.datagrid-selection-checkbox') || target.find('.datagrid-selection-checkbox').length === 1;
        var canSelect = self.settings.clickToSelect ? true : isSelectionCheckbox;

        if (target.is('.datagrid-drilldown')) {
          canSelect = false;
        }

        if (isMixed) {
          canSelect = isSelectionCheckbox;

          // Then Activate
          if (!canSelect) {
            if (e.shiftKey && self.activatedRow().length) {
              self.selectRowsBetweenIndexes([self.activatedRow()[0].row, target.closest('tr').index()]);
              e.preventDefault();
            }

            self.toggleRowActivation(target.closest('tr'));
          }
        }

        if (canSelect && isMultiple && e.shiftKey) {
          self.selectRowsBetweenIndexes([self.lastSelectedRow, target.closest('tr').index()]);
          e.preventDefault();
        } else if (canSelect) {
          self.toggleRowSelection(target.closest('tr'));
        }

        var isEditable = self.makeCellEditable(self.activeCell.rowIndex, self.activeCell.cell, e);

        // Handle Cell Click Event
        var elem = $(this).closest('td');
        var cell = elem.parent().children(':visible').index(elem);
        var col = self.columnSettings(cell, true);

        if (col.click && typeof col.click === 'function' && target.is('button, input[checkbox], a') || target.parent().is('button')) {
          //eslint-disable-line
          var rowElem = $(this).closest('tr');
          var rowIdx = self.actualRowIndex(rowElem);
          dataRowIdx = self.dataRowIndex(rowElem);
          var item = self.settings.treeGrid ? self.settings.treeDepth[rowIdx].node : self.settings.dataset[dataRowIdx];

          if (elem.hasClass('is-focusable')) {
            if (!target.is(self.buttonSelector)) {
              if (!target.parent('button').is(self.buttonSelector)) {
                return;
              }
            }
          }

          if (self.settings.groupable) {
            if (!rowElem.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer')) {
              rowIdx = self.pagingRowIndex(self.actualRowIndex(rowElem));
              item = self.settings.dataset[self.groupArray[rowIdx].group];
              if (item && item.values) {
                item = item.values[self.groupArray[rowIdx].node];
              }
            }
          }

          if (!elem.hasClass('is-cell-readonly') && target.is('button, input[checkbox], a') || target.parent().is('button')) {
            //eslint-disable-line
            col.click(e, [{ row: rowIdx, cell: self.activeCell.cell, item: item, originalEvent: e }]);
          }
        }

        // Handle Context Menu on Some
        if (col.menuId) {
          var btn = $(this).find('button');
          btn.popupmenu({ attachToBody: true, autoFocus: false, mouseFocus: true, menuId: col.menuId, trigger: 'immediate', offset: { y: 5 } });

          if (col.selected) {
            btn.on('selected.datagrid', col.selected);
          }
        }

        // Apply Quick Edit Mode
        if (isEditable) {
          setTimeout(function () {
            if ($('textarea, input', elem).length && !$('.dropdown,' + '[type=file],' + '[type=image],' + '[type=button],' + '[type=submit],' + '[type=reset],' + '[type=checkbox],' + '[type=radio]', elem).length) {
              self.quickEditMode = true;
            }
          }, 0);
        }
      });

      /**
      * Fires after a row is double clicked.
      * @event dblclick
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.row The current row height
      * @property {number} args.cell The columns object
      * @property {object} args.item The current sort column.
      * @property {object} args.originalEvent The original event object.
      */
      tbody.off('dblclick.datagrid').on('dblclick.datagrid', 'tr', function (e) {
        self.triggerRowEvent('dblclick', e, true);
      });

      /**
      * Fires after a row has a right click action.
      * @event contextmenu
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.row The current row height
      * @property {number} args.cell The columns object
      * @property {object} args.item The current sort column.
      * @property {object} args.originalEvent The original event object.
      */
      tbody.off('contextmenu.datagrid').on('contextmenu.datagrid', 'tr', function (e) {
        if (!self.isSubscribedTo(e, 'contextmenu')) {
          return;
        }

        self.triggerRowEvent('contextmenu', e, !!self.settings.menuId);
        e.preventDefault();

        if (self.settings.menuId) {
          $(e.currentTarget).popupmenu({
            menuId: self.settings.menuId,
            eventObj: e,
            beforeOpen: self.settings.menuBeforeOpen,
            attachToBody: true,
            trigger: 'immediate'
          }).off('selected').on('selected', function (selectedEvent, args) {
            if (self.settings.menuSelected) {
              self.settings.menuSelected(selectedEvent, args);
            }
          }).off('close').on('close', function () {
            var elem = $(this);
            if (elem.data('popupmenu')) {
              elem.data('popupmenu').destroy();
            }
          });
        }

        return false; // eslint-disable-line
      });

      // Move the drag handle to the end or start of the column
      this.headerRow.off('mousemove.datagrid').on('mousemove.datagrid', 'th', function (e) {
        if (self.dragging) {
          return;
        }

        self.currentHeader = $(e.target).closest('th');

        if (!self.currentHeader.hasClass('is-resizable')) {
          return;
        }

        var headerDetail = self.currentHeader.closest('.header-detail');
        var extraMargin = headerDetail.length ? parseInt(headerDetail.css('margin-left'), 10) : 0;
        var leftEdge = parseInt(self.currentHeader.position().left, 10) - (extraMargin || 0) + self.element.scrollLeft();
        var rightEdge = leftEdge + self.currentHeader.outerWidth();
        var alignToLeft = e.pageX - leftEdge > rightEdge - e.pageX;
        var leftPos = 0;

        // TODO: Test Touch support - may need handles on each column
        leftPos = alignToLeft ? rightEdge - 6 : leftEdge - 6;

        // Ignore First Column
        if (self.currentHeader.index() === 0 && !alignToLeft) {
          leftPos = '-999';
        }

        if (!alignToLeft) {
          self.currentHeader = self.currentHeader.prevAll(':visible').not('.is-hidden').first();
        }

        if (!self.currentHeader.hasClass('is-resizable')) {
          return;
        }

        self.createResizeHandle();
        self.resizeHandle[0].style.left = leftPos + 'px';
        self.resizeHandle[0].style.cursor = '';
      }).off('contextmenu.datagrid').on('contextmenu.datagrid', 'th', function (e) {
        // Add Header Context Menu Support
        e.preventDefault();

        if (self.settings.headerMenuId) {
          $(e.currentTarget).popupmenu({
            menuId: self.settings.headerMenuId,
            eventObj: e,
            attachToBody: true,
            beforeOpen: self.settings.headerMenuBeforeOpen,
            trigger: 'immediate'
          }).off('selected.gridpopup').on('selected.gridpopup', function (selectedEvent, args) {
            self.settings.headerMenuSelected(selectedEvent, args);
          });
        }

        return false;
      });

      // Handle Clicking Header Checkbox
      this.headerRow.off('click.datagrid').on('click.datagrid', 'th .datagrid-checkbox', function () {
        var checkbox = $(this);

        if (!checkbox.hasClass('is-checked')) {
          checkbox.addClass('is-checked').attr('aria-checked', 'true');

          self.selectAllRows();
        } else {
          checkbox.removeClass('is-checked').attr('aria-checked', 'true');
          self.unSelectAllRows();
        }
      });

      // Implement Editing Auto Commit Functionality
      tbody.off('focusout.datagrid').on('focusout.datagrid', 'td input, td textarea, div.dropdown', function (e) {
        // Keep icon clickable in edit mode
        var target = e.target;

        if ($(target).is('input.lookup, input.timepicker, input.datepicker, input.spinbox, input.colorpicker')) {
          // Wait for modal popup, if did not found modal popup means
          // icon was not clicked, then commit cell edit
          setTimeout(function () {
            var focusElem = $('*:focus');

            if (!$('.lookup-modal.is-visible, #timepicker-popup, #monthview-popup, #colorpicker-menu').length && self.editor) {
              if (focusElem.is('.spinbox')) {
                return;
              }

              if (focusElem.is('.trigger')) {
                return;
              }

              if (!$(target).is(':visible')) {
                return;
              }

              if (focusElem && self.editor.className && focusElem.closest(self.editor.className).length > 0) {
                return;
              }

              self.commitCellEdit(self.editor.input);
            }
          }, 150);

          return;
        }

        // Popups are open
        if ($('#dropdown-list, .autocomplete.popupmenu.is-open, #timepicker-popup').is(':visible')) {
          return;
        }

        if (self.editor && self.editor.input) {
          self.commitCellEdit(self.editor.input);
        }
      });
    },


    /**
    * Check if the event is subscribed to.
    * @private
    * @param {object} e The update empty message config object.
    * @param {object} eventName The update empty message config object.
    * @returns {boolean} If the event is subscribed to.
    */
    isSubscribedTo: function isSubscribedTo(e, eventName) {
      var self = this;

      for (var event in $._data(self.element[0]).events) {
        //eslint-disable-line
        if (event === eventName) {
          return true;
        }
      }

      return false;
    },


    /**
    * Refresh the heights based on the rowHeight setting.
    * @private
    */
    refreshSelectedRowHeight: function refreshSelectedRowHeight() {
      var toolbar = this.element.parent().find('.toolbar:not(.contextual-toolbar)');
      var short = toolbar.find('[data-option="row-short"]');
      var med = toolbar.find('[data-option="row-medium"]');
      var normal = toolbar.find('[data-option="row-normal"]');

      if (this.settings.rowHeight === 'short') {
        short.parent().addClass('is-checked');
        med.parent().removeClass('is-checked');
        normal.parent().removeClass('is-checked');
      }

      if (this.settings.rowHeight === 'medium') {
        short.parent().removeClass('is-checked');
        med.parent().addClass('is-checked');
        normal.parent().removeClass('is-checked');
      }

      if (this.settings.rowHeight === 'normal') {
        short.parent().removeClass('is-checked');
        med.parent().removeClass('is-checked');
        normal.parent().addClass('is-checked');
      }

      // Set draggable targets arrow height
      $('.drag-target-arrows', this.element).css('height', this.getTargetHeight() + 'px');
    },


    /**
    * Append all the UI elements for the toolbar above the grid.
    * @private
    */
    appendToolbar: function appendToolbar() {
      var toolbar = null;
      var title = '';
      var more = null;
      var self = this;

      if (!this.settings.toolbar) {
        return;
      }

      // Allow menu to be added manually
      if (this.element.parent().find('.toolbar:not(.contextual-toolbar)').length === 1) {
        toolbar = this.element.parent().find('.toolbar:not(.contextual-toolbar)');
        this.refreshSelectedRowHeight();
      } else {
        toolbar = $('<div class="toolbar" role="toolbar"></div>');
        this.removeToolbarOnDestroy = true;

        if (this.settings.toolbar.title) {
          title = $('<div class="title">' + this.settings.toolbar.title + '  </div>');
        }

        if (!title) {
          title = toolbar.find('.title');
        }
        toolbar.append(title);

        if (this.settings.toolbar.results) {
          // Actually value filled in displayResults
          title.append('<span class="datagrid-result-count"></span>');
        }

        var buttonSet = $('<div class="buttonset"></div>').appendTo(toolbar);

        if (this.settings.toolbar.keywordFilter) {
          var labelMarkup = $('<label class="audible" for="gridfilter">' + Locale.translate('Keyword') + '</label>');
          var searchfieldMarkup = $('<input class="searchfield" name="searchfield" placeholder="' + Locale.translate('Keyword') + '" id="gridfilter">');

          buttonSet.append(labelMarkup);

          if (!this.settings.toolbar.collapsibleFilter) {
            searchfieldMarkup.attr('data-options', '{ "collapsible": false }');
          }

          buttonSet.append(searchfieldMarkup);
        }

        if (this.settings.toolbar.dateFilter) {
          buttonSet.append('<button class="btn" type="button">' + $.createIcon({ icon: 'calendar' }) + '<span>' + Locale.translate('Date') + '</span></button>');
        }

        if (this.settings.toolbar.actions) {
          more = $('<div class="more"></div>').insertAfter(buttonSet);
          more.append('<button class="btn-actions" title="More" type="button">' + $.createIcon({ icon: 'more' }) + '<span class="audible">Grid Features</span></button>');
          toolbar.addClass('has-more-button');
        }

        var menu = $('<ul class="popupmenu"></ul>');

        if (this.settings.toolbar.personalize) {
          menu.append('<li><a href="#" data-option="personalize-columns">' + Locale.translate('PersonalizeColumns') + '</a></li>');
        }

        if (this.settings.toolbar.resetLayout) {
          menu.append('<li><a href="#" data-option="reset-layout">' + Locale.translate('ResetDefault') + '</a></li>');
        }

        if (this.settings.toolbar.exportToExcel) {
          menu.append('<li><a href="#" data-option="export-to-excel">' + Locale.translate('ExportToExcel') + '</a></li>');
        }

        if (this.settings.toolbar.advancedFilter) {
          menu.append('<li><a href="#">' + Locale.translate('AdvancedFilter') + '</a></li>');
        }

        if (this.settings.toolbar.views) {
          menu.append('<li><a href="#">' + Locale.translate('SaveCurrentView') + '</a></li> ' + '<li class="separator"></li> ' + ('<li class="heading">' + Locale.translate('SavedViews') + '</li>') + '<li><a href="#">View One</a></li>');
        }

        if (this.settings.toolbar.rowHeight) {
          menu.append('' + ('<li class="separator single-selectable-section"></li>' + '<li class="heading">') + Locale.translate('RowHeight') + '</li>' + ('<li class="is-selectable' + (this.settings.rowHeight === 'short' ? ' is-checked' : '') + '"><a data-option="row-short">' + Locale.translate('Short') + '</a></li>') + ('<li class="is-selectable' + (this.settings.rowHeight === 'medium' ? ' is-checked' : '') + '"><a data-option="row-medium">' + Locale.translate('Medium') + '</a></li>') + ('<li class="is-selectable' + (this.settings.rowHeight === 'normal' ? ' is-checked' : '') + '"><a data-option="row-normal">' + Locale.translate('Normal') + '</a></li>'));
        }

        if (this.settings.toolbar.filterRow) {
          menu.append('' + ('<li class="separator"></li>' + '<li class="heading">') + Locale.translate('Filter') + '</li>' + ('<li class="' + (this.settings.filterable ? 'is-checked ' : '') + 'is-toggleable"><a data-option="show-filter-row">' + Locale.translate('ShowFilterRow') + '</a></li>') + ('<li class="is-indented"><a data-option="run-filter">' + Locale.translate('RunFilter') + '</a></li>') + ('<li class="is-indented"><a data-option="clear-filter">' + Locale.translate('ClearFilter') + '</a></li>'));
        }

        if (this.settings.toolbar.actions) {
          more.append(menu);
        }

        if (this.element.prev().is('.contextual-toolbar')) {
          this.element.prev().before(toolbar);
        } else {
          this.element.before(toolbar);
        }
      }

      toolbar.find('.btn-actions').popupmenu().on('selected', function (e, args) {
        var action = args.attr('data-option');
        if (action === 'row-short' || action === 'row-medium' || action === 'row-normal') {
          self.rowHeight(action.substr(4));
        }

        if (action === 'personalize-columns') {
          self.personalizeColumns();
        }

        if (action === 'reset-layout') {
          self.resetColumns();
        }

        if (action === 'export-to-excel') {
          // self.exportToExcel();
          self.exportToCsv();
        }

        // Filter actions
        if (action === 'show-filter-row') {
          self.toggleFilterRow();
        }
        if (action === 'run-filter') {
          self.applyFilter(null, 'menu');
        }
        if (action === 'clear-filter') {
          self.clearFilter();
        }
      });

      if (this.settings.initializeToolbar && !toolbar.data('toolbar')) {
        var opts = $.fn.parseOptions(toolbar);

        if (this.settings.toolbar.fullWidth) {
          opts.rightAligned = true;
        }

        toolbar.toolbar(opts);
      }

      if (this.settings.toolbar && this.settings.toolbar.keywordFilter) {
        var thisSearch = toolbar.find('.searchfield');
        var xIcon = thisSearch.parent().find('.close.icon');

        thisSearch.off('keypress.datagrid').on('keypress.datagrid', function (e) {
          if (e.keyCode === 13 || e.type === 'change') {
            e.preventDefault();
            self.keywordSearch(thisSearch.val());
          }
        });

        xIcon.off('click.datagrid').on('click.datagrid', function () {
          self.keywordSearch(thisSearch.val());
        });
      }

      if (this.settings.toolbar && this.settings.toolbar.contextualToolbar) {
        var contextualToolbar = '\n        <div class="contextual-toolbar datagrid-contextual-toolbar toolbar is-hidden">\n          <div class="title selection-count">1 Selected</div>\n        </div>';

        this.element.before(contextualToolbar);
        this.contextualToolbar = this.element.prev('.contextual-toolbar');
      }

      this.toolbar = toolbar;
      this.element.addClass('has-toolbar');
    },


    /**
     * Get or Set the Row Height.
     * @param  {string} height The row height to use, can be 'short', 'normal' or 'medium'
     * @Returns {string} The current row height
     */
    rowHeight: function rowHeight(height) {
      if (height) {
        this.settings.rowHeight = height;
      }

      this.element.add(this.table).removeClass('short-rowheight medium-rowheight normal-rowheight').addClass(this.settings.rowHeight + '-rowheight');

      if (this.virtualRange && this.virtualRange.rowHeight) {
        this.virtualRange.rowHeight = height === 'normal' ? 40 : height === 'medium' ? 30 : 25;
      }

      this.saveUserSettings();
      this.refreshSelectedRowHeight();
      return this.settings.rowHeight;
    },


    /**
    * Search a Term across all columns
    * @param  {string} term The term to search for.
    */
    keywordSearch: function keywordSearch(term) {
      this.tableBody.find('tr[role="row"]').removeClass('is-filtered').show();
      this.filterExpr = [];

      this.tableBody.find('.datagrid-expandable-row').each(function () {
        var row = $(this);
        // Collapse All rows
        row.prev().find('.datagrid-expand-btn').removeClass('is-expanded');
        row.prev().find('.plus-minus').removeClass('active');
        row.removeClass('is-expanded').css('display', '');
        row.find('.datagrid-row-detail').css('height', '');
      });

      this.tableBody.find('.search-mode').each(function () {
        var cell = $(this);
        var text = cell.text();
        cell.text(text.replace('<i>', '').replace('</i>', ''));
      });

      term = (term || '').toLowerCase();
      this.filterExpr.push({ column: 'all', operator: 'contains', value: term, keywordSearch: true });

      this.filterKeywordSearch();
      this.renderRows();
      this.resetPager('searched');
      this.setSearchActivePage();

      if (!this.settings.paging) {
        this.highlightSearchRows(term);
      }
    },


    /**
     * Set search active page
     * @private
     */
    setSearchActivePage: function setSearchActivePage() {
      if (this.pager && this.filterExpr && this.filterExpr.length === 1) {
        if (this.filterExpr[0].value !== '') {
          if (this.pager.searchActivePage === undefined) {
            this.pager.searchActivePage = this.pager.activePage;
          }
          this.pager.setActivePage(1, true);
        } else if (this.filterExpr[0].value === '' && this.pager.searchActivePage > -1) {
          this.pager.setActivePage(this.pager.searchActivePage, true);
          delete this.pager.searchActivePage;
        }
      } else if (this.pager && this.pager.searchActivePage > -1) {
        this.pager.setActivePage(this.pager.searchActivePage, true);
        delete this.pager.searchActivePage;
      }
    },


    /**
     * Filter to keyword search.
     * @private
     */
    filterKeywordSearch: function filterKeywordSearch() {
      var self = this;
      var dataset = void 0;
      var isFiltered = void 0;
      var i = void 0;
      var len = void 0;
      var filterExpr = self.filterExpr;

      var checkRow = function checkRow(data, row) {
        var isMatch = false;

        var checkColumn = function checkColumn(columnId) {
          var column = self.columnById(columnId)[0];
          var fieldValue = self.fieldValue(data, column.field);
          var value = void 0;
          var cell = self.settings.columns.indexOf(column);

          // Use the formatted value (what the user sees in the cells)
          // since it's a more reliable match
          value = self.formatValue(column.formatter, row, cell, fieldValue, column, data, self);
          value = value.toLowerCase();

          // Strip any html markup that might be in the formatted value
          value = value.replace(/(<([^>]+)>)|(amp;)|(&lt;([^>]+)&gt;)/ig, '');

          return value.indexOf(filterExpr.value) > -1;
        };

        // Check in all visible columns
        if (filterExpr.column === 'all') {
          self.headerRow.find('th:visible').each(function () {
            //eslint-disable-line
            var th = $(this);
            var columnId = th.attr('data-column-id');

            isMatch = checkColumn(columnId);
            if (isMatch) {
              return false;
            }
          });
        } else if (filterExpr.columnId) {
          // Check in only one column, given by columnId
          isMatch = checkColumn(filterExpr.columnId);
        }
        return isMatch;
      };

      // Make sure not more/less than one filter expr
      if (!filterExpr || filterExpr.length !== 1) {
        return;
      }
      filterExpr = filterExpr[0];

      // Check in dataset
      if (self.settings.treeGrid) {
        dataset = self.settings.treeDepth;
        for (i = 0, len = dataset.length; i < len; i++) {
          isFiltered = filterExpr.value === '' ? false : !checkRow(dataset[i].node, i);
          dataset[i].node.isFiltered = isFiltered;
        }
      } else {
        dataset = self.settings.dataset;
        for (i = 0, len = dataset.length; i < len; i++) {
          isFiltered = filterExpr.value === '' ? false : !checkRow(dataset[i], i);
          dataset[i].isFiltered = isFiltered;
        }
      }
    },


    /**
     * Highlight the term in the grid.
     * @private
     * @param  {string} term The term to highlight
     * @returns {void}
     */
    highlightSearchRows: function highlightSearchRows(term) {
      var self = this;

      if (!term || term === '') {
        return;
      }

      // Move across all visible cells and rows, highlighting
      this.tableBody.find('tr').each(function () {
        var found = false;
        var row = $(this);

        row.find('td').each(function () {
          var cell = $(this);
          var cellText = cell.text().toLowerCase();
          var isSearchExpandableRow = self.settings.searchExpandableRow ? true : !row.hasClass('datagrid-expandable-row');

          if (cellText.indexOf(term) > -1 && isSearchExpandableRow) {
            found = true;
            cell.find('*').each(function () {
              if (xssUtils.unescapeHTML(this.innerHTML) === this.textContent) {
                var contents = this.textContent;
                var node = $(this);
                var exp = new RegExp('(' + stringUtils.escapeRegExp(term) + ')', 'gi');

                node.addClass('search-mode').html(contents.replace(exp, '<i>$1</i>'));
              }
            });
          }
        });

        // Hide non matching rows and non detail rows
        if (!found && !row.find('.datagrid-row-detail').length) {
          row.addClass('is-filtered').hide();
        } else if (self.settings.searchExpandableRow && found && row.is('.datagrid-expandable-row') && term !== '') {
          row.prev().show();
          row.prev().find('.datagrid-expand-btn').addClass('is-expanded');
          row.prev().find('.plus-minus').addClass('active');
          row.addClass('is-expanded').css('display', 'table-row');
          row.find('.datagrid-row-detail').css('height', 'auto');
        }
      });
    },


    /**
    * Select all rows. If serverside paging, this will be only the current page.
    * For client side paging, all rows across all pages are selected.
    */
    selectAllRows: function selectAllRows() {
      var rows = [];
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;

      for (var i = 0, l = dataset.length; i < l; i++) {
        var idx = this.pagingRowIndex(i);
        if (this.filterRowRendered || this.filterExpr && this.filterExpr[0] && this.filterExpr[0].keywordSearch) {
          if (!dataset[i].isFiltered) {
            rows.push(idx);
          }
        } else {
          rows.push(idx);
        }
      }

      this.dontSyncUi = true;
      this.selectRows(rows, true, true);
      this.dontSyncUi = false;
      this.syncSelectedUI();

      /**
      * Fires after a row is selected.
      * @event contextmenu
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {array} args.selectedRows An array of selected rows.
      * @property {string} args.trigger The action can be 'selectall', 'deselectall', 'select', 'deselect'
      * @property {object} args.item The current sort column.
      * @property {object} args.originalEvent The original event object.
      */
      this.element.triggerHandler('selected', [this._selectedRows, 'selectall']);
    },


    /**
    * Deselect all rows that are currently selected.
    */
    unSelectAllRows: function unSelectAllRows() {
      this.dontSyncUi = true;

      for (var i = this._selectedRows.length - 1; i >= 0; i--) {
        var idx = this.pagingRowIndex(this._selectedRows[i].idx);
        this.unselectRow(idx, true, true);
      }
      this.dontSyncUi = false;
      this.syncSelectedUI();
      this.element.triggerHandler('selected', [this._selectedRows, 'deselectall']);
    },


    /**
    * Check if node index is exists in selected nodes
    * @private
    * @param {object} node The node to compare.
    * @returns {boolean} If its selected or not.
    */
    isNodeSelected: function isNodeSelected(node) {
      // As of 4.3.3, return the rows that have _selected = true
      return node ? node._selected === true : false;
    },


    /**
     * Select a row node on the UI
     * @param {object} elem The row node to select
     * @param {number} index The row index to select
     * @param {object} data The object attached to the row
     * @param {boolean} force Dont check if already selected
     * @returns {void}
     */
    selectNode: function selectNode(elem, index, data, force) {
      var checkbox = null;
      var self = this;

      // do not add if already exists in selected
      if ((!data || self.isNodeSelected(data)) && !force) {
        return;
      }
      checkbox = self.cellNode(elem, self.columnIdxById('selectionCheckbox'));
      elem.addClass('is-selected' + (self.settings.selectable === 'mixed' ? ' hide-selected-color' : '')).attr('aria-selected', 'true').find('td').attr('aria-selected', 'true');

      if (checkbox.length > 0) {
        checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox').addClass('is-checked').attr('aria-checked', 'true');
      }

      if (data) {
        data._selected = true;
      }
    },


    /**
     * Toggle selection on a single row
     * @param {number} idx The row index to select
     * @param {boolean} nosync Do sync the header
     * @param {boolean} noTrigger Do not trigger events.
     * @returns {void}
     */
    selectRow: function selectRow(idx, nosync, noTrigger) {
      var rowNode = null;
      var dataRowIndex = void 0;
      var self = this;
      var s = this.settings;

      if (idx === undefined || idx === -1 || !s.selectable) {
        return;
      }

      rowNode = this.actualRowNode(idx);
      dataRowIndex = this.dataRowIndex(rowNode);

      if (isNaN(dataRowIndex)) {
        dataRowIndex = idx;
      }

      if (!rowNode || !rowNode.length && s.source) {
        return;
      }

      if (s.selectable === 'single' && this._selectedRows.length > 0) {
        this.unselectRow(this._selectedRows[0].idx, true, true);
      }

      if (!rowNode.hasClass('is-selected')) {
        var rowData = void 0;

        if (s.treeGrid) {
          if (rowNode.is('.datagrid-tree-parent') && s.selectable === 'multiple') {
            // Select node and node-children
            rowNode.add(rowNode.nextUntil('[aria-level="1"]')).each(function (i) {
              var elem = $(this);
              var index = elem.attr('aria-rowindex') - 1;
              var data = s.treeDepth[index].node;

              // Allow select node if selectChildren is true or only first node
              // if selectChildren is false
              if (s.selectChildren || !s.selectChildren && i === 0) {
                self.selectNode(elem, index, data);
              }
            });
          } else if (s.selectable === 'siblings') {
            this.unSelectAllRows();

            // Select node and node-siblings
            var level = rowNode.attr('aria-level');
            var nexts = rowNode.nextUntil('[aria-level!="' + level + '"]');
            var prevs = rowNode.prevUntil('[aria-level!="' + level + '"]');

            if (level === '1') {
              nexts = rowNode.parent().find('[aria-level="1"]');
              prevs = null;
            }

            rowNode.add(nexts).add(prevs).each(function (i) {
              var elem = $(this);
              var index = elem.attr('aria-rowindex') - 1;
              var data = s.treeDepth[index].node;

              // Allow select node if selectChildren is true or only first node
              // if selectChildren is false
              if (s.selectChildren || !s.selectChildren && i === 0) {
                self.selectNode(elem, index, data);
              }
            });
          } else {
            // Default to Single element selection
            rowData = s.treeDepth[self.pager && s.source ? rowNode.index() : idx].node;
            self.selectNode(rowNode, idx, rowData);
          }
          self.setNodeStatus(rowNode);
        } else {
          rowData = s.dataset[dataRowIndex];
          if (s.groupable) {
            var gData = self.groupArray[idx];
            rowData = s.dataset[gData.group].values[gData.node];
            var actualIdx = self.actualPagingRowIndex(idx);
            this._selectedRows.push({
              idx: actualIdx,
              data: rowData,
              elem: self.dataRowNode(actualIdx),
              group: s.dataset[gData.group]
            });
          }
          self.selectNode(rowNode, dataRowIndex, rowData);
          self.lastSelectedRow = idx; // Rememeber index to use shift key
        }

        // Append data to selectedRows
        if (!s.groupable) {
          var _actualIdx = self.actualPagingRowIndex(idx);

          this._selectedRows.push({
            idx: _actualIdx,
            data: rowData,
            elem: self.visualRowNode(_actualIdx),
            page: this.pager ? this.pager.activePage : 1,
            pagingIdx: idx,
            pagesize: this.settings.pagesize
          });
        }
      }

      if (!nosync) {
        self.syncSelectedUI();
      }

      if (!noTrigger) {
        this.element.triggerHandler('selected', [this._selectedRows, 'select']);
      }
    },


    /**
    * Select rows between indexes
    * @private
    * @param  {array} indexes The ranges to select.
    * @returns {void}
    */
    selectRowsBetweenIndexes: function selectRowsBetweenIndexes(indexes) {
      indexes.sort(function (a, b) {
        return a - b;
      });
      for (var i = indexes[0]; i <= indexes[1]; i++) {
        this.selectRow(i);
      }

      this.displayCounts();
    },


    /**
    * Set the checkbox on the header based on selections.
    * @private
    * @param  {array} rows The rows to select.
    * @returns {void}
    */
    syncHeaderCheckbox: function syncHeaderCheckbox(rows) {
      if (!this.headerRow) {
        return;
      }

      var headerCheckbox = this.headerRow.find('.datagrid-checkbox');
      var rowsLength = rows.length;
      var selectedRowsLength = this._selectedRows.length;
      var status = headerCheckbox.data('selected');

      // Do not run if checkbox in same state
      if (selectedRowsLength !== rowsLength && selectedRowsLength > 0 && status === 'partial' || selectedRowsLength === rowsLength && status === 'all' && selectedRowsLength !== 0 || selectedRowsLength === 0 && status === 'none') {
        return;
      }

      // Sync the header checkbox
      if (selectedRowsLength > 0) {
        headerCheckbox.data('selected', 'partial').addClass('is-checked is-partial');
      }

      if (selectedRowsLength === rowsLength) {
        headerCheckbox.data('selected', 'all').addClass('is-checked').removeClass('is-partial');
      }

      if (selectedRowsLength === 0) {
        headerCheckbox.data('selected', 'none').removeClass('is-checked is-partial');
      }
    },


    /**
     * Mark selected rows on the page as selected
     * @private
     * @returns {void}
     */
    syncSelectedRows: function syncSelectedRows() {
      var idx = null;

      for (var i = 0; i < this._selectedRows.length; i++) {
        if (this._selectedRows[i].page === this.pager.activePage) {
          idx = this._selectedRows[i].idx;
          this.selectNode(this.visualRowNode(idx), idx, this.settings.dataset[idx], true);
        }
        // Check for rows that changed page
        idx = this._selectedRows[i].pagingIdx;
        if (this._selectedRows[i].pagesize !== this.settings.pagesize && this.settings.dataset[idx]) {
          this.selectNode(this.visualRowNode(idx), idx, this.settings.dataset[idx], true);
          this._selectedRows[i].pagesize = this.settings.pagesize;
          this._selectedRows[i].idx = idx;
          this._selectedRows[i].page = this.pager.activePage;
        }

        if (this._selectedRows[i].pagesize !== this.settings.pagesize && !this.settings.dataset[idx]) {
          this._selectedRows[i].idx = idx % this.settings.pagesize;
          this._selectedRows[i].page = Math.round(idx / this.settings.pagesize) + 1;
          this._selectedRows[i].pagesize = this.settings.pagesize;
        }
      }
    },


    /**
     * Set ui elements based on selected rows
     * @private
     * @returns {void}
     */
    syncSelectedUI: function syncSelectedUI() {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var rows = dataset;

      if (this.settings.groupable) {
        rows = [];
        for (var i = 0, l = dataset.length; i < l; i++) {
          if (dataset[i].values) {
            for (var i2 = 0, l2 = dataset[i].values.length; i2 < l2; i2++) {
              rows.push(i2);
            }
          }
        }
      }

      if (this.filterRowRendered) {
        rows = [];
        for (var _i6 = 0, _l = dataset.length; _i6 < _l; _i6++) {
          if (!dataset[_i6].isFiltered) {
            rows.push(_i6);
          }
        }
      }

      this.syncHeaderCheckbox(rows);

      // Open or Close the Contextual Toolbar.
      if (this.contextualToolbar.length !== 1 || this.dontSyncUi) {
        return;
      }

      if (this._selectedRows.length === 0) {
        this.contextualToolbar.animateClosed();
      }

      if (this._selectedRows.length > 0 && this.contextualToolbar.height() === 0) {
        this.contextualToolbar.css('display', 'block').one('animateopencomplete.datagrid', function () {
          $(this).triggerHandler('recalculate-buttons');
        }).animateOpen();
      }
    },


    /**
     * Activate a row when in mixed selection mode
     * @param  {number} idx The index.
     */
    activateRow: function activateRow(idx) {
      if (this.activatedRow()[0].row !== idx) {
        this.toggleRowActivation(idx);
      }
    },


    /**
    * Deactivate the currently activated row.
    */
    deactivateRow: function deactivateRow() {
      var idx = this.activatedRow()[0].row;
      if (idx >= 0) {
        this.toggleRowActivation(idx);
      }
    },


    /**
    * Gets the currently activated row.
    * @returns {object} Information about the activated row.
    */
    activatedRow: function activatedRow() {
      var r = [{ row: -1, item: undefined, elem: undefined }];

      if (this.tableBody) {
        var s = this.settings;
        var dataset = s.treeGrid ? s.treeDepth : s.dataset;
        var activatedRow = this.tableBody.find('tr.is-rowactivated');

        if (activatedRow.length) {
          var dataRowIndex = this.dataRowIndex(activatedRow);
          var rowIndex = s.indeterminate ? dataRowIndex : this.actualRowIndex(activatedRow);
          r = [{ row: rowIndex, item: dataset[rowIndex], elem: activatedRow }];
        } else {
          r = null;
          // Activated row may be filtered or on another page, so check all until find it
          for (var i = 0; i < dataset.length; i++) {
            if (dataset[i]._rowactivated) {
              r = [{ row: i, item: dataset[i], elem: undefined }];
              break;
            }
          }

          if (r === null) {
            r = [{ row: -1, item: undefined, elem: activatedRow }];
          }
        }
      }
      return r;
    },


    /**
    * Toggle the current activation state from on to off.
    * @param  {number} idx The row to toggle
    * @returns {void}
    */
    toggleRowActivation: function toggleRowActivation(idx) {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var row = typeof idx === 'number' ? this.tableBody.find('tr[aria-rowindex="' + (idx + 1) + '"]') : idx;
      var rowIndex = typeof idx === 'number' ? idx : s.treeGrid || s.groupable ? this.actualRowIndex(row) : this.dataRowIndex(row);
      var item = dataset[rowIndex];
      var isActivated = item ? item._rowactivated : false;

      if (typeof idx === 'number' && this.pager && s.source && s.indeterminate) {
        var rowIdx = idx + (this.pager.activePage - 1) * s.pagesize;
        row = this.tableBody.find('tr[aria-rowindex="' + (rowIdx + 1) + '"]');
        rowIndex = idx;
      }

      /**
      * Fires after a row is deactivated in mixed selection mode.
      * @event rowdeactivated
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {array} args.row An array of selected rows.
      * @property {object} args.item The current sort column.
      */
      if (isActivated) {
        if (!s.disableRowDeactivation) {
          row.removeClass('is-rowactivated');
          delete dataset[rowIndex]._rowactivated;
          this.element.triggerHandler('rowdeactivated', [{ row: rowIndex, item: dataset[rowIndex] }]);
        }
      } else {
        // Deselect old row
        var oldActivated = this.tableBody.find('tr.is-rowactivated');
        if (oldActivated.length) {
          oldActivated.removeClass('is-rowactivated');
          var oldIdx = s.treeGrid || s.groupable ? this.actualRowIndex(oldActivated) : this.dataRowIndex(oldActivated);
          if (dataset[oldIdx]) {
            // May have changed page
            delete dataset[oldIdx]._rowactivated;
          }
          this.element.triggerHandler('rowdeactivated', [{ row: oldIdx, item: dataset[oldIdx] }]);
        } else {
          // Old active row may be filtered or on another page, so check all until find it
          for (var i = 0; i < dataset.length; i++) {
            if (dataset[i]._rowactivated) {
              delete dataset[i]._rowactivated;
              this.element.triggerHandler('rowdeactivated', [{ row: i, item: dataset[i] }]);
              break;
            }
          }
        }

        /**
        * Fires after a row is activated in mixed selection mode.
        * @event rowactivated
        * @memberof Datagrid
        * @property {object} event The jquery event object
        * @property {object} args Additional arguments
        * @property {array} args.row An array of selected rows.
        * @property {object} args.item The current sort column.
        */
        row.addClass('is-rowactivated');
        if (dataset[rowIndex]) {
          // May have changed page
          dataset[rowIndex]._rowactivated = true;
          this.element.triggerHandler('rowactivated', [{ row: rowIndex, item: dataset[rowIndex] }]);
        }
      }
    },


    /**
    * Toggle the current selection state from on to off.
    * @param  {number} idx The row to select/unselect
    * @returns {void}
    */
    toggleRowSelection: function toggleRowSelection(idx) {
      var row = typeof idx === 'number' ? this.tableBody.find('tr[aria-rowindex="' + (idx + 1) + '"]') : idx;
      var isSingle = this.settings.selectable === 'single';
      var rowIndex = typeof idx === 'number' ? idx : this.settings.treeGrid || this.settings.groupable ? this.actualRowIndex(row) : this.actualRowIndex(row);

      if (this.settings.selectable === false) {
        return;
      }

      if (this.editor && row.hasClass('is-selected')) {
        return;
      }

      if (isSingle && row.hasClass('is-selected')) {
        this.unselectRow(rowIndex);
        this.displayCounts();
        return this._selectedRows; // eslint-disable-line
      }

      if (row.hasClass('is-selected')) {
        this.unselectRow(rowIndex);
      } else {
        this.selectRow(rowIndex);
      }

      this.displayCounts();

      return this._selectedRows; // eslint-disable-line
    },


    /**
    * De-select a selected row.
    * @param  {number} idx The row index
    * @param  {boolean} nosync Do not sync the header
    * @param  {boolean} noTrigger Do not trgger any events
    */
    unselectRow: function unselectRow(idx, nosync, noTrigger) {
      var self = this;
      var s = self.settings;
      var rowNode = self.actualRowNode(idx);
      var checkbox = null;

      if (!rowNode || idx === undefined) {
        return;
      }

      // Unselect it
      var unselectNode = function unselectNode(elem, index) {
        var removeSelected = function removeSelected(node) {
          delete node._selected;
          self.selectedRowCount--;

          for (var i = 0; i < self._selectedRows.length; i++) {
            if (self._selectedRows[i].idx === index) {
              self._selectedRows.splice(i, 1);
              break;
            }
          }
        };
        checkbox = self.cellNode(elem, self.columnIdxById('selectionCheckbox'));
        elem.removeClass('is-selected hide-selected-color').removeAttr('aria-selected').find('td').removeAttr('aria-selected');
        checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox').removeClass('is-checked no-animate').attr('aria-checked', 'false');

        if (s.treeGrid) {
          for (var i = 0; i < s.treeDepth.length; i++) {
            if (self.isNodeSelected(s.treeDepth[i].node)) {
              if (typeof index !== 'undefined') {
                if (index === s.treeDepth[i].idx - 1) {
                  removeSelected(s.treeDepth[i].node);
                }
              } else {
                removeSelected(s.treeDepth[i].node);
              }
            }
          }
        } else {
          var selIdx = elem.length ? self.dataRowIndex(elem) : index;
          var rowData = void 0;

          if (selIdx !== undefined && selIdx > -1) {
            rowData = self.settings.dataset[selIdx];
          }
          if (s.groupable) {
            var gData = self.groupArray[idx];
            rowData = s.dataset[gData.group].values[gData.node];
          }
          if (rowData !== undefined) {
            removeSelected(rowData);
          }
        }
      };

      if (s.treeGrid) {
        if (rowNode.is('.datagrid-tree-parent') && s.selectable === 'multiple') {
          // Select node and node-children
          rowNode.add(rowNode.nextUntil('[aria-level="1"]')).each(function (i) {
            var elem = $(this);
            var index = elem.attr('aria-rowindex') - 1;

            // Allow unselect node if selectChildren is true or only first node
            if (s.selectChildren || !s.selectChildren && i === 0) {
              unselectNode(elem, index);
            }
          });
        } else if (s.selectable === 'siblings') {
          rowNode.parent().find('.is-selected').each(function (i) {
            var elem = $(this);
            var index = elem.attr('aria-rowindex') - 1;

            // Allow unselect node if selectChildren is true or only first node
            if (s.selectChildren || !s.selectChildren && i === 0) {
              unselectNode(elem, index);
            }
          });
        } else {
          // Single element unselection
          unselectNode(rowNode, idx);
        }
        self.setNodeStatus(rowNode);
      } else {
        unselectNode(rowNode, idx);
      }

      if (!nosync) {
        self.syncSelectedUI();
      }

      if (!noTrigger) {
        self.element.triggerHandler('selected', [self._selectedRows, 'deselect']);
      }
    },


    /**
     * Set the current status on the row status column
     * @param {HTMLElement} node The node to set the status on
     */
    setNodeStatus: function setNodeStatus(node) {
      var self = this;
      var isMultiselect = self.settings.selectable === 'multiple';
      var s = self.settings;
      var checkbox = self.cellNode(node, self.columnIdxById('selectionCheckbox'));
      var nodes = void 0;

      // Not multiselect
      if (!isMultiselect) {
        checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox').removeClass('is-checked is-partial').attr('aria-checked', 'false');

        if (node.is('.is-selected')) {
          checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox').addClass('is-checked').attr('aria-checked', 'true');
        }
        return;
      }

      var setStatus = function setStatus(nodeElems, isFirstSkipped) {
        nodeElems.each(function () {
          var nodeToUse = $(this);
          var checkboxToUse = self.cellNode(nodeToUse, self.columnIdxById('selectionCheckbox'));
          var status = self.getSelectedStatus(nodeToUse, isFirstSkipped);

          checkboxToUse.find('.datagrid-cell-wrapper .datagrid-checkbox').removeClass('is-checked is-partial').attr('aria-checked', 'false');

          if (status === 'mixed') {
            checkboxToUse.find('.datagrid-cell-wrapper .datagrid-checkbox').addClass('is-checked is-partial').attr('aria-checked', 'mixed');
          } else if (status) {
            checkboxToUse.find('.datagrid-cell-wrapper .datagrid-checkbox').addClass('is-checked').attr('aria-checked', 'true');
          }
        });
      };

      // Multiselect
      nodes = node.add(node.nextUntil('[aria-level="1"]')).filter('.datagrid-tree-parent');

      // Prevent selecting of parent element when selectChildren is false
      if (s.selectChildren) {
        setStatus(nodes);
      }

      nodes = node;
      if (+node.attr('aria-level') > 1) {
        nodes = nodes.add(node.prevUntil('[aria-level="1"]')).add(node.prevAll('[aria-level="1"]:first'));
      }
      nodes = nodes.filter('.datagrid-tree-parent');

      // Prevent selecting of parent element when selectChildren is false
      if (s.selectChildren) {
        setStatus(nodes);
      }
    },


    /**
    * Get current selection status.
    * @private
    * @param  {object} node The dom element.
    * @returns {object} The status
    */
    getSelectedStatus: function getSelectedStatus(node) {
      var status = false;
      var total = 0;
      var selected = 0;
      var unselected = 0;

      node.add(node.nextUntil('[aria-level="1"]')).each(function () {
        total++;
        if ($(this).is('.is-selected')) {
          selected++;
        } else {
          unselected++;
        }
      });

      status = total === selected ? true : total === unselected ? false : 'mixed';
      return status;
    },


    /**
     * Get the currently selected rows.
     * @returns {array} An array containing the selected rows
     */
    selectedRows: function selectedRows() {
      return this._selectedRows;
    },


    /**
     * Set the selected rows by passing the row index or an array of row indexes.
     * @param  {number/array} row A row index or array of row indexes to select.
     * @param  {boolean} nosync Dont sync the header.
     * @param  {boolean} selectAll Internally used.
     * @returns {void}
     */
    selectRows: function selectRows(row, nosync, selectAll) {
      var idx = -1;
      var s = this.settings;
      var isSingle = s.selectable === 'single';
      var isMultiple = s.selectable === 'multiple' || s.selectable === 'mixed';
      var isSiblings = s.selectable === 'siblings';
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var gIdx = idx;

      if (typeof row === 'number') {
        row = [row];
      }

      if (!row || row.length === 0) {
        return this._selectedRows;
      }

      if (isSingle) {
        // Unselect
        if (this._selectedRows.length) {
          this.unselectRow(this._selectedRows[0].idx, true, true);
        }

        // Select - may be passed array or int
        idx = Object.prototype.toString.call(row) === '[object Array]' ? row[0] : row.index();
        this.selectRow(idx, true, true);
      }

      if (isMultiple || isSiblings) {
        if (Object.prototype.toString.call(row) === '[object Array]') {
          for (var i = 0; i < row.length; i++) {
            if (s.groupable) {
              for (var k = 0; k < dataset[i].values.length; k++) {
                gIdx++;
                this.selectRow(gIdx, true, true);
              }
            } else {
              this.selectRow(row[i], true, true);
            }
          }

          if (row.length === 0) {
            for (var j = 0, l = dataset.length; j < l; j++) {
              this.unselectRow(j, true, true);
            }
          }
        } else {
          this.selectRow(row.index(), true, true);
        }
      }

      this.displayCounts();

      if (!nosync) {
        this.syncSelectedUI();
      }
      if (!selectAll) {
        this.element.triggerHandler('selected', [this._selectedRows, 'select']);
      }

      return this._selectedRows;
    },


    /**
     * Returns an array of row numbers for the rows containing the value for the specified field.
     * @param  {string} fieldName The field name to search.
     * @param  {any} value The value to use in search.
     * @returns {array} an array of row numbers.
     */
    findRowsByValue: function findRowsByValue(fieldName, value) {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var idx = -1;
      var matchedRows = [];
      for (var i = 0, data; i < dataset.length; i++) {
        if (s.groupable) {
          for (var k = 0; k < dataset[i].values.length; k++) {
            idx++;
            data = dataset[i].values[k];
            if (data[fieldName] === value) {
              matchedRows.push(idx);
            }
          }
        } else {
          data = s.treeGrid ? dataset[i].node : dataset[i];
          if (data[fieldName] === value) {
            matchedRows.push(i);
          }
        }
      }
      return matchedRows;
    },


    /**
    * Sets the row status
    * @param {object} idx The index of the row to add status to.
    * @param {string} status The status type 'error', 'info' ect
    * @param {object} tooltip The information for the message/tooltip
    */
    rowStatus: function rowStatus(idx, status, tooltip) {
      if (!status) {
        delete this.settings.dataset[idx].rowStatus;
        this.updateRow(idx);
        return;
      }

      if (!this.settings.dataset[idx]) {
        return;
      }

      this.settings.dataset[idx].rowStatus = {};
      var rowStatus = this.settings.dataset[idx].rowStatus;

      rowStatus.icon = status;
      status = status.charAt(0).toUpperCase() + status.slice(1);
      status = status.replace('-progress', 'Progress');
      rowStatus.text = Locale.translate(status);

      tooltip = tooltip ? tooltip.charAt(0).toUpperCase() + tooltip.slice(1) : rowStatus.text;
      rowStatus.tooltip = tooltip;

      this.updateRow(idx);
      this.setupTooltips(true);
    },


    /**
    * Get the column object by id
    * @param  {number} id The column id to find
    * @returns {object} The corresponding column.
    */
    columnById: function columnById(id) {
      return $.grep(this.settings.columns, function (e) {
        return e.id === id;
      });
    },


    /**
    * Get the column index from the col's id
    * @param  {number} id The column id to find
    * @returns {object} The corresponding columns current position.
    */
    columnIdxById: function columnIdxById(id) {
      var cols = this.settings.columns;
      var idx = -1;

      for (var i = 0; i < cols.length; i++) {
        if (cols[i].id === id) {
          idx = i;
          break;
        }
      }
      return idx;
    },


    /**
    * Handle all keyboard behavior
    * @private
    * @returns {void}
    */
    handleKeys: function handleKeys() {
      var self = this;
      var isMultiple = self.settings.selectable === 'multiple';
      var checkbox = $('th .datagrid-checkbox', self.headerRow);

      // Handle header navigation
      self.headerTable.on('keydown.datagrid', 'th', function (e) {
        var key = e.which || e.keyCode || e.charCode || 0;
        var th = $(this);
        var index = th.siblings(':visible').addBack().index(th);
        var last = self.visibleColumns().length - 1;
        var triggerEl = void 0;
        var move = void 0;

        if ($(e.target).closest('.popupmenu').length > 0) {
          return;
        }

        // Enter or Space
        if (key === 13 || key === 32) {
          triggerEl = isMultiple && index === 0 ? $('.datagrid-checkbox', th) : th;
          triggerEl.trigger('click.datagrid').focus();

          if (key === 32) {
            // Prevent scrolling with space
            e.preventDefault();
          }
        }

        // Press Home, End, Left and Right arrow to move to first, last, previous or next
        if ([35, 36, 37, 39].indexOf(key) !== -1) {
          move = index;

          // Home, End or Ctrl/Meta + Left/Right arrow to move to the first or last
          if (/35|36/i.test(key) || (e.ctrlKey || e.metaKey) && /37|39/i.test(key)) {
            if (Locale.isRTL()) {
              move = key === 36 || (e.ctrlKey || e.metaKey) && key === 37 ? last : 0;
            } else {
              move = key === 35 || (e.ctrlKey || e.metaKey) && key === 39 ? last : 0;
            }
          } else if (Locale.isRTL()) {
            // Left and Right arrow
            move = key === 39 ? index > 0 ? index - 1 : index : index < last ? index + 1 : last;
          } else {
            move = key === 37 ? index > 0 ? index - 1 : index : index < last ? index + 1 : last;
          }
          // Update active cell
          self.activeCell.cell = move;

          // Making move
          th.removeAttr('tabindex').removeClass('is-active');
          $('th:not(.is-hidden)', this.header).eq(move).attr('tabindex', '0').addClass('is-active').focus();
          e.preventDefault();
        }

        // Down arrow
        if (key === 40) {
          th.removeAttr('tabindex');
          self.activeCell.node = self.cellNode(0, self.settings.groupable ? 0 : self.activeCell.cell, true).attr('tabindex', '0').focus();
          e.preventDefault();
        }
      });

      // Handle Editing / Keyboard
      self.table.on('keydown.datagrid', 'td, input', function (e) {
        //eslint-disable-line
        var key = e.which || e.keyCode || e.charCode || 0;
        var handled = false;

        // F2 - toggles actionableMode "true" and "false"
        if (key === 113) {
          self.settings.actionableMode = !self.settings.actionableMode;
          handled = true;
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return handled;
        }
      });

      // Press PageUp or PageDown to open the previous or next page and set focus to the first row.
      // Press Alt+Up or Alt+Down to set focus to the first or last row on the current page.
      // Press Alt+PageUp or Alt+PageDown to open the first or last page and
      // set focus to the first row.

      // Handle rest of the keyboard
      self.table.on('keydown.datagrid', 'td', function (e) {
        var key = e.which || e.keyCode || e.charCode || 0;
        var handled = false;
        var isRTL = Locale.isRTL();
        var node = self.activeCell.node;
        var rowNode = $(this).parent();
        var prevRow = rowNode.prevAll(':not(.is-hidden, .datagrid-expandable-row)').first();
        var nextRow = rowNode.nextAll(':not(.is-hidden, .datagrid-expandable-row)').first();
        var row = self.activeCell.row;
        var cell = self.activeCell.cell;
        var col = self.columnSettings(cell);
        var isGroupRow = rowNode.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer');
        var item = self.settings.dataset[self.dataRowIndex(node)];
        var visibleRows = self.tableBody.find('tr:visible');
        var getVisibleRows = function getVisibleRows(index) {
          var visibleRow = visibleRows.filter('[aria-rowindex="' + (index + 1) + '"]');
          if (visibleRow.is('.datagrid-rowgroup-header')) {
            return visibleRow.index();
          }
          return self.dataRowIndex(visibleRow);
        };

        var getGroupCell = function getGroupCell(currentCell, lastCell, prev) {
          var n = self.activeCell.groupNode || node;
          var nextCell = currentCell + (prev ? -1 : +1);

          if (nextCell > lastCell) {
            nextCell = prev ? n.prevAll(':visible').last() : n.nextAll(':visible').last();
          } else {
            nextCell = prev ? n.prevAll(':visible').first() : n.nextAll(':visible').first();
          }
          return nextCell;
        };

        var getNextVisibleCell = function getNextVisibleCell(currentCell, lastCell, prev) {
          if (isGroupRow) {
            return getGroupCell(currentCell, lastCell, prev);
          }
          var nextCell = currentCell + (prev ? -1 : +1);
          if (nextCell > lastCell) {
            return lastCell;
          }
          while (self.settings.columns[nextCell] && self.settings.columns[nextCell].hidden) {
            nextCell = prev ? nextCell - 1 : nextCell + 1;
          }
          return nextCell;
        };

        var isSelectionCheckbox = !!$('.datagrid-selection-checkbox', node).length;
        var lastRow = visibleRows.last();
        var lastCell = self.settings.columns.length - 1;

        // Tab, Left and Right arrow keys.
        if ([9, 37, 39].indexOf(key) !== -1) {
          if (key === 9 && self.settings.onKeyDown) {
            var ret = self.settings.onKeyDown(e);
            if (ret === false) {
              e.stopPropagation();
              e.preventDefault();
              return;
            }
          }

          if (key === 9 && !self.settings.actionableMode) {
            return;
          }

          if (key !== 9 && e.altKey) {
            // [Alt + Left/Right arrow] to move to the first or last cell on the current row.
            cell = key === 37 && !isRTL || key === 39 && isRTL ? 0 : lastCell;
            self.setActiveCell(row, cell);
          } else if (!self.quickEditMode || key === 9) {
            if (!isRTL && (key === 37 || key === 9 && e.shiftKey) || // eslint-disable-line
            isRTL && (key === 39 || key === 9)) {
              // eslint-disable-line
              cell = getNextVisibleCell(cell, lastCell, true);
            } else {
              cell = getNextVisibleCell(cell, lastCell);
            }

            if (cell instanceof jQuery) {
              self.setActiveCell(cell);
            } else {
              self.setActiveCell(row, cell);
            }

            if (key === 9 && self.settings.actionableMode) {
              self.makeCellEditable(self.activeCell.rowIndex, cell, e);
              if (self.containsTextField(node) && self.containsTriggerField(node)) {
                self.quickEditMode = true;
              }
            }
            self.quickEditMode = false;
            handled = true;
          }
        }

        // Up arrow key
        if (key === 38 && !self.quickEditMode) {
          // Press [Control + Up] arrow to move to the first row on the first page.
          if (e.altKey || e.metaKey) {
            self.setActiveCell(getVisibleRows(0), cell);
            handled = true;
          } else {
            // Up arrow key to navigate by row.
            if (row === 0 && !prevRow.is('.datagrid-rowgroup-header')) {
              node.removeAttr('tabindex');
              self.headerRow.find('th').eq(cell).attr('tabindex', '0').focus();
              return;
            }
            self.setActiveCell(prevRow, cell);
            handled = true;
          }
        }

        // Down arrow key
        if (key === 40 && !self.quickEditMode) {
          // Press [Control + Down] arrow to move to the last row on the last page.
          if (e.altKey || e.metaKey) {
            self.setActiveCell(lastRow, cell);
            handled = true;
          } else {
            // Down arrow key to navigate by row.
            self.setActiveCell(nextRow, cell);
            handled = true;
          }
        }

        // Press Control+Spacebar to announce the current row when using a screen reader.
        if (key === 32 && e.ctrlKey && node) {
          var string = '';
          row = node.closest('tr');

          row.children().each(function () {
            var cellNode = $(this);
            // Read Header
            // string += $('#' + cell.attr('aria-describedby')).text() + ' ' + cell.text() + ' ';
            string += cellNode.text() + ' ';
          });

          $('body').toast({ title: '', audibleOnly: true, message: string });
          handled = true;
        }

        // Press Home or End to move to the first or last cell on the current row.
        if (key === 36) {
          self.setActiveCell(row, 0);
          handled = true;
        }

        // Home to Move to the end of the current row
        if (key === 35) {
          self.setActiveCell(row, lastCell);
          handled = true;
        }

        // End to Move to last row of current cell
        if (key === 34) {
          self.setActiveCell(lastRow, cell);
          handled = true;
        }

        // End to Move to first row of current cell
        if (key === 33) {
          self.setActiveCell(getVisibleRows(0), cell);
          handled = true;
        }

        // For mode 'Selectable':
        // Press Space to toggle row selection, or click to activate using a mouse.
        if (key === 32 && (!self.settings.editable || isSelectionCheckbox)) {
          row = node.closest('tr');

          if ($(e.target).closest('.datagrid-row-detail').length === 1) {
            return;
          }
          e.preventDefault();

          // Toggle datagrid-expand with Space press
          var btn = $(e.target).find('.datagrid-expand-btn, .datagrid-drilldown');
          if (btn && btn.length) {
            btn.trigger('click.datagrid');
            e.preventDefault();
            return;
          }

          if (isMultiple && e.shiftKey) {
            self.selectRowsBetweenIndexes([self.lastSelectedRow, row.index()]);
          } else {
            self.toggleRowSelection(row);
          }
        }

        // For Editable mode - press Enter or Space to edit or toggle a cell,
        // or click to activate using a mouse.
        if (self.settings.editable && key === 32) {
          if (!self.editor) {
            self.makeCellEditable(self.activeCell.rowIndex, cell, e);
          }
        }

        // if column have click function to fire [ie. action button]
        if (key === 13 && col.click && typeof col.click === 'function') {
          if (!node.hasClass('is-cell-readonly')) {
            col.click(e, [{ row: row, cell: cell, item: item, originalEvent: e }]);
          }
        }

        if (self.settings.editable && key === 13) {
          // Allow shift to add a new line
          if ($(e.target).is('textarea') && e.shiftKey) {
            return;
          }

          if (self.editor) {
            self.quickEditMode = false;
            self.commitCellEdit(self.editor.input);
            self.setNextActiveCell(e);
          } else {
            self.makeCellEditable(self.activeCell.rowIndex, cell, e);
            if (self.containsTextField(node) && self.containsTriggerField(node)) {
              self.quickEditMode = true;
            }
          }
          handled = true;
        }

        // Any printable character - well make it editable
        if ([9, 13, 32, 35, 36, 37, 38, 39, 40, 113].indexOf(key) === -1 && !e.altKey && !e.shiftKey && !e.ctrlKey && !e.metaKey && self.settings.editable) {
          if (!self.editor) {
            self.makeCellEditable(self.activeCell.rowIndex, cell, e);
          }
        }

        // If multiSelect is enabled, press Control+A to toggle select all rows
        if (isMultiple && !self.editor && (e.ctrlKey || e.metaKey) && key === 65) {
          checkbox.addClass('is-checked').removeClass('is-partial').attr('aria-checked', 'true');
          self.selectAllRows();
          handled = true;
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return false; // eslint-disable-line
        }
      });
    },


    /**
     * Does the column editor have a text field.
     * @private
     * @param  {object} container The dom element
     * @returns {boolean} If it does or not
     */
    containsTextField: function containsTextField(container) {
      var noTextTypes = ['image', 'button', 'submit', 'reset', 'checkbox', 'radio'];
      var selector = 'textarea, input';
      var l = noTextTypes.length;
      var i = void 0;

      selector += l ? ':not(' : '';
      for (i = 0; i < l; i++) {
        selector += '[type=' + noTextTypes[i] + '],';
      }
      selector = l ? selector.slice(0, -1) + ')' : '';

      return !!$(selector, container).length;
    },


    /**
     * Does the column editor have a picker/trigger field.
     * @private
     * @param  {object} container The dom element
     * @returns {boolean} If it does or not
     */
    containsTriggerField: function containsTriggerField(container) {
      var selector = '.dropdown, .datepicker';
      return !$(selector, container).length;
    },


    /**
     * Is a specific row/cell editable?
     * @param  {number} row The row index
     * @param  {number} cell The cell index
     * @returns {boolean} returns true if the cell is editable
     */
    isCellEditable: function isCellEditable(row, cell) {
      if (!this.settings.editable) {
        return false;
      }

      var col = this.columnSettings(cell);
      if (col.readonly) {
        return false;
      }

      // Check if cell is editable via hook function
      var cellNode = this.activeCell.node.find('.datagrid-cell-wrapper');
      var cellValue = cellNode.text() ? cellNode.text() : this.fieldValue(this.settings.dataset[row], col.field);

      if (col.isEditable) {
        var canEdit = col.isEditable(row, cell, cellValue, col, this.settings.dataset[row]);

        if (!canEdit) {
          return false;
        }
      }

      if (!col.editor) {
        return false;
      }

      return true;
    },


    /**
     * Invoked in three cases
     * 1) a row click
     * 2) keyboard and enter
     * 3) In actionable mode and tabbing
     * @private
     * @param  {number} row The row index
     * @param  {number} cell The cell index
     * @param  {object} event The event information.
     * @returns {boolean} returns true if the cell is editable
     */
    makeCellEditable: function makeCellEditable(row, cell, event) {
      if (this.activeCell.node.closest('tr').hasClass('datagrid-summary-row')) {
        return;
      }

      // Already in edit mode
      var cellNode = this.activeCell.node.find('.datagrid-cell-wrapper');
      var cellParent = cellNode.parent('td');

      if (cellParent.hasClass('is-editing') || cellParent.hasClass('is-editing-inline')) {
        return false; // eslint-disable-line
      }

      // Commit Previous Edit
      if (this.editor && this.editor.input) {
        this.commitCellEdit(this.editor.input);
      }

      // Locate the Editor
      var col = this.columnSettings(cell);

      // Select the Rows if the cell is editable
      if (!col.editor) {
        if (event.keyCode === 32 && !$(event.currentTarget).find('.datagrid-selection-checkbox').length) {
          this.toggleRowSelection(this.activeCell.node.closest('tr'));
        }
        return false; // eslint-disable-line
      }

      var thisRow = this.actualRowNode(row);
      var idx = this.settings.treeGrid ? this.actualRowIndex(thisRow) : this.dataRowIndex(thisRow);
      var rowData = this.settings.treeGrid ? this.settings.treeDepth[idx].node : this.settings.dataset[idx];
      var cellWidth = cellParent.outerWidth();
      var isEditor = $('.is-editor', cellParent).length > 0;
      var isPlaceholder = $('.is-placeholder', cellNode).length > 0;
      var cellValue = cellNode.text() ? cellNode.text() : this.fieldValue(rowData, col.field);

      if (isEditor || isPlaceholder) {
        cellValue = this.fieldValue(rowData, col.field);
      }

      if (!this.isCellEditable(idx, cell)) {
        return false; // eslint-disable-line
      }

      // In Show Ediitor mode the editor is on form already
      if (!col.inlineEditor) {
        if (isEditor) {
          cellNode.css({ position: 'static', height: cellNode.outerHeight() });
        }
        // initialis Editor
        cellParent.addClass('is-editing').css({ 'max-width': cellWidth, 'min-width': cellWidth, width: cellWidth });

        cellNode.empty();
      } else {
        cellParent.addClass('is-editing-inline');
      }

      /**
      * Fires before a cell goes into edit mode. Giving you a chance to adjust column settings.
      * @event entereditmode
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.row An array of selected rows.
      * @property {number} args.cell An array of selected rows.
      * @property {object} args.item The current sort column.
      * @property {HTMLElement} args.target The cell html element that was entered.
      * @property {any} args.value The cell value.
      * @property {object} args.column The column object
      * @property {object} args.editor The editor object.
      */
      this.element.triggerHandler('beforeentereditmode', [{ row: idx, cell: cell, item: rowData, target: cellNode, value: cellValue, column: col, editor: this.editor }]);

      this.editor = new col.editor(idx, cell, cellValue, cellNode, col, event, this, rowData); // eslint-disable-line

      if (this.settings.onEditCell) {
        this.settings.onEditCell(this.editor);
      }

      if (this.editor.useValue) {
        cellValue = this.fieldValue(rowData, col.field);
      }
      this.editor.val(cellValue);
      this.editor.focus();

      /**
      * Fires after a cell goes into edit mode.
      * @event entereditmode
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.row An array of selected rows.
      * @property {number} args.cell An array of selected rows.
      * @property {object} args.item The current sort column.
      * @property {HTMLElement} args.target The cell html element that was entered.
      * @property {any} args.value The cell value.
      * @property {object} args.column The column object
      * @property {object} args.editor The editor object.
      */
      this.element.triggerHandler('entereditmode', [{ row: idx, cell: cell, item: rowData, target: cellNode, value: cellValue, column: col, editor: this.editor }]);

      return true; //eslint-disable-line
    },


    /**
     * Commit the cell thats currently in edit mode.
     * @private
     * @param  {number} input The input dom element.
     */
    commitCellEdit: function commitCellEdit(input) {
      if (!this.editor) {
        return;
      }

      var newValue = void 0;
      var cellNode = void 0;
      var isEditor = this.editor.name === 'editor';
      var isFileupload = this.editor.name === 'fileupload';
      var isUseActiveRow = !input.is('.timepicker, .datepicker, .lookup, .spinbox .colorpicker');

      // Editor.getValue
      newValue = this.editor.val();

      if (isEditor) {
        cellNode = this.editor.td;
      } else if (isFileupload) {
        if (this.editor.status === 'clear') {
          newValue = '';
        } else if (this.editor.status === 'init' || this.editor.status === 'cancel') {
          newValue = this.editor.originalValue;
        }
        // Fix: Not sure why, but `input.closest('td')` did not work
        cellNode = this.tableBody.find('#' + input.attr('id')).closest('td');
        newValue = xssUtils.escapeHTML(newValue);
      } else {
        cellNode = input.closest('td');
        newValue = xssUtils.escapeHTML(newValue);
      }

      // Format Cell again
      var isInline = cellNode.hasClass('is-editing-inline');
      cellNode.removeClass('is-editing is-editing-inline');

      // Editor.destroy
      this.editor.destroy();
      this.editor = null;

      var rowIndex = void 0;
      var dataRowIndex = void 0;
      if (this.settings.source !== null && isUseActiveRow) {
        rowIndex = this.activeCell.rowIndex;
        dataRowIndex = this.activeCell.dataRow;
      } else {
        rowIndex = this.actualRowIndex(cellNode.parent());
        dataRowIndex = this.dataRowIndex(cellNode.parent());
      }

      var cell = cellNode.index();
      var col = this.columnSettings(cell);
      var rowData = this.settings.treeGrid ? this.settings.treeDepth[dataRowIndex].node : this.settings.dataset[dataRowIndex];
      var oldValue = this.fieldValue(rowData, col.field);

      // Save the Cell Edit back to the data set
      this.updateCellNode(rowIndex, cell, newValue, false, isInline);
      var value = this.fieldValue(rowData, col.field);

      /**
      * Fires after a cell goes out of edit mode.
      * @event exiteditmode
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.row An array of selected rows.
      * @property {number} args.cell An array of selected rows.
      * @property {object} args.item The current sort column.
      * @property {HTMLElement} args.target The cell html element that was entered.
      * @property {any} args.value The cell value.
      * @property {any} args.oldValue The previous cell value.
      * @property {object} args.column The column object
      * @property {object} args.editor The editor object.
      */
      this.element.triggerHandler('exiteditmode', [{
        row: rowIndex,
        cell: cell,
        item: rowData,
        target: cellNode,
        value: value,
        oldValue: oldValue,
        column: col,
        editor: this.editor
      }]);
    },


    /**
     * Run validation for the column, for a particular cell.
     * @param  {number} row The row index
     * @param  {number} cell The cell index
     */
    validateCell: function validateCell(row, cell) {
      var _$,
          _this5 = this;

      var self = this;
      var column = this.columnSettings(cell);
      var validate = column.validate;
      var validationType = void 0;

      if (!validate) {
        return;
      }

      var dfd = void 0;
      var dfds = [];
      var rules = column.validate.split(' ');
      var validator = $.fn.validation;
      var cellValue = this.fieldValue(this.settings.dataset[row], column.field);
      var messages = [];
      var messageText = '';
      var i = void 0;

      function manageResult(result, displayMessage, ruleName, dfrd) {
        var rule = validator.rules[ruleName];

        validationType = $.fn.validation.ValidationTypes[rule.type] || $.fn.validation.ValidationTypes.error;
        messageText = '';

        if (messages[validationType.type]) {
          messageText = messages[validationType.type];
        }

        if (!result && displayMessage) {
          if (messageText) {
            messageText = (/^\u2022/.test(messageText) ? '' : '\u2022 ') + messageText;
            messageText += '<br/>' + '\u2022 ' + rule.message;
          } else {
            messageText = rule.message;
          }

          messages[validationType.type] = messageText;
        }

        dfrd.resolve();
      }

      for (i = 0; i < rules.length; i++) {
        var rule = validator.rules[rules[i]];
        var gridInfo = { row: row, cell: cell, item: this.settings.dataset[row], column: column, grid: self };

        dfd = $.Deferred();

        if (rule.async) {
          rule.check(cellValue, $('<input>').val(cellValue), gridInfo, manageResult, dfd);
        } else {
          manageResult(rule.check(cellValue, $('<input>').val(cellValue), gridInfo), true, rules[i], dfd);
        }
        dfds.push(dfd);
      }

      (_$ = $).when.apply(_$, dfds).then(function () {
        var validationTypes = $.fn.validation.ValidationTypes;
        for (var props in validationTypes) {
          // eslint-disable-line
          messageText = '';
          validationType = validationTypes[props];
          if (messages[validationType.type]) {
            messageText = messages[validationType.type];
          }
          if (messageText !== '') {
            self.showCellError(row, cell, messageText, validationType.type);
            var rowNode = _this5.dataRowNode(row);
            self.element.trigger('cell' + validationType.type, { row: row, cell: cell, message: messageText, target: _this5.cellNode(rowNode, cell), value: cellValue, column: column });
          } else {
            self.clearCellError(row, cell, validationType.type);
          }
        }
      });
    },


    /**
    * Show the cell errors.
    * @param  {number} row The row index.
    * @param  {number} cell The cell index.
    * @param  {string} message The message text.
    * @param  {string} type The message type (infor, error, alert )
    * @returns {void}
    */
    showCellError: function showCellError(row, cell, message, type) {
      var rowNode = this.dataRowNode(row);
      var node = this.cellNode(rowNode, cell);

      // clear the table nonVisibleCellErrors for the row and cell
      this.clearNonVisibleCellErrors(row, cell, type);

      if (!node.length) {
        // Store the nonVisibleCellError
        this.nonVisibleCellErrors.push({ row: row, cell: cell, message: message, type: type });
        this.showNonVisibleCellErrors();
        return;
      }

      // Add icon and classes
      node.addClass(type).attr('data-' + type + 'message', message);

      // Add and show tooltip
      var icon = node.find('.icon-' + type);
      if (!icon.length) {
        var wrapper = node.find('.datagrid-cell-wrapper');
        wrapper.append($($.createIcon({ classes: ['icon-' + type], icon: type })));
        icon = node.find('.icon-' + type);

        var tooltip = {
          forced: true,
          placement: 'bottom',
          content: message,
          isError: type === 'error' || type === 'dirtyerror',
          wrapper: icon
        };
        this.cacheTooltip(icon, tooltip);
        this.setupTooltips(false, true);
      }
    },


    /**
     * Show all non visible cell errors
     * @private
     * @returns {void}
     */
    showNonVisibleCellErrors: function showNonVisibleCellErrors() {
      var _this6 = this;

      // Create empty toolbar
      if (!this.toolbar) {
        this.settings.toolbar = { title: ' ' };
        this.appendToolbar();
      }

      // process via type

      var _loop4 = function _loop4(props) {
        // eslint-disable-line
        var validationType = $.fn.validation.ValidationTypes[props].type;
        var errors = $.grep(_this6.nonVisibleCellErrors, function (error) {
          return error.type === validationType;
        });
        _this6.showNonVisibleCellErrorType(errors, validationType);
      };

      for (var props in $.fn.validation.ValidationTypes) {
        _loop4(props);
      }
    },


    /**
     * Show all non visible cell errors, for a given message/validation type.
     * @private
     * @param  {array} nonVisibleCellErrors An array of non visible cells, in error state.
     * @param  {string} type The message type to show
     */
    showNonVisibleCellErrorType: function showNonVisibleCellErrorType(nonVisibleCellErrors, type) {
      var messages = void 0;
      var tableerrors = void 0;
      var icon = void 0;
      var i = void 0;
      var nonVisiblePages = [];
      var validationType = $.fn.validation.ValidationTypes[type] || $.fn.validation.ValidationTypes.error;

      if (this.toolbar.parent().find('.table-errors').length === 1) {
        tableerrors = this.toolbar.parent().find('.table-errors');
      }

      if (nonVisibleCellErrors.length === 0) {
        // clear the displayed message
        if (tableerrors && tableerrors.length) {
          icon = tableerrors.find('.icon-' + validationType.type);
          this.hideTooltip();
          tableerrors.find('.icon-' + validationType.type).remove();
        }
        return;
      }

      // Process message type, so it displays one message per page
      for (i = 0; i < nonVisibleCellErrors.length; i++) {
        var page = Math.floor((nonVisibleCellErrors[i].row + this.settings.pagesize) / this.settings.pagesize);
        if ($.inArray(page, nonVisiblePages) === -1) {
          nonVisiblePages.push(page);
        }
      }

      for (i = 0; i < nonVisiblePages.length; i++) {
        messages = (messages ? messages + '<br>' : '') + Locale.translate(validationType.pagingMessageID) + ' ' + nonVisiblePages[i];
      }

      if (this.toolbar.parent().find('.table-errors').length === 0) {
        tableerrors = $('<div class="table-errors"></div>');
      }
      icon = tableerrors.find('.icon-' + type);
      if (!icon.length) {
        tableerrors.append($($.createIcon({ classes: ['icon-' + type], icon: type })));
        icon = tableerrors.find('.icon-' + type);
      }

      if (this.element.hasClass('has-toolbar')) {
        // Add Error to the Toolbar
        this.toolbar.children('.title').append(tableerrors);
      }

      this.cacheTooltip(icon, {
        forced: true,
        placement: 'bottom',
        content: messages,
        isError: type === 'error' || type === 'dirtyerror',
        wrapper: icon
      });
    },


    /**
     * Clear all error for a given cell in a row
     * @param {number} row The row index.
     * @param {number} cell The cell index.
     * @returns {void}
     */
    clearAllCellError: function clearAllCellError(row, cell) {
      var validationTypes = $.fn.validation.ValidationTypes;
      for (var props in validationTypes) {
        // eslint-disable-line
        var _validationType = validationTypes[props];
        this.clearCellError(row, cell, _validationType.type);
      }
    },


    /**
     * Clear a cell with an error of a given type
     * @param {number} row The row index.
     * @param {number} cell The cell index.
     * @param {string} type of error.
     * @returns {void}
     */
    clearCellError: function clearCellError(row, cell, type) {
      this.clearNonVisibleCellErrors(row, cell, type);
      var rowNode = this.dataRowNode(row);
      var node = this.cellNode(rowNode, cell);

      if (!node.length) {
        return;
      }

      this.clearNodeErrors(node, type);
    },


    /**
     * Clear a non visible cells from errors of a given type
     * @private
     * @param {number} row The row index.
     * @param {number} cell The cell index.
     * @param {string} type of error.
     * @returns {void}
     */
    clearNonVisibleCellErrors: function clearNonVisibleCellErrors(row, cell, type) {
      if (!this.nonVisibleCellErrors.length) {
        return;
      }

      this.nonVisibleCellErrors = $.grep(this.nonVisibleCellErrors, function (error) {
        if (!(error.row === row && error.cell === cell && error.type === type)) {
          return error;
        }
        return '';
      });

      if (!this.nonVisibleCellErrors.length) {
        this.showNonVisibleCellErrors();
      }
    },


    /**
     * Clear a row level all errors, alerts, info messages and dirty indicators
     * @param {number} row The row index.
     * @returns {void}
     */
    clearRowError: function clearRowError(row) {
      var classList = 'error alert rowstatus-row-error rowstatus-row-alert rowstatus-row-info rowstatus-row-in-progress rowstatus-row-confirm';
      var rowNode = this.dataRowNode(row);

      rowNode.removeClass(classList);
      this.rowStatus(row, '', '');
      for (var cell = 0; cell < this.settings.columns.length; cell++) {
        this.clearAllCellError(row, cell);
      }
    },


    /**
     * Clear all errors, alerts, info messages and dirty indicators in entire datagrid.
     * @returns {void}
     */
    clearAllErrors: function clearAllErrors() {
      var rowStatus = 0;
      for (var row = 0; row < this.settings.dataset.length; row++) {
        if (this.settings.dataset[row].rowStatus) {
          delete this.settings.dataset[row].rowStatus;
          rowStatus++;
        }
        for (var cell = 0; cell < this.settings.columns.length; cell++) {
          this.clearAllCellError(row, cell);
        }
      }

      if (rowStatus > 0) {
        this.render();
      }
    },


    /**
     * Remove messages form a cell element.
     * @private
     * @param {object} node cell element.
     * @param {string} type of messages.
     * @returns {void}
     */
    clearNodeErrors: function clearNodeErrors(node, type) {
      node = node instanceof jQuery ? node[0] : node;
      node.classList.remove(type);
      node.removeAttribute('data-' + type + 'message');

      var icon = node.querySelector('.icon-' + type);
      if (icon) {
        icon.parentNode.removeChild(icon);
        this.hideTooltip();
      }
    },


    /**
    * Set the row status on a row to none.
    * @returns {void}
    */
    resetRowStatus: function resetRowStatus() {
      var errors = this.settings.dataset.filter(function (row) {
        return row.rowStatus;
      });
      for (var i = 0; i < errors.length; i++) {
        delete errors[i].rowStatus;
      }
      if (errors.length > 0) {
        this.render();
      }
    },


    /**
    * Return all of the currently dirty rows by row index.
    * @returns {array} An array of dirty rows.
    */
    dirtyRows: function dirtyRows() {
      var rows = [];
      var data = this.settings.dataset;

      for (var i = 0; i < data.length; i++) {
        if (data[i].rowStatus && data[i].rowStatus.icon === 'dirty') {
          rows.push(data[i]);
        }
      }
      return rows;
    },


    /**
     * Show an error on a row of a given type.
     * @param  {number} row The row index.
     * @param  {string} message The row description.
     * @param  {string} type The error type.
     * @returns {void}
     */
    showRowError: function showRowError(row, message, type) {
      var messageType = type || 'error';
      var rowNode = this.dataRowNode(row);

      rowNode.addClass(type);
      this.rowStatus(row, messageType, message);
    },


    /**
     * Validate all visible cells in a row if they have validation on the column
     * @param  {number} row The row index.
     * @returns {void}
     */
    validateRow: function validateRow(row) {
      if (!row) {
        return;
      }

      for (var i = 0; i < this.settings.columns.length; i++) {
        this.validateCell(row, i);
      }
    },


    /**
     * Validate all rows and cells in the entire grid if they have validation on the column
     * @returns {void}
     */
    validateAll: function validateAll() {
      for (var j = 0; j < this.settings.dataset.length; j++) {
        for (var i = 0; i < this.settings.columns.length; i++) {
          this.validateCell(j, i);
        }
      }
    },


    /**
     * Get the settings for a column by index.
     * @param  {number} idx The column index.
     * @param  {boolean} onlyVisible If only the visible columns should be included.
     * @returns {array} The settings array
     */
    columnSettings: function columnSettings(idx, onlyVisible) {
      var foundColumn = this.settings.columns[idx];

      if (onlyVisible) {
        foundColumn = this.visibleColumns()[idx];
      }

      return foundColumn || {};
    },


    /**
     * Attempt to serialize the value back into the dataset
     * @private
     * @param {any} value The new column value
     * @param {any} oldVal The old column value.
     * @param {number} col The column definition
     * @param {number} row  The row index.
     * @param {number} cell The cell index.
     * @returns {void}
     */
    coerceValue: function coerceValue(value, oldVal, col, row, cell) {
      var newVal = void 0;

      if (col.serialize) {
        newVal = col.serialize(value, oldVal, col, row, cell, this.settings.dataset[row]);
        return newVal;
      } else if (col.sourceFormat) {
        if (value instanceof Date) {
          newVal = Locale.parseDate(value, col.sourceFormat);
        } else {
          newVal = Locale.formatDate(value, { pattern: col.sourceFormat });
        }
      } else if (typeof oldVal === 'number' && value) {
        newVal = Locale.parseNumber(value); // remove thousands sep , keep a number a number
      }

      return newVal;
    },


    /**
     * Update one cell with a specific value
     * @param {number} row  The row index.
     * @param {number} cell The cell index.
     * @param {any} value The value to use.
     * @returns {void}
     */
    updateCell: function updateCell(row, cell, value) {
      var col = this.columnSettings(cell);

      if (value === undefined) {
        value = this.fieldValue(this.settings.dataset[row], col.field);
      }

      this.updateCellNode(row, cell, value, true);
    },


    /**
     * Update one cell with a specific value
     * @private
     * @param {number} row  The row index.
     * @param {number} cell The cell index.
     * @param {any} value The value to use.
     * @param {boolean} fromApiCall Us from an api call.
     * @param {boolean} isInline If the editor is an inline value.
     * @returns {void}
     */
    updateCellNode: function updateCellNode(row, cell, value, fromApiCall, isInline) {
      var coercedVal = void 0;
      var rowNode = this.actualRowNode(row);
      var cellNode = rowNode.find('td').eq(cell);
      var col = this.settings.columns[cell] || {};
      var formatted = '';
      var formatter = col.formatter ? col.formatter : this.defaultFormatter;
      var isEditor = $('.editor', cellNode).length > 0;
      var isTreeGrid = this.settings.treeGrid;
      var dataRowIndex = this.dataRowIndex(rowNode);
      if (dataRowIndex === null || dataRowIndex === undefined || isNaN(dataRowIndex)) {
        dataRowIndex = row;
      }
      var rowData = isTreeGrid ? this.settings.treeDepth[row].node : this.settings.dataset[dataRowIndex];

      if (rowNode.length === 0 && this.settings.paging) {
        rowNode = this.visualRowNode(row);
        cellNode = rowNode.find('td').eq(cell);
      }
      var oldVal = this.fieldValue(rowData, col.field);

      // Coerce/Serialize value if from cell edit
      if (!fromApiCall) {
        coercedVal = this.coerceValue(value, oldVal, col, row, cell);

        // coerced value may be coerced to empty string, null, or 0
        if (coercedVal === undefined) {
          coercedVal = value;
        }
      } else {
        coercedVal = value;
      }

      // Remove rowStatus icon
      if (rowNode.length && rowData && !rowData.rowStatus) {
        var rowstatusIcon = rowNode.find('svg.icon-rowstatus');
        if (rowstatusIcon.length) {
          rowstatusIcon.remove();
        }
      }

      // Remove older tooltip data
      this.removeTooltipData(cellNode);

      // Update the value in the dataset
      if (cell === 0 && rowData && rowData.rowStatus) {
        var svg = cellNode.find('svg.icon-rowstatus');

        if (rowNode[0] && cellNode[0]) {
          rowNode[0].classList.add('rowstatus-row-' + rowData.rowStatus.icon);
          cellNode[0].classList.add('rowstatus-cell');

          if (!svg.length) {
            var svgIcon = rowData.rowStatus.icon === 'confirm' ? '#icon-check' : '#icon-exclamation';
            cellNode.prepend('<svg class="icon icon-rowstatus" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="' + svgIcon + '"></use></svg>');
          }
        }
        if (rowData.rowStatus.tooltip) {
          svg = cellNode.find('svg.icon-rowstatus');
          var statusIcon = rowData.rowStatus.icon;
          this.cacheTooltip(svg, {
            forced: true,
            placement: 'right',
            content: rowData.rowStatus.tooltip,
            isError: statusIcon === 'error' || statusIcon === 'dirtyerror',
            wrapper: cellNode
          });
        }
      }

      coercedVal = xssUtils.unescapeHTML(coercedVal);

      if (col.field && coercedVal !== oldVal) {
        if (col.field.indexOf('.') > -1) {
          var parts = col.field.split('.');
          if (parts.length === 2) {
            rowData[parts[0]][parts[1]] = coercedVal;
          }

          if (parts.length === 3) {
            rowData[parts[0]][parts[1]][parts[2]] = coercedVal;
          }
        } else {
          rowData[col.field] = coercedVal;
        }
      }

      // update cell value
      var escapedVal = xssUtils.escapeHTML(coercedVal);
      var rowIdx = isTreeGrid ? row + 1 : row;
      var val = isEditor ? coercedVal : escapedVal;
      formatted = this.formatValue(formatter, rowIdx, cell, val, col, rowData);

      if (col.contentVisible) {
        var canShow = col.contentVisible(row, cell, escapedVal, col, rowData);
        if (!canShow) {
          formatted = '';
        }
      }

      if (!isInline) {
        cellNode.find('.datagrid-cell-wrapper').html(formatted);
      }

      if (!fromApiCall) {
        // Validate the cell
        this.validateCell(dataRowIndex, cell);
      }

      if (coercedVal !== oldVal && !fromApiCall) {
        var args = {
          row: this.settings.source !== null ? dataRowIndex : row,
          relativeRow: row,
          cell: cell,
          target: cellNode,
          value: coercedVal,
          oldValue: oldVal,
          column: col
        };
        args.rowData = isTreeGrid && this.settings.treeDepth[row] ? this.settings.treeDepth[row].node : rowData;

        /**
         * Fires when a cell value is changed via the editor.
         * @event cellchange
         * @memberof Datagrid
         * @property {object} event The jquery event object
         * @property {object} args Additional arguments
         * @property {number} args.row An array of selected rows.
         * @property {number} args.cell An array of selected rows.
         * @property {HTMLElement} args.target The cell html element that was entered.
         * @property {any} args.value The cell value.
         * @property {any} args.oldValue The previous cell value.
         * @property {object} args.column The column object
         */
        this.element.trigger('cellchange', args);
        this.wasJustUpdated = true;

        if (this.settings.showDirty) {
          this.rowStatus(row, 'dirty');
        }
      }
    },


    /**
     * For the row node get the index adjusting for paging / invisible rowsCache
     * @private
     * @param {number} row The row index
     * @returns {number} The row index adjusted for paging/non visible rows.
     */
    visualRowIndex: function visualRowIndex(row) {
      return this.tableBody.find('tr:visible:not(.is-hidden, .datagrid-expandable-row)').index(row);
    },


    /**
     * For the row index get the node adjusting for paging / invisible rowsCache
     * @private
     * @param {number} idx The row index
     * @returns {object} The row node adjusted for paging/non visible rows.
     */
    visualRowNode: function visualRowNode(idx) {
      var rowIdx = idx;

      if (this.settings.paging && this.settings.source) {
        rowIdx += (this.pager.activePage - 1) * this.settings.pagesize;
      }

      if (!this.isRowVisible(idx)) {
        return $([]);
      }

      return this.tableBody.find('tr[aria-rowindex="' + (rowIdx + 1) + '"]');
    },


    /**
     * For an internal row index, get the dataset row index
     * @private
     * @param {number} idx The row index
     * @returns {object} The row index in the dataset.
     */
    actualRowNode: function actualRowNode(idx) {
      return this.tableBody.find('tr[aria-rowindex="' + (idx + 1) + '"]');
    },


    /**
     * For an internal row node, get the dataset row index
     * @private
     * @param {number} row The row node.
     * @returns {object} The row index in the dataset.
     */
    actualRowIndex: function actualRowIndex(row) {
      return row.attr('aria-rowindex') - 1;
    },


    /**
     * For an internal row index, get row index across page number.
     * This may or may not be the one in the dataset.
     * @private
     * @param {number} idx The row idx.
     * @returns {object} The row index
     */
    pagingRowIndex: function pagingRowIndex(idx) {
      var rowIdx = idx;

      if (this.settings.paging && this.settings.source && !this.settings.indeterminate) {
        rowIdx += (this.pager.activePage - 1) * this.settings.pagesize;
      }
      return rowIdx;
    },


    /**
     * For an internal row index, get row index across page number.
     * This may or may not be the one in the dataset.
     * @private
     * @param {number} idx The row idx.
     * @returns {object} The row index
     */
    actualPagingRowIndex: function actualPagingRowIndex(idx) {
      var rowIdx = idx;

      if (this.settings.paging && this.settings.source && !this.settings.indeterminate) {
        rowIdx -= (this.pager.activePage - 1) * this.settings.pagesize;
      }
      return rowIdx;
    },


    /**
     * Return the data node for a row. This is the newer way of getting this info.
     * @private
     * @param {number} idx The row idx to find
     * @returns {object} The row node
     */
    dataRowNode: function dataRowNode(idx) {
      return this.tableBody.find('tr[data-index="' + idx + '"]');
    },


    /**
     * Return the data index for a row. This is the newer way of getting this info.
     * @private
     * @param {number} row The row idx
     * @returns {number} The row index in the dataset.
     */
    dataRowIndex: function dataRowIndex(row) {
      return parseInt(row.attr('data-index'), 10);
    },


    /**
     * Sets focus on a cell.
     * @param  {number} row The row index
     * @param  {number} cell The cell index
     */
    setActiveCell: function setActiveCell(row, cell) {
      var self = this;
      var prevCell = self.activeCell;
      var rowElem = row;
      var rowNum = void 0;
      var rowIndex = void 0;
      var dataRowNum = void 0;
      var isGroupRow = row instanceof jQuery && row.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer');

      if (row instanceof jQuery && row.length === 0) {
        return;
      }

      if (typeof row === 'number') {
        rowNum = row;
        rowElem = this.tableBody.find('tr:visible').eq(row);
        rowIndex = this.actualRowIndex(rowElem);
        dataRowNum = this.dataRowIndex(rowElem);
      }

      // Support passing the td in
      if (row instanceof jQuery && row.is('td')) {
        isGroupRow = row.parent().is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer');
        if (isGroupRow) {
          rowElem = row.parent();
        }
        cell = row.index();
        rowNum = this.visualRowIndex(row.parent());
        rowIndex = this.actualRowIndex(row.parent());
        dataRowNum = this.dataRowIndex(row.parent());
        rowElem = row.parent();
      }

      if (row instanceof jQuery && row.is('tr')) {
        rowNum = this.visualRowIndex(row);
        rowIndex = this.actualRowIndex(row);
        dataRowNum = this.dataRowIndex(row);
        rowElem = row;
      }

      if (rowNum < 0 || cell < 0) {
        return;
      }

      // Remove previous tab index
      if (prevCell.node && prevCell.node.length === 1) {
        self.activeCell.node.removeAttr('tabindex').removeClass('is-active');
      }

      // Hide any cell tooltips (Primarily for validation)
      if (prevCell.cell !== cell || prevCell.row !== row) {
        self.hideTooltip();
      }

      // Find the cell if it exists
      self.activeCell.node = self.cellNode(isGroupRow || rowElem ? rowElem : rowIndex > -1 ? rowIndex : rowNum, cell).attr('tabindex', '0');

      if (self.activeCell.node && prevCell.node.length === 1) {
        self.activeCell.row = rowNum;
        self.activeCell.cell = cell;
        rowIndex = this.actualRowIndex(self.activeCell.node.parent());
        dataRowNum = this.dataRowIndex(self.activeCell.node.parent());
      } else {
        self.activeCell = prevCell;
      }

      if (!$('input, button:not(.btn-secondary, .row-btn, .datagrid-expand-btn, .datagrid-drilldown, .btn-icon)', self.activeCell.node).length) {
        self.activeCell.node.focus();
        if (isGroupRow) {
          self.activeCell.groupNode = self.activeCell.node;
        }
      }
      if (self.activeCell.node.hasClass('is-focusable')) {
        self.activeCell.node.find('button').focus();
      }

      if (dataRowNum !== undefined) {
        self.activeCell.dataRow = dataRowNum;
      }

      if (rowIndex !== undefined) {
        self.activeCell.rowIndex = rowIndex;
      }

      var colSpan = +rowElem.find('td[colspan]').attr('colspan');

      if (isGroupRow && self.activeCell.node && prevCell.node && !(row instanceof jQuery && row.is('td'))) {
        if (cell < colSpan) {
          rowElem.find('td[colspan]').attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td[colspan]');
        } else if (cell >= colSpan) {
          rowElem.find('td').eq(cell - colSpan + 1).attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td').eq(cell - colSpan + 1);
        } else {
          rowElem.find('td').eq(cell).attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td').eq(cell);
        }
      }

      if (isGroupRow && row instanceof jQuery && row.is('td')) {
        self.activeCell.cell = colSpan - 1 + cell;
        if (row.is('[colspan]')) {
          self.activeCell.cell = cell;
        }
      }

      if (this.settings.cellNavigation) {
        var headers = self.headerNodes();
        var prevSpans = 0;

        // Check if any previous rows are spanned
        if (this.hasColSpans) {
          prevSpans = 0;

          headers.eq(cell).prevAll('[colspan]').each(function (i, elem) {
            var span = $(elem).attr('colspan') - 1;
            prevSpans += span;
          });

          cell -= prevSpans;
        }

        headers.removeClass('is-active');
        headers.eq(cell).addClass('is-active');
      }
      this.activeCell.isFocused = true;

      // Expand On Activate Feature
      var col = this.settings.columns[cell];
      if (col && col.expandOnActivate && this.activeCell && this.activeCell.node) {
        self.activeCell.node.addClass('is-active');
      }

      /**
      * Fires when a cell is focued.
      * @event activecellchange
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {HTMLElement} args.node  The cell element that was entered.
      * @property {number} args.cell The selected cell
      * @property {number} args.row The selected row
      */
      self.element.trigger('activecellchange', [{ node: this.activeCell.node, row: this.activeCell.row, cell: this.activeCell.cell }]);
    },


    /**
     * Sets focus to the next active cell, depending on a key.
     * @private
     * @param {object} e The event object
     */
    setNextActiveCell: function setNextActiveCell(e) {
      var self = this;
      if (e.type === 'keydown') {
        if (this.settings.actionableMode) {
          setTimeout(function () {
            var evt = $.Event('keydown.datagrid');
            evt.keyCode = 40; // move down
            self.activeCell.node.trigger(evt);
          }, 0);
        } else {
          this.setActiveCell(this.activeCell.row, this.activeCell.cell);
        }
      }
    },


    /**
     * Add children to treegrid dataset
     * @private
     * @param {object} parent The parent object
     * @param {object} data The data for the child
     */
    addChildren: function addChildren(parent, data) {
      if (!data || data && !data.length || parent < 0) {
        return;
      }
      var node = this.settings.treeDepth[parent].node;
      node.children = node.children || [];

      // Make sure it's not reference pointer to data object, make copy of data
      data = JSON.parse(JSON.stringify(data));

      for (var i = 0, len = data.length; i < len; i++) {
        node.children.push(data[i]);
      }
      this.updateDataset(this.settings.dataset);
    },


    /**
     * Set the expanded property in the dataset
     * @private
     * @param {number} dataRowIndex The index in the dataset.
     * @param {boolean} isExpanded Expanded value to set.
     */
    setExpandedInDataset: function setExpandedInDataset(dataRowIndex, isExpanded) {
      this.settings.treeDepth[dataRowIndex].node.expanded = isExpanded;
    },


    /**
     * Expand the tree children
     * @private
     * @param {object} e The event data from the click or keyboard event.
     * @param {number} dataRowIndex Index in the dataset
     */
    toggleChildren: function toggleChildren(e, dataRowIndex) {
      if (this.settings.groupable) {
        return;
      }
      var self = this;
      var rowElement = this.settings.treeGrid ? this.actualRowNode(dataRowIndex) : this.visualRowNode(dataRowIndex);
      var expandButton = rowElement.find('.datagrid-expand-btn');
      var level = parseInt(rowElement.attr('aria-level'), 10);
      var children = rowElement.nextUntil('[aria-level="' + level + '"]');
      var isExpanded = expandButton.hasClass('is-expanded');
      var args = [{ grid: self, row: dataRowIndex, item: rowElement, children: children }];

      if (self.settings.treeDepth && self.settings.treeDepth[dataRowIndex]) {
        args[0].rowData = self.settings.treeDepth[dataRowIndex].node;
      }

      if (!rowElement.hasClass('datagrid-tree-parent') || !$(e.target).is(expandButton) && (self.settings.editable || self.settings.selectable)) {
        return;
      }

      var toggleExpanded = function toggleExpanded() {
        rowElement = self.settings.treeGrid ? self.actualRowNode(dataRowIndex) : self.visualRowNode(dataRowIndex);
        expandButton = rowElement.find('.datagrid-expand-btn');
        children = rowElement.nextUntil('[aria-level="' + level + '"]');

        if (isExpanded) {
          rowElement.attr('aria-expanded', false);
          expandButton.removeClass('is-expanded').find('.plus-minus').removeClass('active');
        } else {
          rowElement.attr('aria-expanded', true);
          expandButton.addClass('is-expanded').find('.plus-minus').addClass('active');
        }
        self.setExpandedInDataset(dataRowIndex, !isExpanded);

        var setChildren = function setChildren(elem, lev, expanded) {
          var nodes = elem.nextUntil('[aria-level="' + level + '"]');

          if (expanded) {
            nodes.each(function () {
              var node = $(this);
              var nodeLevel = parseInt(node.attr('aria-level'), 10);
              if (nodeLevel > lev) {
                node.addClass('is-hidden');
              }
            });
          } else {
            nodes.each(function () {
              var node = $(this);
              var nodeLevel = parseInt(node.attr('aria-level'), 10);

              if (nodeLevel === lev + 1) {
                if (!node.hasClass('is-filtered')) {
                  node.removeClass('is-hidden');
                }

                if (node.is('.datagrid-tree-parent')) {
                  var nodeIsExpanded = node.find('.datagrid-expand-btn.is-expanded').length > 0;
                  if (nodeIsExpanded) {
                    setChildren(node, nodeLevel, !nodeIsExpanded);
                  }
                }
              }
            });
          }
        };

        setChildren(rowElement, level, isExpanded);
        self.setAlternateRowShading();
      };

      /**
      * Fires when a row is collapsed to show its detail.
      * @event collapserow
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {object} args.self The grid api.
      * @property {number} args.row The selected row index
      * @property {object} args.item The selected row data.
      * @property {array} args.children The selected rows children (tree grid)
      */

      /**
      * Fires when a row is expanded to show its detail.
      * @event expandrow
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {object} args.self The grid api.
      * @property {number} args.row The selected row index
      * @property {object} args.item The selected row data.
      * @property {array} args.children The selected rows children (tree grid)
      */
      $.when(self.element.triggerHandler(isExpanded ? 'collapserow' : 'expandrow', args)).done(function () {
        toggleExpanded();
      });
    },


    /**
     * Expand Detail Row Or Tree Row
     * @param  {number} dataRowIndex The row to toggle
     * @returns {void}
     */
    toggleRowDetail: function toggleRowDetail(dataRowIndex) {
      var self = this;
      var rowElement = self.actualRowNode(dataRowIndex);
      if (!rowElement.length && self.settings.paging && (self.settings.rowTemplate || self.settings.expandableRow)) {
        dataRowIndex += (self.pager.activePage - 1) * self.settings.pagesize;
        rowElement = self.dataRowNode(dataRowIndex);
      }
      var expandRow = rowElement.next();
      var expandButton = rowElement.find('.datagrid-expand-btn');
      var detail = expandRow.find('.datagrid-row-detail');
      var item = self.settings.dataset[self.dataRowIndex(rowElement)];

      if (rowElement.hasClass('datagrid-tree-parent')) {
        return;
      }

      if (self.settings.allowOneExpandedRow && self.settings.groupable === null) {
        // collapse any other expandable rows
        var prevExpandRow = self.tableBody.find('tr.is-expanded');
        var prevExpandButton = prevExpandRow.prev().find('.datagrid-expand-btn');
        var parentRow = prevExpandRow.prev();
        var parentRowIdx = self.actualRowNode(parentRow);
        var parentdataRowIdx = self.dataRowIndex(parentRow);

        if (prevExpandRow.length && expandRow.index() !== prevExpandRow.index()) {
          var prevDetail = prevExpandRow.find('.datagrid-row-detail');

          prevExpandRow.add(prevExpandButton).removeClass('is-expanded');
          parentRow.removeClass('is-rowactivated');
          parentRow.find('.plus-minus').removeClass('active');
          prevDetail.animateClosed().on('animateclosedcomplete', function () {
            prevExpandRow.removeClass('is-expanded');
            self.element.triggerHandler('collapserow', [{ grid: self, row: parentRowIdx, detail: prevDetail, item: self.settings.dataset[parentdataRowIdx] }]);
          });

          var prevActionBtn = prevExpandRow.prev().find('.btn-primary');
          if (prevActionBtn.length) {
            prevActionBtn.attr('class', prevActionBtn.attr('class').replace('btn-primary', 'btn-secondary'));
          }
        }

        // Toggle the button to make it primary
        var isExpanded = !expandRow.hasClass('is-expanded');
        var actionButton = expandRow.prev().find(isExpanded ? '.btn-secondary' : '.btn-primary');

        if (actionButton.length > 0 && parentRow && actionButton) {
          var currentClass = actionButton.attr('class') || '';

          actionButton.attr('class', currentClass.replace(isExpanded ? 'btn-secondary' : 'btn-primary', isExpanded ? 'btn-primary' : 'btn-secondary'));
        }
      }

      if (expandRow.hasClass('is-expanded')) {
        expandRow.removeClass('is-expanded');
        expandButton.removeClass('is-expanded').find('.plus-minus').removeClass('active');

        if (self.settings.allowOneExpandedRow) {
          rowElement.removeClass('is-rowactivated');
        }

        detail.animateClosed();
        self.element.triggerHandler('collapserow', [{ grid: self, row: dataRowIndex, detail: detail, item: item }]);
      } else {
        expandRow.addClass('is-expanded');
        expandButton.addClass('is-expanded').find('.plus-minus').addClass('active');

        // Optionally Contstrain the width
        expandRow.find('.constrained-width').css('max-width', this.element.outerWidth());

        var eventData = [{ grid: self, row: dataRowIndex, detail: detail, item: item }];
        self.element.triggerHandler('expandrow', eventData);

        if (self.settings.allowOneExpandedRow) {
          rowElement.addClass('is-rowactivated');
        }

        if (self.settings.onExpandRow) {
          var response = function response(markup) {
            if (markup) {
              detail.find('.datagrid-row-detail-padding').empty().append(markup);
            }
            detail.animateOpen();
          };

          self.settings.onExpandRow(eventData[0], response);
        } else {
          detail.animateOpen();
        }
      }
    },


    /**
     * Expand the grouped row children
     * @private
     * @param {object} rowElement The row DOM element
     */
    toggleGroupChildren: function toggleGroupChildren(rowElement) {
      if (!this.settings.groupable) {
        return;
      }

      var self = this;
      var children = rowElement.nextUntil('.datagrid-rowgroup-header');
      var expandButton = rowElement.find('.datagrid-expand-btn');

      if (rowElement.hasClass('is-expanded')) {
        expandButton.removeClass('is-expanded').find('.plus-minus').removeClass('active');

        children.hide();
        children.addClass('is-hidden');
        self.element.triggerHandler('collapserow', [{ grid: self, row: rowElement.index(), detail: children, item: {} }]);

        rowElement.removeClass('is-expanded');
      } else {
        expandButton.addClass('is-expanded').find('.plus-minus').addClass('active');

        children.show();
        children.removeClass('is-hidden');
        self.element.triggerHandler('expandrow', [{ grid: self, row: rowElement.index(), detail: children, item: {} }]);

        rowElement.addClass('is-expanded');
      }
    },


    /**
     * Set the current datagrid sort column
     * @param {string} id The column id
     * @param {boolean} ascending Set the sort in ascending or descending order
     */
    setSortColumn: function setSortColumn(id, ascending) {
      // Set Direction based on if passed in or toggling existing field
      if (ascending !== undefined) {
        this.sortColumn.sortAsc = ascending;
      } else {
        if (this.sortColumn.sortId === id) {
          this.sortColumn.sortAsc = !this.sortColumn.sortAsc;
        } else {
          this.sortColumn.sortAsc = true;
        }
        ascending = this.sortColumn.sortAsc;
      }

      this.sortColumn.sortId = id;
      this.sortColumn.sortField = this.columnById(id)[0] ? this.columnById(id)[0].field : id;
      this.sortColumn.sortAsc = ascending;

      // Do Sort on Data Set
      this.setSortIndicator(id, ascending);
      this.sortDataset();

      if (!this.settings.focusAfterSort && this.activeCell && this.activeCell.isFocused) {
        this.activeCell.isFocused = false;
      }

      var wasFocused = this.activeCell.isFocused;
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();
      this.renderRows();
      // Update selected and Sync header checkbox
      this.syncSelectedUI();

      if (wasFocused && this.activeCell.node.length === 1) {
        this.setActiveCell(this.activeCell.row, this.activeCell.cell);
      }

      this.resetPager('sorted');
      this.tableBody.removeClass('is-loading');
      this.saveUserSettings();
      this.validateAll();
      this.element.trigger('sorted', [this.sortColumn]);
    },


    /**
     * Sort the currently attached dataset.
     * @private
     */
    sortDataset: function sortDataset() {
      if (this.originalDataset) {
        this.settings.dataset = this.originalDataset;
      }
      var sort = this.sortFunction(this.sortColumn.sortId, this.sortColumn.sortAsc);

      if (!this.settings.disableClientSort) {
        this.settings.dataset.sort(sort);
      }

      // Resync the _selectedRows array
      if (this.settings.selectable) {
        this.syncDatasetWithSelectedRows();
      }
    },


    /**
    * Sync the dataset._selected elements with the _selectedRows array
    * @private
    */
    syncDatasetWithSelectedRows: function syncDatasetWithSelectedRows() {
      this._selectedRows = [];
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var idx = -1;

      for (var i = 0, data; i < dataset.length; i++) {
        if (s.groupable) {
          for (var k = 0; k < dataset[i].values.length; k++) {
            idx++;
            data = dataset[i].values[k];
            if (this.isNodeSelected(data)) {
              this._selectedRows.push({
                idx: idx,
                data: data,
                elem: this.dataRowNode(idx),
                group: dataset[i],
                page: this.pager ? this.pager.activePage : 1,
                pagingIdx: idx,
                pagesize: this.settings.pagesize
              });
            }
          }
        } else {
          data = s.treeGrid ? dataset[i].node : dataset[i];
          if (this.isNodeSelected(data)) {
            this._selectedRows.push({
              idx: i,
              data: data,
              elem: this.visualRowNode(i),
              pagesize: this.settings.pagesize,
              page: this.pager ? this.pager.activePage : 1,
              pagingIdx: idx
            });
          }
        }
      }
    },


    /**
     * Sort the ui sort indicator on the column.
     * @private
     * @param {string} id The column id
     * @param {boolean} ascending Set the sort in ascending or descending order
     */
    setSortIndicator: function setSortIndicator(id, ascending) {
      if (!this.headerRow) {
        return;
      }

      // Set Visual Indicator
      this.headerRow.find('.is-sorted-asc, .is-sorted-desc').removeClass('is-sorted-asc is-sorted-desc').attr('aria-sort', 'none');
      this.headerRow.find('[data-column-id="' + id + '"]').addClass(ascending ? 'is-sorted-asc' : 'is-sorted-desc').attr('aria-sort', ascending ? 'ascending' : 'descending');
    },


    /**
    * Overridable function to conduct array sorting
    * @param {string} id The matching field/id in the array to sort on
    * @param {boolean} ascending Determines direction of the sort.
    * @returns {boolean} If found.
    */
    sortFunction: function sortFunction(id, ascending) {
      var column = this.columnById(id);
      // Assume the field and id match if no column found
      var field = column.length === 0 ? id : column[0].field;

      var self = this;
      var primer = function primer(a) {
        a = a === undefined || a === null ? '' : a;

        if (typeof a === 'string') {
          a = a.toUpperCase();

          if ($.isNumeric(a)) {
            a = parseFloat(a);
          }
        }
        return a;
      };

      var key = function key(x) {
        return primer(self.fieldValue(x, field));
      };

      ascending = !ascending ? -1 : 1;

      return function (a, b) {
        a = key(a);
        b = key(b);

        if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== (typeof b === 'undefined' ? 'undefined' : _typeof(b))) {
          a = a.toString().toLowerCase();
          b = b.toString().toLowerCase();
        }

        return ascending * ((a > b) - (b > a));
      };
    },


    /**
    * Determine equality for two deeply nested JavaScript objects.
    * @private
    * @param {object} obj1 First object to compare
    * @param {object} obj2 Second object to compare
    * @returns {boolean} If it is equal or not
    */
    isEquivalent: function isEquivalent(obj1, obj2) {
      function _equals(a, b) {
        return JSON.stringify(a) === JSON.stringify($.extend(true, {}, a, b));
      }
      return _equals(obj1, obj2) && _equals(obj2, obj1);
    },


    /**
     * The default formatter to use (just plain text). When no formatter is specified.
     * @param  {number} row The rowindex
     * @param  {number} cell The cell index
     * @param  {any} value The data value
     * @returns {string} The html string
     */
    defaultFormatter: function defaultFormatter(row, cell, value) {
      return value === null || value === undefined || value === '' ? '' : value.toString();
    },


    /**
    * Add the pager and paging functionality.
    * @private
    */
    handlePaging: function handlePaging() {
      var self = this;

      if (!this.settings.paging) {
        return;
      }

      var pagerElem = this.tableBody;
      this.element.addClass('paginated');
      pagerElem.pager({
        componentAPI: this,
        dataset: this.settings.dataset,
        hideOnOnePage: this.settings.hidePagerOnOnePage,
        source: this.settings.source,
        pagesize: this.settings.pagesize,
        indeterminate: this.settings.indeterminate,
        rowTemplate: this.settings.rowTemplate,
        pagesizes: this.settings.pagesizes,
        showPageSizeSelector: this.settings.showPageSizeSelector,
        activePage: this.restoreActivePage ? parseInt(this.savedActivePage, 10) : 1
      });

      if (this.restoreActivePage) {
        this.savedActivePage = null;
        this.restoreActivePage = false;
      }

      this.pager = pagerElem.data('pager');

      pagerElem.off('afterpaging').on('afterpaging', function (e, args) {
        // Hide the entire pager bar if we're only showing one page, if applicable
        if (self.pager.hidePagerBar(args)) {
          self.element.removeClass('paginated');
        } else {
          self.element.addClass('paginated');
        }

        self.recordCount = args.total;
        self.displayCounts(args.total);

        // Handle row selection across pages
        self.syncSelectedUI();

        if (self.filterExpr && self.filterExpr[0] && self.filterExpr[0].column === 'all') {
          self.highlightSearchRows(self.filterExpr[0].value);
        }
      });
    },


    /**
    * Add the pager and paging functionality.
    * @param {string} pagingInfo The paging object with activePage ect used by pager.js
    * @param {boolean} isResponse Internal flag used to prevent callbacks from rexecuting.
    * @param {function} callback The callback function.
    */
    renderPager: function renderPager(pagingInfo, isResponse, callback) {
      var api = this.pager;

      if (!api) {
        return;
      }

      api.updatePagingInfo(pagingInfo);

      if (!isResponse) {
        api.renderPages(pagingInfo.type, callback, pagingInfo.trigger);
      }

      // Update selected and Sync header checkbox
      this.syncSelectedUI();
    },


    /**
    * Reset the pager to the first page.
    * @private
    * @param {string} type The action type, which gets sent to the source callback.
    * @param {string} trigger The triggering action
    */
    resetPager: function resetPager(type, trigger) {
      if (!this.pager) {
        return;
      }

      if (!this.pager.pagingInfo) {
        this.pager.pagingInfo = {};
      }

      if (trigger) {
        this.pager.pagingInfo.trigger = trigger;
      }

      this.pager.pagingInfo.type = type;
      this.pager.pagingInfo.activePage = 1;
      this.renderPager(this.pager.pagingInfo);
    },


    /**
    * Add grid tooltip to the page.
    * @private
    * @param {string} extraClass class to add to target uniqueness
    * @returns {void}
    */
    appendTooltip: function appendTooltip(extraClass) {
      var _this7 = this;

      this.tooltip = document.getElementById('tooltip');

      if (!this.tooltip) {
        var tooltip = '' + ('<div id="tooltip" class="tooltip ' + extraClass + ' is-hidden">\n          <div class="arrow"></div>\n          <div class="tooltip-content"></div>\n        </div>');
        document.body.insertAdjacentHTML('beforeend', tooltip);

        this.tooltip = document.getElementById('tooltip');

        if (this.isTouch) {
          this.tooltip.style.pointerEvents = 'auto';
          $(this.tooltip).on('touchend.gridtooltip', function () {
            _this7.hideTooltip();
          });
        }
      }
    },


    /**
     * Cache tooltip content so it can use for more then once
     * @private
     * @param  {object} elem The element to be cached.
     * @param  {object} tooltip Optional to cache given data.
     * @returns {object} tooltip object.
     */
    cacheTooltip: function cacheTooltip(elem, tooltip) {
      if (typeof tooltip === 'undefined') {
        var contentTooltip = elem.querySelector('.is-editor.content-tooltip');
        var aTitle = elem.querySelector('a[title]');
        var isRowstatus = elem.classList.contains('rowstatus-cell');
        var isSvg = elem.tagName.toLowerCase() === 'svg';
        var isTh = elem.tagName.toLowerCase() === 'th';
        var title = void 0;

        tooltip = { content: '', wrapper: elem.querySelector('.datagrid-cell-wrapper') };

        if (isTh) {
          tooltip.wrapper = elem;
          tooltip.placement = 'bottom';
        }

        // Cache rowStatus cell
        if (isRowstatus || isSvg) {
          var rowNode = this.closest(elem, function (el) {
            return el.classList.contains('datagrid-row');
          });
          var classList = rowNode ? rowNode.classList : [];
          tooltip.isError = classList.contains('rowstatus-row-error') || classList.contains('rowstatus-row-dirtyerror');
          tooltip.placement = 'right';

          // For nonVisibleCellErrors
          if (isSvg) {
            tooltip.wrapper = this.closest(elem, function (el) {
              return el.tagName.toLowerCase() === 'td';
            });
          }
        }

        if (contentTooltip) {
          // Used with rich text editor
          var cell = elem.getAttribute('aria-colindex') - 1;
          var _col5 = this.columnSettings(cell);
          var width = _col5.editorOptions && _col5.editorOptions.width ? this.setUnit(_col5.editorOptions.width) : false;

          // Width for tooltip can be come from column options
          contentTooltip.style.width = width || elem.offsetWidth + 'px';
          var wrapperHTML = tooltip.wrapper.innerHTML;

          if (xssUtils.stripHTML(wrapperHTML) !== '') {
            tooltip.content = wrapperHTML;
            tooltip.extraClassList = ['popover', 'alternate', 'content-tooltip'];
          }
        } else if (aTitle) {
          // Title attribute on links `a`
          tooltip.content = aTitle.getAttribute('title');
          aTitle.removeAttribute('title');
        } else {
          title = elem.getAttribute('title');
          if (title) {
            // Title attribute on current element
            tooltip.content = title;
            elem.removeAttribute('title');
          } else {
            // Default use wrapper content
            tooltip.content = xssUtils.stripHTML(tooltip.wrapper.textContent);
          }
        }

        if (tooltip.content !== '') {
          var isEllipsis = elem.classList.contains('text-ellipsis');
          tooltip.textwidth = stringUtils.textWidth(tooltip.content) + (isEllipsis ? 8 : 0);
          tooltip.content = contentTooltip ? tooltip.content : '<p>' + tooltip.content + '</p>';
          if (title) {
            tooltip.forced = true;
          }
        }
      }

      elem = elem instanceof jQuery ? elem : $(elem);
      elem.data('gridtooltip', tooltip);
      return tooltip;
    },


    /**
     * Show Tooltip
     * @private
     * @param  {object} [options] for tooltip.
     * @param  {string} [options.content] The tooltip contents.
     * @param  {object} [options.wrapper] The parent DOM element.
     * @param  {boolean} [options.isError] True for if is error color.
     * @param  {string} [options.placement] 'top'|'right'|'bottom'|'left'.
     * @param  {array} [options.extraClassList] list of css classes to be added to tooltip.
     * @returns {void}
     */
    showTooltip: function showTooltip(options) {
      var _this8 = this;

      this.tooltip = document.getElementById('tooltip');
      if (this.tooltip) {
        var tooltip = $(this.tooltip);
        var tooltipContentEl = this.tooltip.querySelector('.tooltip-content');
        if (tooltipContentEl) {
          tooltipContentEl.innerHTML = options.content;
          this.tooltip.classList.remove('is-hidden', 'top', 'right', 'bottom', 'left');
          this.tooltip.style.display = '';
          this.tooltip.classList.add(options.placement || 'top');

          if (options.isError) {
            this.tooltip.classList.add('is-error');
          }
          if (options.extraClassList) {
            options.extraClassList.map(function (className) {
              return _this8.tooltip.classList.add(className);
            });
          }

          var distance = 10;
          var placeOptions = {
            x: 0,
            y: distance,
            container: this.element.closest('.page-container.scrollable') || $('body'),
            containerOffsetX: options.wrapper.offsetLeft,
            containerOffsetY: options.wrapper.offsetTop,
            parent: $(options.wrapper),
            placement: options.placement || 'top',
            strategies: ['flip', 'nudge']
          };
          if (placeOptions.placement === 'left' || placeOptions.placement === 'right') {
            placeOptions.x = distance;
            placeOptions.y = 0;
          }

          // If already have place instance
          if (tooltip.data('place')) {
            tooltip.data('place').place(placeOptions);
          } else {
            tooltip.place(placeOptions);
            tooltip.data('place').place(placeOptions);
          }

          // Flag to mark as gridtooltip
          tooltip.data('gridtooltip', true);

          tooltip.one('afterplace.gridtooltip', function (e, placementObj) {
            _this8.handleAfterPlaceTooltip(e, placementObj);
          }).on('click.gridtooltip', function () {
            _this8.hideTooltip();
          });

          // Hide the tooltip when the page scrolls.
          $('body, .scrollable').off('scroll.gridtooltip').on('scroll.gridtooltip', function () {
            _this8.hideTooltip();
          });
        }
      }
    },


    /**
     * Placement behavior's "afterplace" handler.
     * @private
     * @param {jquery.event} e custom `afterPlace` event
     * @param {placementobject} placementObj object containing placement settings
     * @returns {void}
     */
    handleAfterPlaceTooltip: function handleAfterPlaceTooltip(e, placementObj) {
      var tooltip = $('#tooltip');
      if (tooltip[0]) {
        tooltip.data('place').setArrowPosition(e, placementObj, tooltip);
        tooltip.triggerHandler('tooltipafterplace', [placementObj]);
      }
    },


    /**
     * Hide the visible tooltip.
     * @private
     * @returns {void}
     */
    hideTooltip: function hideTooltip() {
      var _this9 = this;

      if (this.tooltip) {
        this.removeTooltipData(this.tooltip); // Remove flag as gridtooltip
        this.tooltip.classList.add('is-hidden');
        this.tooltip.classList.remove('is-error', 'popover', 'alternate', 'content-tooltip');
        this.tooltip.style.left = '-999px';
      }

      // Remove scroll events
      $('body, .scrollable').off('scroll.gridtooltip', function () {
        _this9.hideTooltip();
      });
    },


    /**
     * Check for tooltip type gridtooltip or component
     * @private
     * @returns {boolean} True if is gridtooltip
     */
    isGridtooltip: function isGridtooltip() {
      var isGridtooltipType = false;
      if (this.tooltip) {
        var tooltipJQ = this.tooltip instanceof jQuery ? this.tooltip : $(this.tooltip);
        if (tooltipJQ.data('gridtooltip')) {
          isGridtooltipType = true;
        }
      }
      return isGridtooltipType;
    },


    /**
     * Remove the tooltip data from given node
     * @private
     * @param {object} elem The DOM element to remove data
     * @returns {void}
     */
    removeTooltipData: function removeTooltipData(elem) {
      elem = elem instanceof jQuery ? elem : $(elem);
      if (elem.data('gridtooltip')) {
        $.removeData(elem[0], 'gridtooltip');
      }
    },


    /**
     * Remove the tooltip from the DOM
     * @private
     * @returns {void}
     */
    removeTooltip: function removeTooltip() {
      var _this10 = this;

      if (this.tooltip) {
        var tooltip = $(this.tooltip);

        // Set selector
        var selector = {
          th: '.datagrid-header th',
          td: '.datagrid-body tr.datagrid-row td[role="gridcell"]:not(.rowstatus-cell)',
          rowstatus: '.datagrid-body tr.datagrid-row td[role="gridcell"] .icon-rowstatus'
        };
        selector.str = selector.th + ', ' + selector.td + ', ' + selector.rowstatus;

        // Unbind events
        $('body, .scrollable').off('scroll.gridtooltip');
        tooltip.off('touchend.gridtooltip');
        this.element.off('mouseenter.gridtooltip mouseleave.gridtooltip click.gridtooltip longpress.gridtooltip keydown.gridtooltip', selector.str);

        // Remove the place component
        var placeApi = tooltip.data('place');
        if (placeApi) {
          placeApi.destroy();
        }

        // Remove cached tooltip data
        var nodes = [].slice.call(this.element[0].querySelectorAll(selector.str));
        nodes.forEach(function (node) {
          return _this10.removeTooltipData(node);
        });

        if (this.tooltip.parentNode) {
          this.tooltip.parentNode.removeChild(this.tooltip);
        }
      }
      this.tooltip = undefined;
    },


    /**
    * Unwrap the grid back to a simple div, and destory all events and pointers.
    * @returns {object} The plugin api for chaining.
    */
    destroy: function destroy() {
      // Remove grid tooltip
      this.removeTooltip();

      // UnBind the pager
      if (this.tableBody.data() && this.tableBody.data('pager')) {
        this.tableBody.data('pager').destroy();
      }

      // Remove the toolbar, clean the div out and remove the pager
      this.element.off().empty().removeClass('datagrid-container');
      var toolbar = this.element.prev('.toolbar');

      this.triggerDestroyCell();

      if (this.removeToolbarOnDestroy && this.settings.toolbar && this.settings.toolbar.keywordFilter) {
        var searchfield = toolbar.find('.searchfield');
        if (searchfield.data('searchfield')) {
          searchfield.data('searchfield').destroy();
        }
        searchfield.removeData('options');
      }

      if (this.removeToolbarOnDestroy) {
        // only remove toolbar if it was created by this datagrid
        if (toolbar.data('toolbar')) {
          toolbar.data('toolbar').destroy();
        }
        toolbar.remove();
      }

      this.element.next('.pager-toolbar').remove();
      $.removeData(this.element[0], COMPONENT_NAME$1b);

      // TODO Test Memory Leaks in Chrome - null out fx this.table
      $(document).off('touchstart.datagrid touchend.datagrid touchcancel.datagrid click.datagrid touchmove.datagrid');
      this.contentContainer.off().remove();
      $('body').off('resize.vtable resize.datagrid');
      return this;
    },


    /**
    * Update the datagrid and optionally apply new settings.
    * @param  {object} settings the settings to update to.
    * @returns {object} The plugin api for chaining.
    */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      if (settings && settings.columns) {
        this.settings.columns = settings.columns;
      }

      this.render();

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Datagrid
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.datagrid = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1b);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1b, new Datagrid(this, settings));
      }
    });
  };

  // The Component Name
  var COMPONENT_NAME$1c = 'header';

  /**
   * Special Header with Toolbar at the top of the page used to faciliate SoHo Xi Nav Patterns
   * @class Header
   * @param {HTMLElement|jQuery[]} element the base element
   * @param {object} [settings] incoming settings
   * @param {boolean} [settings.demoOptions = true] Used to enable/disable default SoHo Xi options for demo purposes
   * @param {boolean} [settings.useBackButton = true] If true, displays a back button next to the title in the header toolbar
   * @param {boolean} [settings.useBreadcrumb = false] If true, displays a breadcrumb on drilldown
   * @param {boolean} [settings.usePopupmenu = false] If true, changes the Header Title into a popupmenu that can change the current page
   * @param {array} [settings.tabs = null] If defined as an array of Tab objects, displays a series of tabs that represent application sections
   * @param {array} [settings.wizardTicks = null] If defined as an array of Wizard Ticks, displays a Wizard Control that represents steps in a process
   * @param {boolean} [settings.useAlternate = null] If true, use alternate background/text color for sub-navigation areas
   * @param {boolean} [settings.addScrollClass = false] If true a class will be added as the page scrolls up and down
   * to the header for manipulation. Eg: Docs Page.
   */
  var HEADER_DEFAULTS = {
    demoOptions: true,
    useBackButton: true,
    useBreadcrumb: false,
    usePopupmenu: false,
    tabs: null,
    wizardTicks: null,
    useAlternate: false,
    addScrollClass: false
  };

  function Header(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, HEADER_DEFAULTS);
    this.init();
  }

  Header.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup().build().handleEvents();

      // Theme, Personalization, Language Changer, Scrolling
      if (this.settings.demoOptions) {
        this.initPageChanger();
      }
    },


    /**
     * @private
     * @returns {this} component instance
     */
    setup: function setup() {
      // TODO: Settings all work independently, but give better descriptions
      this.settings.demoOptions = this.element.attr('data-demo-options') ? this.element.attr('data-demo-options') === 'true' : this.settings.demoOptions;
      this.settings.useBackButton = this.element.attr('data-use-backbutton') ? this.element.attr('data-use-backbutton') === 'true' : this.settings.useBackButton;
      this.settings.useBreadcrumb = this.element.attr('data-use-breadcrumb') ? this.element.attr('data-use-breadcrumb') === 'true' : this.settings.useBreadcrumb;
      this.settings.useAlternate = this.element.attr('data-use-alternate') ? this.element.attr('data-use-alternate') === 'true' : this.settings.useAlternate;

      this.settings.tabs = !$.isArray(this.settings.tabs) ? null : this.settings.tabs;
      this.settings.wizardTicks = !$.isArray(this.settings.wizardTicks) ? null : this.settings.wizardTicks;

      this.titleText = this.element.find('.title > h1');

      // Used to track levels deep
      this.levelsDeep = [];
      this.levelsDeep.push('' + this.titleText.text());

      return this;
    },


    /**
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      this.toolbarElem = this.element.find('.toolbar');

      // Build toolbar if it doesn't exist
      if (!this.toolbarElem.data('toolbar')) {
        this.toolbarElem.toolbar();
      }
      this.toolbar = this.toolbarElem.data('toolbar');

      // Hamburger Icon is optional, but tracking it is necessary.
      this.titleButton = this.element.find('.title > .application-menu-trigger');
      this.hasTitleButton = this.titleButton.length > 0;

      if (this.hasTitleButton) {
        this.toolbarElem.addClass('has-title-button');
        var appMenu = $('#application-menu').data('applicationmenu');
        if (appMenu) {
          appMenu.modifyTriggers([this.titleButton], null, true);
        } else {
          $('#application-menu').applicationmenu({
            triggers: [this.titleButton]
          });
        }
      }

      // Application Tabs would be available from the Application Start, so activate
      // them during build if they exist
      if (this.settings.tabs && this.settings.tabs.length) {
        this.buildTabs();
      }

      if (this.settings.wizardTicks && this.settings.wizardTicks.length) {
        this.buildWizard();
      }

      if (this.settings.usePopupmenu) {
        this.buildPopupmenu();
      }

      // Add a Scrolling Class to manipulate the header
      if (this.settings.addScrollClass) {
        var self = $(this.element);
        var scrollDiv = $(this.element).next('.scrollable');
        var container = scrollDiv.length === 1 ? scrollDiv : $(window);
        var scrollThreshold = this.settings.scrollThreshold ? this.settings.scrollThreshold : 15;

        container.on('scroll.header', function () {
          if (this.scrollTop > scrollThreshold) {
            self.addClass('is-scrolled-down');
          } else {
            self.removeClass('is-scrolled-down');
          }
        });

        if (container.scrollTop() > scrollThreshold) {
          self.addClass('is-scrolled-down');
        }
      }

      return this;
    },


    /**
     * @private
     * @returns {void}
     */
    buildTitleButton: function buildTitleButton() {
      if (this.levelsDeep.length > 1 && !this.hasTitleButton && !this.titleButton.length) {
        this.titleButton = $('<button class="btn-icon back-button" type="button"></button>');
        this.titleButton.html('<span class="audible">' + Locale.translate('Drillup') + '</span>' + '<span class="icon app-header go-back">' + '<span class="one"></span>' + '<span class="two"></span>' + '<span class="three"></span>' + '</span>');
        this.titleButton.prependTo(this.element.find('.title'));

        // Need to trigger an update on the toolbar control to make sure tabindexes
        // and events are all firing on the button
        this.toolbar.element.triggerHandler('updated');
      }

      this.titleButton.find('.icon.app-header').addClass('go-back');
    },


    /**
     * Used for adding a Breadcrumb Element to the Header
     * @private
     * @returns {void}
     */
    buildBreadcrumb: function buildBreadcrumb() {
      var self = this;
      var breadcrumbClass = 'has-breadcrumb';

      if (this.settings.useAlternate) {
        breadcrumbClass = 'has-alternate-breadcrumb';
      }
      this.element.addClass(breadcrumbClass);

      this.breadcrumb = this.element.find('.breadcrumb');
      if (!this.breadcrumb.length) {
        this.breadcrumb = $('<nav class="breadcrumb hidden" role="navigation"></nav>').appendTo(this.element);
        this.breadcrumb.on('click', 'a', function (e) {
          self.handleBreadcrumbClick(e);
        });
      }

      this.breadcrumb[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate');
      this.adjustBreadcrumb();
    },


    /**
     * Builds Breadcrumb markup that reflects the current state of the application
     * @private
     * @returns {void}
     */
    adjustBreadcrumb: function adjustBreadcrumb() {
      var last = this.levelsDeep[this.levelsDeep.length - 1];
      this.breadcrumb.empty();

      var bcMarkup = $('<ol aria-label="breadcrumb"></ol>').appendTo(this.breadcrumb);
      $.each(this.levelsDeep, function (i, txt) {
        var current = '';
        if (last === txt) {
          current = ' current';
        }

        bcMarkup.append($('<li><a href="#" class="hyperlink' + current + '">' + txt + '</a></li>'));
      });
    },


    /**
     * Builds Header Tabs
     * @private
     * @returns {void}
     */
    buildTabs: function buildTabs() {
      this.tabsContainer = this.element.find('.tab-container');
      if (!this.tabsContainer.length) {
        this.tabsContainer = $('<div class="tab-container"></div>').appendTo(this.element);

        // TODO: Flesh this out so that the header control can build tabs based on options
        var tablist = $('<ul class="tab-list" role="tablist"></ul>').appendTo(this.tabsContainer);
        $('<li class="tab"><a href="#header-tabs-home" role="tab">SoHo Xi Controls | Patterns</a></li>').appendTo(tablist);
        $('<li class="tab"><a href="#header-tabs-level-1" role="tab">Level 1 Detail</a></li>').appendTo(tablist);
        $('<li class="tab"><a href="#header-tabs-level-2" role="tab">Level 2 Detail</a></li>').appendTo(tablist);
      }

      this.element.addClass(this.settings.useAlternate ? 'has-alternate-tabs' : 'has-tabs');
      this.tabsContainer[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate');

      // NOTE: For demo purposes the markup for tab panels is already inside the
      // Nav Patterns Test page.
      $('#header-tabs-level-1').removeAttr('style');
      $('#header-tabs-level-2').removeAttr('style');

      // Invoke Tabs Control
      this.tabsContainer.tabs({
        containerElement: '#maincontent'
      });
    },


    /**
     * Builds a Header Wizard
     * @private
     * @returns {void}
     */
    buildWizard: function buildWizard() {
      this.element.addClass('has-wizard');

      this.wizard = this.element.find('.wizard');
      if (!this.wizard.length) {
        this.wizard = $('<div class="wizard"></div>').appendTo(this.element);
        var header = $('<div class="wizard-header"></div>').appendTo(this.wizard);
        var bar = $('<div class="bar"></div>').appendTo(header);
        $('<div class="completed-range"></div>').appendTo(bar);

        // TODO: Flesh this out so the header control can build the Wizard Ticks based on options
        $('<a href="#" class="tick current"><span class="label">Context Apps</span></a>').appendTo(bar);
        $('<a href="#" class="tick"><span class="label">Utility Apps</span></a>').appendTo(bar);
        $('<a href="#" class="tick"><span class="label">Inbound Configuration</span></a>').appendTo(bar);
        $('<a href="#" class="tick"><span class="label">OID Mapping</span></a>').appendTo(bar);
      }

      this.wizard[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate');

      // NOTE: For Demo Purposes, the shifting forms associated with the Wizard are coded
      // inside the Nav Patterns Test page.
      // TODO: Build shifting forms

      // Invoke the Wizard Control
      this.wizard.wizard();
    },


    /**
     * Builds a Popupmenu in place of the usual Title text, to allow for context swapping.
     * @private
     * @returns {void}
     */
    buildPopupmenu: function buildPopupmenu() {
      var title = this.toolbarElem.children('.title');
      this.titlePopup = title.find('.btn-menu');
      if (!this.titlePopup.length) {
        var heading = title.find('h1'); // If H1 doesn't exist here, you're doing it wrong.
        heading.wrap('<button id="header-menu" type="button" class="btn-menu"></button>');
        this.titlePopup = heading.parent('.btn-menu');
      }
      this.titlePopupMenu = this.titlePopup.next('.popupmenu');
      if (!this.titlePopupMenu.length) {
        this.titlePopupMenu = $('<ul class="popupmenu is-selectable"></ul>').insertAfter(this.titlePopup);
        $('<li class="is-checked"><a href="#">Page One Title</a></li>' + '<li><a href="#">Page Two Title</a></li>' + '<li><a href="#">Page Three Title</a></li>' + '<li class="is-disabled"><a href="#">Page Four Title</a></li>' + '<li><a href="#">Page Five Title</a></li>').appendTo(this.titlePopupMenu);
      }
      this.titlePopupMenu.addClass('is-selectable');

      // Set the text on the Title
      var selectedText = this.titlePopupMenu.children('.is-checked').first().text();
      if (!selectedText) {
        selectedText = this.titlePopupMenu.children().first().text();
      }
      this.titlePopup.children('h1').text(selectedText);

      // Invoke the Popupmenu on the Title
      this.titlePopup.button().popupmenu();

      // Update the Header toolbar to account for the new button
      this.toolbarElem.triggerHandler('updated');
    },


    /**
     * Sets up header-level events
     * @fires Header#events
     * @listens updated
     * @listens reset
     * @listens drilldown
     * @listens drillup
     * @listens click
     * @listens selected
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.on('updated.header', function (e, settings) {
        self.updated(settings);
      }).on('reset.header', function () {
        self.reset();
      }).on('drilldown.header', function (e, viewTitle) {
        self.drilldown(viewTitle);
      }).on('drillup.header', function (e, viewTitle) {
        self.drillup(viewTitle);
      });

      // Events for the title button.  e.preventDefault(); stops Application Menu
      // functionality while drilled
      this.titleButton.bindFirst('click.header', function (e) {
        if (self.levelsDeep.length > 1) {
          e.stopImmediatePropagation();
          self.drillup();
          e.returnValue = false;
        }
      });

      // Popupmenu Events
      if (this.settings.usePopupmenu) {
        this.titlePopup.on('selected.header', function (e, anchor) {
          $(this).children('h1').text(anchor.text());
        });
      }

      return this;
    },


    /**
     * Handles click events on Breadcrumb elements
     * @private
     * @param {jQuery.Event} e `click` event
     * @returns {void}
     */
    handleBreadcrumbClick: function handleBreadcrumbClick(e) {
      var selected = $(e.target).parent();
      var breadcrumbs = this.breadcrumb.find('li');
      var selectedIndex = breadcrumbs.index(selected);
      var delta = void 0;

      if (selected.hasClass('current')) {
        return;
      }

      if (selectedIndex === 0) {
        this.reset();
        return;
      }

      if (selectedIndex < breadcrumbs.length - 1) {
        delta = breadcrumbs.length - 1 - selectedIndex;
        while (delta > 0) {
          this.drillup();
          delta -= 1;
        }
      }
    },


    /**
     * Sets up the `selected` events on the More Actions area of the header, which can include
     * Menu Options for changing the current theme, persoanlization colors, and language locale.
     * @private
     * @param {jQuery.Event} e `click` event
     * @returns {void}
     */
    initPageChanger: function initPageChanger() {
      this.element.find('.page-changer').on('selected.header', function (e, link) {
        // Change Theme
        if (link.attr('data-theme')) {
          var theme = link.attr('data-theme');
          $('body').trigger('changetheme', theme.replace('-theme', ''));
          return;
        }

        // TODO: Change Lang
        if (link.attr('data-lang')) {
          Locale.set(link.attr('data-lang'));
          return;
        }

        // Change Color
        var color = link.attr('data-rgbcolor');
        $('body').trigger('changecolors', [color]);
      });
    },


    /**
     * Drills deeper into a breadcrumb structure while updating the Header title to reflect state.
     * @private
     * @param {string} viewTitle text contents to put in place of the title area.
     * @returns {void}
     */
    drilldown: function drilldown(viewTitle) {
      this.element.addClass('is-drilldown');
      this.levelsDeep.push(viewTitle.toString());
      this.titleText.text(this.levelsDeep[this.levelsDeep.length - 1]);

      if (this.settings.useBackButton) {
        this.buildTitleButton();
      }

      if (this.settings.useBreadcrumb) {
        if (!this.breadcrumb || !this.breadcrumb.length) {
          this.buildBreadcrumb();
          this.breadcrumb.css({ display: 'block', height: 'auto' }).removeClass('hidden');
        } else {
          this.adjustBreadcrumb();
        }
      }
    },


    /**
     * Moves up into a breadcrumb structure while updating the Header title to reflect state.
     * @private
     * @param {string} viewTitle text contents to put in place of the title area.
     * @returns {void}
     */
    drillup: function drillup(viewTitle) {
      var title = void 0;
      this.element.removeClass('is-drilldown');

      if (this.levelsDeep.length > 1) {
        this.levelsDeep.pop();
        title = this.levelsDeep[this.levelsDeep.length - 1];
      }

      if (viewTitle !== undefined) {
        title = viewTitle;
      }

      if (this.levelsDeep.length > 1) {
        if (this.settings.useBreadcrumb) {
          this.adjustBreadcrumb();
        }
        this.titleText.text(title);
        return;
      }

      // Completely reset all the way back to normal
      title = this.levelsDeep[0];

      if (this.settings.useBackButton) {
        this.removeButton();
      }
      if (this.settings.useBreadcrumb) {
        this.removeBreadcrumb();
      }
      if (this.settings.usePopupmenu) {
        this.removePopupmenu();
      }

      this.titleText.text(title);
      this.element.trigger('drillTop');
    },


    /**
     * Reset the toolbar to its default removing the drilled in patterns.
     * @returns {this} component instance
     */
    reset: function reset() {
      while (this.levelsDeep.length > 1) {
        this.levelsDeep.pop();
      }
      this.titleText.text(this.levelsDeep[0]);

      this.removeBreadcrumb();
      this.removeTabs();
      this.removeWizard();
      this.removePopupmenu();
      this.removeButton();

      this.element.trigger('afterreset');
      return this;
    },


    /**
     * Removes a previously-built Button pattern from the Header.
     * @private
     * @returns {void}
     */
    removeButton: function removeButton() {
      if (this.hasTitleButton) {
        this.titleButton.find('.icon.app-header').removeClass('go-back');
        return;
      }

      if (this.titleButton && this.titleButton.length) {
        this.titleButton.remove();
        this.titleButton = $();

        // Need to trigger an update on the toolbar control to make sure
        // tabindexes and events are all firing on the button
        this.toolbar.element.triggerHandler('updated');
      }
    },


    /**
     * @public
     * Manually remove go-back class from button
     */
    removeBackButton: function removeBackButton() {
      this.element.find('.go-back').removeClass('go-back');
    },


    /**
     * Removes a previously-built Breadcrumb structure from the Header.
     * @private
     * @returns {void}
     */
    removeBreadcrumb: function removeBreadcrumb() {
      if (!this.breadcrumb || !this.breadcrumb.length) {
        return;
      }

      var self = this;
      var transitionEnd = $.fn.transitionEndName();
      var timeout = void 0;

      function destroyBreadcrumb() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }

        self.element.off(transitionEnd + '.breadcrumb-header');
        self.breadcrumb.off().remove();
        self.breadcrumb = $();
      }

      self.element.removeClass('has-breadcrumb').removeClass('has-alternate-breadcrumb');
      if (this.breadcrumb.is(':not(:hidden)')) {
        this.element.one(transitionEnd + '.breadcrumb-header', destroyBreadcrumb);
        timeout = setTimeout(destroyBreadcrumb, 300);
      } else {
        destroyBreadcrumb();
      }
    },


    /**
     * Removes a previously-built Header Tabs pattern from the Header.
     * @private
     * @returns {void}
     */
    removeTabs: function removeTabs() {
      if (!this.tabsContainer || !this.tabsContainer.length) {
        return;
      }

      var self = this;
      var transitionEnd = $.fn.transitionEndName();
      var timeout = void 0;

      function destroyTabs() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }

        self.element.off(transitionEnd + '.tabs-header');
        self.tabsContainer.data('tabs').destroy();
        self.tabsContainer.remove();
        self.tabsContainer = null;

        // NOTE: For demo purposes the markup for tab panels is already
        // inside the Nav Patterns Test page.
        $('#header-tabs-level-1').css('display', 'none');
        $('#header-tabs-level-2').css('display', 'none');
      }

      this.element.removeClass('has-tabs').removeClass('has-alternate-tabs');
      if (this.tabsContainer.is(':not(:hidden)')) {
        this.element.one(transitionEnd + '.tabs-header', destroyTabs);
        timeout = setTimeout(destroyTabs, 300);
      } else {
        destroyTabs();
      }
    },


    /**
     * Removes a previously-built Header Wizard pattern from the Header.
     * @private
     * @returns {void}
     */
    removeWizard: function removeWizard() {
      if (!this.wizard || !this.wizard.length) {
        return;
      }

      var self = this;
      var transitionEnd = $.fn.transitionEndName();
      var timeout = void 0;

      function destroyWizard() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }

        self.element.off(transitionEnd + '.wizard-header');
        self.wizard.data('wizard').destroy();
        self.wizard.remove();
        self.wizard = null;
      }

      this.element.removeClass('has-wizard');
      if (this.wizard.is(':not(:hidden)')) {
        this.element.one(transitionEnd + '.wizard-header', destroyWizard);
        timeout = setTimeout(destroyWizard, 300);
      } else {
        destroyWizard();
      }
    },


    /**
     * Removes a previously-built Popupmenu pattern from the Header's title.
     * @private
     * @returns {void}
     */
    removePopupmenu: function removePopupmenu() {
      var self = this;

      if (!this.titlePopup || !this.titlePopup.length) {
        return;
      }

      this.titlePopup.data('popupmenu').destroy();
      this.titlePopup.data('button').destroy();
      this.titlePopupMenu.remove();
      this.titlePopup.children('h1').detach().insertBefore(self.titlePopup);
      this.titlePopup.remove();

      this.titlePopup = undefined;
      this.titlePopupMenu = undefined;

      this.toolbarElem.triggerHandler('updated');
    },


    /**
     * Removes bound events from the Header
     * @private
     * @returns {this} component instance
     */
    unbind: function unbind() {
      this.titleButton.off('click.header');
      this.element.off('drilldown.header drillup.header');
      return this;
    },


    /**
     * Sync up the ui with settings.
     * @param {object} [settings] incoming settings.
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.reset().unbind().init();
    },


    /**
     * Teardown and destroy the menu and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      if (this.hasTitleButton) {
        this.toolbarElem.removeClass('has-title-button');
      }

      $.removeData(this.element[0], COMPONENT_NAME$1c);
    }
  };

  /**
   * jQuery Component Wrapper for Header
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.header = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1c);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1c, new Header(this, settings));
      }
    });
  };

  /* eslint-disable no-continue: "off, no-underscore-dangle */

  // Component Name
  var COMPONENT_NAME$1d = 'lookup';

  // Lookup components are "modal" (one on-screen at any given time)
  var LOOKUP_GRID_ID = 'lookup-datagrid';

  /**
   * Input element that opens a dialog with a list for selection.
   * @class Lookup
   * @param {jquery[]|htmlelement} element the base element
   * @param {object} [settings] incoming settings
   * @param {function} [settings.click] Provide a special function to run when the dialog opens to customize the interaction entirely.
   * @param {string} [settings.clickArguments={}] If a click method is defined, this flexible object can be passed
   * into the click method, and augmented with parameters specific to the implementation.
   * @param {string} [settings.field='id'] Field name to return from the dataset or can be a function which returns a string on logic
   * @param {string} [settings.title] Dialog title to show, or befault shows  field label + "Lookup"
   * @param {array} [settings.buttons] Pass dialog buttons or Cancel / Apply
   * @param {object} [settings.options] Options to pass to the datagrid
   * @param {function} [settings.beforeShow] Call back that executes async before the lookup is opened.
   * @param {string} [settings.modalContent] Custom modal markup can be sent in here
   * @param {boolean} [settings.editable=true] Can the user type text in the field
   * @param {boolean} [settings.autoApply=true] If set to false the dialog wont apply the value on clicking a value.
   * @param {function} [settings.validator] A function that fires to let you validate form items on open and select
   * @param {boolean} [settings.autoWidth=false] If true the field will grow/change in size based on the content selected.
   * @param {char} [settings.delimiter=','] A character being used to separate data strings
   */

  var LOOKUP_DEFAULTS = {
    click: null,
    field: 'id',
    title: null,
    buttons: [],
    options: null,
    beforeShow: null,
    modalContent: null,
    editable: true,
    typeahead: false, // Future TODO
    autoApply: true,
    validator: null,
    autoWidth: false,
    clickArguments: {},
    delimiter: ','
  };

  function Lookup(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, LOOKUP_DEFAULTS);
    this.init();
  }

  Lookup.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.inlineLabel = this.element.closest('label');
      this.inlineLabelText = this.inlineLabel.find('.label-text');
      this.isInlineLabel = !!this.inlineLabelText.length;
      this.build();
      this.handleEvents();
      this.grid = null;
      this.selectedRows = null;
    },


    /**
     * Build the UI for the Lookup
     * @private
     * @returns {void}
     */
    build: function build() {
      var lookup = this.element;

      // appends a wrapper to the lookup field.
      function getWrapperCSSClass() {
        var str = 'lookup-wrapper';

        if (lookup.is('.input-xs')) {
          str += ' xs';
        }
        if (lookup.is('.input-sm')) {
          str += ' sm';
        }
        if (lookup.is('.input-lg')) {
          str += ' lg';
        }

        return str;
      }
      var cssClass = getWrapperCSSClass();

      if (this.element.is('.has-actions')) {
        cssClass += ' has-actions-wrapper';
      }

      // Add Button
      this.icon = $('<span class="trigger" tabindex="-1"></span>').append($.createIcon('search-list'));
      if (this.isInlineLabel) {
        this.inlineLabel.addClass(cssClass);
      } else {
        this.container = $('<span class="' + cssClass + '"></span>');

        if (this.element.is('.field-options')) {
          var field = this.element.closest('.field');
          var fieldOptionsTrigger = field.find('.btn-actions');

          lookup.add(fieldOptionsTrigger).add(fieldOptionsTrigger.next('.popupmenu')).wrapAll(this.container);
        } else {
          lookup.wrap(this.container);
        }
      }

      lookup.after(this.icon);

      if (this.settings.autoWidth) {
        this.applyAutoWidth();
      }

      // Add Masking to show the #
      if (lookup.attr('data-mask')) {
        lookup.mask();
      }

      if (this.element.is(':disabled')) {
        this.disable();
      }

      if (!this.settings.editable) {
        this.element.attr('readonly', 'true').addClass('is-not-editable');
      }

      // Fix field options in case lookup is initialized after
      var wrapper = this.element.parent('.lookup-wrapper');
      if (wrapper.next().is('.btn-actions')) {
        if (this.element.data('fieldoptions')) {
          this.element.data('fieldoptions').destroy();
        }
        this.element.fieldoptions();
      }

      this.addAria();
    },


    /**
     * Add/Update Aria
     * @private
     * @returns {void}
     */
    addAria: function addAria() {
      var self = this;
      self.label = self.isInlineLabel ? self.inlineLabelText : $('label[for="' + self.element.attr('id') + '"]');

      if (self.label) {
        self.label.append('<span class="audible">' + Locale.translate('UseEnter') + '</span>');
      }
    },


    /**
     * Handle events on the field
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.icon.on('click.lookup', function (e) {
        self.openDialog(e);
      });

      // Down Arrow opens the dialog in this field
      this.element.on('keyup.lookup', function (e) {
        // If autocomplete open dont open list
        if ($('#autocomplete-list').length > 0) {
          return;
        }

        if (e.which === 40) {
          self.openDialog(e);
        }
      });
    },


    /**
     * Create and Open the Dialog
     * @private
     * @param {jquery.event} e click or keyup event
     * @returns {void}
     */
    openDialog: function openDialog(e) {
      var self = this;
      /**
        * Fires before open dialog.
        *
        * @event beforeopen
        * @memberof Lookup
        * @property {object} event - The jquery event object
        */
      var canOpen = self.element.triggerHandler('beforeopen');

      if (canOpen === false) {
        return;
      }

      if (self.isDisabled() || self.isReadonly() && !self.element.hasClass('is-not-editable')) {
        return;
      }

      if (self.settings.click) {
        self.settings.click(e, this, self.settings.clickArguments);
        return;
      }

      if (this.settings.beforeShow) {
        var response = function response(grid) {
          if (grid) {
            self.createGrid(grid);
          }

          if (typeof grid === 'boolean' && grid === false) {
            return false;
          }

          self.createModal();
          /**
            * Fires on complete dialog open (for busy indicator).
            *
            * @event complete
            * @memberof Lookup
            * @property {object} event - The jquery event object
            */
          self.element.triggerHandler('complete'); // for Busy Indicator

          /**
            * Fires on open dialog.
            *
            * @event open
            * @memberof Lookup
            * @property {object} event - The jquery event object
            * @property {object} modal instance
            * @property {object} grid in lookup
            */
          self.element.trigger('open', [self.modal, self.grid]);

          if (self.settings.validator) {
            self.settings.validator(self.element, self.modal, self.grid);
          }
          return true;
        };

        /**
          * Fires before start open dialog (for busy indicator).
          *
          * @event start
          * @memberof Lookup
          * @property {object} event - The jquery event object
          */
        this.element.triggerHandler('start'); // for Busy Indicator
        this.settings.beforeShow(this, response);
        return;
      }

      if (!this.settings.options) {
        return;
      }

      self.createModal();
      self.element.trigger('open', [self.modal, self.grid]);
      self.modal.element.find('.btn-actions').removeClass('is-selected');

      // Set tabindex on first row
      if (self.grid) {
        self.grid.cellNode(0, 0, true).attr('tabindex', '0');
      }

      // Fix: IE-11 more button was not showing
      var thisMoreBtn = self.modal.element.find('.toolbar .more > .btn-actions');
      if (thisMoreBtn.length) {
        setTimeout(function () {
          utils.fixSVGIcons(thisMoreBtn);
        }, 600);
      }

      /**
        * Fires after open dialog.
        *
        * @event afteropen
        * @memberof Lookup
        * @property {object} event - The jquery event object
        * @property {object} modal instance
        * @property {object} grid in lookup
        */
      self.element.trigger('afteropen', [self.modal, self.grid]);

      if (self.settings.validator) {
        self.settings.validator(self.element, self.modal, self.grid);
      }
    },


    /**
     * Overidable function to create the modal dialog
     * @returns {void}
     */
    createModal: function createModal() {
      var self = this;
      var content = '<div id="' + LOOKUP_GRID_ID + '"></div>';
      var thisLabel = $('label[for="' + self.element.attr('id') + '"]');

      function getLabelText() {
        if (self.isInlineLabel) {
          return self.inlineLabelText;
        }
        if (thisLabel.length) {
          return thisLabel.clone().find('span').remove().end().text();
        }
        if (self.settings.title) {
          return self.settings.title;
        }
        return '';
      }
      var labelText = getLabelText();

      var settingContent = this.settings.modalContent;
      if (settingContent && settingContent instanceof jQuery) {
        content = settingContent;
        settingContent.show();
      }

      if (settingContent && !(settingContent instanceof jQuery)) {
        content = settingContent;
      }

      var buttons = this.settings.buttons;
      if (this.settings.options && this.settings.options.selectable === 'multiple' && buttons.length === 0 || !self.settings.autoApply && buttons.length === 0) {
        buttons = [{
          text: Locale.translate('Cancel'),
          click: function click(e, modal) {
            self.element.focus();
            modal.close();
          }
        }, {
          text: Locale.translate('Apply'),
          click: function click(e, modal) {
            modal.close();
            self.insertRows(self.grid.selectedRows());
          },

          isDefault: true
        }];
      }

      if (this.settings.options && this.settings.options.selectable === 'single' && buttons.length === 0 && self.settings.autoApply) {
        buttons = [{
          text: Locale.translate('Cancel'),
          click: function click(e, modal) {
            self.element.focus();
            modal.close();
          }
        }];
      }

      var hasKeywordSearch = this.settings.options && this.settings.options.toolbar && this.settings.options.toolbar.keywordFilter;

      $('body').modal({
        title: labelText,
        content: content,
        buttons: buttons,
        cssClass: 'lookup-modal' + (!hasKeywordSearch ? ' lookup-no-search' : '')
      }).off('open.lookup').on('open.lookup', function () {
        self.createGrid();
      }).off('close.lookup').on('close.lookup', function () {
        self.element.focus();
        /**
          * Fires on close dialog.
          *
          * @event close
          * @memberof Lookup
          * @property {object} event - The jquery event object
          * @property {object} modal instance
          * @property {object} grid in lookup
          */
        self.element.triggerHandler('close', [self.modal, self.grid]);
      });

      self.modal = $('body').data('modal');
      if (!this.settings.title) {
        self.modal.element.find('.modal-title').append(' <span class="datagrid-result-count"></span>');
      }

      self.modal.element.off('afterclose.lookup').on('afterclose.lookup', function () {
        self.closeTearDown();
      });

      // Wait until search field available
      setTimeout(function () {
        $('.modal.is-visible .searchfield').on('keypress.lookup', function (e) {
          if (e.keyCode === 13) {
            return false; // Prevent for closing modal
          }
          return true;
        });
      }, 300);
    },


    /**
     * Tears down the modal/grid elements by removing events, markup, and component instances.
     * @private
     * @returns {void}
     */
    closeTearDown: function closeTearDown() {
      var search = $('.modal.is-visible .searchfield').off('keypress.lookup');
      if (search.data() && search.data('searchfield')) {
        search.data('searchfield').destroy();
      }

      if (search.data() && search.data('searchfield')) {
        search.data('searchfield').destroy();
        search.removeData();
      }
      search = null;

      if (this.grid && this.grid.destroy) {
        this.grid.destroy();
        this.grid = null;
      }
    },


    /**
     * Overridable Function in which we create the grid on the current UI dialog.
     * @interface
     * @param {jquery[]} grid jQuery wrapped element containing a pre-invoked datagrid instance
     * @returns {void}
     */
    createGrid: function createGrid(grid) {
      var self = this;
      var lookupGrid = void 0;

      if (grid) {
        lookupGrid = grid;
        LOOKUP_GRID_ID = grid.attr('id');
        self.settings.options = grid.data('datagrid').settings;
      } else {
        lookupGrid = self.modal.element.find('#' + LOOKUP_GRID_ID);
      }

      if (self.settings.options) {
        if (self.settings.options.selectable === 'single' && self.settings.autoApply) {
          self.settings.options.cellNavigation = false;
          lookupGrid.find('tr').addClass('is-clickable');
        }

        self.settings.options.isList = true;

        // Create grid (unless already exists from passed in grid)
        if (!lookupGrid.data('datagrid')) {
          lookupGrid.datagrid(self.settings.options);
        }
      }

      self.grid = lookupGrid.data('datagrid');
      if (!this.settings.title && self.modal) {
        self.modal.element.find('.title').not('.selection-count').remove();
      }

      var hasKeywordSearch = this.settings.options && this.settings.options.toolbar && this.settings.options.toolbar.keywordFilter;

      if (!hasKeywordSearch && self.modal) {
        self.modal.element.find('.toolbar').appendTo(self.modal.element.find('.modal-header'));
      }

      // Reset keyword search from previous loads
      if (hasKeywordSearch && self.grid) {
        if (!self.grid.filterExpr || self.grid.filterExpr && self.grid.filterExpr[0] && self.grid.filterExpr[0].value !== '') {
          self.grid.keywordSearch('');
        }
      }

      // Mark selected rows
      lookupGrid.off('selected.lookup');
      var val = self.element.val();
      if (val && !this.settings.options.source) {
        self.selectGridRows(val);
      }

      // Restore selected rows when pages change
      if (this.settings.options.source) {
        lookupGrid.off('afterpaging.lookup').on('afterpaging.lookup', function () {
          var fieldVal = self.element.val();
          if (fieldVal) {
            self.selectGridRows(fieldVal);
          }
        });
      }

      if (this.settings.options) {
        lookupGrid.on('selected.lookup', function (e, selectedRows) {
          // Only proceed if a row is selected
          if (!selectedRows || selectedRows.length === 0) {
            return;
          }

          if (self.settings.validator) {
            self.settings.validator(self.element, self.modal, self.grid);
          }

          if (self.settings.options.selectable === 'single' && self.settings.autoApply) {
            self.modal.close();
            self.insertRows();
          }
        });
      }
    },


    /**
     * Given a field value, select the row
     * @param {object} val incoming value from the grid row
     * @returns {void}
     */
    selectGridRows: function selectGridRows(val) {
      var selectedId = val;
      var adjust = false;

      if (!val) {
        return;
      }

      if (this.grid && this.settings.options.source) {
        for (var k = 0; k < this.grid._selectedRows.length; k++) {
          if (isNaN(this.grid._selectedRows[k].idx)) {
            this.grid._selectedRows.splice(k, 1);
          }
        }
      }

      // Multi Select
      if (selectedId.indexOf(this.settings.delimiter) > 1) {
        var selectedIds = selectedId.split(this.settings.delimiter);
        var isFound = false;

        for (var i = 0; i < selectedIds.length; i++) {
          isFound = this.selectRowByValue(this.settings.field, selectedIds[i]);

          if (this.grid && this.settings.options.source && !isFound) {
            var data = {};
            var foundInData = false;
            for (var j = 0; j < this.grid._selectedRows.length; j++) {
              if (this.grid._selectedRows[j].data[this.settings.field].toString() === selectedIds[i].toString()) {
                foundInData = true;
              }
            }

            if (!foundInData) {
              data[this.settings.field] = selectedIds[i];
              this.grid._selectedRows.push({ data: data });
            }
            adjust = true;
          }
        }

        // There are rows selected off page. Update the count.
        if (adjust) {
          this.modal.element.find('.contextual-toolbar .selection-count').text(selectedIds.length + ' ' + Locale.translate('Selected'));
        }
        return;
      }

      this.selectRowByValue(this.settings.field, selectedId);
    },


    /**
     * Find the row and select it based on select value / function / field value
     * @param {string} field the ID of the field whose value is to be returned.
     * @param {string} value the value to set.
     * @returns {boolean} True if the id is found.
     */
    selectRowByValue: function selectRowByValue(field, value) {
      if (!this.settings.options) {
        return false;
      }

      var data = this.settings.options.source ? this.grid.settings.dataset : this.settings.options.dataset;
      var selectedRows = [];

      // in this case we will recall on source - server side paging
      if (!data) {
        return false;
      }

      for (var i = 0; i < data.length; i++) {
        var isMatch = false;
        if (typeof this.settings.match === 'function') {
          if (this.settings.match(value, data[i], this.element, this.grid)) {
            isMatch = true;
          }
        }

        if (typeof this.settings.match !== 'function' && data[i][field].toString() === value.toString()) {
          isMatch = true;
        }

        if (isMatch) {
          var rowIndex = this.grid.settings.source ? this.grid.actualRowIndex(this.grid.tableBody.find('tr').eq(i)) : i;
          selectedRows.push(rowIndex);
        }
      }

      if (this.grid && selectedRows.length > 0) {
        this.grid.selectRows(selectedRows);
        return true;
      }
      return false;
    },


    /**
     * Get the selected rows and return them to the UI
     * @returns {void}
     */
    insertRows: function insertRows() {
      var value = '';

      this.selectedRows = this.grid.selectedRows();

      for (var i = 0; i < this.selectedRows.length; i++) {
        var currValue = '';

        if (typeof this.settings.field === 'function') {
          currValue = this.settings.field(this.selectedRows[i].data, this.element, this.grid);
        } else {
          currValue = this.selectedRows[i].data[this.settings.field];
        }

        value += (i !== 0 ? this.settings.delimiter : '') + currValue;

        // Clear _selected tag
        var idx = this.selectedRows[i].idx;
        if (this.settings.options.dataset && this.settings.options.dataset[idx]) {
          delete this.settings.options.dataset[idx]._selected;
        }
      }

      /**
        * Fires on input value change.
        *
        * @event change
        * @memberof Lookup
        * @property {object} event - The jquery event object
        * @property {object} selected rows
        */
      this.element.val(value).trigger('change', [this.selectedRows]);
      this.applyAutoWidth();
      this.element.focus();
    },


    /**
     * Enable the input.
     * @returns {void}
     */
    enable: function enable() {
      this.element.prop('disabled', false).prop('readonly', false);
      this.element.parent().removeClass('is-disabled');
    },


    /**
     * Disable the input.
     * @returns {void}
     */
    disable: function disable() {
      this.element.prop('disabled', true);
      this.element.parent().addClass('is-disabled');
    },


    /**
     * Make the input readonly.
     * @returns {void}
     */
    readonly: function readonly() {
      this.element.prop('readonly', true);
    },


    /**
     * Make the input the size of the text.
     * @private
     * @returns {void}
     */
    applyAutoWidth: function applyAutoWidth() {
      var value = this.element.val();
      var length = value.length;
      var isUpperCase = value === value.toUpperCase();
      var isNumber = !isNaN(value);

      this.element.attr('size', length + (isUpperCase && !isNumber ? 2 : 1));
    },


    /**
     * Input is disabled or not
     * @returns {boolean} whether or not the Input is disabled
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
     * Input is readonly or not
     * @returns {boolean} whether or not the Input is readonly
     */
    isReadonly: function isReadonly() {
      return this.element.prop('readonly');
    },


    /**
     * Updates the lookup instance with new settings
     * @param {object} settings incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }
    },


    /**
    * Send in a new data set to display in the datagrid in the lookup.
    * This will work whether or not the lookup is open or closed.
    * @param {object} dataset The array of data to show in the datagridgrid.
    * @param {object} pagerInfo The extra pager info object with information like activePage and pagesize.
    */
    updateDataset: function updateDataset(dataset, pagerInfo) {
      this.settings.options.dataset = dataset;

      if (pagerInfo && pagerInfo.activePage) {
        this.settings.options.activePage = pagerInfo.activePage;
      }

      if (pagerInfo && pagerInfo.pagesize) {
        this.settings.options.pagesize = pagerInfo.pagesize;
      }

      if (this.grid) {
        this.grid.updateDataset(dataset, pagerInfo);
      }
    },


    /**
    * Teardown events and objects.
    * @returns {void}
    */
    destroy: function destroy() {
      $.removeData(this.element[0], COMPONENT_NAME$1d);
      this.element.off('click.dropdown keypress.dropdown');

      this.icon.remove();
      this.element.unwrap();

      if (this.label && this.label != null) {
        this.label.find('.audible').remove();
      }
    }
  };

  /**
   * jQuery Component Wrapper for Lookup
   * @param {object} settings The settings to apply.
   * @returns {jQuery[]} The jquery object for chaining.
   */
  $.fn.lookup = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1d);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1d, new Lookup(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$1e = 'multitabs';

  // Default Settings for MultiTabs
  var MULTITABS_DEFAULTS = {
    tabContainers: []
  };

  // Pre-defined names used internally for tab containers
  var TAB_CONTAINER_NAMES = ['primary', 'secondary', 'tertiary'];

  /**
   * Scaffolding for containment of multiple, associated tabs containers.
   *
   * @class MultiTabs
   * @param {jQuery[]|HTMLElement} element base element
   * @param {object} [settings] incoming settings
   * @param {array} [settings.tabContainers] contains pre-set tab containers
   */
  function MultiTabs(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, MULTITABS_DEFAULTS);

    // internal stuff
    this.tabContainers = {};

    return this.init();
  }

  MultiTabs.prototype = {
    /**
     * Extra initializing steps
     * @private
     * @returns {void}
     */
    init: function init() {
      var self = this;
      var tabContainers = [];

      if (this.settings.tabContainers instanceof Array && this.settings.tabContainers.length) {
        tabContainers = this.settings.tabContainers;
      } else {
        tabContainers = this.element.find('.tab-container').filter(function () {
          return !$(this).parents('.tab-panel-container').length;
        });
      }

      $(tabContainers).each(function () {
        self.setupTabsInstance($(this));
      });
    },


    /**
     * Builds and stores an instance of a Tabs component.
     * @param {jQuery[]} tabContainer a reference to a `.tab-container` element.
     * @returns {void}
     */
    setupTabsInstance: function setupTabsInstance(tabContainer) {
      if (!(tabContainer instanceof $)) {
        return;
      }

      var self = this;
      var didAdd = false;

      TAB_CONTAINER_NAMES.forEach(function (propname) {
        if (didAdd || Object.prototype.hasOwnProperty.call(self.tabContainers, propname)) {
          return;
        }

        var api = tabContainer.data('tabs');
        if (!api) {
          tabContainer.tabs();
          api = tabContainer.data('tabs');
        }
        api.multitabsID = propname;

        tabContainer.attr('data-multitabs', propname);
        self.tabContainers[propname] = tabContainer;
        didAdd = true;
      });

      if (!didAdd) {
        throw new Error('all tab-container slots in MultiTabs component are taken, so a new tabs container was not invoked and stored');
      }
    },


    /**
     * Pass-through method for adding tabs that takes the container into account.
     * @param {jQuery[]|String} tabContainer the tab container to target
     * @param {string} tabId (directly passed into the Tabs `add` method)
     * @param {object} options (directly passed into the Tabs `add` method)
     * @param {number} [atIndex] (directly passed into the Tabs `add` method)
     * @returns {Tabs} the tabs API
     */
    add: function add(tabContainer, tabId, options, atIndex) {
      tabContainer = this.checkForValidTabContainer(tabContainer);

      var api = tabContainer.data('tabs');
      return api.add(tabId, options, atIndex);
    },


    /**
     * Pass-through method for removing tabs that takes the container into account.
     * @param {jQuery[]|String} tabContainer the tab container being removed
     * @param {string} tabId - (directly passed into the Tabs `add` method)
     * @param {boolean} [disableBeforeClose] - (directly passed into the Tabs `add` method)
     * @returns {Tabs} the tabs API instance
     */
    remove: function remove(tabContainer, tabId, disableBeforeClose) {
      tabContainer = this.checkForValidTabContainer(tabContainer);

      var api = tabContainer.data('tabs');
      return api.remove(tabId, disableBeforeClose);
    },


    /**
     * Finds an existing Tab Panel in any of the tab containers, and moves it
     *  to a designated target tab container.
     * @param {string} tabId the ID of the tab panel (and HREF attribute of the tab) being moved.
     * @param {string} targetTabContainerName name of the tab container that will receive the panel.
     * @param {boolean} [doActivate] optionally activtes the tab after it's moved.
     * @returns {void}
     */
    move: function move(tabId, targetTabContainerName, doActivate) {
      if (!tabId || !targetTabContainerName) {
        throw new Error('can\'t move a tab without both a tabId and a targetTabContainerName');
      }

      var tabMarkup = void 0;
      var panelMarkup = void 0;
      var allTabContainers = this.getFilterableTabContainers();
      var originalTabContainerName = void 0;

      allTabContainers.each(function () {
        var api = $(this).data('tabs');
        var tab = api.getTab(null, tabId);

        // No tabs exist by this id
        if (tab === null) {
          return;
        }

        originalTabContainerName = api.multitabsID;
        tabMarkup = tab.clone();
        panelMarkup = api.getPanel(tabId).children();
      });

      if (!tabMarkup) {
        throw new Error('No tab markup was found in any Multitabs container for href "' + tabId + '"');
      }

      this.remove(originalTabContainerName, tabId);
      this.add(targetTabContainerName, tabId, {
        name: tabMarkup.children('a').text().trim(),
        content: panelMarkup,
        doActivate: doActivate
      }); // TODO: test atIndex
    },


    /**
     * Uses the internal name of the tab container to either get a reference to an existing
     *  Tab container, or a null reference.
     * @private
     * @param {string} name - the internal name used for this tabs instance
     * @returns {jQuery[]|undefined} a tab container reference
     */
    getTabContainer: function getTabContainer(name) {
      var self = this;
      var ref = void 0;

      TAB_CONTAINER_NAMES.forEach(function (propname) {
        if (ref || !self.tabContainers[propname]) {
          return;
        }

        if (name === propname) {
          ref = self.tabContainers[propname];
        }
      });

      return ref;
    },


    /**
     * Gets all currently-setup tab containers in a jQuery selector.
     * @private
     * @returns {jQuery[]} a jQuery-based collection of all available tab containers
     */
    getFilterableTabContainers: function getFilterableTabContainers() {
      var ret = $();

      this.performOnAllContainers(function (propname, container) {
        ret = ret.add(container);
      });

      return ret;
    },


    /**
     * Validates an incoming tabContainer name, or jQuery-wrapped Tab Container instance, and returns.
     * @private
     * @param {jQuery[]|string} tabContainer the tab container being checked
     * @returns {jQuery[]} the validated tab container
     */
    checkForValidTabContainer: function checkForValidTabContainer(tabContainer) {
      if (!tabContainer) {
        throw new Error('Need to have a tabContainer defined to hide a tabs instance');
      }
      if (typeof tabContainer === 'string') {
        tabContainer = this.getTabContainer(tabContainer);
      }
      if (!(tabContainer instanceof $) || !tabContainer.length) {
        throw new Error('No matching tabContainer could be found and hidden.');
      }

      return tabContainer;
    },


    /**
     * Runs a callback function on all available tab containers.
     * @param {function} callback the callback function to be executed
     * @param {array} [additionalArgs] any additional arguments to be run in the
     *  context of the callback.
     * @returns {void}
     */
    performOnAllContainers: function performOnAllContainers(callback, additionalArgs) {
      var self = this;

      // Make sure additionalArgs is an array of some sort.
      if (!Array.isArray(additionalArgs)) {
        if (!additionalArgs) {
          additionalArgs = [];
        } else {
          additionalArgs = [additionalArgs];
        }
      }

      TAB_CONTAINER_NAMES.forEach(function (propname) {
        var container = self.tabContainers[propname];
        var args = [];

        if (container) {
          args.push(propname, container);
          args = args.concat(additionalArgs);
          callback.apply(this, args);
        }
      });
    },


    /**
     * Re-adjust Module-tab containers' tab widths/alignments so everything lines up.
     * @private
     * @returns {void}
     */
    adjustModuleTabContainers: function adjustModuleTabContainers() {
      this.performOnAllContainers(function (propname, container) {
        var api = container.data('tabs');
        if (api.isModuleTabs()) {
          api.adjustModuleTabs();
        }
      });
    },


    /**
     * Temporarily removes a tabset from view without destroying it.
     * @param {jQuery[]|string} tabContainer the tab container to be hidden.
     * @returns {void}
     */
    hideTabsInstance: function hideTabsInstance(tabContainer) {
      tabContainer = this.checkForValidTabContainer(tabContainer);
      tabContainer.parent('.multitabs-section').addClass('hidden');
      this.adjustModuleTabContainers();
    },


    /**
     * Re-displays a tabset that has temporarily been removed from view.
     * @param {jQuery[]|string} tabContainer the tab container to be shown.
     * @returns {void}
     */
    showTabsInstance: function showTabsInstance(tabContainer) {
      tabContainer = this.checkForValidTabContainer(tabContainer);
      tabContainer.parent('.multitabs-section').removeClass('hidden');
      this.adjustModuleTabContainers();
    },


    /**
     * Destroys a tabs instance and removes it from the queue.
     * NOTE: This only happens if the tabContainer is a part of this instance of Multitabs.
     * @param {jQuery[]} tabContainer the tab container to be destroyed.
     * @returns {void}
     */
    destroyTabsInstance: function destroyTabsInstance(tabContainer) {
      if (!(tabContainer instanceof $) || !tabContainer.data('tabs') || typeof tabContainer.data('tabs').destroy !== 'function') {
        return;
      }

      var self = this;
      var doRemove = false;

      TAB_CONTAINER_NAMES.forEach(function (propname) {
        if (doRemove || !self.tabContainers[propname].is(tabContainer)) {
          return;
        }

        var api = tabContainer.data('tabs');

        delete api.multitabsID;
        tabContainer.removeAttr('data-multitabs');

        api.destroy();
        delete self.tabContainers[propname];
        doRemove = true;
      });

      if (!doRemove) {
        throw new Error('could not destroy a tabContainer because it was not associated with this Multitabs instance');
      }
    },


    /**
     * Detects whether or not a Tab Container is currently hidden
     * @param {jQuery[]|string} tabContainer the tab container to be checked.
     * @returns {boolean} whether or not the tab container is currently hidden.
     */
    isHidden: function isHidden(tabContainer) {
      tabContainer = this.checkForValidTabContainer(tabContainer);
      return tabContainer.parent('.multitabs-section').is('.hidden');
    },


    /**
     * Update this multi-tabs instance with new settings
     * @param {object} [settings] incoming settings.
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }
    },


    /**
     * Tears down a Multitabs instance
     * @returns {this} component instance
     */
    teardown: function teardown() {
      var _this = this;

      var containers = Object.keys(this.tabContainers);
      containers.forEach(function (container) {
        _this.destroyTabsInstance(container);
      });

      return this;
    },


    /**
     * Destroys a Multitabs instance
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$1e);
    }
  };

  /**
   * jQuery Component Wrapper for MultiTabs
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} invoked/updated component elements
   */
  $.fn.multitabs = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1e);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1e, new MultiTabs(this, settings));
      }
    });
  };

  // All desired Soho jQuery-based components ==================== /

  // Component Name
  var COMPONENT_NAME$1f = 'listdetail';
  // Available breakpoint types for Edge Bleeding
  var LIST_DETAIL_EDGE_BLEED_BREAKPOINTS = ['phone', 'tablet'];

  /**
   * @class ListDetail
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {HTMLElement} [settings.backElement] defines a trigger button that will be used to "drill up" from the detail
   * back to the list on the responsive view of this pattern.
   * @param {boolean} [settings.edgeBleed=false] if true, will show an interactive edge of the "list" element while the
   * detail view is active.  Clicking the left edge (or a button in the left edge) will cause the "drillup" operation to occur
   * while making the list active.
   * @param {string} [settings.edgeBleedBreakpoint='phone'] Defines the breakpoint where the responsive "edge bleeding" style will occur.
   * @param {HTMLElement} [settings.listElement] the base element for the Soho component that will be used as the "List" to be chosen from.
   * Must implement a Soho Accordion or Listview element.
   * @param {HTMLElement} [settings.listCloseElement]  defines a trigger button element that can be used to collapse a bleeding-edge list drawer.
   * @param {HTMLElement} [settings.detailElement] the base element for the Soho component that will be used as "detail" or content area that can
   * change based on what is picked from the list.
   */
  var LIST_DETAIL_DEFAULTS = {
    backElement: undefined,
    edgeBleed: false,
    edgeBleedBreakpoint: LIST_DETAIL_EDGE_BLEED_BREAKPOINTS[0],
    listElement: undefined,
    listCloseElement: undefined,
    detailElement: undefined
  };

  // Available Soho Elements to be used as the list
  var LIST_DETAIL_SUPPORTED_LIST_TYPES = ['accordion', 'listview'];

  /**
   * Gets the type of list component
   * @private
   * @param {HTMLElement} listElement the element being checked
   * @returns {string|undefined} the type of component, or undefined
   */
  function getListType(listElement) {
    if (!(listElement instanceof HTMLElement)) {
      return undefined;
    }

    var components = Object.keys($(listElement).data());
    var type = void 0;
    components.forEach(function (key) {
      if (LIST_DETAIL_SUPPORTED_LIST_TYPES.indexOf(key) > -1) {
        type = key;
      }
    });

    return type;
  }

  /**
   * Checks an HTMLElement for a Soho Component instance that can be used for the list
   * @private
   * @param {HTMLElement} listElement the element being checked
   * @returns {boolean} whether or not the element is a valid list type
   */
  function isValidList(listElement) {
    if (!(listElement instanceof HTMLElement)) {
      return false;
    }

    var type = getListType(listElement);
    return type !== undefined;
  }

  /**
   * Implements cross-functionality between a list component and a content area that are described by
   * a Soho List/Detail pattern
   * @constructor
   * @param {HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   * @returns {void}
   */
  function ListDetail(element, settings) {
    if (!(element instanceof HTMLElement)) {
      return;
    }

    this.element = element;
    this.settings = utils.mergeSettings(this.element, settings, LIST_DETAIL_DEFAULTS);
    this.init();
  }

  ListDetail.prototype = {

    /**
     * @private
     */
    init: function init() {
      var _this = this;

      this.setInternalElementReference('listElement', function (elemType) {
        return isValidList(_this.settings[elemType]);
      });
      this.setInternalElementReference('detailElement');
      this.setInternalElementReference('backElement');
      this.setInternalElementReference('listCloseElement');

      // Single sanity-check for showing the detail area.
      this.showDetail = false;
      if (this.element.classList.contains('show-detail')) {
        this.showDetail = true;
      }

      // If a proper listElement has been provided, set a flag on its Component API
      // that notifies the API that it's controlling an adjacent detail area.
      if (this.listElement) {
        this.listComponentType = getListType(this.listElement);
        var API = this.getListAPI();
        if (API) {
          API.isControllingDetails = true;
        }
      }

      if (this.backElement) {
        this.backElement.classList.add('list-detail-back-button');

        // If it's an icon button, get a reference to the icon so we can change its state.
        var hasIcon = this.backElement.querySelector('.icon');
        if (hasIcon) {
          this.backElementIcon = hasIcon;
        }

        // Setup internal references that can be used to find out where a backElement
        // is located internally in this pattern instance.
        this.listContainsBackElement = this.listElement.contains(this.backElement);
        this.detailContainsBackElement = this.detailElement.contains(this.backElement);
      }

      // Gets children list/detail components
      var children = this.element.querySelectorAll('.list-detail');
      if (children) {
        this.childrenListDetailElements = children;
      }

      // Change edgebleed setting
      if (this.settings.edgeBleed) {
        this.edgeBleed = true;
        this.element.classList.add('bleeding-edge__' + this.settings.edgeBleedBreakpoint);
      } else {
        this.edgeBleed = false;
        this.element.classList.remove('bleeding-edge__phone', 'bleeding-edge__tablet');
      }

      // Flags for responsive behavior
      this.setBreakpointChecks();

      this.handleEvents();
    },


    /**
     * Sets internal checks for certain breakpoints
     * @private
     * @returns {void}
     */
    setBreakpointChecks: function setBreakpointChecks() {
      this.abovePhoneBreakpoint = breakpoints.isAbove('phone-to-tablet');
      this.aboveTabletBreakpoint = breakpoints.isAbove('desktop');
    },


    /**
     * Takes elements defined as settings properties, and evaluates them to determine if they
     * are valid. If so, they are set as internal component properties for future use.
     * @private
     * @param {string} elementType corresponds to a setting on the pattern that
     *  represents an element reference.
     * @param {function} [storageConditions] if defined as a function, will provide an
     *  additional set of parameters for determining if an HTMLElement is valid for this element type.
     * @returns {void}
     */
    setInternalElementReference: function setInternalElementReference(elementType, storageConditions) {
      if (typeof this.settings[elementType] === 'string' && this.settings[elementType].length) {
        var queryForElem = document.querySelector(this.settings[elementType]);
        if (queryForElem) {
          this.settings[elementType] = queryForElem;
        }
      }

      // Set to true to simply pass the next check, if a callback isn't provided.
      // Otherwise, resolve the callback (which should return a boolean)
      if (typeof storageConditions !== 'function') {
        storageConditions = true;
      } else {
        storageConditions = storageConditions(elementType);
      }

      if (this.settings[elementType] instanceof HTMLElement && storageConditions) {
        this[elementType] = this.settings[elementType];
      }
    },


    /**
     * @private
     * @listens drilldown custom jQuery event that causes the detail area to become active
     * @listens drillup custom jQuery event that causes the list area to become active
     * @listens click
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      $(this.element).on('drilldown.' + COMPONENT_NAME$1f, function (e, item) {
        e.stopPropagation();
        _this2.drilldown(item, e.target);
      }).on('drillup.' + COMPONENT_NAME$1f, function (e) {
        e.stopPropagation();
        _this2.drillup();
      });

      if (this.backElement) {
        this.backElement.addEventListener('click', this.handleBackClick.bind(this));
      }

      if (this.listCloseElement) {
        this.listCloseElement.addEventListener('click', this.handleClose.bind(this));
      }

      // Run certain responsive checks on page resize
      $('body').off('resize.' + COMPONENT_NAME$1f).on('resize.' + COMPONENT_NAME$1f, function () {
        _this2.handleResize();
      });
    },


    /**
     * Causes the list/detail pattern to activate the detail area, "drilling down"
     *  into it, away from the list area.
     * @param {HTMLElement} section provides context from the element chosen from the list
     * @param {HTMLElement} [eventTarget] will cause the drilldown operation to stop if the
     *  element provided isn't registered as the list in this list/detail instance (used when
     *  events trigger this method).
     * @returns {void}
     */
    drilldown: function drilldown(section, eventTarget) {
      if (this.showDetail) {
        return;
      }

      // If eventTarget's provided, check to see if it's the same element as the
      // stored ListElement.  If they're not, don't continue (could have been triggered
      // by an inner-detail area ListView/Accordion)
      if (eventTarget && eventTarget.innerHTML !== this.listElement.innerHTML) {
        return;
      }

      this.showDetail = true;
      this.element.classList.add('show-detail');

      this.addBackElementIconContext();

      if (!this.isAboveBreakpoint()) {
        this.getListAPI().disable();
      }

      // Pass an event to the Detail Area's main element with some context about
      // what was clicked inside the list.
      if (this.detailArea) {
        $(this.detailElement).triggerHandler('activatescreen', [section]);
      }
    },


    /**
     * Causes the list/detail pattern to activate the list area, "drilling up" from the detail area.
     * @returns {void}
     */
    drillup: function drillup() {
      if (!this.showDetail) {
        return;
      }

      this.removeBackElementIconContext();

      this.getListAPI().enable();

      this.showDetail = false;
      this.element.classList.remove('show-detail');
    },


    /**
     * @private
     * @returns {void}
     */
    addBackElementIconContext: function addBackElementIconContext() {
      if (this.showDetail && this.backElementIcon && !this.backElementIcon.classList.contains('go-back')) {
        this.backElementIcon.classList.add('go-back');
      }
    },


    /**
     * @private
     * @returns {void}
     */
    removeBackElementIconContext: function removeBackElementIconContext() {
      if (this.backElementIcon && this.backElementIcon.classList.contains('go-back')) {
        this.backElementIcon.classList.remove('go-back');
      }
    },


    /**
     * Handles `click` events passed to the `backElement`.
     * @private
     * @param {Event} e `click` event
     * @returns {boolean} whether or not the click operation should be allowed to continue
     */
    handleBackClick: function handleBackClick(e) {
      function cancelClick() {
        // Prevent the normal `click` operation of the backElement.
        // (FX: if `backElement` is the App Menu trigger, prevents the App Menu from opening)
        e.stopPropagation();
        e.stopImmediatePropagation();
        e.preventDefault();
      }

      if (!this.showDetail) {
        // In "edgeBleed" configuration, the BackElement can be used to drill back into a previously
        // selected list item, if one was previously selected.
        if (this.edgeBleed) {
          var selected = this.getCurrentSelectedListItem();
          if (selected) {
            this.drilldown(selected);
            cancelClick();
            return false;
          }
        }

        return true;
      }

      this.drillup();

      if (this.childrenListDetailElements) {
        this.childrenListDetailElements.forEach(function (elem) {
          var api = $(elem).data(COMPONENT_NAME$1f);
          if (api && typeof api.drillup === 'function') {
            api.drillup();
          }
        });
      }

      cancelClick();
      return false;
    },


    /**
     * Handler for the listCloseElement's `click` event.
     * @returns {void}
     */
    handleClose: function handleClose() {
      if (this.showDetail) {
        return;
      }

      // `selected` may be undefined here
      var selected = this.getCurrentSelectedListItem();
      this.drilldown(selected);
    },


    /**
     * Event handler for `body.on('resize')`. Runs whenever the page is resized.
     * @returns {void}
     */
    handleResize: function handleResize() {
      this.setBreakpointChecks();
      var listAPI = this.getListAPI();

      if (this.isAboveBreakpoint()) {
        if (this.edgeBleed && !this.showDetail && this.listElement.classList.contains('is-disabled')) {
          listAPI.enable();
        }
      } else if (this.edgeBleed && this.showDetail && !this.listElement.classList.contains('is-disabled')) {
        listAPI.disable();
      }

      // Removes the `go-back` class from the hamburger icon if we're above the breakpoint.
      if (this.isAboveBreakpoint()) {
        this.removeBackElementIconContext();
      } else {
        this.addBackElementIconContext();
      }

      // Make sure the list is always re-enabled on desktop
      if (breakpoints.isAbove('desktop')) {
        listAPI.enable();
      }
    },


    /**
     * Checks to see if the screen size is currently above the defined breakpoint
     * @returns {boolean} whether or not the screen size is larger than the defined breakpoint.
     */
    isAboveBreakpoint: function isAboveBreakpoint() {
      var breakpoint = this.settings.edgeBleedBreakpoint;
      var breakpointPropname = 'above' + stringUtils.capitalize(breakpoint) + 'Breakpoint';

      return this[breakpointPropname];
    },


    /**
     * Gets a reference to the defined List Element's Component API.
     * @returns {object|undefined} a Soho Component API from a supported list type, or undefined
     * if no API currently exists.
     */
    getListAPI: function getListAPI() {
      if (!this.listElement) {
        return undefined;
      }
      return $(this.listElement).data(this.listComponentType);
    },


    /**
     * Finds whatever item is currently selected by the listElement.
     * @returns {HTMLElement} a reference to that element.
     */
    getCurrentSelectedListItem: function getCurrentSelectedListItem() {
      if (!this.listElement) {
        return '';
      }

      var item = void 0;
      var API = this.getListAPI();

      switch (this.listComponentType) {
        case 'accordion':
          item = API.getSelected();
          break;
        default:
          // 'listview'
          item = API.getSelected();
          break;
      }

      // Most components are still using jQuery,
      // Run through a simple reference extraction to get at the HTMLElement
      item = DOM.convertToHTMLElement(item);

      return item;
    },


    /**
     * Updates the List/Detail pattern with new settings
     * @param {object} [settings] incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.teardown();
      this.init();
    },


    /**
     * Removes all bound events and internal references to other components' elements/APIs
     * @private
     * @returns {void}
     */
    teardown: function teardown() {
      $('body').off('resize.' + COMPONENT_NAME$1f);

      $(this.element).off('drilldown.' + COMPONENT_NAME$1f + ' drillup.' + COMPONENT_NAME$1f);

      if (this.backElement) {
        this.backElement.removeEventListener('click', this.handleBackClick.bind(this));
      }

      if (this.listCloseElement) {
        this.listCloseElement.removeEventListener('click', this.handleClose.bind(this));
      }

      if (this.listComponentType) {
        var API = this.getListAPI();
        if (API) {
          delete API.isControllingDetails;
        }
      }

      delete this.listElement;
      delete this.detailElement;
      delete this.backElement;
      delete this.backElementIcon;
      delete this.edgeBleed;
      delete this.listContainsBackElement;
      delete this.detailContainsBackElement;
      delete this.childrenListDetailElements;
      delete this.showDetail;
    },


    /**
     * @private
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element, COMPONENT_NAME$1f);
    }
  };

  /**
   * jQuery Component Wrapper for List/Detail Pattern
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */
  $.fn.listdetail = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1f);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1f, new ListDetail(this, settings));
        instance.destroy = function destroy() {
          this.teardown();
          $.removeData(this, COMPONENT_NAME$1f);
        };
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$1g = 'stepprocess';

  // Default Stepprocess Options
  var STEPPROCESS_DEFAULTS = {
    linearProgression: false,
    folderIconOpen: 'caret-up',
    folderIconClosed: 'caret-down',
    stepList: '#step-list',
    stepLi: '.js-step',
    stepLink: '.js-step-link',
    stepFolder: '.js-step-folder',
    btnPrev: '.js-step-link-prev',
    btnNext: '.js-step-link-next',
    btnSaveClose: '.js-btn-save-changes',
    beforeSelectStep: null
  };

  /**
   * A Stepprocess/wizard control
   *
   * @class Stepprocess
   * @param {string} element The component element.
   * @param {string} [settings] The component settings.
   * @param {boolean} [settings.linearProgression = false] The Main Application Name to display
   in the header. (Defaults to false)
   * @param {string} [settings.folderIconOpen = 'caret-up'] A specific folder open icon. (Defaults to 'caret-up')
   * @param {string} [settings.folderIconClosed =  'caret-down'] A specific folder close icon. (Defaults to 'caret-down')
   * @param {boolean} [settings.stepList = '#step-list'] Determines whether or not to display device
   information (Browser, Platform, Locale, Cookies Enabled).
   * @param {string} [settings.stepLi = '.js-step'] jQuery selector for the step elements.
   * @param {boolean} [settings.stepLink =  '.js-step-link'] jQuery selector for the step link elements.
   * @param {string} [settings.stepFolder = '.js-step-folder'] jQuery selector for the step folder elements.
   * @param {string} [settings.btnPrev = '.js-step-link-prev'] jQuery selector for the previous step button.
   * @param {string} [settings.btnNext = '.js-step-link-prev'] jQuery selector for the next step button.
   * @param {function} [settings.beforeSelectStep] A callback (function or promise)
   that gives args: stepLink (the step link element) and isStepping
   (whether we are prev/next'ing or not).
   */
  function Stepprocess(element, settings) {
    this.settings = utils.mergeSettings(element, settings, STEPPROCESS_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Stepprocess Methods
  Stepprocess.prototype = {

    /**
     * Init stepprocess
     * @private
     */
    init: function init() {
      this.stepListJq = $(this.settings.stepList);
      this.initStepprocess();
      this.handleKeys();
      this.setupEvents();
      this.focusFirst();
    },


    /**
     * Initialize stepprocess
     * @private
     * @returns {void}
     */
    initStepprocess: function initStepprocess() {
      var steps = this.stepListJq.find(this.settings.stepLi);

      for (var i = 0, l = steps.length; i < l; i++) {
        this.decorateNode(steps[i]);
      }

      var startingStep = $(this.settings.stepLi + '.is-selected');
      var startingStepLink = startingStep.find(this.settings.stepLink);
      this.selectStep(startingStepLink);
    },


    /**
     * Set initial attributes on each step its counterparts
     * @private
     * @param  {object} step - The step element to decorate
     * @returns {void}
     */
    decorateNode: function decorateNode(step) {
      var self = this;
      var stepJq = $(step);
      var stepLinkJq = stepJq.children(this.settings.stepLink);
      var stepFolderJq = stepJq.children(this.settings.stepFolder);
      var isDisabled = stepLinkJq.hasClass('is-disabled');
      var isOpen = stepFolderJq.hasClass('is-open');

      if (isDisabled) {
        stepLinkJq.attr('aria-disabled', 'true');
      }

      if (stepFolderJq.length) {
        stepJq.addClass('folder');
        stepFolderJq.attr('role', 'group');

        if (isDisabled) {
          stepFolderJq.addClass('disabled');

          if (isOpen) {
            var stepLinks = stepFolderJq.children();

            for (var i = 0, l = stepLinks.length; i < l; i++) {
              $(stepLinks[i]).find(self.settings.stepLink).addClass('is-disabled').attr('aria-disabled', 'true');
            }
          }
        }

        stepLinkJq.attr('aria-expanded', isOpen);
      }

      // parentCount 'aria-level' to the node's level depth
      var parentCount = stepLinkJq.parentsUntil(this.stepListJq, 'ul').length - 1;

      // Set the current stepprocess item node position relative to its aria-setsize
      var posinset = stepJq.index();

      // Set the current stepprocess item aria-setsize
      var listCount = stepJq.siblings().addBack().length;

      stepLinkJq.attr({
        role: 'stepitem',
        tabindex: '-1',
        'aria-selected': 'false',
        'aria-level': parentCount + 1,
        'aria-posinset': posinset + 1,
        'aria-setsize': listCount,
        'aria-disabled': isDisabled
      }).addClass('hide-focus').hideFocus();
    },


    /**
     * Set tabindex to be focus first
     * @private
     * @returns {void}
     */
    focusFirst: function focusFirst() {
      this.stepListJq.find(this.settings.stepLi + ':first').attr('tabindex', '0');
    },


    /**
     * Set initial attributes on each step its counterparts
     * @private
     * @param  {object} step - The step element
     * @returns {void}
     */
    folderClose: function folderClose(step) {
      var _this = this;

      var stepJq = $(step);
      var stepLinkJq = stepJq.children(this.settings.stepLink);
      var stepFolderJq = stepJq.children(this.settings.stepFolder);

      var treeIcon = stepLinkJq.closest('.folder').removeClass('is-open').end().find('svg.icon-tree');

      this.setIcon(treeIcon, this.settings.folderIconClosed);
      this.isAnimating = true;

      stepFolderJq.one('animateclosedcomplete', function () {
        stepFolderJq.removeClass('is-open');
        _this.isAnimating = false;
      }).animateClosed();

      stepLinkJq.attr('aria-expanded', 'false');
    },


    /**
     * Folder open
     * @private
     * @param  {object} step - The step element
     * @returns {void}
     */
    folderOpen: function folderOpen(step) {
      var _this2 = this;

      var stepJq = $(step);

      if (!this.isOpen(stepJq)) {
        var stepLinkJq = stepJq.children(this.settings.stepLink);
        var stepFolderJq = stepJq.children(this.settings.stepFolder);

        stepJq.addClass('is-open');
        stepLinkJq.attr('aria-expanded', 'true');

        var svgElem = stepLinkJq.find('svg.icon-tree');
        this.setIcon(svgElem, this.settings.folderIconOpen);

        this.isAnimating = true;

        stepFolderJq.one('animateopencomplete', function () {
          _this2.isAnimating = false;
        }).addClass('is-open').css('height', 0).animateOpen();
      }
    },


    /**
     * Folder toggle
     * @private
     * @param  {object} stepLink - Description
     * @returns {void}
     */
    folderToggle: function folderToggle(stepLink) {
      var stepJq = stepLink.closest(this.settings.stepLi);

      if (this.isFolder(stepJq)) {
        var stepFolderJq = stepJq.children(this.settings.stepFolder);
        if (this.isOpen(stepFolderJq)) {
          this.folderClose(stepJq);
        } else {
          this.folderOpen(stepJq);
        }
      }
    },


    /**
     * Get selected step
     * @private
     * @returns {object} selected step
     */
    getSelectedStep: function getSelectedStep() {
      return $(this.settings.stepLi + '.is-selected', this.stepListJq);
    },


    /**
     * Get next node
     * @private
     * @param  {object} stepLink - The step link element
     * @returns {object} node
     */
    getNextNode: function getNextNode(stepLink) {
      var s = this.settings;
      var next = stepLink.parent().next().find(s.stepLink + ':first');
      var nextStepJq = next.closest(s.stepLi);

      // Possibly Move Into Children
      if (stepLink.next().is(s.stepFolder) && stepLink.next().hasClass('is-open')) {
        next = stepLink.next().find(s.stepLink + ':first');
      }

      // Skip disabled
      if (next.hasClass('is-disabled')) {
        next = nextStepJq.next().find(s.stepLink + ':first');
      }

      // Bottom of a group..{l=2: max folders to be deep }
      if (next.length === 0) {
        for (var i = 0, l = 2, closest = stepLink; i < l; i++) {
          closest = closest.parent().closest('.folder');
          next = closest.next().find(s.stepLink + ':first');
          if (next.length) {
            break;
          }
        }
      }
      return next;
    },


    /**
     * Get the next step in the tree
     * (not to be confused with getNextNode, which includes folders)
     * @private
     * @returns {object} next step
     */
    getNextStep: function getNextStep() {
      var curStepJq = this.getSelectedStep();
      var curStepLinkJq = curStepJq.children(this.settings.stepLink);
      var curStepFolderJq = curStepJq.next(this.settings.stepFolder);
      var nextStepLinkJq = this.getNextNode(curStepLinkJq);
      var nextStepFolderJq = nextStepLinkJq.next(this.settings.stepFolder);
      var stepLinkToSelect = null;
      var theFolder = null;

      if (curStepFolderJq.length) {
        // Select the first node of the current folder,
        // unless its empty, which means nextStep will be the folder's "title"
        theFolder = curStepFolderJq;
        stepLinkToSelect = theFolder.children().length ? theFolder.find(this.settings.stepLink).first() : nextStepLinkJq;
      } else if (nextStepFolderJq.length) {
        // Select the first node of the next node's folder,
        // unless its empty, which means nextStep will be the folder's "title"
        theFolder = nextStepFolderJq;
        stepLinkToSelect = theFolder.children().length ? theFolder.find(this.settings.stepLink).first() : nextStepLinkJq;
      } else {
        // Neither folders options work so select the next node
        stepLinkToSelect = nextStepLinkJq;
      }

      return stepLinkToSelect;
    },


    /**
     * Get the previous node
     * @private
     * @param  {object} stepLink - The step link element
     * @returns {object} previous node
     */
    getPreviousNode: function getPreviousNode(stepLink) {
      var s = this.settings;
      var prev = stepLink.parent().prev().find(s.stepLink + ':first');
      var prevStepJq = prev.closest(s.stepLi);

      // Move into children at bottom
      if (prevStepJq.is('.folder.is-open') && prevStepJq.find('ul.is-open a').length && !prevStepJq.find('ul.is-disabled').length) {
        prev = prevStepJq.find('ul.is-open ' + s.stepLink + ':last');
      }

      // Skip disabled
      if (prev.hasClass('is-disabled')) {
        prev = prevStepJq.prev().find(s.stepLink + ':first');
      }

      // Top of a group
      if (prev.length === 0) {
        prev = stepLink.closest(s.stepFolder).prev(s.stepLink);
      }
      return prev;
    },


    /**
     * Get the previous step in the tree
     * (not to be confused with getPreviousNode, which includes folders)
     * @private
     * @param  {object} stepLink - The step link element
     * @returns {object} previous step
     */
    getPreviousStep: function getPreviousStep() {
      var s = this.settings;
      // Get the currently select node
      var curStepJq = this.getSelectedStep();
      var curStepLinkJq = curStepJq.children(s.stepLink);

      // Get the previous step to switch to
      var prevStepLinkJq = this.getPreviousNode(curStepLinkJq);
      var prevStepJq = prevStepLinkJq.closest(s.stepLi);
      var stepLinkToSelect = prevStepLinkJq;

      // If we are moving upwards and hit a folder title step
      if (this.isFolder(prevStepJq)) {
        if (this.isOpen(prevStepJq)) {
          // If the folder is open, and we got here, that means we
          // were currently at the first step in the folder and need to
          // go to the prev step above the folder step (aka the prev to the prev)
          stepLinkToSelect = this.getPreviousNode(prevStepLinkJq);
        } else {
          var theFolder = prevStepJq.children(s.stepFolder);

          if (theFolder.children().length) {
            stepLinkToSelect = theFolder.find(s.stepLink).last();
          }
        }
      }
      return stepLinkToSelect;
    },


    /**
     * Go to the next step element
     * @private
     * @returns {void}
     */
    goToNextStep: function goToNextStep() {
      var self = this;
      var stepLink = self.getNextStep();
      if (stepLink.length) {
        self.selectStep(stepLink, 'next');
      } else if (typeof self.settings.beforeSelectStep === 'function') {
        var args = { isStepping: 'next' };
        self.settings.beforeSelectStep(args);
      }
    },


    /**
     * Go to the previous step element
     * @private
     * @returns {void}
     */
    goToPreviousStep: function goToPreviousStep() {
      var stepLink = this.getPreviousStep();
      if (stepLink.length) {
        this.selectStep(stepLink, 'prev');
      }
    },


    /**
     * Key Behavior as per:
     * http://access.aol.com/dhtml-style-guide-working-group/#treeview
     * @private
     * @returns {void}
     */
    handleKeys: function handleKeys() {
      /* eslint-disable consistent-return */
      var self = this;
      var s = this.settings;

      this.stepListJq.on('focus.stepprocess', s.stepLink, function () {
        var target = $(this);
        if (parseInt(target.attr('aria-level'), 10) === 0 && parseInt(target.attr('aria-posinset'), 10) === 1) {
          // First element if disabled
          if (target.hasClass('is-disabled')) {
            var e = $.Event('keydown.stepprocess');
            e.keyCode = 40; // move down
            target.trigger(e);
            return; // eslint-disable-line
          }
        }
      });

      // Handle Up/Down Arrow Keys and Space
      this.stepListJq.on('keydown.stepprocess', s.stepLink, function (e) {
        var charCode = e.charCode || e.keyCode;
        var target = $(this);
        var next = void 0;
        var prev = void 0;

        if (self.isAnimating) {
          return;
        }

        // Down arrow
        if (charCode === 40) {
          var nextNode = self.getNextNode(target);
          self.setFocus(nextNode);
        }

        // Up arrow,
        if (charCode === 38) {
          var prevNode = self.getPreviousNode(target);
          self.setFocus(prevNode);
        }

        // Space
        if (e.keyCode === 32) {
          target.trigger('click.stepprocess');
        }

        // Left arrow
        if (charCode === 37) {
          if (Locale.isRTL()) {
            if (target.next().hasClass('is-open')) {
              prev = target.next().find(s.stepLink + ':first');
              self.setFocus(prev);
            } else {
              self.folderToggle(target);
            }
          } else if (target.next().hasClass('is-open')) {
            self.folderToggle(target);
          } else {
            prev = target.closest('.folder').find(s.stepLink + ':first');
            self.setFocus(prev);
          }
          e.stopPropagation();
          return false;
        }

        // Right arrow
        if (charCode === 39) {
          if (Locale.isRTL()) {
            if (target.next().hasClass('is-open')) {
              self.folderToggle(target);
            } else {
              next = target.closest('.folder').find(s.stepLink + ':first');
              self.setFocus(next);
            }
          } else if (target.next().hasClass('is-open')) {
            next = target.next().find(s.stepLink + ':first');
            self.setFocus(next);
          } else {
            self.folderToggle(target);
            self.setFocus(target);
          }
          e.stopPropagation();
          return false; // eslint-disable-line
        }

        // Home  (fn-right on mac)
        if (charCode === 36) {
          next = self.stepListJq.find(s.stepLink + ':first:visible');
          self.setFocus(next);
        }

        // End (fn-right on mac)
        if (charCode === 35) {
          next = self.stepListJq.find(s.stepLink + ':last:visible');
          self.setFocus(next);
        }
      });

      // Handle Left/Right Arrow Keys
      this.stepListJq.on('keypress.stepprocess', s.stepLink, function (e) {
        var charCode = e.charCode || e.keyCode;
        var target = $(this);

        if (charCode >= 37 && charCode <= 40 || charCode === 32) {
          e.stopPropagation();
          return false;
        }

        // Printable Chars Jump to first high level node with it...
        if (e.which !== 0) {
          target.closest(s.stepLi).nextAll().find('.js-step-link:visible').each(function () {
            var node = $(this);
            var first = node.text().substr(0, 1).toLowerCase();
            var term = String.fromCharCode(e.which).toLowerCase();

            if (first === term) {
              self.setFocus(node);
              return false;
            }
          });
        }
      });
      /* eslint-enable consistent-return */
    },


    /**
     * Checks if given step element is folder.
     * @private
     * @param {object} step - The step element
     * @returns {boolean} true if folder
     */
    isFolder: function isFolder(step) {
      return $(step).hasClass('folder');
    },


    /**
     * Checks if given step element is in folder.
     * @private
     * @param {object} step - The step element
     * @returns {boolean} true is in folder
     */
    isInFolder: function isInFolder(step) {
      return $(step).closest(this.settings.stepFolder, this.stepListJq).length;
    },


    /**
     * Checks if given step folder is open.
     * @private
     * @param {object} stepFolder element
     * @returns {boolean} true is open
     */
    isOpen: function isOpen(stepFolder) {
      return $(stepFolder).hasClass('is-open');
    },


    /**
     * Set focus on given step link.
     * @private
     * @param {object} stepLink element
     * @returns {void}
     */
    setFocus: function setFocus(stepLink) {
      stepLink.focus();
    },


    /**
     * Replace all "icon-", "hide-focus", "\s? - all spaces if any" with nothing.
     * @private
     * @param {object} svg element.
     * @param {string} icon to set.
     * @returns {void}
     */
    setIcon: function setIcon(svg, icon) {
      var iconStr = icon.replace(/icon-|hide-focus|\s?/gi, '');
      svg.changeIcon(iconStr);
    },


    /**
     * Select a step
     * @private
     * @param  {object} stepLink - The jquery object for the step link element
     * @param  {string} linearDirection - [none|previous|next] Which direction we are traveling
     * @returns {void}
     */
    selectStep: function selectStep(stepLink, linearDirection) {
      var self = this;
      if (linearDirection === undefined) {
        linearDirection = 'none';
      }

      // Possibly Call the beforeSelectStep
      var result = void 0;
      if (typeof self.settings.beforeSelectStep === 'function') {
        var args = {
          stepLink: stepLink,
          isStepping: linearDirection
        };
        result = self.settings.beforeSelectStep(args);

        if (result.done && typeof result.done === 'function') {
          // A promise is returned
          result.done(function (continueSelectNode, stepLinkToSelect) {
            if (continueSelectNode) {
              if (stepLinkToSelect) {
                stepLink = stepLinkToSelect;
              }
              self.selectStepFinish(stepLink, linearDirection);
            }
          });
        } else if (result) {
          // boolean is returned instead of a promise
          self.selectStepFinish(stepLink, linearDirection);
        }
      } else {
        // No Callback specified
        self.selectStepFinish(stepLink, linearDirection);
      }
    },


    /**
     * Finishes selecting a step
     * @private
     * @param  {object} stepLink - Description
     * @param  {string} [linearDirection=previous|next] - Description
     * @returns {void}
     */
    selectStepFinish: function selectStepFinish(stepLink, linearDirection) {
      var self = this;
      var allStepLinksJq = $(this.settings.stepLink, this.stepListJq);
      var stepJq = stepLink.closest(this.settings.stepLi);

      allStepLinksJq.attr({
        tabindex: '-1',
        'aria-selected': 'false'
      }).parent().removeClass('is-selected');

      stepLink.attr({
        tabindex: '0',
        'aria-selected': 'true'
      });

      stepJq.addClass('is-selected');

      if (this.isFolder(stepJq)) {
        // It is a folder
        if (linearDirection === 'none') {
          this.folderToggle(stepJq); // clicking toggles
        } else {
          this.folderOpen(stepJq); // going prev/next always opens
        }
      } else {
        // Its not a folder
        var parentIsFolder = stepJq.closest(this.settings.stepFolder, this.stepListJq);

        if (parentIsFolder.length) {
          // If the step is in a folder, make sure that folder opens
          this.folderOpen(parentIsFolder.closest(this.settings.stepLi));
        }

        // Show the step's panel
        this.showStepPanel(stepLink.attr('href'));
      }
      stepLink.focus();

      setTimeout(function () {
        /**
         * Fires when selected step link.
         * @event selected
         * @memberof Stepprocess
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} stepLink element
         */
        self.element.triggerHandler('selected', stepLink);
      }, 0);
    },


    /**
     * Un selected node
     * @private
     * @param {object} step - The step element to decorate
     * @returns {void}
     */
    unSelectedNode: function unSelectedNode(step) {
      var aTags = $(this.settings.stepLink, this.stepListJq);
      var stepJq = $(step);
      var stepLinkJq = stepJq.children(this.settings.stepLink);

      aTags.attr('tabindex', '-1');
      stepLinkJq.attr('tabindex', '0');

      stepJq.removeClass('is-selected');
      stepLinkJq.attr('aria-selected', 'false');
    },


    /**
     * Setup events
     * @private
     * @returns {void}
     */
    setupEvents: function setupEvents() {
      var _this3 = this;

      var self = this;
      var s = this.settings;

      // Updated and Click events
      this.stepListJq.on('updated.stepprocess', function () {
        _this3.initStepprocess();
      }).on('click.stepprocess', s.stepLink + ':not(.is-clone)', function (e) {
        e.preventDefault();

        if (!s.linearProgression) {
          var targetJq = $(this);

          if (!targetJq.is('.is-disabled, .is-loading')) {
            self.selectStep(targetJq);
            e.stopPropagation();
          }
        }
      });

      // Next Button Click
      $(s.btnPrev).on('click', function (e) {
        e.preventDefault();
        _this3.goToPreviousStep.call(self);
      });

      // Previous Button Click
      $(s.btnNext).on('click', function (e) {
        e.preventDefault();
        _this3.goToNextStep.call(self);
      });

      // Setup main scrolling
      $(s.contentScroll).scrollaction({
        scrollActionTarget: '.main'
      });

      // Setup sidebar scrolling
      $(s.stepListScroll).scrollaction({
        scrollActionTarget: '.sidebar'
      });

      // Toggle sidebar
      // Button to toggle the tree in responsive view
      $('.js-toggle-sidebar').click(function (e) {
        e.preventDefault();
        _this3.element.toggleClass('tablet-hide-steps').toggleClass('phone-hide-steps');
      });
    },


    /**
     * Show the content panel for the step
     * @private
     * @param  {string} contentId - The contentId to show
     * @returns {void}
     */
    showStepPanel: function showStepPanel(contentId) {
      $('.step-panel-active').removeClass('step-panel-active');
      $(contentId).addClass('step-panel-active');
      this.element.addClass('phone-hide-steps');
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.stepListJq.off('updated.stepprocess click.stepprocess focus.stepprocess keydown.stepprocess keypress.stepprocess').empty();
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, STEPPROCESS_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$1g);
    }
  };

  /**
   * jQuery Component Wrapper for Stepprocess
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.stepprocess = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1g);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1g, new Stepprocess(this, settings));
      }
    });
  };

  // Soho Patterns (jQuery Components)

  // Component Defaults
  var INITIALIZE_DEFAULTS = {
    locale: null
  };

  // Contains excluded CSS selectors that prevent automatic initialization
  var noinitExcludes = '.no-init, [data-init]';

  // Invokes a Soho component against an Element
  function invoke(elem, pluginName, settings) {
    return $(elem)[pluginName](settings);
  }

  // Finds child elements that match a CSS selector
  function matchedItems(elem, selector) {
    var items = elem.find(selector).not(noinitExcludes);
    if (elem.filter(selector).length) {
      items = items.add(elem);
    }
    return items;
  }

  // Array of plugin names, selectors (optional), and callback functions (optional),
  // for no-configuration initializations.
  var PLUGIN_MAPPINGS = [

  // Mobile Zoom Control
  // Needs manual invokation because the rest of initialization is scoped to the
  // calling element, which is the <body> tag.
  ['zoom', null, function () {
    $('head').zoom();
  }],

  // Application Menu
  ['applicationmenu', '#application-menu', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      $(item).applicationmenu({
        triggers: rootElem.find('.application-menu-trigger')
      });
    });
  }],

  // Personalization
  ['personalize', null, function () {
    $('html').personalize();
  }],

  // Hyperlinks
  ['hyperlink'],

  // Icons
  ['icon'],

  // Radio switch
  ['radio', '.radio-section input:radio.handle', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).change(function () {
      if (this.checked) {
        var option = $(this).closest('.option');
        var siblings = option.siblings();
        var fields = 'button, select, input[type="text"]';

        $(fields, option).removeAttr('disabled');
        $(fields, siblings).attr('disabled', 'disabled');
      }
    });
  }], ['splitter'],

  // Tabs
  ['tabs', '.tab-container:not(.vertical)'],

  // Vertical Tabs
  ['verticaltabs', '.tab-container.vertical'],

  // MultiTabs Containers
  ['multitabs', '.multitabs-container'],

  // Select / DropDowns
  ['dropdown', 'select.dropdown:not(.multiselect)'], ['dropdown', 'select.dropdown-xs:not(.multiselect)'], ['dropdown', 'select.dropdown-sm:not(.multiselect)'], ['dropdown', 'select.dropdown-lg:not(.multiselect)'],

  // Modals
  ['modal'],

  // Sliders
  ['slider', 'input[type="range"], .slider'],

  // Editors
  ['editor'],

  // Tooltips
  ['tooltip', 'button[title], span[title], .hyperlink[title], .icon[title]'],

  // Tree
  ['tree'],

  // Rating
  ['rating'],

  // Listbuilder
  ['listbuilder'],

  // Composite Form Wrapper
  ['compositeform', '.composite-form'],

  // Progress
  ['progress', '.progress-bar'],

  // Format
  ['mask', 'input[data-mask], .new-mask'],

  // Auto Complete
  ['autocomplete', '.autocomplete:not([data-init])'],

  // Multiselect
  ['multiselect', 'select[multiple]:not(.dropdown), .multiselect:not([data-init])'],

  // Button with Effects
  ['button', ['.btn', '.btn-toggle', '.btn-secondary', '.btn-primary', '.btn-modal-primary', '.btn-tertiary', '.btn-icon', '.btn-actions', '.btn-menu', '.btn-split', '.btn-secondary-border'].join(', ')],

  // Hide Focus
  ['hideFocus', 'a.hide-focus, a.tick, .checkbox, .radio, .switch'],

  // Circle Pager
  ['circlepager'],

  // Clear x
  ['clearable', '[data-clearable="true"]'],

  // Text Area
  ['textarea', 'textarea'],

  // Spinbox
  ['spinbox'],

  // sort drag and drop
  ['arrange'],

  // Swap List
  ['swaplist'],

  // Color Picker
  ['colorpicker'],

  // Date Picker
  ['datepicker'],

  // Time Picker
  ['timepicker'],

  // Tag
  ['tag'],

  // Busy Indicator
  ['busyindicator', '.busy, .busy-xs, .busy-sm'], ['header'], ['fileupload', 'input.fileupload:not(.fileupload-background-transparent)'], ['fileuploadadvanced', '.fileupload-advanced'], ['fieldfilter', '.field-filter'], ['fieldoptions', '.field-options'], ['about'], ['contextualactionpanel', '.contextual-action-panel-trigger'], ['expandablearea', '.expandable-area'], ['signin'], ['homepage'], ['lookup', '.lookup:not([data-init])'], ['wizard'], ['popdown', '[data-popdown]'], ['stepchart', '.step-chart'], ['calendar', '.calendar'], ['monthview', '.monthview'], ['listview'],

  // Track Dirty
  ['trackdirty', '[data-trackdirty="true"]'],

  // Context Menus - Popupmenu Components with no trigger buttons
  ['popupmenu', '[data-popupmenu]:not(.btn-actions, .btn-filter, .btn-menu)', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var popupElem = $(item);
      var settings = $.extend({}, utils.parseOptions(popupElem));
      var popupData = popupElem.attr('data-popupmenu');

      if (popupData) {
        settings.menuId = popupData;
      }

      invoke(popupElem, pluginName, settings);
    });
  }],

  // Menu Buttons - Popupmenu Components attached to trigger buttons
  ['popupmenu', '.btn-actions, .btn-filter, .btn-menu', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var triggerButton = $(item);

      // Don't auto-invoke Toolbar's Popupmenus.
      // Toolbar needs to completely control its contents and invoke each one manually.
      if (triggerButton.parents('.toolbar, .flex-toolbar').length > 0) {
        return;
      }

      invoke(triggerButton, pluginName);
    });
  }],

  // Popover
  ['popover', '[data-popover]', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function () {
      var options = utils.parseOptions(this);
      var obj = $(this);
      var trigger = obj.attr('data-trigger');
      var title = obj.attr('data-title');
      var placement = obj.attr('data-placement');

      if (!$.isEmptyObject(options)) {
        obj.popover({
          content: $(options.content),
          popover: true,
          trigger: options.trigger || 'click',
          title: options.title || undefined,
          placement: options.placement || 'right',
          extraClass: options.extraClass || undefined
        });
      } else {
        obj.popover({
          content: $('#' + obj.attr('data-popover')),
          popover: true,
          trigger: trigger || 'click',
          title: title || undefined,
          placement: placement || 'right',
          extraClass: options.extraClass || undefined
        });
      }
    });
  }],

  // Searchfield components need to be filtered for ToolbarSearchfield components,
  // which are invoked separately by their Toolbar element containers.
  ['searchfield', '.searchfield', function (rootElem, pluginName, selector) {
    var searchfields = matchedItems(rootElem, selector);
    var toolbarSearchfields = searchfields.filter(function () {
      return $(this).parents('.toolbar').length;
    });
    searchfields = searchfields.not(toolbarSearchfields);

    searchfields.each(function () {
      invoke(this, 'searchfield');
    });
  }],

  // Toolbar components that are invoked by parent Headers, Contextual Action Panels, and
  // Modal components should be excluded.
  ['toolbar', '.toolbar', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var t = $(item);

      if (t.parents('.header, .contextual-action-panel .modal-header').length && !rootElem.is('.toolbar')) {
        return;
      }

      invoke(t, 'toolbar');
    });
  }],

  // Flex Toolbar
  ['toolbarflex', '.flex-toolbar'],

  // Accordion components that are invoked by Application Menus should be excluded.
  ['accordion', '.accordion', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var a = $(item);
      if (a.parents('.application-menu').length) {
        return;
      }

      invoke(a, 'accordion');
    });
  }],

  // List/Detail Pattern
  ['listdetail', '.list-detail', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      invoke($(item), 'listdetail');
    });
  }],

  // Inline text translations by Locale, via the `data-translate` attribute.
  // (Not all inline text items are powered by JS components)
  ['texttranslations', '[data-translate="text"]', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var obj = $(item);
      obj.text(Locale.translate(obj.text()));
    });
  }],

  // Translate `aria-label` attributes on Breadcrumb lists
  // (Breadcrumbs aren't invoked with a JS component)
  ['breadcrumblabels', '.breadcrumb ol', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).attr('aria-label', Locale.translate('Breadcrumb'));
  }],

  // Validation on individual fields (Should run last)
  ['validate', '[data-validate]', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).closest('form, body').validate();
  }],

  // Form validation
  ['validate', 'form[data-validate-on="submit"]']];

  // Invokes a specific Soho component type against an element, in some cases with
  // specified rules or CSS selectors.
  function mapToInit(elem, plugin, selector, callback) {
    // Don't continue if the jQuery constructor for this plugin isn't loaded.
    if (!$.fn[plugin]) {
      return;
    }

    // Allow only the plugin name to be specified if the default selector is
    // a class with the same name, Like `$.fn.header` applying to elements that
    // match `.header`
    if (typeof selector === 'undefined') {
      selector = '.' + plugin;
    }

    // If a callback function is provided, run that instead of the normal init.
    // Functions contain more-customized initialization for some components.
    if (typeof callback === 'function') {
      callback(elem, plugin, selector);
      return;
    }

    // Run the matcher and do normal init.
    matchedItems(elem, selector).each(function () {
      var thisElem = $(this);

      // Don't init if this element or one of its containing elements is flagged
      // with `[data-init]` or `.no-init`.
      if (thisElem.is(noinitExcludes) || thisElem.parents(noinitExcludes).length) {
        return;
      }

      invoke(this, plugin);
    });
  }

  /**
   * Page Bootstrapper, will initialize all components on a page with default settings.
   * @class Initialize
   * @constructor
   * @param {jQuery[]|HTMLElement} element the root element to initialize
   * @param {object} [settings] incoming settings
   */
  function Initialize(element, settings) {
    // Settings and Options
    if (typeof settings === 'string') {
      settings = {
        locale: settings
      };
    }

    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, INITIALIZE_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Initialize.prototype = {

    /**
     * Makes sure the Locale is set before attempting initialize components
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      var self = this;
      var locale = this.settings.locale;
      if ((!Locale || !Locale.currentLocale) && !this.settings.locale) {
        locale = 'en-US';
      }

      if (locale) {
        Locale.set(locale).done(function () {
          self.initAll();
        });
      } else {
        self.initAll();
      }

      return this;
    },


    /**
     * Initializes all Soho components inside the root element provided.
      * @returns {this} component instance
     */
    initAll: function initAll() {
      var self = this;

      // Iterate all objects we are initializing
      this.element.each(function () {
        for (var i = 0; i < PLUGIN_MAPPINGS.length; i++) {
          mapToInit.apply(undefined, [$(this)].concat(toConsumableArray(PLUGIN_MAPPINGS[i])));
        }
      });

      // NOTE: use of .triggerHandler() here causes event listeners for "initialized"
      // to fire, but prevents the "initialized" event from bubbling up the DOM.
      // It should be possible to initialize just the contents of an element on
      // the page without causing the entire page to re-initialize.
      this.element.triggerHandler('initialized');

      // Run validation on the entire element, if applicable.
      if ($.fn.validate) {
        self.element.validate();
      }

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Initialize
   * @param {object} settings The settings to apply.
   * @returns {jQuery[]} The jquery object for chaining.
   */
  $.fn.initialize = function (settings) {
    return this.each(function () {
      return new Initialize(this, settings);
    });
  };

  var BEHAVIOR_NAME = 'longpress';

  // Default LongPress settings
  var LONGPRESS_DEFAULTS = {
    delay: 400,
    mouseEvents: false
  };

  /**
   * @class LongPress
   * @constructor
   * @param {Object} [settings] incoming settings
   * @param {Number} [settings.delay] the amount of time that should pass between the touch start, and
   *  the trigger of the "longpress" event.
   * @param {boolean} [settings.mouseEvents] if true, will setup longpress capability against mouse events
   *  as well as touch events.  If false, only touch events will be enabled, excluding mice from triggering
   *  the event.
   */
  function LongPress(settings) {
    this.settings = utils.mergeSettings(this.element, settings, LONGPRESS_DEFAULTS);
    return this.init();
  }

  LongPress.prototype = {

    /**
     * @property {RenderLoopItem} [timer=null]
     */
    timer: null,

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      var _this = this;

      var evts = this.getInputEventNames();
      var self = this;

      // User touches the screen.
      // If this goes uninterrupted for the defined duration, it causes a
      // `longpress` event to trigger on the target element.
      $(document).on(evts.mousedown + '.' + BEHAVIOR_NAME, function (e) {
        var target = e.target;

        // Add a timer to the renderLoop
        _this.timer = new RenderLoopItem({
          id: BEHAVIOR_NAME + '-timer',
          duration: math.convertDelayToFPS(_this.settings.delay),
          timeoutCallback: function timeoutCallback() {
            self.fire(target, e);
          }
        });
        renderLoop.register(_this.timer);
      });

      // User moves or releases the touch, causing the timer to be cancelled.
      $(document).on([evts.mouseup + '.' + BEHAVIOR_NAME, evts.mouseout + '.' + BEHAVIOR_NAME, evts.mousemove + '.' + BEHAVIOR_NAME].join(' '), function () {
        _this.killTimer();
      });
    },


    /**
     * @param {HTMLElement} target the target element on which to trigger the event
     * @param {jQuery.Event} [e=undefined] the original event, if applicable
     * @returns {void}
     */
    fire: function fire(target, e) {
      $(target).trigger('' + BEHAVIOR_NAME, [e]);
    },


    /**
     * @private
     * @returns {void}
     */
    killTimer: function killTimer() {
      if (!this.timer) {
        return;
      }

      // Kill the renderloop item with no call to the timeout callback
      this.timer.destroy(true);
      this.timer = null;
    },


    /**
     * @private
     * @returns {object} containing desired event names
     */
    getInputEventNames: function getInputEventNames() {
      var isTouch = Environment.features.touch;
      var useMouse = this.settings.mouseEvents;
      var testCondition = isTouch || !useMouse;

      return {
        mousedown: testCondition ? 'touchstart' : 'mousedown',
        mouseout: testCondition ? 'touchcancel' : 'mouseout',
        mouseup: testCondition ? 'touchend' : 'mouseup',
        mousemove: testCondition ? 'touchmove' : 'mousemove'
      };
    },


    /**
     * @param {object} settings updated incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.teardown();
      this.init();
    },


    /**
     * @returns {void}
     */
    teardown: function teardown() {
      var evts = this.getInputEventNames();

      this.killTimer();

      $(document).off([evts.mousedown + '.' + BEHAVIOR_NAME, evts.mouseup + '.' + BEHAVIOR_NAME, evts.mouseout + '.' + BEHAVIOR_NAME, evts.mousemove + '.' + BEHAVIOR_NAME].join(' '));
    }
  };

  // Setup a single instance of the LongPress behavior for export
  var longPress = new LongPress();

  // All desired Soho components ==================== /

  var components = /*#__PURE__*/Object.freeze({
    Button: Button,
    Hyperlink: Hyperlink,
    Icon: Icon,
    ListFilter: ListFilter,
    MaskInput: MaskInput,
    Modal: Modal,
    PopupMenu: PopupMenu,
    Tmpl: Tmpl,
    About: About,
    Accordion: Accordion,
    ApplicationMenu: ApplicationMenu,
    Autocomplete: Autocomplete,
    Bar: Bar,
    Blockgrid: Blockgrid,
    Bullet: Bullet,
    BusyIndicator: BusyIndicator,
    ColorPicker: ColorPicker,
    Column: Column,
    CompletionChart: CompletionChart,
    ContextualActionPanel: ContextualActionPanel,
    Drag: Drag,
    DatePicker: DatePicker,
    Dropdown: Dropdown,
    EmptyMessage: EmptyMessage,
    ExpandableArea: ExpandableArea,
    Line: Line,
    ListBuilder: ListBuilder,
    ListView: ListView,
    Message: Message,
    MultiSelect: MultiSelect,
    Notification: Notification,
    Pager: Pager,
    Pie: Pie,
    Popdown: Popdown,
    Radar: Radar,
    SearchField: SearchField,
    Slider: Slider,
    Sparkline: Sparkline,
    Spinbox: Spinbox,
    Splitter: Splitter,
    StepChart: StepChart,
    Tabs: Tabs,
    Tag: Tag,
    Textarea: Textarea,
    TimePicker: TimePicker,
    Toast: Toast,
    Toolbar: Toolbar,
    ToolbarFlex: ToolbarFlex,
    Tooltip: Tooltip,
    Tree: Tree,
    Treemap: Treemap,
    Validator: Validator,
    Wizard: Wizard,
    Zoom: Zoom,
    Calendar: Calendar,
    CompositeForm: CompositeForm,
    Datagrid: Datagrid,
    Header: Header,
    Lookup: Lookup,
    MonthView: MonthView,
    MultiTabs: MultiTabs
  });

  // Soho Patterns (jQuery Components)

  var patterns = /*#__PURE__*/Object.freeze({
    ListDetail: ListDetail,
    Stepprocess: Stepprocess
  });

  /* eslint-disable import/first */

  exports.debug = debug;
  exports.components = components;
  exports.patterns = patterns;
  exports.version = version;
  exports.utils = utils;
  exports.DOM = DOM;
  exports.string = stringUtils;
  exports.xss = xssUtils;
  exports.breakpoints = breakpoints;
  exports.Locale = Locale;
  exports.env = Environment;
  exports.base = base;
  exports.renderLoop = renderLoop;
  exports.RenderLoopItem = RenderLoopItem;
  exports.personalization = personalization;
  exports.setTheme = setTheme;
  exports.setColors = setColors;
  exports.getColorStyleSheet = getColorStyleSheet;
  exports.Initialize = Initialize;
  exports.longPress = longPress;
  exports.Place = Place;
  exports.HideFocus = HideFocus;
  exports.smoothScrollTo = smoothScrollTo;
  exports.defer = defer;
  exports.masks = masks;
  exports.Validation = Validation;
  exports.Formatters = formatters;
  exports.Editors = editors;
  exports.GroupBy = groupBy;
  exports.excel = excel;

  return exports;

}({}));
//# sourceMappingURL=sohoxi.js.map
